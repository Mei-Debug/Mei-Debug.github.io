<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Regulus"/><meta name="copyright" content="Regulus"/><meta name="theme-color" content="#FFB347"/><meta name="format-detection" content="telephone=no"/><meta name="keywords" content="Hexo Theme MEOW"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-touch-fullscreen" content="yes"/><meta name="application-name" content="Crypto常用算法 | Mei的小窝"/><meta name="apple-mobile-web-app-title" content="Crypto常用算法 | Mei的小窝"/><meta name="apple-mobile-web-app-status-bar-style" content="#FFB347"/><link rel="canonical" href="http://example.com/2026/02/05/Crypto常用算法/"/><meta name="description" content="Crypto常用算法从来都没有写过算法，虽然在密码里面学会了算法感觉比赛也写不出题目来。但是下学期有算法课，不知道学了有没有用。 1.快速幂算法我们在遇到求$$a^b%c$$的时候，如果数字小的化可以选择先求出$a^b$然后再去对c进行取余 12345result &#x3D; 1for _ in range(b):    result *&#x3D;areturn result%c  这样写的问题在于时间复杂...">
<meta property="og:type" content="article">
<meta property="og:title" content="Crypto常用算法 | Mei的小窝">
<meta property="og:url" content="http://example.com/2026/02/05/Crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Mei的小窝">
<meta property="og:description" content="Crypto常用算法从来都没有写过算法，虽然在密码里面学会了算法感觉比赛也写不出题目来。但是下学期有算法课，不知道学了有没有用。 1.快速幂算法我们在遇到求$$a^b%c$$的时候，如果数字小的化可以选择先求出$a^b$然后再去对c进行取余 12345result &#x3D; 1for _ in range(b):    result *&#x3D;areturn result%c  这样写的问题在于时间复杂...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2026/02/05/Crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/assets/images/Hexo-Theme-MEOW.png">
<meta property="article:published_time" content="2026-02-05T09:13:53.000Z">
<meta property="article:modified_time" content="2026-02-10T12:10:35.599Z">
<meta property="article:author" content="Regulus">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2026/02/05/Crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/assets/images/Hexo-Theme-MEOW.png"><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="revisit-after" content="1 days"/><title>Crypto常用算法 | Mei的小窝</title><link rel="shortcut icon" href="/assets/images/Hexo-Theme-MEOW.ico"><link rel="preconnect" href="/assets"/><link rel="preconnect" href="assets"/>
<link rel="stylesheet" href="/css/style.css">
<link rel="prefetch" href="/"/><link rel="prefetch" href="/archives"/><link rel="prefetch" href="/tags"/><meta name="generator" content="Hexo 7.3.0"></head><body bg-style="none"><header><div id="navbar"><div id="nav-info"><a id="site-icon" href="/" title="主页"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></a><a id="site-name" href="/" title="主页"><div>Mei的小窝</div><img src="/assets/images/svg/uc/uc-home.svg" class="icon noview" alt="Icon"></a></div><div id="nav-menu"><div class="menu-item"><a href="javascript:void(0);"><img src="/assets/images/svg/uc/uc-article.svg" class="icon noview" alt="Icon"><span>文章</span></a><ul class="sub-menu-item"><li><a href="/archives"><img src="/assets/images/svg/uc/uc-archive.svg" class="icon noview" alt="Icon"><span>归档</span></a></li><li><a href="/categories"><img src="/assets/images/svg/uc/uc-category.svg" class="icon noview" alt="Icon"><span>分类</span></a></li><li><a href="/tags"><img src="/assets/images/svg/uc/uc-tag.svg" class="icon noview" alt="Icon"><span>标签</span></a></li><li><a href="/about"><img src="/assets/images/svg/uc/uc-about.svg" class="icon noview" alt="Icon"><span>关于</span></a></li></ul></div></div><div id="nav-function"><div id="search-btn"><a href="javascript:void(0);" title="搜索" accesskey="s"><img src="/assets/images/svg/uc/uc-search.svg" class="icon noview" alt="Icon"><span>搜索</span></a></div><div id="menu-btn"><a href="javascript:void(0);" title="打开菜单"><img src="/assets/images/svg/uc/uc-menu.svg" class="icon noview" alt="Icon"></a></div></div></div></header><div id="menu-aside"><div id="menu-aside-container"><div id="menu-aside-info"><a href="/" title="主页"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></a><a href="/" title="主页">Mei的小窝</a></div><div class="menu-aside-item"><a href="javascript:void(0);"><img src="/assets/images/svg/uc/uc-article.svg" class="icon noview" alt="Icon"><span>文章</span></a><ul class="menu-aside-sub-item"><li><a href="/archives"><img src="/assets/images/svg/uc/uc-archive.svg" class="icon noview" alt="Icon"><span>归档</span></a></li><li><a href="/categories"><img src="/assets/images/svg/uc/uc-category.svg" class="icon noview" alt="Icon"><span>分类</span></a></li><li><a href="/tags"><img src="/assets/images/svg/uc/uc-tag.svg" class="icon noview" alt="Icon"><span>标签</span></a></li><li><a href="/about"><img src="/assets/images/svg/uc/uc-about.svg" class="icon noview" alt="Icon"><span>关于</span></a></li></ul></div><hr/></div></div><main><div class="banner"><div class="banner-info"><div class="banner-avatar"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Avatar"/></div><div class="banner-title">「 Mei的小窝 」</div></div></div><div class="post-container"><div class="post-main"><div class="post-content"><h1 class="post-title">Crypto常用算法</h1><div class="post-author"><span>作者: Regulus</span></div><div class="post-meta"><div class="post-info"><div class="post-date"><div class="post-pubdate"><img src="/assets/images/svg/ta/ta-pubdate.svg" class="icon noview" alt="Icon"><span>发表于2026-02-05</span></div><div class="post-update"><img src="/assets/images/svg/ta/ta-update.svg" class="icon noview" alt="Icon"><span>更新于2026-02-10</span></div></div><div class="post-read"><div class="post-wordcount"><img src="/assets/images/svg/ta/ta-write.svg" class="icon noview" alt="Icon"><span>总字数: 2.7k字</span></div><div class="post-readtime"><img src="/assets/images/svg/ta/ta-time.svg" class="icon noview" alt="Icon"><span>阅读时长: 9分钟</span></div><div class="post-pageview"><img src="/assets/images/svg/ta/ta-fire.svg" class="icon noview" alt="Icon"><span>访问量: </span><span id="vercount_value_page_pv"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 6l0 -3" /><path d="M16.25 7.75l2.15 -2.15" /><path d="M18 12l3 0" /><path d="M16.25 16.25l2.15 2.15" /><path d="M12 18l0 3" /><path d="M7.75 16.25l-2.15 2.15" /><path d="M6 12l-3 0" /><path d="M7.75 7.75l-2.15 -2.15" /></svg></span></div></div></div><div class="post-attribute"></div></div><div class="post markdown" indent="false"><h1 id="Crypto常用算法"><a href="#Crypto常用算法" class="headerlink" title="Crypto常用算法"></a>Crypto常用算法</h1><p>从来都没有写过算法，虽然在密码里面学会了算法感觉比赛也写不出题目来。但是下学期有算法课，不知道学了有没有用。</p>
<h2 id="1-快速幂算法"><a href="#1-快速幂算法" class="headerlink" title="1.快速幂算法"></a>1.快速幂算法</h2><p>我们在遇到求<br>$$<br>a^b%c<br>$$<br>的时候，如果数字小的化可以选择先求出$a^b$然后再去对c进行取余</p>
<div class="code-container" code-lang="Python"><div class="codebox"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(b):</span><br><span class="line">    result *=a</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result%c</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>这样写的问题在于时间复杂度为b，然后如果a和b都有一点大，就会导致result可能突破Long Long，然后算起来也是特别的慢。</p>
<p>我们需要先知道公式<br>$$<br>(a<em>b)%c&#x3D;(a%c</em>b%c)%c<br>$$<br>这个公式的推理就是<br>$$<br>a&#x3D;n1<em>c+k1;;;;b&#x3D;n2</em>c+k2<br>$$<br>相乘的结果就是带有系数c的在取模中都会被删掉，最后留下$(k1*k2)%c$，然后我们先对ab对c进行取模，然后再进行一次取余这两个结果是一样的</p>
<p>于是我们在计算 $a^b%c$ 的时候可以不要先计算a的b次方，而是先计算各个因数对c的模，然后再相乘取模。</p>
<p>我们数据过大的问题解决了，还存在时间复杂度的问题，如果把a的b次方拆成b个a的话，如果b过大，时间复杂度不仅没变，需要进行计算的次数还多了。</p>
<p>我们在计算一个数字的幂的时候，比如$a^{10}$，我们可以化为$(a^2)^5$，继续化成$(a^2)^4*a^2$，我们这个时候就根据当前括号内幂提取出来一个乘项用来单独计算。计算完后指数又变成了偶数，我们继续往里面提取一个平方得到$(a^4)^2$，最后直接再进行一次平方运算即可。（括号内的算式先计算，再慢慢化简外面的指数）</p>
<p>这个计算的核心在于遇到一个数的高阶幂的时候，使用2去除指数，每次计算一次平方，遇到奇数就提出去单独计算。需要注意的是没计算一次就可以进行对c进行取余减小数字大小，不会影响最终结果。</p>
<p>一直对幂进行取平方就可以一直减少计算次数。</p>
<p>于是将幂和化简计算和取模化简结合到一起就会得到，由于最后要相乘的结果都可以先对c进行取模，然后得到最后的结果再进行一次取模。即可得到答案</p>
<div class="code-container" code-lang="Python"><div class="codebox"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fast_power</span>(<span class="params">a, b, m</span>):</span><br><span class="line">  result = <span class="number">1</span></span><br><span class="line">  a = a % m</span><br><span class="line"><span class="keyword">while</span> b &gt; <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">if</span> b &amp; <span class="number">1</span>: <span class="comment"># 如果b是奇数</span></span><br><span class="line">     result = (result * a) % m</span><br><span class="line">  a = (a * a) % m <span class="comment"># 偶数是就每次取一个平方 需要记录</span></span><br><span class="line">  b = b &gt;&gt; <span class="number">1</span> <span class="comment"># 将b除以2</span></span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>





<h2 id="2-欧里几得算法"><a href="#2-欧里几得算法" class="headerlink" title="2.欧里几得算法"></a>2.欧里几得算法</h2><p>算法原来都这么难的吗，还好当初没选算法。</p>
<p>辗转相除法是用来求最大公约数的，比如数4和6的最大公约数是2，4和8则是4。</p>
<p>一开始的时候都是直接从1开始遍历比较小的那个数，看这个数是不是两个数的因数，然后取最后最大的结果。但是那样写还是太麻烦了，连那些不是的数都需要去计算一遍，如果两个数再大一点，时间复杂度就非常大。</p>
<p><strong>证明</strong></p>
<p>我们把两个数分为一大一下A大于B，于是我们可以得到A&#x3D;kB+c，c为A对B取余的值。我们社最大公因数为u，于是可以得到au&#x3D;kbu+c，最后得到c&#x3D;(a-kb)u。</p>
<p>这也就证明了，两个数中A对B进行求余的结果c的因数也有u，于是我们B再和c进行求余也会得到u作为因数的数字，于是我们重复这样两组数字进行求余，最后数字会越来越小，直到最后求余为0的时候，那个较小的数字就是最大公因数。</p>
<img lazyload src="/assets/images/Meow-Loading.webp" data-lazy-src="/2026/02/05/Crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/image-20260205212437159.png" class title="image-20260205212437159">

<p>使用算法实现十分简单，因为直接内置了gcd函数就是用来求最大公因数的。</p>
<div class="code-container" code-lang="Python"><div class="codebox"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcd(a,b)</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>





<h2 id="3-欧里几得拓展算法"><a href="#3-欧里几得拓展算法" class="headerlink" title="3.欧里几得拓展算法"></a>3.欧里几得拓展算法</h2><p>这个是用来计算婓蜀定理给出的一个结论：</p>
<p><strong>给定两个整数a,b，必定会存在x,y满足  ax+by&#x3D;gcd(a,b)</strong></p>
<p>我们先看一个计算，假如a为8，b为4，那这个方程的解就存在x&#x3D;0 ，y&#x3D;1。然后这是不是欧里几得算到最后一步的结果，到后面会使用到这个解作为递归开始的解。</p>
<p>我们通过欧里几得算法可以直到gcd(a,b)&#x3D;gcd(b,a%b) 。于是我们可以将这两个等式进行化简<br>$$<br>ax+by&#x3D;gcd(a,b);;bx1+(a%b)y1&#x3D;gcd(b,a%b);;gcd(a,b)&#x3D;gcd(b,a%b)-&gt;\ax+by&#x3D;bx1+(a%b)y1<br>$$<br>然后我们可以把a%b化为$a-(b*[a&#x2F;b])$ 其中对a&#x2F;b进行向下取整。我们再进行联立可以得到<br>$$<br>x&#x3D;y1;;y&#x3D;x1+[a&#x2F;b]y1<br>$$</p>
<p>然后如果我们再使用欧里几得算法继续取余的话，y1和x1也是可以被表示的。最后我们会得到一个类似于函数递归的逻辑，先算出最底层的结果然后往前面计算。</p>
<p><strong>欧里几得算到最后，会出现b%(a%b)&#x3D;0的请况</strong>，也就是a%b是b的因数，此时再联立$ax+by&#x3D;bx1+(a%b)y1$   可以得到等式右边是一个nb，左边却有一个a%b!&#x3D;0的a。</p>
<p>于是我们要等式相等，左边a需要消除掉，x&#x3D;0 。通过x&#x3D;0带入$ax+by&#x3D;gcd(a,b)$可以得到y&#x3D;1；</p>
<p><strong>于是我们便计算出了最后一层的结果，最后必定会得到一个x&#x3D;0,y&#x3D;1的结果</strong>，然后就可以递归计算最后的解了。这只是一个算法，具体结果取决于递归的层数和a,b的值。</p>
<p>只需要一直递归计算到第一层就可以得到**ax+by&#x3D;gcd(a,b)**的解，这也证明了裴蜀定理。</p>
<p>算法实现主要利用了欧里几得算法和嵌套</p>
<div class="code-container" code-lang="Python"><div class="codebox"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ext_euclid</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x, y, q = ext_euclid(b, a % b) <span class="comment">#最后一层必定返回1,0,a</span></span><br><span class="line">        x, y = y, (x - (a // b) * y)</span><br><span class="line">        <span class="keyword">return</span> x, y, q</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>最后一层返回后每一层计算一遍联立公式<br>$$<br>x&#x3D;y1;;y&#x3D;x1+[a&#x2F;b]y1<br>$$</p>
<h2 id="4-欧拉函数"><a href="#4-欧拉函数" class="headerlink" title="4.欧拉函数"></a>4.欧拉函数</h2><p>在学习欧拉定理之前需要先学习一下欧拉函数，也就是<strong>φ(n)<strong>，表示的是从1到n这个区间中和n互质的</strong>整数的数量</strong>。<br>$$<br>φ(n)&#x3D;#{k∈Z+∣1≤k≤n,gcd(k,n)&#x3D;1}<br>$$</p>
<p><strong>质数n</strong></p>
<p>容易理解的比如一个质数n，φ(n)&#x3D;n-1，除了质数n本身外全部都是互质数。</p>
<p><strong>质数幂$n^k$</strong></p>
<p><strong>一个质数n的k次方中和n不互质的只有n的倍数</strong>，也就是$1n,2n,3n…n^k$，我们可以知道数量为$n^{k-1}$，只需要使用$n^k-n^{k-1}$即可。于是我们可以得到公式<br>$$<br>φ(p^k)&#x3D;p^k−p^{k−1}&#x3D;p^k(1−1&#x2F;p)<br>$$</p>
<p><strong>积性函数</strong></p>
<p>若 gcd⁡(m,n)&#x3D;1gcd(<em>m</em>,<em>n</em>)&#x3D;1，则：<br>$$<br>φ(mn)&#x3D;φ(m)⋅φ(n)<br>$$<br>rsa加密算法中使用的就是这个结论，rsa算法中选取的m和n不仅是互质数，而且是两个质数于是$φ(mn)&#x3D;(m-1)(n-1)$</p>
<p><strong>一般公式</strong></p>
<p>面对一些普通的数字就需要使用到一般公式。当我么拿到一个数字n的时候，我们可以尝试使用不同质数幂$p^k$相乘来表示出数字n，然后我们分别计算各个质数幂相加即可。</p>
<p>如果$n&#x3D;p1^{k1}*p2^{k2}*p3^{k^3}$，则：<br>$$<br>φ(n)&#x3D;n(1-1&#x2F;p1)(1-1&#x2F;p2)(1-1&#x2F;p3)<br>$$</p>
<h2 id="5-欧拉定理"><a href="#5-欧拉定理" class="headerlink" title="5.欧拉定理"></a>5.欧拉定理</h2><p>欧拉函数只是一个数学算式，欧拉定理则是基于欧拉函数的一个数学定理。</p>
<p><strong>定理内容</strong></p>
<p>欧拉定理用来描述两个互质数之间的关系，假设有数字a于n互质，则有<br>$$<br>a^{φ(n)}≡;1;(mod;n)<br>$$</p>
<p><strong>证明</strong></p>
<p>在证明欧拉定理之前我们需要证明一个定理，虽然我也不知道定理的名称叫什么</p>
<p>我们取n&#x3D;12，a&#x3D;5。其中a随意只需要和n互质就行了。</p>
<p>我们可以得到n的欧拉函数的一个集合<br>$$<br>x&#x3D;{1,5,7,11}<br>$$<br>然后我们尝试使用a一个n的互质数对集合内每个元素计算$y&#x3D;(a*x_1)mod;n$，得到的结果再重新放入集合<br>$$<br>{5;mod;12,25;mod;12,35;mod;12;,55;mod;12}-&gt;\y&#x3D;{5,1,11,7}<br>$$<br>我们发现经过这样计算的集合和原来x的集合一样。</p>
<p>于是我们尝试将这两个集合的条件列出来比较一下</p>
<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x集合</span><br><span class="line">1. 0&lt;x&lt;n</span><br><span class="line">2. (x,n)=1</span><br><span class="line">3. 不重复 虽然x集合肯定不会重复，但是我们需要保证y集合也不重复</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们尝试使用y集合去证明符合这两点就可以证明这两个集合相等</p>
<p><strong>1.  $0&lt;(a*x_1)mod;n&lt;n$</strong></p>
<p>模运算，肯定满足不需要证明</p>
<p><strong>2. $((a*x_1)mod;n,n)&#x3D;1$</strong></p>
<p>也就是为了证明y里面的元素都是和n互质的。</p>
<p>放弃证明了，直接看结论<strong>乘法群的封闭性定理</strong>推导出来的的</p>
<p>如果 gcd⁡(a,n)&#x3D;1 且 gcd⁡(b,n)&#x3D;1，那么 <strong>gcd⁡(ab mod n,n)&#x3D;1</strong></p>
<p><strong>3.元素不相等</strong></p>
<p>我们需要证明$(a<em>x_1)mod;n$计算出来的结果不会重复。在x集合不重复的请况下进行反证<br>$$<br>(a</em>x_1)mod;n&#x3D;(a*x_2)mod;n;<br>$$</p>
<p>因为$(a<em>b)%m&#x3D;(a%m</em>b%m)%m$，然后a和x又与n互质，于是$a%m$可以被化简，得到<br>$$<br>x_1%n&#x3D;x_2%n<br>$$<br>矛盾，于是y集合内元素不相等得证。</p>
<p>我们在证明了x和$y&#x3D;(a<em>x_1)mod;n$集合相等后也就证明了这两个集合里面所有元素的乘积相等。<br>$$<br>x_1</em>x_2<em>x_3</em>x_4&#x3D;(a<em>x_1)mod;n</em>…(a<em>x_4)mod;n;-&gt;\<br>(x_1</em>x_2<em>x_3</em>x_4)mod;n&#x3D;(ax_1*…*ax_4)mod;n<br>$$<br>因为x和a都与n互质，于是在模运算的时候可以消去得到<br>$$<br>1;mod;n&#x3D;a^{φ(n)}mod;n<br>$$</p>
<p>于是最后得到欧拉定理的结论：</p>
<p>两个互质数a，n存在关系<br>$$<br>a^{φ(n)}mod;n&#x3D;1<br>$$</p>
<h2 id="6-费马小定理"><a href="#6-费马小定理" class="headerlink" title="6.费马小定理"></a>6.费马小定理</h2><p><strong>定理内容</strong></p>
<p>如果 <em>p</em> 是素数，那么对于<strong>任意</strong>整数 <em>a</em>：<br>$$<br>a^p≡a;(mod;p)<br>$$<br>还有一种说法就是</p>
<p>如果 p 是<strong>素数</strong>，且整数 a 不是 p 的倍数则：<br>$$<br>a^{p-1}≡1;mod;p<br>$$</p>
<p>费马小定理就是欧拉定理的特殊形式，p和a不仅仅是互质数，p必须是一个质数</p>
</div><div class="post-reward"><div class="post-reward-btn" title="赞赏作者"><img src="/assets/images/svg/uc/uc-gift.svg" class="icon noview" alt="Icon"><span></span></div><div class="post-reward-content"><div class="post-reward-text"></div><div class="post-reward-list"><a href="/null" target="_blank">致谢名单</a></div></div></div><div class="post-copyright"><div class="post-copyright-info">本作品由 Regulus 于 2026-02-05 17:13:53 发布</div><div class="post-copyright-link"><span>作品地址：<a href="http://example.com/2026/02/05/Crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/">Crypto常用算法</a></span><button class="copy-text" type="button" data-text="http://example.com/2026/02/05/Crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/">复制</button></div><div class="post-copyright-detail">除特别声明外，本站作品均采用 <a href='https://creativecommons.org/licenses/by-nc-sa/4.0/' title='Attribution-NonCommercial-ShareAlike' target='_blank'>CC BY-NC-SA 4.0</a> 许可协议，转载请注明来自 <a href='/'>Mei的小窝</a></div><img class="post-copyright-icon noview" src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></div><div class="post-tail-tags"></div></div><aside id="post-sidebar" status="show"><div id="toc-container"><div class="toc-title"><img src="/assets/images/svg/ta/ta-toc.svg" class="icon noview" alt="Icon"><span>目录</span></div><div class="toc-content" id="toc-div"><ol class="toc-list"><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#Crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-list-text">Crypto常用算法</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#1-%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95"><span class="toc-list-text">1.快速幂算法</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#2-%E6%AC%A7%E9%87%8C%E5%87%A0%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-list-text">2.欧里几得算法</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#3-%E6%AC%A7%E9%87%8C%E5%87%A0%E5%BE%97%E6%8B%93%E5%B1%95%E7%AE%97%E6%B3%95"><span class="toc-list-text">3.欧里几得拓展算法</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#4-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-list-text">4.欧拉函数</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#5-%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86"><span class="toc-list-text">5.欧拉定理</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#6-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86"><span class="toc-list-text">6.费马小定理</span></a></li></ol></li></ol></div></div></aside></div></div><div id="toolbar" hide=""><div id="toolbar-setting-container" hide=""><div class="toolbar-item"><button id="tool-color-mode" title="深色模式" type="button"><img src="/assets/images/svg/ta/ta-moon.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button class="copy-text" id="tool-share" title="分享" type="button" data-text="http://example.com/2026/02/05/Crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"><img src="/assets/images/svg/ta/ta-share.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-font-size-plus" title="放大字体" type="button"><img src="/assets/images/svg/ta/ta-text-plus.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-font-size-minus" title="缩小字体" type="button"><img src="/assets/images/svg/ta/ta-text-minus.svg" class="icon noview" alt="Icon"></button></div></div><div class="toolbar-container"><div class="toolbar-item"><button id="tool-setting" title="设置" type="button"><img src="/assets/images/svg/ta/ta-setting.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-toc" title="目录" type="button"><img src="/assets/images/svg/ta/ta-toc.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-gototop" title="返回顶部" type="button"><img src="/assets/images/svg/ta/ta-up.svg" class="icon noview" alt="Icon"></button></div></div></div><div class="search-overlay"><div class="search-container"><div class="search-header"><div class="search-title"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" /><path d="M21 21l-6 -6" /></svg>
搜索</div><div class="search-close-btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 21a9 9 0 0 0 9 -9a9 9 0 0 0 -9 -9a9 9 0 0 0 -9 9a9 9 0 0 0 9 9z" /><path d="M9 8l6 8" /><path d="M15 8l-6 8" /></svg></div></div><div class="search-input-box"><input id="search-input" type="search" placeholder="请输入关键词进行站内搜索……" value="" maxlength="80"/></div><div class="search-result-container"><div class="search-result-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" /><path d="M21 21l-6 -6" /></svg></div></div></div></div></main><footer><div class="footer"><div id="footer-copyright">© 2024 - 2026 <span>💗</span> <a href="/null">Regulus</a></div><div id="footer-info"><div id="footer-framework">🚀本站由 <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/chanwj/hexo-theme-meow" title="3.2.0" target="_blank">Meow</a> 强力驱动</div><div id="footer-runtime"><span id="runtime" data-startdate="2024-04-02T22:16:20.000Z">🌻已稳定运行.年.月.天</span></div></div><div id="footer-statistic"><span>共撰写168篇文章，全站共460.2k字</span></div><div id="footer-pageview"><div id="container_site_pv"><span>🔥总访问量</span><span id="vercount_value_site_pv"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 6l0 -3" /><path d="M16.25 7.75l2.15 -2.15" /><path d="M18 12l3 0" /><path d="M16.25 16.25l2.15 2.15" /><path d="M12 18l0 3" /><path d="M7.75 16.25l-2.15 2.15" /><path d="M6 12l-3 0" /><path d="M7.75 7.75l-2.15 -2.15" /></svg></span></div><div id="container_site_uv"><span>🐈访客人数</span><span id="vercount_value_site_uv"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 6l0 -3" /><path d="M16.25 7.75l2.15 -2.15" /><path d="M18 12l3 0" /><path d="M16.25 16.25l2.15 2.15" /><path d="M12 18l0 3" /><path d="M7.75 16.25l-2.15 2.15" /><path d="M6 12l-3 0" /><path d="M7.75 7.75l-2.15 -2.15" /></svg></span></div></div></div></footer><div class="scripts"><script>const GLOBALCONFIG = {
  root: '/',
  toolbar: true,
  lazyload_src: '/assets/images/Meow-Loading.webp',
  friends: false,
  codeblock: true,
  share_text: '',
  onblur_title: 'Please Come Back～✧(´▽`ʃ♡ƪ)',
  mouse_click: false,
  notify:{
    enable: false,
    info: '复制成功～转载请标注本文地址',
    f12_info: '开发者模式已打开，请遵循本站版权协议'
  },
  search: {
    enable: true,
    path: 'search.json',
    local: {
      top_n_per_article: 1,
      preload: false
    }
  },
  encrypt: false,
};
</script><script>if (!localStorage.getItem('color-mode')) {
  localStorage.setItem('color-mode', 'light' || 'light');
}
document.body.setAttribute('data-mode', localStorage.getItem('color-mode'));
</script>
<script src="/js/theme/tools/utils.js"></script>

<script src="/js/plugins/dist/lazyload.min.js"></script>

<script src="/js/plugins/view-image.min.js"></script>
<script src="https://events.vercount.one/js" defer="defer"></script><script>if (localStorage.getItem('font-size')) {
  document.querySelector('.post').style.fontSize = localStorage.getItem('font-size') + 'px';
}
</script>
<script src="/js/plugins/dist/search.js"></script>

<script src="/js/main.js" type="module"></script>
</div></body></html>