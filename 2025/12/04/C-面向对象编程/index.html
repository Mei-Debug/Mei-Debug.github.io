<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Regulus"/><meta name="copyright" content="Regulus"/><meta name="theme-color" content="#FFB347"/><meta name="format-detection" content="telephone=no"/><meta name="keywords" content="C++"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-touch-fullscreen" content="yes"/><meta name="application-name" content="C++面向对象编程 | Mei的小窝"/><meta name="apple-mobile-web-app-title" content="C++面向对象编程 | Mei的小窝"/><meta name="apple-mobile-web-app-status-bar-style" content="#FFB347"/><link rel="canonical" href="http://example.com/2025/12/04/C-面向对象编程/"/><meta name="description" content="C++面向对象编程为什么计科要从C++开始学面向对象编程，一开始以为反正都是面向对象编程，以为会和Java差不多，结果一看发现还是没有Java方便，到现在又要期末考试了，只能趁着实验课来补一下不会的。 妈的，上次这么复习的还是汇编，我复习了整整一个星期啊，看了十多个小时的教程，结果被那傻逼试卷给被刺了，不仅题目变成了一几年的类型题目好多，题目难度更是逆天，本来靠写概念题我都可以及格，结果概念...">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面向对象编程 | Mei的小窝">
<meta property="og:url" content="http://example.com/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Mei的小窝">
<meta property="og:description" content="C++面向对象编程为什么计科要从C++开始学面向对象编程，一开始以为反正都是面向对象编程，以为会和Java差不多，结果一看发现还是没有Java方便，到现在又要期末考试了，只能趁着实验课来补一下不会的。 妈的，上次这么复习的还是汇编，我复习了整整一个星期啊，看了十多个小时的教程，结果被那傻逼试卷给被刺了，不仅题目变成了一几年的类型题目好多，题目难度更是逆天，本来靠写概念题我都可以及格，结果概念...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/assets/images/Hexo-Theme-MEOW.png">
<meta property="article:published_time" content="2025-12-04T08:11:57.000Z">
<meta property="article:modified_time" content="2026-01-03T15:00:26.189Z">
<meta property="article:author" content="Regulus">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/assets/images/Hexo-Theme-MEOW.png"><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="revisit-after" content="1 days"/><title>C++面向对象编程 | Mei的小窝</title><link rel="shortcut icon" href="/assets/images/Hexo-Theme-MEOW.ico"><link rel="preconnect" href="/assets"/><link rel="preconnect" href="assets"/>
<link rel="stylesheet" href="/css/style.css">
<link rel="prefetch" href="/"/><link rel="prefetch" href="/archives"/><link rel="prefetch" href="/tags"/><meta name="generator" content="Hexo 7.3.0"></head><body bg-style="none"><header><div id="navbar"><div id="nav-info"><a id="site-icon" href="/" title="主页"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></a><a id="site-name" href="/" title="主页"><div>Mei的小窝</div><img src="/assets/images/svg/uc/uc-home.svg" class="icon noview" alt="Icon"></a></div><div id="nav-menu"><div class="menu-item"><a href="javascript:void(0);"><img src="/assets/images/svg/uc/uc-article.svg" class="icon noview" alt="Icon"><span>文章</span></a><ul class="sub-menu-item"><li><a href="/archives"><img src="/assets/images/svg/uc/uc-archive.svg" class="icon noview" alt="Icon"><span>归档</span></a></li><li><a href="/categories"><img src="/assets/images/svg/uc/uc-category.svg" class="icon noview" alt="Icon"><span>分类</span></a></li><li><a href="/tags"><img src="/assets/images/svg/uc/uc-tag.svg" class="icon noview" alt="Icon"><span>标签</span></a></li><li><a href="/about"><img src="/assets/images/svg/uc/uc-about.svg" class="icon noview" alt="Icon"><span>关于</span></a></li></ul></div></div><div id="nav-function"><div id="search-btn"><a href="javascript:void(0);" title="搜索" accesskey="s"><img src="/assets/images/svg/uc/uc-search.svg" class="icon noview" alt="Icon"><span>搜索</span></a></div><div id="menu-btn"><a href="javascript:void(0);" title="打开菜单"><img src="/assets/images/svg/uc/uc-menu.svg" class="icon noview" alt="Icon"></a></div></div></div></header><div id="menu-aside"><div id="menu-aside-container"><div id="menu-aside-info"><a href="/" title="主页"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></a><a href="/" title="主页">Mei的小窝</a></div><div class="menu-aside-item"><a href="javascript:void(0);"><img src="/assets/images/svg/uc/uc-article.svg" class="icon noview" alt="Icon"><span>文章</span></a><ul class="menu-aside-sub-item"><li><a href="/archives"><img src="/assets/images/svg/uc/uc-archive.svg" class="icon noview" alt="Icon"><span>归档</span></a></li><li><a href="/categories"><img src="/assets/images/svg/uc/uc-category.svg" class="icon noview" alt="Icon"><span>分类</span></a></li><li><a href="/tags"><img src="/assets/images/svg/uc/uc-tag.svg" class="icon noview" alt="Icon"><span>标签</span></a></li><li><a href="/about"><img src="/assets/images/svg/uc/uc-about.svg" class="icon noview" alt="Icon"><span>关于</span></a></li></ul></div><hr/></div></div><main><div class="banner"><div class="banner-info"><div class="banner-avatar"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Avatar"/></div><div class="banner-title">「 Mei的小窝 」</div></div></div><div class="post-container"><div class="post-main"><div class="post-content"><h1 class="post-title">C++面向对象编程</h1><div class="post-author"><span>作者: Regulus</span></div><div class="post-meta"><div class="post-info"><div class="post-date"><div class="post-pubdate"><img src="/assets/images/svg/ta/ta-pubdate.svg" class="icon noview" alt="Icon"><span>发表于2025-12-04</span></div><div class="post-update"><img src="/assets/images/svg/ta/ta-update.svg" class="icon noview" alt="Icon"><span>更新于2026-01-03</span></div></div><div class="post-read"><div class="post-wordcount"><img src="/assets/images/svg/ta/ta-write.svg" class="icon noview" alt="Icon"><span>总字数: 8.9k字</span></div><div class="post-readtime"><img src="/assets/images/svg/ta/ta-time.svg" class="icon noview" alt="Icon"><span>阅读时长: 29分钟</span></div><div class="post-pageview"><img src="/assets/images/svg/ta/ta-fire.svg" class="icon noview" alt="Icon"><span>访问量: </span><span id="vercount_value_page_pv"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 6l0 -3" /><path d="M16.25 7.75l2.15 -2.15" /><path d="M18 12l3 0" /><path d="M16.25 16.25l2.15 2.15" /><path d="M12 18l0 3" /><path d="M7.75 16.25l-2.15 2.15" /><path d="M6 12l-3 0" /><path d="M7.75 7.75l-2.15 -2.15" /></svg></span></div></div></div><div class="post-attribute"><div class="post-tags"><img src="/assets/images/svg/ta/ta-tag.svg" class="icon noview" alt="Icon"><span><a class="post-tags-link" href="/tags/C/" rel="tag">C++</a></span></div></div></div><div class="post markdown" indent="false"><h1 id="C-面向对象编程"><a href="#C-面向对象编程" class="headerlink" title="C++面向对象编程"></a>C++面向对象编程</h1><p>为什么计科要从C++开始学面向对象编程，一开始以为反正都是面向对象编程，以为会和Java差不多，结果一看发现还是没有Java方便，到现在又要期末考试了，只能趁着实验课来补一下不会的。</p>
<p>妈的，上次这么复习的还是汇编，我复习了整整一个星期啊，看了十多个小时的教程，结果被那傻逼试卷给被刺了，不仅题目变成了一几年的类型题目好多，题目难度更是逆天，本来靠写概念题我都可以及格，结果概念题几乎没有，还全部是算地址的题目。如果老师不在我那个只写了框架的程序设计题多给点分的话我肯定挂科了。</p>
<p>C++的面向过程还是和其他语言一致的，语法上应该只有输入和输出和C语言不一样</p>
<h2 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1.类与对象"></a>1.类与对象</h2><p>类和对象没什么特别的，所有面向对象编程概念都是差不多的，只不过语法上有一些差别。</p>
<p><strong>类的定义</strong></p>
<p>定义一个类需要使用关键字 <strong>class</strong>，然后指定类的名称，并类的主体是包含在一对花括号中，主体包含类的成员变量和成员函数。</p>
<p>定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p>
<img lazyload src="/assets/images/Meow-Loading.webp" data-lazy-src="/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/cpp-classes-objects-2020-12-10-11.png" class title="img">

<p>我们来看一个实例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">double</span> length;   <span class="comment">// 盒子的长度</span></span><br><span class="line">      <span class="type">double</span> breadth;  <span class="comment">// 盒子的宽度</span></span><br><span class="line">      <span class="type">double</span> height;   <span class="comment">// 盒子的高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们可以注意到，和Java不同的就是C++没有对class进行修饰符修饰，这样就意味着所有类都是可以在其他类中被访问然后进行实例化。不像在Java中比如Runtime类就是private的，也就是不能直接被new，需要调用方法getRuntime返回一个Runtime对象。C++中通过对变量和函数进行修饰来实现封装</p>
<p>然后就是C++不能像python和Java那样，直接通过import语句进行引用，而是通过include语句去引用一个.h文件。一开始学C语言的时候不知道<code>#include &lt;stdio.h&gt;</code>的作用是什么，只是每次都写上，其实现在也不知道到底是为了使用哪个方法才去引用它</p>
<p>我们在写面向对象的程序的时候就会看到.h文件中的内容类似</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//student.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grade</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> math; <span class="comment">// 数学成绩</span></span><br><span class="line">    <span class="type">double</span> english; <span class="comment">// 英语成绩</span></span><br><span class="line">    <span class="type">double</span> programming; <span class="comment">// 编程成绩</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Grade</span>();</span><br><span class="line">    <span class="built_in">Grade</span>(<span class="type">double</span> _math, <span class="type">double</span> _english, <span class="type">double</span> _programming);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_math</span><span class="params">(<span class="type">double</span> _math)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_english</span><span class="params">(<span class="type">double</span> _english)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_programming</span><span class="params">(<span class="type">double</span> _programming)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_math</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_english</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_programming</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>这样的目的就是将我们在对应的student.cpp文件中定义的类和函数在这里进行一个声明，然后在其他.cpp文件中只需要<code>include &quot;student.h&quot;</code>，然后我们就可以访问到h中声明的函数和类了，也可以选择在h文件中声明变量。</p>
<p>然后就是只要在h文件中引入的文件在对应的cpp文件中只需要<code>include &quot;student.h&quot;</code>就相当于引入了</p>
<p>我们还需要注意，类的定义有两种方式。分别是单独一个cpp文件和h&#x2F;cpp文件。</p>
<p>单独cpp文件</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就是不依赖h文件的声明，直接在cpp文件中写类的所有信息</span></span><br><span class="line"><span class="comment">// student.cpp - 最简单的学生类示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义Student类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(std::string n, <span class="type">int</span> a) &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数：显示信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; name </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, 年龄: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数：庆祝生日</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">birthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        age++;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 过生日啦！现在 &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; 岁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">int</span> age;           <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 主函数 - 使用Student类</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Student对象</span></span><br><span class="line">    <span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">stu2</span><span class="params">(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用对象的方法</span></span><br><span class="line">    stu<span class="number">1.</span><span class="built_in">show</span>();</span><br><span class="line">    stu<span class="number">2.</span><span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 张三过生日</span></span><br><span class="line">    stu<span class="number">1.</span><span class="built_in">birthday</span>();</span><br><span class="line">    stu<span class="number">1.</span><span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p>cpp和h文件定义类</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个和传统的类不同，主要就是类的中心是h文件而并非cpp文件，在h文件中声明了类的属性和方法，在调用类的方法的时候是先去访问h文件，然后通过在对应cpp文件中去寻找方法的实现，对于没有在h文件中声明的方法即使在cpp中实现了也没用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//student.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STUDENT_H  <span class="comment">// 防止重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STUDENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  <span class="comment">// 需要用到string类型</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数声明</span></span><br><span class="line">    <span class="built_in">Student</span>(std::string name, <span class="type">int</span> age);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数声明（只有函数原型，没有实现）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">introduce</span><span class="params">()</span></span>;      <span class="comment">// 自我介绍</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">haveBirthday</span><span class="params">()</span></span>;   <span class="comment">// 过生日</span></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">// 获取姓名</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 成员变量声明（不暴露具体值）</span></span><br><span class="line">    std::string name_;     <span class="comment">// 姓名（私有）</span></span><br><span class="line">    <span class="type">int</span> age_;              <span class="comment">// 年龄（私有）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// STUDENT_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//student.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span>  <span class="comment">// 必须包含自己的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>   <span class="comment">// 需要用到cout</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 构造函数实现</span></span><br><span class="line"><span class="comment">// 格式：类名::构造函数名(参数)</span></span><br><span class="line">Student::<span class="built_in">Student</span>(std::string name, <span class="type">int</span> age) </span><br><span class="line">    : <span class="built_in">name_</span>(name), <span class="built_in">age_</span>(age)  <span class="comment">// 初始化列表（推荐写法）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数体</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;创建学生: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 成员函数实现</span></span><br><span class="line"><span class="comment">// 格式：返回类型 类名::函数名(参数)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::introduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;大家好，我是&quot;</span> &lt;&lt; name_ </span><br><span class="line">              &lt;&lt; <span class="string">&quot;，今年&quot;</span> &lt;&lt; age_ &lt;&lt; <span class="string">&quot;岁。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::haveBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    age_++;  <span class="comment">// 年龄加1</span></span><br><span class="line">    std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot;过生日啦！现在&quot;</span> &lt;&lt; age_ &lt;&lt; <span class="string">&quot;岁。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Student::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name_;  <span class="comment">// 返回姓名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>







<h3 id="1-定义对象"><a href="#1-定义对象" class="headerlink" title="1.定义对象"></a>1.定义对象</h3><p>C++中对象的基本实例化方法要简单一点，直接像变量一样直接通过类型写即可，不像Java中还需要new</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box Box1;          <span class="comment">// 声明 Box1，类型为 Box</span></span><br><span class="line">Box Box2;          <span class="comment">// 声明 Box2，类型为 Box</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>可以直接通过include语句声明类之后直接通过Box类型进行声明</p>
<p><strong>访问数据成员</strong></p>
<p>这个所有语言都一样，无论结构体还是对象直接通过箭头和点访问即可</p>
<p>示例：</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">      <span class="type">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">double</span> height;   <span class="comment">// 高度</span></span><br><span class="line">      <span class="comment">// 成员函数声明</span></span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">( <span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 成员函数定义</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Box::get</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Box::set</span><span class="params">( <span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    breadth = bre;</span><br><span class="line">    height = hei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Box Box1;        <span class="comment">// 声明 Box1，类型为 Box</span></span><br><span class="line">   Box Box2;        <span class="comment">// 声明 Box2，类型为 Box</span></span><br><span class="line">   Box Box3;        <span class="comment">// 声明 Box3，类型为 Box</span></span><br><span class="line">   <span class="type">double</span> volume = <span class="number">0.0</span>;     <span class="comment">// 用于存储体积</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 1 详述</span></span><br><span class="line">   Box<span class="number">1.</span>height = <span class="number">5.0</span>; </span><br><span class="line">   Box<span class="number">1.l</span>ength = <span class="number">6.0</span>; </span><br><span class="line">   Box<span class="number">1.</span>breadth = <span class="number">7.0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 2 详述</span></span><br><span class="line">   Box<span class="number">2.</span>height = <span class="number">10.0</span>;</span><br><span class="line">   Box<span class="number">2.l</span>ength = <span class="number">12.0</span>;</span><br><span class="line">   Box<span class="number">2.</span>breadth = <span class="number">13.0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 1 的体积</span></span><br><span class="line">   volume = Box<span class="number">1.</span>height * Box<span class="number">1.l</span>ength * Box<span class="number">1.</span>breadth;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Box1 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 2 的体积</span></span><br><span class="line">   volume = Box<span class="number">2.</span>height * Box<span class="number">2.l</span>ength * Box<span class="number">2.</span>breadth;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Box2 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 3 详述</span></span><br><span class="line">   Box<span class="number">3.</span><span class="built_in">set</span>(<span class="number">16.0</span>, <span class="number">8.0</span>, <span class="number">12.0</span>); </span><br><span class="line">   volume = Box<span class="number">3.</span><span class="built_in">get</span>(); </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Box3 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>输出结果</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box1 的体积：<span class="number">210</span></span><br><span class="line">Box2 的体积：<span class="number">1560</span></span><br><span class="line">Box3 的体积：<span class="number">1536</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。</p>
<h3 id="2-构造和析构函数"><a href="#2-构造和析构函数" class="headerlink" title="2.构造和析构函数"></a>2.构造和析构函数</h3><p>使用和其他语言都是一样的，构造函数都是在对象被定义的时候调用用来初始化，析构函数则是在每个对象被销毁之前进行调用，只需要记住语法用来期末考试就行了</p>
<p>构造函数分为无参构造函数，有参构造函数，默认参数构造函数。主要就是默认参数构造函数，这个函数在无参的时候会使用默认的参数，在有参的时候则会使用输入的参数</p>
<p>构造函数示例：</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//h文件声明</span></span><br><span class="line">    <span class="comment">// 默认参数只能在声明中指定，不能同时在定义中指定</span></span><br><span class="line">    <span class="built_in">Book</span>(<span class="type">const</span> std::string&amp; title = <span class="string">&quot;未命名&quot;</span>, </span><br><span class="line">         <span class="type">const</span> std::string&amp; author = <span class="string">&quot;未知作者&quot;</span>, </span><br><span class="line">         <span class="type">double</span> price = <span class="number">0.0</span>, </span><br><span class="line">         <span class="type">int</span> pages = <span class="number">0</span>);</span><br><span class="line"><span class="comment">//cpp文件中实现</span></span><br><span class="line">Book::<span class="built_in">Book</span>(<span class="type">const</span> std::string&amp; title, </span><br><span class="line">           <span class="type">const</span> std::string&amp; author, </span><br><span class="line">           <span class="type">double</span> price, </span><br><span class="line">           <span class="type">int</span> pages)</span><br><span class="line">    : <span class="built_in">title_</span>(title), <span class="built_in">author_</span>(author), <span class="built_in">price_</span>(price), </span><br><span class="line">      <span class="built_in">pages_</span>(pages), <span class="built_in">pagesRead_</span>(<span class="number">0</span>)  <span class="comment">// 初始化列表</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;创建图书: &quot;</span> &lt;&lt; title_ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是在头文件中声明，那在单独的cpp文件类中我们是可以直接写默认参数的，但是我们需要确保默认参数的构造函数中默认参数只声明一次</span></span><br><span class="line"><span class="comment">//单独cpp文件中</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name = <span class="string">&quot;匿名&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>) </span><br><span class="line">        : <span class="built_in">name_</span>(name), <span class="built_in">age_</span>(age) <span class="comment">//这样可以直接将name和age赋值给name_和age_</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建学生: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p>析构函数的特点是没有参数和返回值，在对象被销毁的时候调用</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">MyClass</span>();  <span class="comment">// 析构函数：类名前加 ~</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>示例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Student</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] scores_;  <span class="comment">// 释放动态内存</span></span><br><span class="line">    std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; 对象被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我懒得去知道对象到底在哪些请况中会被销毁。</p>
<h3 id="3-对象数组与指针"><a href="#3-对象数组与指针" class="headerlink" title="3.对象数组与指针"></a>3.对象数组与指针</h3><p>虽然说对象数组就是每一个元素都是同一类型的对象的数组，但是和普通数组的区别在于对象数组需要进行初始化</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全部使用默认参数</span></span><br><span class="line">Student students[<span class="number">5</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同的构造函数初始化每个元素</span></span><br><span class="line">Student students[<span class="number">3</span>] = &#123;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">85</span>),    <span class="comment">// 调用参数构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">92</span>),    <span class="comment">// 调用参数构造函数  </span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">78</span>)     <span class="comment">// 调用参数构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分指定，其余使用默认构造函数</span></span><br><span class="line">Student students[<span class="number">5</span>] = &#123;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">85</span>),  <span class="comment">// 第一个元素</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">92</span>)   <span class="comment">// 第二个元素</span></span><br><span class="line">    <span class="comment">// 后三个元素使用默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以自动推断出元素数量</span></span><br><span class="line"><span class="comment">// C++11支持的新语法</span></span><br><span class="line">Student students[<span class="number">3</span>] &#123;</span><br><span class="line">    &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">85</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">92</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">78</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动推断数组大小</span></span><br><span class="line">Student students[] &#123;</span><br><span class="line">    &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">85</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">92</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">78</span>&#125;  <span class="comment">// 自动推断数组大小为3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p><strong>对象指针语法</strong></p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明方式</span></span><br><span class="line">类名*对象指针名;</span><br><span class="line"><span class="comment">//赋值方式</span></span><br><span class="line">对象指针名<span class="number">0</span>=&amp;对象名;</span><br><span class="line"><span class="comment">//使用对象指针和对象名都可以访问类的成员，其中使用对象指针的访问方式为</span></span><br><span class="line">对象指针名-&gt;类的成员;</span><br><span class="line">(*对象指针名).类的成员</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p><strong>this指针</strong></p>
<p>this指针就是一个只可以在当前类中使用，用来在执行代码的时候指向当前对象的一个指针。this指针的类型是<code>ClassName* const</code>，我们也可以使用对象指针的语法去使用this指针</p>
<p>使用示例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;  <span class="comment">// this-&gt;name 是成员变量，name 是参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//返回当前对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Calculator&amp; <span class="title">add</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        value += n;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们需要注意类的静态方法是代码开始运行之前就加载了的，可以直接通过类名进行调用，是不能使用this指针的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this-&gt;x = 10;  // 错误！静态函数没有 this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p><strong>对象的赋值</strong></p>
<p>对象之间也可以像那些数据类型一样，同类型之间的可以使用等号进行赋值，相应的两个对象之间进行了赋值，但是其仍然是分离的</p>
<p>语法</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student student1;</span><br><span class="line">Student student2;</span><br><span class="line">student1=student2;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>之所以可以通过等号进行对象之前的赋值，这是因为在执行的时候C++自动生成了一个&#x3D;的运算符重载函数，其参数就是对应的对象。</p>
<h2 id="2-类的继承"><a href="#2-类的继承" class="headerlink" title="2.类的继承"></a>2.类的继承</h2><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</p>
<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// eat() 函数</span></span><br><span class="line">    <span class="comment">// sleep() 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="comment">// bark() 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>然后就是和其他的一样，一个类可以同时继承多个类，但是不能有同名的方法和属性上的冲突，否则就是二义性了</p>
<h3 id="1-类在内存中的分布"><a href="#1-类在内存中的分布" class="headerlink" title="1.类在内存中的分布"></a>1.类在内存中的分布</h3><p>这已经是我学的好几遍面向对象编程了，每次都要看一遍继承这些操作，我想在这次学习一下面向对象编程中的内存分布，来从底层的角度理解这些操作。</p>
<p><strong>C++ 的类，本质是“内存布局 + 访问规则 + 编译期生成的代码”。</strong>这也就好像解释了后面我们说为什么类是不占用内存的，占用内存的是对象。这也就解释了为什么类是无法直接执行方法的，直接执行的方法需要使用静态修饰提前加载就可以直接调用了。</p>
<p>虽然我还不知道在编译过程中发生了什么才能够即使不为类提供内存也能够正常运行。为了解决这个问题我们还需要进一步了解一下代码到底是如何从写到编译然后到运行期间到底发生了什么</p>
<ul>
<li>类 <strong>本身不占内存</strong></li>
<li>对象 <strong>才占内存</strong></li>
<li>成员函数 <strong>不在对象里</strong></li>
</ul>
<p>记住这 3 句，后面所有内容都会顺。</p>
<p><strong>对象</strong></p>
<p>C++ 的对象，本质上就是一块连续的内存</p>
<p>类 ≈ 数据布局规则<br> 对象 ≈ 按规则分配的一段内存</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一个对象在内存中分布就是直接储存属性，至于方法是存放在代码区的</span></span><br><span class="line">| x | y |</span><br><span class="line"><span class="comment">//没有魔法</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<ul>
<li><code>sizeof(A) == 8</code>（通常）</li>
<li><code>a</code> 是一段连续内存</li>
<li>成员顺序 &#x3D; 声明顺序（⚠️不是初始化列表顺序）也就是定义对象时就为属性分配内存了，而不是往里面写才有内存</li>
</ul>
<p><strong>方法</strong></p>
<p>这个时候我们就有疑惑了，既然对象在内存中没有储存着方法，那方法又是如何调用的，方法大多是都是需要对当前对象进行操作的。</p>
<p>对于我们这样的一个对象</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//即使有一个函数，内存还是只有x 我们使用sizeof来判断还是4</span></span><br><span class="line">| x |</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>说明</p>
<ul>
<li><strong>成员函数不占对象内存</strong></li>
<li><code>f()</code> 在 <strong>代码区</strong></li>
</ul>
<p>调用时编译器偷偷干了这件事：</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">f</span>();</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">f</span>(&amp;a);</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>也就是说我们调用方法的时候是在代码区找到这个方法，然后在通过对象调用时会将指向对象的指针（感觉和this指针一样）传递给方法，代码区的方法来源于编译代码的时候将类中的方法存到了代码区。</p>
<p>👉 所以成员函数的本质：<strong>普通函数 + 隐式 this 指针</strong></p>
<p><strong>继承</strong></p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//其实就是在存放B对象的时候再提前存放一个A对象，后面再跟上B对象额外写的，然后在使用的时候B的数据会对前面的A进行覆盖这就是重写，代码区应该也是这样的</span></span><br><span class="line">| A::x | B::y |</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; <span class="type">int</span> b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多继承只不过是多了一个对象而已，这个图只是看一下，实际上B和C是同级别的，运行的时候应该会进行二义性校验</span></span><br><span class="line">| A::a | B::b | C::c |</span><br><span class="line"></span><br><span class="line"><span class="comment">//还需要说一下，假如继承顺序是A-&gt;B-&gt;C其中C的内存分布是</span></span><br><span class="line">| A::a | B::b | C::c |</span><br><span class="line"><span class="comment">//这也就是为什么C指针也可以转化为A指针</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>由于我们在继承的时候由于前面其实会跟着基类的一个对象，于是我们的派生类也可以随时转换为基类的指针</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C c;</span><br><span class="line">B* pb = &amp;c;  <span class="comment">// 编译器自动偏移</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p><strong>虚继承</strong></p>
<p>我承认我是后面学到虚继承的时候才想到要学习一下内存使用，但是现在还是一知半解，希望这肤浅的理解水平后面够用。</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">int</span> x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//虚继承就相当于共享基类，一个类只有一个虚基类，所有虚继承的类都会指向那个虚基类</span></span><br><span class="line">| B 子对象 | C 子对象 | <span class="built_in">A</span>(虚基类) | D::y |</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们从这里也可以看到，最后这个虚基类其实是由最后的派生类（最后是多继承不是虚继承）负责的。</p>
<p>至于其他复杂一点的操作，比如重写等操作，我感觉也是基于这种内存储存实现的。这个基本上使用不到，只是为了理解。</p>
<h3 id="2-派生类"><a href="#2-派生类" class="headerlink" title="2.派生类"></a>2.派生类</h3><p>C++有一个不同于其他语言的特性就是，在进行继承的时候子类会带有一个修饰符，这个修饰符不像Java那样是修饰子类的，因为C++在定义类的时候类是不需要修饰符的，所有类都是全局访问，这个修饰符主要就是会修改一些基类中原来的修饰符。</p>
<p>具体情况就是从public到private范围小的会覆盖范围大的修饰符，也就是protected修饰的时候Animal类中的public修饰的全部变为了protected</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicVar;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 不可访问，无论何种继承</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 公有继承 (public inheritance) - &quot;是一个&quot;关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedPublic</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// publicVar → 仍为 public</span></span><br><span class="line">    <span class="comment">// protectedVar → 仍为 protected</span></span><br><span class="line">    <span class="comment">// 继承接口和行为</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 保护继承 (protected inheritance) - &quot;实现继承&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedProtected</span> : <span class="keyword">protected</span> Base &#123;</span><br><span class="line">    <span class="comment">// publicVar → 变为 protected</span></span><br><span class="line">    <span class="comment">// protectedVar → 仍为 protected</span></span><br><span class="line">    <span class="comment">// 隐藏基类接口，仅继承实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 私有继承 (private inheritance) - &quot;实现继承&quot;，默认</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedPrivate</span> : <span class="keyword">private</span> Base &#123;  <span class="comment">// class默认private继承</span></span><br><span class="line">    <span class="comment">// publicVar → 变为 private</span></span><br><span class="line">    <span class="comment">// protectedVar → 变为 private</span></span><br><span class="line">    <span class="comment">// 完全隐藏基类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 不加public会怎样？</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedWithoutPublic</span> : Base &#123;  <span class="comment">// class默认private继承！</span></span><br><span class="line">    <span class="comment">// 等价于: class DerivedWithoutPublic : private Base</span></span><br><span class="line">    <span class="comment">// publicVar → private (不是public！)</span></span><br><span class="line">    <span class="comment">// protectedVar → private (不是protected！)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p><strong>访问修饰符</strong></p>
<p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>
<p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="left">访问</th>
<th align="left">public</th>
<th align="left">protected</th>
<th align="left">private</th>
</tr>
</thead>
<tbody><tr>
<td align="left">同一个类</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">派生类</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">外部的类</td>
<td align="left">yes</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
</tbody></table></div>
<p><strong>一个派生类继承了所有的基类方法，但下列情况除外：</strong></p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<h3 id="3-派生类的构造和析构函数"><a href="#3-派生类的构造和析构函数" class="headerlink" title="3.派生类的构造和析构函数"></a>3.派生类的构造和析构函数</h3><p>我们从继承可以知道派生类是不会继承基类的构造函数和析构函数的，但是我们也知道定义子类的对象在C++中会在内存中也定义一个父类的对象。</p>
<p>我们平常的话子类在定义对象执行构造函数的时候自动调用父类的构造函数，但是如果父类的构造函数需要参数的话，我们不显示调用去传参就会报错，这个时候我们就<strong>必须</strong>在子类中获取到父类构造函数需要的参数，然后在子类的构造函数中调用父类的构造方法</p>
<p>我们来看一下由DS赞助的代码</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类：模拟一个有实际功能的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：初始化对象数据</span></span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> string&amp; n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物 [&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;] 出生了，年龄: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; 岁&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数：清理资源</span></span><br><span class="line">    ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物 [&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;] 离开了，享年 &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; 岁&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类方法：展示功能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 发出动物声音&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> string&amp; food)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 正在吃 &quot;</span> &lt;&lt; food &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类：扩展基类功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string breed;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类构造函数：先调用基类构造函数初始化基类部分</span></span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> string&amp; n, <span class="type">int</span> a, <span class="type">const</span> string&amp; b) <span class="comment">//注意也需要提供基类构造方法的参数</span></span><br><span class="line">        : <span class="built_in">Animal</span>(n, a), <span class="built_in">breed</span>(b) &#123;  <span class="comment">//调用Animal类的构造方法，在此基础上再为Dog类新属性breed赋值</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;这是一只 &quot;</span> &lt;&lt; breed &lt;&lt; <span class="string">&quot; 品种的狗&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 派生类析构函数：先执行派生类清理，再自动调用基类析构函数</span></span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        cout &lt;&lt; breed &lt;&lt; <span class="string">&quot; 狗即将离开&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩展基类功能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; 汪汪叫！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fetch</span><span class="params">(<span class="type">const</span> string&amp; item)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; 正在捡回 &quot;</span> &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">getBreed</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> breed; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=== 程序开始 ===&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n--- 创建Dog对象 ---&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>, <span class="string">&quot;金毛&quot;</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n--- 使用基类功能 ---&quot;</span> &lt;&lt; endl;</span><br><span class="line">        myDog.<span class="built_in">makeSound</span>();        <span class="comment">// 继承自基类</span></span><br><span class="line">        myDog.<span class="built_in">eat</span>(<span class="string">&quot;狗粮&quot;</span>);        <span class="comment">// 继承自基类</span></span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n--- 使用派生类功能 ---&quot;</span> &lt;&lt; endl;</span><br><span class="line">        myDog.<span class="built_in">bark</span>();             <span class="comment">// 派生类特有</span></span><br><span class="line">        myDog.<span class="built_in">fetch</span>(<span class="string">&quot;球&quot;</span>);        <span class="comment">// 派生类特有</span></span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n--- 获取对象信息 ---&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;名字: &quot;</span> &lt;&lt; myDog.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;年龄: &quot;</span> &lt;&lt; myDog.<span class="built_in">getAge</span>() &lt;&lt; <span class="string">&quot;岁&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;品种: &quot;</span> &lt;&lt; myDog.<span class="built_in">getBreed</span>() &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n--- Dog对象即将离开作用域 ---&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// myDog在这里被销毁</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n=== 程序结束 ===&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>





<h3 id="4-多重继承与虚继承"><a href="#4-多重继承与虚继承" class="headerlink" title="4.多重继承与虚继承"></a>4.多重继承与虚继承</h3><p>这个其实就是和继承一样，只不过从继承一个变为了继承多个，只需要这几个基类不会出现二义性就和普通继承一样</p>
<p>虽然说是这么说，但是如果继承的层数多起来就会导致一些难以处理的问题。</p>
<p>我们来看一组继承关系</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们可以看到，当b和c继承自a的时候会拥有同名的来自a的数据，当D同时继承b和c会出现二义性冲突而导致编译错误</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>这个问题就是典型的菱形继承，解决这种问题的最好办法就是虚继承，通过虚继承的派生类，继承到的全部都是共享的一个虚基类。</p>
<p>我们从上面虚继承的内存分布我们可以知道，使用虚继承的类指向的都是同一个虚基类，然后在被一个类进行多继承的时候那个派生类就会继承到。</p>
<p>然后就是和普通继承不同的地方来了，我们普通继承的话都是继承一次构造一次，也就是内存是</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;B-&gt;C</span><br><span class="line"><span class="comment">//B中是，构造一次A</span></span><br><span class="line">A|B</span><br><span class="line"><span class="comment">//C中则是会构造一个B，由于B中构造了A，所以C其实也构造了A</span></span><br><span class="line">A|B|C</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>到了虚继承这里，就有很大的不同，基类A并不是由虚继承的B，C构造出来的，而是由最后多继承的D构造出来。</p>
<p>我们来看一下代码</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> v) &#123; cout &lt;&lt; <span class="string">&quot;A &quot;</span> &lt;&lt; v &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() : <span class="built_in">A</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() : <span class="built_in">A</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>() : <span class="built_in">A</span>(<span class="number">3</span>), <span class="built_in">B</span>(), <span class="built_in">C</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>当我们定义D对象的时候会输出</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A <span class="number">3</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们可以看到，当同时调用基类的构造方法进行对A传递的时候，明明是最先传进行的3，最后却保留了下来，这也就说明了</p>
<ul>
<li><code>B()</code>、<code>C()</code>里对 <code>A</code> 的初始化 <strong>会被忽略</strong>（因为只有构造对象的那个对象才能对其进行操作）</li>
<li><strong>只有 D 对 A 的初始化有效</strong></li>
</ul>
<p>于是说明B和C对没有对A进行构造，事实上BC由于没有构造A，使用的其实是D构造出来的那个A对象</p>
<p><strong>“虚基类由最派生类构造”这句话始终成立</strong></p>
<p>当然，这个时候就会有疑惑，既然虚基类A是由D进行构造的，那B和C又是如何构造A的呢？其实，B和C和普通继承使用上没什么区别，重写等操作都是看起来一样的。但是BC实际上是将普通继承中构造出来的那个A对象变为了一个<strong>vbptr</strong>，这个指针指向BC共同的那个A对象。</p>
<p>于是我们的虚继承代码</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">int</span> x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="comment">//需要注意为了破解菱形继承，需要继承的多个类都进行虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实际上的内存空间为</span></span><br><span class="line">| B 子对象 | C 子对象 | <span class="built_in">A</span>(虚基类) | D::y |</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>然后需要注意的是，由于是D作为最派生类构造了A，于是B和C这两个构造出来的子类对A的操作都会被忽略。和重写一样，只有构造对象的那个对象才能进行操作。</p>
<p>也就是说虚继承的类也就是B和C其实和普通继承使用相似，只不过多了被多继承时只保留一个虚基类A，只不过是有一个标签表明他们是虚继承了同一个了类，这个标签也就是一个指向虚基类A的指针<strong>vbptr</strong>，以这个<strong>vbptr</strong>来判断其虚继承的是否为同一个对象。</p>
<p>而D才是虚继承那个重要的类，会通过BC的标签识别出是同一个类，然后由D亲自去构造一个A虚基类，然后A只由D去操作，其内存中BC对象的操作都被忽略。我觉得这样设计的原因是为了解决菱形继承BC中对虚基类的重写等问题</p>
<p>我们最后再来看一段代码和内存分布</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Final</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line">    <span class="comment">// 现在Final中只有一份Base子对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>内存分布</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Final 对象:</span><br><span class="line">+-------------------+</span><br><span class="line">| Derived1          |</span><br><span class="line">| +---------------+ |</span><br><span class="line">| | vptr          | |--&gt; Derived1的虚表</span><br><span class="line">| +---------------+ |</span><br><span class="line">+-------------------+</span><br><span class="line">| Derived2          |</span><br><span class="line">| +---------------+ |</span><br><span class="line">| | vptr          | |--&gt; Derived2的虚表</span><br><span class="line">| +---------------+ |</span><br><span class="line">+-------------------+</span><br><span class="line">| Base              |</span><br><span class="line">| +---------------+ |</span><br><span class="line">| | data          | |</span><br><span class="line">| +---------------+ |</span><br><span class="line">+-------------------+</span><br><span class="line">| Final 特有数据    |</span><br><span class="line">+-------------------+</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>





<p><strong>为什么虚继承一定需要动态绑定</strong></p>
<p>这是因为代码没有运行的时候，由于BC都无法知道那个虚基类A的位置到底在哪，如果是普通继承的话等代码运行的时候再获取也没问题，因为都是单独构造的，没什么特别操作。</p>
<p>但是虚继承需要BC中指向同一个A对象，但是在编译过程中无法确定这共用A的地址。</p>
<p>还有就是会无法在编译过程确定最派生类，最派生类需要自己构造一个虚基类A，如果不运行代码无法确定到底是哪个类是最派生类。</p>
<h2 id="3-动态多态性"><a href="#3-动态多态性" class="headerlink" title="3.动态多态性"></a>3.动态多态性</h2><p>多态性其实就是决定使用哪个函数的一个性质，多态允许<strong>同一接口</strong>根据上下文表现出<strong>不同行为</strong>。最常见的就是静态多态，在一个对象中，拥有多个同名的函数，却因为函数的参数不同而调用不同的函数，主要有参数数量不同，参数类型不同，参数顺序不同等。</p>
<p>但是我们现在写的不是静态多态性，这个后面会和函数模板，重载和运算符重载一起写。现在要学的是动态多态性</p>
<p>首先我们要知道一个事情，C++代码在运行期间会现在编译过程中完成静态绑定和动态绑定。</p>
<p>其中静态绑定就是决定好该使用哪个对象和调用哪个函数这些都是普通的对象和函数，都是可以不通过运行代码就知道的。</p>
<p>动态绑定则是需要运行代码才能知道要执行哪些操作，比如虚继承，和虚函数。虚函数就是动态多态性的代表，需要进行动态绑定。</p>
<h3 id="1-虚函数"><a href="#1-虚函数" class="headerlink" title="1.虚函数"></a>1.虚函数</h3><p>我们之前知道之所以派生类的指针可以转换为基类的指针，这是因为派生类对象中也内嵌了一个基类对象，于是可以转换，<strong>但是如果使用的是转换为基类的指针去调用一个被重写了的方法，代码运行就会根据这是基类的指针而选择去调用基类的方法（其实是通过基类指针只能去调用基类的成员），而不是重写的方法，使用虚函数就是为了解决这个问题</strong></p>
<p>我们之前会面对一个问题，当我们来看下面代码</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> xValue;</span><br><span class="line">    <span class="type">int</span> yValue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        xValue = x;</span><br><span class="line">        yValue = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点的坐标 &quot;</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; xValue &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; yValue &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> r) : <span class="built_in">Point</span>(x, y)</span><br><span class="line">    &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showCircle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">showPoint</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;圆的半径 r=&quot;</span> &lt;&lt; radius &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">pt1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    pt<span class="number">1.</span><span class="built_in">showPoint</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Circle <span class="title">c</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    c.<span class="built_in">showCircle</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pt1 = c;</span><br><span class="line">    pt<span class="number">1.</span><span class="built_in">showPoint</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Point &amp;p2 = c;</span><br><span class="line">    p<span class="number">2.</span><span class="built_in">showPoint</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;点的面积 &quot;</span> &lt;&lt; pt<span class="number">1.</span><span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;点的面积 &quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Point *p3 = &amp;pt1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;点的坐标 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    p3-&gt;<span class="built_in">showPoint</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;点的面积 &quot;</span> &lt;&lt; p3-&gt;<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Point *p4 = &amp;c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的坐标 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    p4-&gt;<span class="built_in">showPoint</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的面积 &quot;</span> &lt;&lt; p4-&gt;<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//虽然我们是将c的地址赋值给了Point*指针是合法的，但是最后在通过p4调用area方法的时候却返回的是0，这里的原因是</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>程序运行结果为</p>
<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">点的坐标 (10,10)</span><br><span class="line">*****</span><br><span class="line">点的坐标 (0,0)</span><br><span class="line">圆的半径 r=1</span><br><span class="line">*****</span><br><span class="line">点的坐标 (0,0)</span><br><span class="line">*****</span><br><span class="line">点的坐标 (0,0)</span><br><span class="line">*****</span><br><span class="line">点的面积 0</span><br><span class="line">圆的面积 3.14</span><br><span class="line">*****</span><br><span class="line">点的面积 0</span><br><span class="line">圆的面积 0</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>最后输出圆的面积的时候调用不是Circle重写的方法，而是通过基类指针调用基类的area方法</p>
<p>那我们是如何使用虚函数来解决这个问题的呢</p>
<p>语法</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 普通函数</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>虚函数是定义在基类中的，virtual表明这个函数是虚函数，然后虚函数不是像普通函数一样存放，<strong>如果一个类有虚函数就会有一个虚函数表用来存放虚函数。</strong></p>
<p>我们都知道当派生类继承基类的时候会在其中内嵌一个基类，函数和属性一样都会内嵌，然后重写的时候不会对基类的方法进行改写，而是在通过对象调用的时候会调用派生类重写的方法。</p>
<p>但是虚函数不一样，继承的时候派生类也会继承基类的虚函数表，之所以不能和普通函数放一起，是因为虚函数表中会被完全覆盖，而不是像普通函数那样只是不同的调用。</p>
<p>我们先来看一下普通函数是如何进行调用的</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;<span class="built_in">f</span>();</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">A::<span class="built_in">f</span>(p);</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>虚函数则是</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;<span class="built_in">f</span>();</span><br><span class="line">(*(p-&gt;vptr)[idx])(p);<span class="comment">//idx是虚函数在虚函数表中的序号</span></span><br><span class="line"><span class="comment">//vptr是虚函数表的地址</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们看到会直接通过p指针访问到虚函数然后执行。</p>
<p>于是虚函数之所以可以通过派生类转化为的基类指针调用重写的虚函数，这是因为</p>
<ul>
<li><strong>首先虚函数表派生类不会重新创建，而是直接进行覆盖</strong></li>
<li>其次调用的时候不是通过确定对象类型再去代码区调用函数，而是直接通过指针找到虚函数进行调用</li>
<li>能够直接通过指针去找虚函数表是因为有vptr指针</li>
</ul>
<p>于是虚函数调用的时候不需要考虑指针类型，而是通过虚函数表直接调用。</p>
<h3 id="2-纯虚函数与抽象基类"><a href="#2-纯虚函数与抽象基类" class="headerlink" title="2.纯虚函数与抽象基类"></a>2.纯虚函数与抽象基类</h3><p>我们知道了虚函数之后就发现一个问题，如果函数被定义为虚函数就可以在虚函数表中被完全覆盖，也就意味着虚函数表或许可以不需要基类去实现，这让我想起了Java的抽象类和接口可能和这个相似</p>
<p><strong>纯虚函数</strong></p>
<p>纯虚函数是一个没有具体实现的函数，通过在函数声明后面不加括号实现，而是加上&#x3D;0表示这个是一个纯虚函数，本质是将指向函数实现的指针定义为null。</p>
<p>由于函数没有被实现于是含有纯虚函数的类也被称为抽象类，由于函数没有被实现导致不能被实例化为对象，但是却可以被继承。继承的类如果还是没有实现纯虚函数，就还是抽象类不能被定义为对象。</p>
<p>语法</p>
<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual 函数类型 函数名 (参数表)=0;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>





</div><div class="post-reward"><div class="post-reward-btn" title="赞赏作者"><img src="/assets/images/svg/uc/uc-gift.svg" class="icon noview" alt="Icon"><span></span></div><div class="post-reward-content"><div class="post-reward-text"></div><div class="post-reward-list"><a href="/null" target="_blank">致谢名单</a></div></div></div><div class="post-copyright"><div class="post-copyright-info">本作品由 Regulus 于 2025-12-04 16:11:57 发布</div><div class="post-copyright-link"><span>作品地址：<a href="http://example.com/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">C++面向对象编程</a></span><button class="copy-text" type="button" data-text="http://example.com/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">复制</button></div><div class="post-copyright-detail">除特别声明外，本站作品均采用 <a href='https://creativecommons.org/licenses/by-nc-sa/4.0/' title='Attribution-NonCommercial-ShareAlike' target='_blank'>CC BY-NC-SA 4.0</a> 许可协议，转载请注明来自 <a href='/'>Mei的小窝</a></div><img class="post-copyright-icon noview" src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></div><div class="post-tail-tags"><a class="post-tail-tags-link" href="/tags/C/" rel="tag">C++</a></div></div><aside id="post-sidebar" status="show"><div id="toc-container"><div class="toc-title"><img src="/assets/images/svg/ta/ta-toc.svg" class="icon noview" alt="Icon"><span>目录</span></div><div class="toc-content" id="toc-div"><ol class="toc-list"><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-list-text">C++面向对象编程</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#1-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-list-text">1.类与对象</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#1-%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1"><span class="toc-list-text">1.定义对象</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#2-%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-list-text">2.构造和析构函数</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#3-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-list-text">3.对象数组与指针</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#2-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-list-text">2.类的继承</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#1-%E7%B1%BB%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83"><span class="toc-list-text">1.类在内存中的分布</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#2-%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-list-text">2.派生类</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#3-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-list-text">3.派生类的构造和析构函数</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#4-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-list-text">4.多重继承与虚继承</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#3-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-list-text">3.动态多态性</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#1-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-list-text">1.虚函数</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#2-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-list-text">2.纯虚函数与抽象基类</span></a></li></ol></li></ol></li></ol></div></div></aside></div></div><div id="toolbar" hide=""><div id="toolbar-setting-container" hide=""><div class="toolbar-item"><button id="tool-color-mode" title="深色模式" type="button"><img src="/assets/images/svg/ta/ta-moon.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button class="copy-text" id="tool-share" title="分享" type="button" data-text="http://example.com/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"><img src="/assets/images/svg/ta/ta-share.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-font-size-plus" title="放大字体" type="button"><img src="/assets/images/svg/ta/ta-text-plus.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-font-size-minus" title="缩小字体" type="button"><img src="/assets/images/svg/ta/ta-text-minus.svg" class="icon noview" alt="Icon"></button></div></div><div class="toolbar-container"><div class="toolbar-item"><button id="tool-setting" title="设置" type="button"><img src="/assets/images/svg/ta/ta-setting.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-toc" title="目录" type="button"><img src="/assets/images/svg/ta/ta-toc.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-gototop" title="返回顶部" type="button"><img src="/assets/images/svg/ta/ta-up.svg" class="icon noview" alt="Icon"></button></div></div></div><div class="search-overlay"><div class="search-container"><div class="search-header"><div class="search-title"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" /><path d="M21 21l-6 -6" /></svg>
搜索</div><div class="search-close-btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 21a9 9 0 0 0 9 -9a9 9 0 0 0 -9 -9a9 9 0 0 0 -9 9a9 9 0 0 0 9 9z" /><path d="M9 8l6 8" /><path d="M15 8l-6 8" /></svg></div></div><div class="search-input-box"><input id="search-input" type="search" placeholder="请输入关键词进行站内搜索……" value="" maxlength="80"/></div><div class="search-result-container"><div class="search-result-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" /><path d="M21 21l-6 -6" /></svg></div></div></div></div></main><footer><div class="footer"><div id="footer-copyright">© 2024 - 2026 <span>💗</span> <a href="/null">Regulus</a></div><div id="footer-info"><div id="footer-framework">🚀本站由 <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/chanwj/hexo-theme-meow" title="3.2.0" target="_blank">Meow</a> 强力驱动</div><div id="footer-runtime"><span id="runtime" data-startdate="2024-04-02T22:16:20.000Z">🌻已稳定运行.年.月.天</span></div></div><div id="footer-statistic"><span>共撰写164篇文章，全站共414.8k字</span></div><div id="footer-pageview"><div id="container_site_pv"><span>🔥总访问量</span><span id="vercount_value_site_pv"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 6l0 -3" /><path d="M16.25 7.75l2.15 -2.15" /><path d="M18 12l3 0" /><path d="M16.25 16.25l2.15 2.15" /><path d="M12 18l0 3" /><path d="M7.75 16.25l-2.15 2.15" /><path d="M6 12l-3 0" /><path d="M7.75 7.75l-2.15 -2.15" /></svg></span></div><div id="container_site_uv"><span>🐈访客人数</span><span id="vercount_value_site_uv"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 6l0 -3" /><path d="M16.25 7.75l2.15 -2.15" /><path d="M18 12l3 0" /><path d="M16.25 16.25l2.15 2.15" /><path d="M12 18l0 3" /><path d="M7.75 16.25l-2.15 2.15" /><path d="M6 12l-3 0" /><path d="M7.75 7.75l-2.15 -2.15" /></svg></span></div></div></div></footer><div class="scripts"><script>const GLOBALCONFIG = {
  root: '/',
  toolbar: true,
  lazyload_src: '/assets/images/Meow-Loading.webp',
  friends: false,
  codeblock: true,
  share_text: '',
  onblur_title: 'Please Come Back～✧(´▽`ʃ♡ƪ)',
  mouse_click: false,
  notify:{
    enable: false,
    info: '复制成功～转载请标注本文地址',
    f12_info: '开发者模式已打开，请遵循本站版权协议'
  },
  search: {
    enable: true,
    path: 'search.json',
    local: {
      top_n_per_article: 1,
      preload: false
    }
  },
  encrypt: false,
};
</script><script>if (!localStorage.getItem('color-mode')) {
  localStorage.setItem('color-mode', 'light' || 'light');
}
document.body.setAttribute('data-mode', localStorage.getItem('color-mode'));
</script>
<script src="/js/theme/tools/utils.js"></script>

<script src="/js/plugins/dist/lazyload.min.js"></script>

<script src="/js/plugins/view-image.min.js"></script>
<script src="https://events.vercount.one/js" defer="defer"></script><script>if (localStorage.getItem('font-size')) {
  document.querySelector('.post').style.fontSize = localStorage.getItem('font-size') + 'px';
}
</script>
<script src="/js/plugins/dist/search.js"></script>

<script src="/js/main.js" type="module"></script>
</div></body></html>