<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Regulus"/><meta name="copyright" content="Regulus"/><meta name="theme-color" content="#FFB347"/><meta name="format-detection" content="telephone=no"/><meta name="keywords" content="C++"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-touch-fullscreen" content="yes"/><meta name="application-name" content="C++面向对象编程 | Mei的小窝"/><meta name="apple-mobile-web-app-title" content="C++面向对象编程 | Mei的小窝"/><meta name="apple-mobile-web-app-status-bar-style" content="#FFB347"/><link rel="canonical" href="http://example.com/2025/12/04/C-面向对象编程/"/><meta name="description" content="C++面向对象编程为什么计科要从C++开始学面向对象编程，一开始以为反正都是面向对象编程，以为会和Java差不多，结果一看发现还是没有Java方便，到现在又要期末考试了，只能趁着实验课来补一下不会的。 妈的，上次这么复习的还是汇编，我复习了整整一个星期啊，看了十多个小时的教程，结果被那傻逼试卷给背刺了，不仅题目变成了一几年的类型题目好多，题目难度更是逆天，本来靠写概念题我都可以及格，结果概念...">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面向对象编程 | Mei的小窝">
<meta property="og:url" content="http://example.com/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Mei的小窝">
<meta property="og:description" content="C++面向对象编程为什么计科要从C++开始学面向对象编程，一开始以为反正都是面向对象编程，以为会和Java差不多，结果一看发现还是没有Java方便，到现在又要期末考试了，只能趁着实验课来补一下不会的。 妈的，上次这么复习的还是汇编，我复习了整整一个星期啊，看了十多个小时的教程，结果被那傻逼试卷给背刺了，不仅题目变成了一几年的类型题目好多，题目难度更是逆天，本来靠写概念题我都可以及格，结果概念...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/assets/images/Hexo-Theme-MEOW.png">
<meta property="article:published_time" content="2025-12-04T08:11:57.000Z">
<meta property="article:modified_time" content="2026-02-06T09:24:57.175Z">
<meta property="article:author" content="Regulus">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/assets/images/Hexo-Theme-MEOW.png"><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="revisit-after" content="1 days"/><title>C++面向对象编程 | Mei的小窝</title><link rel="shortcut icon" href="/assets/images/Hexo-Theme-MEOW.ico"><link rel="preconnect" href="/assets"/><link rel="preconnect" href="assets"/>
<link rel="stylesheet" href="/css/style.css">
<link rel="prefetch" href="/"/><link rel="prefetch" href="/archives"/><link rel="prefetch" href="/tags"/><meta name="generator" content="Hexo 7.3.0"></head><body bg-style="none"><header><div id="navbar"><div id="nav-info"><a id="site-icon" href="/" title="主页"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></a><a id="site-name" href="/" title="主页"><div>Mei的小窝</div><img src="/assets/images/svg/uc/uc-home.svg" class="icon noview" alt="Icon"></a></div><div id="nav-menu"><div class="menu-item"><a href="javascript:void(0);"><img src="/assets/images/svg/uc/uc-article.svg" class="icon noview" alt="Icon"><span>文章</span></a><ul class="sub-menu-item"><li><a href="/archives"><img src="/assets/images/svg/uc/uc-archive.svg" class="icon noview" alt="Icon"><span>归档</span></a></li><li><a href="/categories"><img src="/assets/images/svg/uc/uc-category.svg" class="icon noview" alt="Icon"><span>分类</span></a></li><li><a href="/tags"><img src="/assets/images/svg/uc/uc-tag.svg" class="icon noview" alt="Icon"><span>标签</span></a></li><li><a href="/about"><img src="/assets/images/svg/uc/uc-about.svg" class="icon noview" alt="Icon"><span>关于</span></a></li></ul></div></div><div id="nav-function"><div id="search-btn"><a href="javascript:void(0);" title="搜索" accesskey="s"><img src="/assets/images/svg/uc/uc-search.svg" class="icon noview" alt="Icon"><span>搜索</span></a></div><div id="menu-btn"><a href="javascript:void(0);" title="打开菜单"><img src="/assets/images/svg/uc/uc-menu.svg" class="icon noview" alt="Icon"></a></div></div></div></header><div id="menu-aside"><div id="menu-aside-container"><div id="menu-aside-info"><a href="/" title="主页"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></a><a href="/" title="主页">Mei的小窝</a></div><div class="menu-aside-item"><a href="javascript:void(0);"><img src="/assets/images/svg/uc/uc-article.svg" class="icon noview" alt="Icon"><span>文章</span></a><ul class="menu-aside-sub-item"><li><a href="/archives"><img src="/assets/images/svg/uc/uc-archive.svg" class="icon noview" alt="Icon"><span>归档</span></a></li><li><a href="/categories"><img src="/assets/images/svg/uc/uc-category.svg" class="icon noview" alt="Icon"><span>分类</span></a></li><li><a href="/tags"><img src="/assets/images/svg/uc/uc-tag.svg" class="icon noview" alt="Icon"><span>标签</span></a></li><li><a href="/about"><img src="/assets/images/svg/uc/uc-about.svg" class="icon noview" alt="Icon"><span>关于</span></a></li></ul></div><hr/></div></div><main><div class="banner"><div class="banner-info"><div class="banner-avatar"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Avatar"/></div><div class="banner-title">「 Mei的小窝 」</div></div></div><div class="post-container"><div class="post-main"><div class="post-content"><h1 class="post-title">C++面向对象编程</h1><div class="post-author"><span>作者: Regulus</span></div><div class="post-meta"><div class="post-info"><div class="post-date"><div class="post-pubdate"><img src="/assets/images/svg/ta/ta-pubdate.svg" class="icon noview" alt="Icon"><span>发表于2025-12-04</span></div><div class="post-update"><img src="/assets/images/svg/ta/ta-update.svg" class="icon noview" alt="Icon"><span>更新于2026-02-06</span></div></div><div class="post-read"><div class="post-wordcount"><img src="/assets/images/svg/ta/ta-write.svg" class="icon noview" alt="Icon"><span>总字数: 18.5k字</span></div><div class="post-readtime"><img src="/assets/images/svg/ta/ta-time.svg" class="icon noview" alt="Icon"><span>阅读时长: 63分钟</span></div><div class="post-pageview"><img src="/assets/images/svg/ta/ta-fire.svg" class="icon noview" alt="Icon"><span>访问量: </span><span id="vercount_value_page_pv"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 6l0 -3" /><path d="M16.25 7.75l2.15 -2.15" /><path d="M18 12l3 0" /><path d="M16.25 16.25l2.15 2.15" /><path d="M12 18l0 3" /><path d="M7.75 16.25l-2.15 2.15" /><path d="M6 12l-3 0" /><path d="M7.75 7.75l-2.15 -2.15" /></svg></span></div></div></div><div class="post-attribute"><div class="post-tags"><img src="/assets/images/svg/ta/ta-tag.svg" class="icon noview" alt="Icon"><span><a class="post-tags-link" href="/tags/C/" rel="tag">C++</a></span></div></div></div><div class="post markdown" indent="false"><h1 id="C-面向对象编程"><a href="#C-面向对象编程" class="headerlink" title="C++面向对象编程"></a>C++面向对象编程</h1><p>为什么计科要从C++开始学面向对象编程，一开始以为反正都是面向对象编程，以为会和Java差不多，结果一看发现还是没有Java方便，到现在又要期末考试了，只能趁着实验课来补一下不会的。</p>
<p>妈的，上次这么复习的还是汇编，我复习了整整一个星期啊，看了十多个小时的教程，结果被那傻逼试卷给背刺了，不仅题目变成了一几年的类型题目好多，题目难度更是逆天，本来靠写概念题我都可以及格，结果概念题几乎没有，还全部是算地址的题目。如果老师不在我那个只写了框架的程序设计题多给点分的话我肯定挂科了。</p>
<p>C++的面向过程还是和其他语言一致的，语法上应该和C语言差不多</p>
<h2 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1.类与对象"></a>1.类与对象</h2><p>类和对象没什么特别的，所有面向对象编程概念都是差不多的，只不过语法上有一些差别。</p>
<p><strong>类的定义</strong></p>
<p>定义一个类需要使用关键字 <strong>class</strong>，然后指定类的名称，并类的主体是包含在一对花括号中，主体包含类的成员变量和成员函数。</p>
<p>定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p>
<img lazyload src="/assets/images/Meow-Loading.webp" data-lazy-src="/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/cpp-classes-objects-2020-12-10-11.png" class title="img">

<p>我们来看一个实例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">double</span> length;   <span class="comment">// 盒子的长度</span></span><br><span class="line">      <span class="type">double</span> breadth;  <span class="comment">// 盒子的宽度</span></span><br><span class="line">      <span class="type">double</span> height;   <span class="comment">// 盒子的高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们可以注意到，和Java不同的就是C++没有对class进行修饰符修饰，这样就意味着所有类都是可以在其他类中被访问然后进行实例化。不像在Java中比如Runtime类就是private的，也就是不能直接被new，需要调用方法getRuntime返回一个Runtime对象。C++中通过对变量和函数进行修饰来实现封装</p>
<p>然后就是C++不能像python和Java那样，直接通过import语句进行引用，而是通过include语句去引用一个.h文件。一开始学C语言的时候不知道<code>#include &lt;stdio.h&gt;</code>的作用是什么，只是每次都写上，其实现在也不知道到底是为了使用哪个方法才去引用它</p>
<p>我们在写面向对象的程序的时候就会看到.h文件中的内容类似</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//student.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grade</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> math; <span class="comment">// 数学成绩</span></span><br><span class="line">    <span class="type">double</span> english; <span class="comment">// 英语成绩</span></span><br><span class="line">    <span class="type">double</span> programming; <span class="comment">// 编程成绩</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Grade</span>();</span><br><span class="line">    <span class="built_in">Grade</span>(<span class="type">double</span> _math, <span class="type">double</span> _english, <span class="type">double</span> _programming);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_math</span><span class="params">(<span class="type">double</span> _math)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_english</span><span class="params">(<span class="type">double</span> _english)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_programming</span><span class="params">(<span class="type">double</span> _programming)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_math</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_english</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_programming</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>这样的目的就是将我们在对应的student.cpp文件中定义的类和函数在这里进行一个声明，然后在其他.cpp文件中只需要<code>include &quot;student.h&quot;</code>，然后我们就可以访问到h中声明的函数和类了，也可以选择在h文件中声明变量。</p>
<p>然后就是只要在h文件中引入的文件在对应的cpp文件中只需要<code>include &quot;student.h&quot;</code>就相当于引入了</p>
<p>我们还需要注意，类的定义有两种方式。分别是单独一个cpp文件和h&#x2F;cpp文件。</p>
<p>单独cpp文件</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就是不依赖h文件的声明，直接在cpp文件中写类的所有信息</span></span><br><span class="line"><span class="comment">// student.cpp - 最简单的学生类示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义Student类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(std::string n, <span class="type">int</span> a) &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数：显示信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; name </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, 年龄: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数：庆祝生日</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">birthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        age++;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 过生日啦！现在 &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; 岁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">int</span> age;           <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 主函数 - 使用Student类</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Student对象</span></span><br><span class="line">    <span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">stu2</span><span class="params">(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用对象的方法</span></span><br><span class="line">    stu<span class="number">1.</span><span class="built_in">show</span>();</span><br><span class="line">    stu<span class="number">2.</span><span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 张三过生日</span></span><br><span class="line">    stu<span class="number">1.</span><span class="built_in">birthday</span>();</span><br><span class="line">    stu<span class="number">1.</span><span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p>cpp和h文件定义类</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个和传统的类不同，主要就是类的中心是h文件而并非cpp文件，在h文件中声明了类的属性和方法，在调用类的方法的时候是先去访问h文件，然后通过在对应cpp文件中去寻找方法的实现，对于没有在h文件中声明的方法即使在cpp中实现了也没用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//student.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STUDENT_H  <span class="comment">// 防止重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STUDENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  <span class="comment">// 需要用到string类型</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数声明</span></span><br><span class="line">    <span class="built_in">Student</span>(std::string name, <span class="type">int</span> age);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数声明（只有函数原型，没有实现）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">introduce</span><span class="params">()</span></span>;      <span class="comment">// 自我介绍</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">haveBirthday</span><span class="params">()</span></span>;   <span class="comment">// 过生日</span></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">// 获取姓名</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 成员变量声明（不暴露具体值）</span></span><br><span class="line">    std::string name_;     <span class="comment">// 姓名（私有）</span></span><br><span class="line">    <span class="type">int</span> age_;              <span class="comment">// 年龄（私有）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// STUDENT_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//student.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span>  <span class="comment">// 必须包含自己的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>   <span class="comment">// 需要用到cout</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 构造函数实现</span></span><br><span class="line"><span class="comment">// 格式：类名::构造函数名(参数)</span></span><br><span class="line">Student::<span class="built_in">Student</span>(std::string name, <span class="type">int</span> age) </span><br><span class="line">    : <span class="built_in">name_</span>(name), <span class="built_in">age_</span>(age)  <span class="comment">// 初始化列表（推荐写法）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数体</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;创建学生: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 成员函数实现</span></span><br><span class="line"><span class="comment">// 格式：返回类型 类名::函数名(参数)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::introduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;大家好，我是&quot;</span> &lt;&lt; name_ </span><br><span class="line">              &lt;&lt; <span class="string">&quot;，今年&quot;</span> &lt;&lt; age_ &lt;&lt; <span class="string">&quot;岁。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::haveBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    age_++;  <span class="comment">// 年龄加1</span></span><br><span class="line">    std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot;过生日啦！现在&quot;</span> &lt;&lt; age_ &lt;&lt; <span class="string">&quot;岁。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Student::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name_;  <span class="comment">// 返回姓名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>







<h3 id="1-定义对象"><a href="#1-定义对象" class="headerlink" title="1.定义对象"></a>1.定义对象</h3><p>C++中对象的基本实例化方法要简单一点，直接像变量一样直接通过类型写即可，不像Java中还需要new</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box Box1;          <span class="comment">// 声明 Box1，类型为 Box</span></span><br><span class="line">Box Box2;          <span class="comment">// 声明 Box2，类型为 Box</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>可以直接通过include语句声明类之后直接通过Box类型进行声明</p>
<p><strong>访问数据成员</strong></p>
<p>这个所有语言都一样，无论结构体还是对象直接通过箭头和点访问即可</p>
<p>示例：</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">      <span class="type">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">double</span> height;   <span class="comment">// 高度</span></span><br><span class="line">      <span class="comment">// 成员函数声明</span></span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">( <span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 成员函数定义</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Box::get</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Box::set</span><span class="params">( <span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    breadth = bre;</span><br><span class="line">    height = hei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Box Box1;        <span class="comment">// 声明 Box1，类型为 Box</span></span><br><span class="line">   Box Box2;        <span class="comment">// 声明 Box2，类型为 Box</span></span><br><span class="line">   Box Box3;        <span class="comment">// 声明 Box3，类型为 Box</span></span><br><span class="line">   <span class="type">double</span> volume = <span class="number">0.0</span>;     <span class="comment">// 用于存储体积</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 1 详述</span></span><br><span class="line">   Box<span class="number">1.</span>height = <span class="number">5.0</span>; </span><br><span class="line">   Box<span class="number">1.l</span>ength = <span class="number">6.0</span>; </span><br><span class="line">   Box<span class="number">1.</span>breadth = <span class="number">7.0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 2 详述</span></span><br><span class="line">   Box<span class="number">2.</span>height = <span class="number">10.0</span>;</span><br><span class="line">   Box<span class="number">2.l</span>ength = <span class="number">12.0</span>;</span><br><span class="line">   Box<span class="number">2.</span>breadth = <span class="number">13.0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 1 的体积</span></span><br><span class="line">   volume = Box<span class="number">1.</span>height * Box<span class="number">1.l</span>ength * Box<span class="number">1.</span>breadth;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Box1 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 2 的体积</span></span><br><span class="line">   volume = Box<span class="number">2.</span>height * Box<span class="number">2.l</span>ength * Box<span class="number">2.</span>breadth;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Box2 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 3 详述</span></span><br><span class="line">   Box<span class="number">3.</span><span class="built_in">set</span>(<span class="number">16.0</span>, <span class="number">8.0</span>, <span class="number">12.0</span>); </span><br><span class="line">   volume = Box<span class="number">3.</span><span class="built_in">get</span>(); </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Box3 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>输出结果</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box1 的体积：<span class="number">210</span></span><br><span class="line">Box2 的体积：<span class="number">1560</span></span><br><span class="line">Box3 的体积：<span class="number">1536</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。</p>
<h3 id="2-构造和析构函数"><a href="#2-构造和析构函数" class="headerlink" title="2.构造和析构函数"></a>2.构造和析构函数</h3><p>使用和其他语言都是一样的，构造函数都是在对象被定义的时候调用用来初始化，析构函数则是在每个对象被销毁之前进行调用，只需要记住语法用来期末考试就行了</p>
<p>构造函数分为无参构造函数，有参构造函数，默认参数构造函数。主要就是默认参数构造函数，这个函数在无参的时候会使用默认的参数，在有参的时候则会使用输入的参数</p>
<p>构造函数示例：</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//h文件声明</span></span><br><span class="line">    <span class="comment">// 默认参数只能在声明中指定，不能同时在定义中指定</span></span><br><span class="line">    <span class="built_in">Book</span>(<span class="type">const</span> std::string&amp; title = <span class="string">&quot;未命名&quot;</span>, </span><br><span class="line">         <span class="type">const</span> std::string&amp; author = <span class="string">&quot;未知作者&quot;</span>, </span><br><span class="line">         <span class="type">double</span> price = <span class="number">0.0</span>, </span><br><span class="line">         <span class="type">int</span> pages = <span class="number">0</span>);</span><br><span class="line"><span class="comment">//cpp文件中实现</span></span><br><span class="line">Book::<span class="built_in">Book</span>(<span class="type">const</span> std::string&amp; title, </span><br><span class="line">           <span class="type">const</span> std::string&amp; author, </span><br><span class="line">           <span class="type">double</span> price, </span><br><span class="line">           <span class="type">int</span> pages)</span><br><span class="line">    : <span class="built_in">title_</span>(title), <span class="built_in">author_</span>(author), <span class="built_in">price_</span>(price), </span><br><span class="line">      <span class="built_in">pages_</span>(pages), <span class="built_in">pagesRead_</span>(<span class="number">0</span>)  <span class="comment">// 初始化列表</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;创建图书: &quot;</span> &lt;&lt; title_ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是在头文件中声明，那在单独的cpp文件类中我们是可以直接写默认参数的，但是我们需要确保默认参数的构造函数中默认参数只声明一次</span></span><br><span class="line"><span class="comment">//单独cpp文件中</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name = <span class="string">&quot;匿名&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>) </span><br><span class="line">        : <span class="built_in">name_</span>(name), <span class="built_in">age_</span>(age) <span class="comment">//这样可以直接将name和age赋值给name_和age_</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;创建学生: &quot;</span> &lt;&lt; name_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p>析构函数的特点是没有参数和返回值，在对象被销毁的时候调用</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">MyClass</span>();  <span class="comment">// 析构函数：类名前加 ~</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>示例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Student</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] scores_;  <span class="comment">// 释放动态内存</span></span><br><span class="line">    std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; 对象被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我懒得去知道对象到底在哪些请况中会被销毁。</p>
<h3 id="3-对象数组与指针"><a href="#3-对象数组与指针" class="headerlink" title="3.对象数组与指针"></a>3.对象数组与指针</h3><p>虽然说对象数组就是每一个元素都是同一类型的对象的数组，但是和普通数组的区别在于对象数组需要进行初始化</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全部使用默认参数</span></span><br><span class="line">Student students[<span class="number">5</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同的构造函数初始化每个元素</span></span><br><span class="line">Student students[<span class="number">3</span>] = &#123;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">85</span>),    <span class="comment">// 调用参数构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">92</span>),    <span class="comment">// 调用参数构造函数  </span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">78</span>)     <span class="comment">// 调用参数构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分指定，其余使用默认构造函数</span></span><br><span class="line">Student students[<span class="number">5</span>] = &#123;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">85</span>),  <span class="comment">// 第一个元素</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">92</span>)   <span class="comment">// 第二个元素</span></span><br><span class="line">    <span class="comment">// 后三个元素使用默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以自动推断出元素数量</span></span><br><span class="line"><span class="comment">// C++11支持的新语法</span></span><br><span class="line">Student students[<span class="number">3</span>] &#123;</span><br><span class="line">    &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">85</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">92</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">78</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动推断数组大小</span></span><br><span class="line">Student students[] &#123;</span><br><span class="line">    &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">85</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">92</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">78</span>&#125;  <span class="comment">// 自动推断数组大小为3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p><strong>对象指针语法</strong></p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明方式</span></span><br><span class="line">类名*对象指针名;</span><br><span class="line"><span class="comment">//赋值方式</span></span><br><span class="line">对象指针名<span class="number">0</span>=&amp;对象名;</span><br><span class="line"><span class="comment">//使用对象指针和对象名都可以访问类的成员，其中使用对象指针的访问方式为</span></span><br><span class="line">对象指针名-&gt;类的成员;</span><br><span class="line">(*对象指针名).类的成员</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p><strong>this指针</strong></p>
<p>this指针就是一个只可以在当前类中使用，用来在执行代码的时候指向当前对象的一个指针。this指针的类型是<code>ClassName* const</code>，我们也可以使用对象指针的语法去使用this指针</p>
<p>使用示例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;  <span class="comment">// this-&gt;name 是成员变量，name 是参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//返回当前对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Calculator&amp; <span class="title">add</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        value += n;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们需要注意类的静态方法是代码开始运行之前就加载了的，可以直接通过类名进行调用，是不能使用this指针的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this-&gt;x = 10;  // 错误！静态函数没有 this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<h3 id="4-对象的赋值与复制"><a href="#4-对象的赋值与复制" class="headerlink" title="4.对象的赋值与复制"></a>4.对象的赋值与复制</h3><p><strong>对象的赋值</strong></p>
<p>对象之间也可以像那些数据类型一样，同类型之间的可以使用等号进行赋值，相应的两个对象之间进行了赋值，但是其仍然是分离的</p>
<p>语法</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student student1;</span><br><span class="line">Student student2;</span><br><span class="line">student1=student2;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>之所以可以通过等号进行对象之前的赋值，这是因为在执行的时候C++自动生成了一个&#x3D;的运算符重载函数，其参数就是对应的对象。</p>
<p>对象的赋值发生在两个对象都被定义的时候，拿一个对象去覆盖另外一个对象。</p>
<p><strong>对象的复制</strong></p>
<p>由一个对象去复制另外一个对象，这个听起来就知道是发生在一个对象被创建的时候。</p>
<p>于是对象的复制和赋值不同的地方在于，对象的复制发生在对象定义的时候，而不是两个对象都被定义好的时候</p>
<p>语法</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student student1;</span><br><span class="line">Student student2=student1;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>这个等号也是经过运算符重载的结果</p>
<p>如果不使用等号也可以通过构造函数去复制，构造函数的写法就是把每一个成员都进行一次赋值，感觉没有&#x3D;好用</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student student1;</span><br><span class="line"><span class="function">Student <span class="title">student2</span><span class="params">(student1)</span></span>;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>





<h3 id="5-友元函数"><a href="#5-友元函数" class="headerlink" title="5.友元函数"></a>5.友元函数</h3><p><strong>友元函数是一个不是类成员的普通函数，但被授予访问该类私有（private）和保护（protected）成员的权限。</strong></p>
<p>关键点：</p>
<ol>
<li>不是类成员函数</li>
<li>可以访问类的私有和保护成员</li>
<li>需要在类内部声明为 <code>friend</code></li>
</ol>
<p><strong>友元函数的特性</strong></p>
<ol>
<li><strong>不是成员函数</strong><ul>
<li>没有 <code>this</code> 指针</li>
<li>不能通过 <code>obj-&gt;friendFunc()</code> 调用，<strong>只能普通函数调用</strong></li>
</ul>
</li>
<li><strong>可以访问私有&#x2F;保护成员</strong><ul>
<li>友元权限只授予声明它的类</li>
<li>不属于继承体系的多态</li>
</ul>
</li>
<li><strong>对类的封装破坏有限</strong><ul>
<li><strong>只能访问声明它的类</strong></li>
<li>不会自动扩展到其他类</li>
</ul>
</li>
<li><strong>可以是全局函数，也可以是类的成员函数的友元</strong><ul>
<li>全局函数或其他类的函数都可以被声明为友元</li>
</ul>
</li>
</ol>
<p>语法</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> v) : <span class="built_in">x</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">showX</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span>;  <span class="comment">// 声明友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showX</span><span class="params">(<span class="type">const</span> A&amp; a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; a.x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在需要访问的类中以friend声明，然后再进行普通函数实现，即使是在类中实现也不是类的成员，而是一个普通函数。然后参数需要是目标类对象</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>常见使用到的地方是运算符重载</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vec</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec&amp; a, <span class="type">const</span> Vec&amp; b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec&amp; a, <span class="type">const</span> Vec&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vec</span>(a.x + b.x, a.y + b.y);  <span class="comment">// 访问私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们需要注意的是友元函数并不是一个具体的函数，而是一个普通函数被声明为了友元函数，其中友元函数必须是一个普通函数，不能被对象-&gt;函数的形式调用，即使是在类中被实现了也不行</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在类内定义友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">showX</span><span class="params">(<span class="type">const</span> A&amp; a)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; a.x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用方式：showX(a)，而不是 a.showX()</span></span><br><span class="line"><span class="comment">//其实就相当于在类中声明然后在类外实现</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>





<h3 id="6-函数模板"><a href="#6-函数模板" class="headerlink" title="6.函数模板"></a>6.函数模板</h3><p>函数模板不是函数，而是“生成函数的规则”。</p>
<p>当我们遇到这种请况的时候，假如要写一个各种数据类型相加后的结果的函数。如果按照正常写法，就会出现int、float、double类型都有函数，这会导致代码量十分大。我们为了解决这个问题，可以使用函数的模板，可以在面对不同类型的参数的时候执行同一套逻辑</p>
<p>示例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//函数模板的声明</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多个不同参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(a * b)</span> </span>&#123; <span class="comment">//auto表示返回类型在后面指定 decltype返回参数的类型</span></span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>使用方法就和正常函数一样，只不过编译器会自己根据代码传入的参数去生成然后执行对应的函数</p>
<p>实例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;          <span class="comment">// 或 template&lt;class T&gt;</span></span><br><span class="line">返回类型 函数名(参数列表);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个模板参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(a * b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result1 = <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>);        <span class="comment">// T = int</span></span><br><span class="line">    <span class="keyword">auto</span> result2 = <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">3.7</span>);    <span class="comment">// T = double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> result3 = <span class="built_in">multiply</span>(<span class="number">2</span>, <span class="number">3.5</span>); <span class="comment">// T1 = int, T2 = double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>然后函数模板也不一定每一次都需要参数，没有参数来对T进行类型判断，我们该如何进行类型判断呢，我们可是使用模板实参的显示指定，就是指定函数执行时T的类型</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">T</span>();  <span class="comment">// 返回类型T的默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方式1：隐式推导（无法用于无参函数！）</span></span><br><span class="line">    <span class="comment">// auto x = getDefault();  // 错误！编译器无法推导T</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式2：显式指定模板参数</span></span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">getDefault</span>&lt;<span class="type">int</span>&gt;();     <span class="comment">// 显式指定 T = int</span></span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">getDefault</span>&lt;<span class="type">double</span>&gt;();  <span class="comment">// 显式指定 T = double</span></span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">getDefault</span>&lt;std::string&gt;(); <span class="comment">// 显式指定 T = std::string</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int默认值: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;       <span class="comment">// 0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double默认值: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;    <span class="comment">// 0.0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;string默认值: &quot;</span> &lt;&lt; z &lt;&lt; std::endl;    <span class="comment">// &quot;&quot; (空字符串)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p>然后函数模板的参数也可以不是模板类型，可以提前规定好类型</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function">T <span class="title">scale</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scale</span>&lt;<span class="type">int</span>, <span class="number">3</span>&gt;(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>使用的时候不是传递类型，而是传递一个符合类型的值</p>
<h3 id="7-类的模板"><a href="#7-类的模板" class="headerlink" title="7.类的模板"></a>7.类的模板</h3><p>没想到不止有函数模板还有类的模板，考个试也太难了吧。</p>
<p>类模板不是类，而是“生成类的蓝图（规则）”</p>
<p>和函数模板一样，都是为了解决相同操作，不同类型而造成代码量过大的问题。</p>
<p>我们先来看一个简单的类模板</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Box</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function">Box&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Box&lt;<span class="type">double</span>&gt; <span class="title">b</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们可以看到类模板和函数模板不同的地方就在于，其模板不仅可以用来规定函数的返回值和参数，还可以指定类的属性的类型。</p>
<p>相应的和模板函数一样，如果是有参就可以自动判断模板类型，无参则需要我们在类名后面使用尖括号指定模板类型。然后这个示例代码是使用了构造函数去传入参数进行初始化，不在Box后面写类型也不会编译错误，但是如果没有构造函数，或者构造函数没有使用参数确定所有模板类型就需要在使用类模板的时候进行声明。</p>
<p><strong>类模板的成员函数</strong></p>
<p>类模板整体在使用时生成，但成员函数是“按需生成”</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">a.<span class="built_in">f</span>(); <span class="comment">// 只生成 f&lt;int&gt;</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p>我们还需要注意类模板中成员函数的写法</p>
<p>1️⃣ 类内定义（简单）</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p>2️⃣ 类外定义（必须写全模板参数）</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Box&lt;T&gt;::<span class="built_in">show</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Box&lt;T&gt;:: 不能省</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p>和函数模板一样，类模板也支持非类型参数</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    T data[N];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>使用的时候也需要给一个符合类型的值</p>
<p><strong>模板必须写在头文件中</strong></p>
<p>我们函数的模板和类模板都必须写在头文件中而不是cpp文件</p>
<p>这是因为，模板不是任何有效的类或者函数，而是一套生成规则。</p>
<p>也就是说面对cpp文件中的类和函数，编译器都是可以生成对应的机器码的。但是面对cpp文件中写了模板的实现的话</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>编译器视角：</p>
<ul>
<li>编译 <code>main.cpp</code><ul>
<li>看到 <code>f&lt;int&gt;</code> 需要实例化</li>
<li>❌ <strong>看不到模板定义</strong></li>
</ul>
</li>
<li>编译失败 &#x2F; 链接失败</li>
</ul>
<p>于是实际流程应该是编译器看见模板调用，去h文件中看到模板的规则，然后再在cpp文件中去生成模板的实现，所以我们需要把规则写到h文件中让编译器可以看到规则。</p>
<p>因为：使用模板的地方，必须“看到模板的完整定义”，才能实例化。</p>
<p>头文件的作用：</p>
<ul>
<li>被 <code>#include</code></li>
<li>在<strong>使用点展开</strong></li>
<li>模板定义对编译器可见</li>
</ul>
<p>类模板也是一样，也需要知道规则后才能去生成对应的类</p>
<h3 id="8-用户自定义类型转换运算符"><a href="#8-用户自定义类型转换运算符" class="headerlink" title="8.用户自定义类型转换运算符"></a>8.用户自定义类型转换运算符</h3><p>假如我们的对象被赋值给一个字符串，这个时候可能会编译报错，但是我们使用<strong>用户自定义类型转换运算符</strong>可以避免报错并返回一个我们指定的字符串</p>
<p>我们之前学php的时候，php的类有各种魔术方法，对应对象被各种特殊操作的时候进行应对，比如<code>__toString</code>魔术方法，在对象被作为字符串被调用的时候会调用<code>__toString</code>方法去返回一个字符串</p>
<p><strong>用户自定义类型转换运算符</strong>是一种特殊的成员函数，告诉编译器如何将你的类对象转换为其他类型。</p>
<p>语法</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> [<span class="type">const</span>] [<span class="keyword">volatile</span>] [&amp;] [&amp;&amp;] [<span class="keyword">noexcept</span>] [-&gt; trailing-<span class="keyword">return</span>-type] </span>&#123;</span><br><span class="line">    <span class="comment">// 转换逻辑</span></span><br><span class="line">&#125;<span class="comment">//返回的必须是type类型 </span></span><br><span class="line"><span class="comment">//这里面const的意思是允许const 修饰的对象进行类型转换</span></span><br><span class="line"><span class="comment">//其他的选项我感觉考试不会考到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际例子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 转换为int</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换为double（const版本）</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换为string（可能抛出异常）</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">std::string</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;example&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11：explicit转换运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11：引用限定符</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="type">int</span>&amp;() &amp; &#123;  <span class="comment">// 仅当对象是左值时可用</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> value = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">operator</span> <span class="type">int</span>&amp;&amp;() &amp;&amp; &#123;  <span class="comment">// 仅当对象是右值时可用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p>示例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 数据成员...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 转换运算符声明</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">TargetType</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function">MyClass::<span class="keyword">operator</span> <span class="title">TargetType</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回TargetType类型的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>其中这个函数有些规则</p>
<ul>
<li>没有返回类型声明</li>
<li>必须是成员函数</li>
<li>没有参数</li>
<li>不是静态函数</li>
</ul>
<p>使用方式</p>
<p><strong>隐式转换（默认行为）</strong></p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImplicitExample</span> &#123;</span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ImplicitExample</span>(<span class="type">double</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隐式转换到double</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隐式转换到int</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testImplicit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ImplicitExample <span class="title">obj</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动隐式转换</span></span><br><span class="line">    <span class="type">double</span> d = obj;      <span class="comment">// 调用 operator double()</span></span><br><span class="line">    <span class="type">int</span> i = obj;         <span class="comment">// 调用 operator int()</span></span><br><span class="line">    <span class="type">float</span> f = obj;       <span class="comment">// 先转double，再转float</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在表达式中隐式转换</span></span><br><span class="line">    <span class="type">double</span> sum = obj + <span class="number">2.5</span>;    <span class="comment">// obj转double，然后相加</span></span><br><span class="line">    <span class="type">bool</span> greater = obj &gt; <span class="number">3.0</span>;  <span class="comment">// obj转double，然后比较</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数参数隐式转换</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printDouble</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br><span class="line">    <span class="built_in">printDouble</span>(obj);    <span class="comment">// 自动转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 但可能引起歧义</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br><span class="line">    <span class="comment">// process(obj);  // 错误！ambiguous call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p><strong>显式转换（C++11引入explicit）</strong>不是由编译器自己去选择类型而是通过在类前面加<code>static_cast&lt;int&gt;</code>指定调用哦个那个转换函数</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExplicitExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ExplicitExample</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// explicit转换运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testExplicit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ExplicitExample <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 错误！不能隐式转换</span></span><br><span class="line">    <span class="comment">// int i = obj;</span></span><br><span class="line">    <span class="comment">// double d = obj;</span></span><br><span class="line">    <span class="comment">// if (obj == 42) &#123; ... &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正确：显式转换</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(obj);</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(obj);</span><br><span class="line">    <span class="type">bool</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(obj);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 例外：在条件中，explicit operator bool()可以被隐式调用</span></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;  <span class="comment">// 合法！调用 explicit operator bool()</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;obj is truthy&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 但不能用在其他需要bool的上下文</span></span><br><span class="line">    <span class="comment">// bool flag = obj;  // 错误！</span></span><br><span class="line">    <span class="comment">// while (obj) &#123; ... &#125;  // 在while中是合法的</span></span><br><span class="line">    <span class="comment">// for (; obj; ) &#123; ... &#125;  // 在for中是合法的</span></span><br><span class="line">    <span class="comment">// do &#123; ... &#125; while (obj);  // 在do-while中是合法的</span></span><br><span class="line">    <span class="comment">// !obj, obj &amp;&amp; true, obj || false  // 逻辑运算符中是合法的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是C++标准对explicit operator bool()的特殊处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<h3 id="9-转换构造函数"><a href="#9-转换构造函数" class="headerlink" title="9.转换构造函数"></a>9.转换构造函数</h3><p>转换构造函数是C++中一种特殊的构造函数，它允许<strong>从其他类型隐式或显式地构造类对象。</strong>这是C++类型转换机制的重要组成部分。</p>
<p>转换构造函数是<strong>能够用单个参数调用</strong>的构造函数（或多个参数，但第一个参数之后的所有参数都有默认值）。它定义了如何从参数类型转换到类类型。</p>
<p>有了转换构造函数我们就可以在定义对象的时候实现这种操作</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringWrapper s3 = <span class="string">&quot;Implicit&quot;</span>;    <span class="comment">// const char* -&gt; StringWrapper</span></span><br><span class="line">StringWrapper s4 = <span class="number">42</span>;            <span class="comment">// int -&gt; StringWrapper</span></span><br><span class="line">StringWrapper s5 = <span class="number">3.14159</span>;       <span class="comment">// double -&gt; StringWrapper</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p>示例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 转换构造函数：从int构造MyClass</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="comment">// 构造逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换构造函数：从double构造MyClass</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">double</span> value, <span class="type">int</span> extra = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意：第二个参数有默认值，所以可以单参数调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不是转换构造函数：需要两个明确参数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;  <span class="comment">// 不是转换构造函数</span></span><br><span class="line">        <span class="comment">// 需要两个int，不能单参数调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>使用方法</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringWrapper</span> &#123;</span><br><span class="line">    std::string data;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 转换构造函数：从C风格字符串</span></span><br><span class="line">    <span class="built_in">StringWrapper</span>(<span class="type">const</span> <span class="type">char</span>* str) : <span class="built_in">data</span>(str) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Converted from const char*&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换构造函数：从std::string</span></span><br><span class="line">    <span class="built_in">StringWrapper</span>(<span class="type">const</span> std::string&amp; str) : <span class="built_in">data</span>(str) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Converted from std::string&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换构造函数：从int（转换为字符串）</span></span><br><span class="line">    <span class="built_in">StringWrapper</span>(<span class="type">int</span> number) : <span class="built_in">data</span>(std::<span class="built_in">to_string</span>(number)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Converted from int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换构造函数：从double</span></span><br><span class="line">    <span class="built_in">StringWrapper</span>(<span class="type">double</span> number, <span class="type">int</span> precision = <span class="number">2</span>) &#123;</span><br><span class="line">        std::ostringstream oss;</span><br><span class="line">        oss &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(precision) &lt;&lt; number;</span><br><span class="line">        data = oss.<span class="built_in">str</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Converted from double&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(<span class="type">const</span> StringWrapper&amp; sw)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; sw.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显式构造</span></span><br><span class="line">    <span class="function">StringWrapper <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;        <span class="comment">// 直接调用构造函数</span></span><br><span class="line">    StringWrapper s2 = <span class="built_in">StringWrapper</span>(<span class="string">&quot;World&quot;</span>);  <span class="comment">// 显式转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隐式转换（调用转换构造函数）</span></span><br><span class="line">    StringWrapper s3 = <span class="string">&quot;Implicit&quot;</span>;    <span class="comment">// const char* -&gt; StringWrapper</span></span><br><span class="line">    StringWrapper s4 = <span class="number">42</span>;            <span class="comment">// int -&gt; StringWrapper</span></span><br><span class="line">    StringWrapper s5 = <span class="number">3.14159</span>;       <span class="comment">// double -&gt; StringWrapper</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数参数隐式转换</span></span><br><span class="line">    <span class="built_in">printString</span>(<span class="string">&quot;Test&quot;</span>);              <span class="comment">// const char* -&gt; StringWrapper</span></span><br><span class="line">    <span class="built_in">printString</span>(<span class="number">100</span>);                 <span class="comment">// int -&gt; StringWrapper</span></span><br><span class="line">    <span class="built_in">printString</span>(<span class="number">2.71828</span>);             <span class="comment">// double -&gt; StringWrapper</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p><strong>转换构造函数和普通构造函数的区别</strong></p>
<p><strong>1. 参数数量要求不同</strong></p>
<p>普通构造函数参数可以随便，但是转换构造函数必须可以单参调用，多出来的参数必须有默认值确保可以单参调用。</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 普通构造函数：可以是任意参数数量</span></span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; &#125;                          <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123; &#125;              <span class="comment">// 两参数构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) &#123; &#125;       <span class="comment">// 三参数构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换构造函数：必须能单参数调用</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a) &#123; &#125;                     <span class="comment">// ✓ 转换构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">double</span> d, <span class="type">int</span> extra = <span class="number">0</span>) &#123; &#125;   <span class="comment">// ✓ 转换构造函数（有默认参数）</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> n = <span class="number">-1</span>) &#123; &#125; <span class="comment">// ✓ 转换构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下不是转换构造函数：</span></span><br><span class="line">    <span class="comment">// MyClass(int a, int b, int c = 0)   // ✗ 虽然c有默认值，但仍需至少两个参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p><strong>2.隐式转换的触发</strong></p>
<p>我们知道构造函数只能在，实例化对象的时候去调用。但是转换构造函数可以有多种触发方式</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Distance</span> &#123;</span><br><span class="line">    <span class="type">double</span> meters;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 转换构造函数（允许隐式转换）</span></span><br><span class="line">    <span class="built_in">Distance</span>(<span class="type">double</span> m) : <span class="built_in">meters</span>(m) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Converting from double: &quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通两参数构造函数（不允许隐式转换）</span></span><br><span class="line">    <span class="built_in">Distance</span>(<span class="type">double</span> m, <span class="type">const</span> std::string&amp; unit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="string">&quot;km&quot;</span>) meters = m * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (unit == <span class="string">&quot;cm&quot;</span>) meters = m / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">else</span> meters = m;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Explicit construction&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processDistance</span><span class="params">(Distance d)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing distance&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转换构造函数允许隐式转换</span></span><br><span class="line">    Distance d1 = <span class="number">100.0</span>;           <span class="comment">// ✓ 隐式：double -&gt; Distance</span></span><br><span class="line">    Distance d2 = <span class="number">200</span>;             <span class="comment">// ✓ 隐式：int -&gt; double -&gt; Distance</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">processDistance</span>(<span class="number">500.0</span>);        <span class="comment">// ✓ 隐式转换参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通构造函数需要显式调用</span></span><br><span class="line">    <span class="function">Distance <span class="title">d3</span><span class="params">(<span class="number">1000</span>, <span class="string">&quot;km&quot;</span>)</span></span>;       <span class="comment">// ✓ 显式调用</span></span><br><span class="line">    <span class="comment">// Distance d4 = (1000, &quot;km&quot;); // ✗ 错误！不能隐式转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用列表初始化（C++11）</span></span><br><span class="line">    Distance d5 = &#123;<span class="number">1500</span>, <span class="string">&quot;m&quot;</span>&#125;;     <span class="comment">// ✓ C++11: 列表初始化</span></span><br><span class="line">    Distance d6&#123;<span class="number">2000</span>, <span class="string">&quot;m&quot;</span>&#125;;        <span class="comment">// ✓ 直接列表初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>









<h2 id="2-类的继承"><a href="#2-类的继承" class="headerlink" title="2.类的继承"></a>2.类的继承</h2><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</p>
<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// eat() 函数</span></span><br><span class="line">    <span class="comment">// sleep() 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="comment">// bark() 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>然后就是和其他的一样，一个类可以同时继承多个类，但是不能有同名的方法和属性上的冲突，否则就是二义性了</p>
<h3 id="1-类在内存中的分布"><a href="#1-类在内存中的分布" class="headerlink" title="1.类在内存中的分布"></a>1.类在内存中的分布</h3><p>这已经是我学的好几遍面向对象编程了，每次都要看一遍继承这些操作，我想在这次学习一下面向对象编程中的内存分布，来从底层的角度理解这些操作。</p>
<p><strong>C++ 的类，本质是“内存布局 + 访问规则 + 编译期生成的代码”。</strong>这也就好像解释了后面我们说为什么类是不占用内存的，占用内存的是对象。这也就解释了为什么类是无法直接执行方法的，直接执行的方法需要使用静态修饰提前加载就可以直接调用了。</p>
<p>虽然我还不知道在编译过程中发生了什么才能够即使不为类提供内存也能够正常运行。为了解决这个问题我们还需要进一步了解一下代码到底是如何从写到编译然后到运行期间到底发生了什么</p>
<ul>
<li>类 <strong>本身不占内存</strong></li>
<li>对象 <strong>才占内存</strong></li>
<li>成员函数 <strong>不在对象里</strong></li>
</ul>
<p>记住这 3 句，后面所有内容都会顺。</p>
<p><strong>对象</strong></p>
<p>C++ 的对象，本质上就是一块连续的内存</p>
<p>类 ≈ 数据布局规则<br> 对象 ≈ 按规则分配的一段内存</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一个对象在内存中分布就是直接储存属性，至于方法是存放在代码区的</span></span><br><span class="line">| x | y |</span><br><span class="line"><span class="comment">//没有魔法</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<ul>
<li><code>sizeof(A) == 8</code>（通常）</li>
<li><code>a</code> 是一段连续内存</li>
<li>成员顺序 &#x3D; 声明顺序（⚠️不是初始化列表顺序）也就是定义对象时就为属性分配内存了，而不是往里面写才有内存</li>
</ul>
<p><strong>方法</strong></p>
<p>这个时候我们就有疑惑了，既然对象在内存中没有储存着方法，那方法又是如何调用的，方法大多是都是需要对当前对象进行操作的。</p>
<p>对于我们这样的一个对象</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//即使有一个函数，内存还是只有x 我们使用sizeof来判断还是4</span></span><br><span class="line">| x |</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>说明</p>
<ul>
<li><strong>成员函数不占对象内存</strong></li>
<li><code>f()</code> 在 <strong>代码区</strong></li>
</ul>
<p>调用时编译器偷偷干了这件事：</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">f</span>();</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">f</span>(&amp;a);</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>也就是说我们调用方法的时候是在代码区找到这个方法，然后在通过对象调用时会将指向对象的指针（感觉和this指针一样）传递给方法，代码区的方法来源于编译代码的时候将类中的方法存到了代码区。</p>
<p>👉 所以成员函数的本质：<strong>普通函数 + 隐式 this 指针</strong></p>
<p><strong>继承</strong></p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//其实就是在存放B对象的时候再提前存放一个A对象，后面再跟上B对象额外写的，然后在使用的时候B的数据会对前面的A进行覆盖这就是重写，代码区应该也是这样的</span></span><br><span class="line">| A::x | B::y |</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; <span class="type">int</span> b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多继承只不过是多了一个对象而已，这个图只是看一下，实际上B和C是同级别的，运行的时候应该会进行二义性校验</span></span><br><span class="line">| A::a | B::b | C::c |</span><br><span class="line"></span><br><span class="line"><span class="comment">//还需要说一下，假如继承顺序是A-&gt;B-&gt;C其中C的内存分布是</span></span><br><span class="line">| A::a | B::b | C::c |</span><br><span class="line"><span class="comment">//这也就是为什么C指针也可以转化为A指针</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>由于我们在继承的时候由于前面其实会跟着基类的一个对象，于是我们的派生类也可以随时转换为基类的指针</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C c;</span><br><span class="line">B* pb = &amp;c;  <span class="comment">// 编译器自动偏移</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p><strong>虚继承</strong></p>
<p>我承认我是后面学到虚继承的时候才想到要学习一下内存使用，但是现在还是一知半解，希望这肤浅的理解水平后面够用。</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">int</span> x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//虚继承就相当于共享基类，一个类只有一个虚基类，所有虚继承的类都会指向那个虚基类</span></span><br><span class="line">| B 子对象 | C 子对象 | <span class="built_in">A</span>(虚基类) | D::y |</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们从这里也可以看到，最后这个虚基类其实是由最后的派生类（最后是多继承不是虚继承）负责的。</p>
<p>至于其他复杂一点的操作，比如重写等操作，我感觉也是基于这种内存储存实现的。这个基本上使用不到，只是为了理解。</p>
<h3 id="2-派生类"><a href="#2-派生类" class="headerlink" title="2.派生类"></a>2.派生类</h3><p>C++有一个不同于其他语言的特性就是，在进行继承的时候子类会带有一个修饰符，这个修饰符不像Java那样是修饰子类的，因为C++在定义类的时候类是不需要修饰符的，所有类都是全局访问，这个修饰符主要就是会修改一些基类中原来的修饰符。</p>
<p>具体情况就是从public到private范围小的会覆盖范围大的修饰符，也就是protected修饰的时候Animal类中的public修饰的全部变为了protected</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicVar;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 不可访问，无论何种继承</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 公有继承 (public inheritance) - &quot;是一个&quot;关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedPublic</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// publicVar → 仍为 public</span></span><br><span class="line">    <span class="comment">// protectedVar → 仍为 protected</span></span><br><span class="line">    <span class="comment">// 继承接口和行为</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 保护继承 (protected inheritance) - &quot;实现继承&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedProtected</span> : <span class="keyword">protected</span> Base &#123;</span><br><span class="line">    <span class="comment">// publicVar → 变为 protected</span></span><br><span class="line">    <span class="comment">// protectedVar → 仍为 protected</span></span><br><span class="line">    <span class="comment">// 隐藏基类接口，仅继承实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 私有继承 (private inheritance) - &quot;实现继承&quot;，默认</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedPrivate</span> : <span class="keyword">private</span> Base &#123;  <span class="comment">// class默认private继承</span></span><br><span class="line">    <span class="comment">// publicVar → 变为 private</span></span><br><span class="line">    <span class="comment">// protectedVar → 变为 private</span></span><br><span class="line">    <span class="comment">// 完全隐藏基类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 不加public会怎样？</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedWithoutPublic</span> : Base &#123;  <span class="comment">// class默认private继承！</span></span><br><span class="line">    <span class="comment">// 等价于: class DerivedWithoutPublic : private Base</span></span><br><span class="line">    <span class="comment">// publicVar → private (不是public！)</span></span><br><span class="line">    <span class="comment">// protectedVar → private (不是protected！)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p><strong>访问修饰符</strong></p>
<p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>
<p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="left">访问</th>
<th align="left">public</th>
<th align="left">protected</th>
<th align="left">private</th>
</tr>
</thead>
<tbody><tr>
<td align="left">同一个类</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">派生类</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">外部的类</td>
<td align="left">yes</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
</tbody></table></div>
<p><strong>一个派生类继承了所有的基类方法，但下列情况除外：</strong></p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<h3 id="3-派生类的构造和析构函数"><a href="#3-派生类的构造和析构函数" class="headerlink" title="3.派生类的构造和析构函数"></a>3.派生类的构造和析构函数</h3><p>我们从继承可以知道派生类是不会继承基类的构造函数和析构函数的，但是我们也知道定义子类的对象在C++中会在内存中也定义一个父类的对象。</p>
<p>我们平常的话子类在定义对象执行构造函数的时候自动调用父类的构造函数，但是如果父类的构造函数需要参数的话，我们不显示调用去传参就会报错，这个时候我们就<strong>必须</strong>在子类中获取到父类构造函数需要的参数，然后在子类的构造函数中调用父类的构造方法</p>
<p>我们来看一下由DS赞助的代码</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类：模拟一个有实际功能的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：初始化对象数据</span></span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> string&amp; n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物 [&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;] 出生了，年龄: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; 岁&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数：清理资源</span></span><br><span class="line">    ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物 [&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;] 离开了，享年 &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; 岁&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类方法：展示功能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 发出动物声音&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> string&amp; food)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 正在吃 &quot;</span> &lt;&lt; food &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类：扩展基类功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string breed;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类构造函数：先调用基类构造函数初始化基类部分</span></span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> string&amp; n, <span class="type">int</span> a, <span class="type">const</span> string&amp; b) <span class="comment">//注意也需要提供基类构造方法的参数</span></span><br><span class="line">        : <span class="built_in">Animal</span>(n, a), <span class="built_in">breed</span>(b) &#123;  <span class="comment">//调用Animal类的构造方法，在此基础上再为Dog类新属性breed赋值</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;这是一只 &quot;</span> &lt;&lt; breed &lt;&lt; <span class="string">&quot; 品种的狗&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 派生类析构函数：先执行派生类清理，再自动调用基类析构函数</span></span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        cout &lt;&lt; breed &lt;&lt; <span class="string">&quot; 狗即将离开&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩展基类功能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; 汪汪叫！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fetch</span><span class="params">(<span class="type">const</span> string&amp; item)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; 正在捡回 &quot;</span> &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">getBreed</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> breed; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=== 程序开始 ===&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n--- 创建Dog对象 ---&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>, <span class="string">&quot;金毛&quot;</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n--- 使用基类功能 ---&quot;</span> &lt;&lt; endl;</span><br><span class="line">        myDog.<span class="built_in">makeSound</span>();        <span class="comment">// 继承自基类</span></span><br><span class="line">        myDog.<span class="built_in">eat</span>(<span class="string">&quot;狗粮&quot;</span>);        <span class="comment">// 继承自基类</span></span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n--- 使用派生类功能 ---&quot;</span> &lt;&lt; endl;</span><br><span class="line">        myDog.<span class="built_in">bark</span>();             <span class="comment">// 派生类特有</span></span><br><span class="line">        myDog.<span class="built_in">fetch</span>(<span class="string">&quot;球&quot;</span>);        <span class="comment">// 派生类特有</span></span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n--- 获取对象信息 ---&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;名字: &quot;</span> &lt;&lt; myDog.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;年龄: &quot;</span> &lt;&lt; myDog.<span class="built_in">getAge</span>() &lt;&lt; <span class="string">&quot;岁&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;品种: &quot;</span> &lt;&lt; myDog.<span class="built_in">getBreed</span>() &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n--- Dog对象即将离开作用域 ---&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// myDog在这里被销毁</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n=== 程序结束 ===&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>





<h3 id="4-多重继承与虚继承"><a href="#4-多重继承与虚继承" class="headerlink" title="4.多重继承与虚继承"></a>4.多重继承与虚继承</h3><p>这个其实就是和继承一样，只不过从继承一个变为了继承多个，只需要这几个基类不会出现二义性就和普通继承一样</p>
<p>虽然说是这么说，但是如果继承的层数多起来就会导致一些难以处理的问题。</p>
<p>我们来看一组继承关系</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们可以看到，当b和c继承自a的时候会拥有同名的来自a的数据，当D同时继承b和c会出现二义性冲突而导致编译错误</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>这个问题就是典型的菱形继承，解决这种问题的最好办法就是虚继承，通过虚继承的派生类，继承到的全部都是共享的一个虚基类。</p>
<p>我们从上面虚继承的内存分布我们可以知道，使用虚继承的类指向的都是同一个虚基类，然后在被一个类进行多继承的时候那个派生类就会继承到。</p>
<p>然后就是和普通继承不同的地方来了，我们普通继承的话都是继承一次构造一次，也就是内存是</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;B-&gt;C</span><br><span class="line"><span class="comment">//B中是，构造一次A</span></span><br><span class="line">A|B</span><br><span class="line"><span class="comment">//C中则是会构造一个B，由于B中构造了A，所以C其实也构造了A</span></span><br><span class="line">A|B|C</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>到了虚继承这里，就有很大的不同，基类A并不是由虚继承的B，C构造出来的，而是由最后多继承的D构造出来。</p>
<p>我们来看一下代码</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> v) &#123; cout &lt;&lt; <span class="string">&quot;A &quot;</span> &lt;&lt; v &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() : <span class="built_in">A</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() : <span class="built_in">A</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>() : <span class="built_in">A</span>(<span class="number">3</span>), <span class="built_in">B</span>(), <span class="built_in">C</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>当我们定义D对象的时候会输出</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A <span class="number">3</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们可以看到，当同时调用基类的构造方法进行对A传递的时候，明明是最先传进行的3，最后却保留了下来，这也就说明了</p>
<ul>
<li><code>B()</code>、<code>C()</code>里对 <code>A</code> 的初始化 <strong>会被忽略</strong>（因为只有构造对象的那个对象才能对其进行操作）</li>
<li><strong>只有 D 对 A 的初始化有效</strong></li>
</ul>
<p>于是说明B和C对没有对A进行构造，事实上BC由于没有构造A，使用的其实是D构造出来的那个A对象</p>
<p><strong>“虚基类由最派生类构造”这句话始终成立</strong></p>
<p>当然，这个时候就会有疑惑，既然虚基类A是由D进行构造的，那B和C又是如何构造A的呢？其实，B和C和普通继承使用上没什么区别，重写等操作都是看起来一样的。但是BC实际上是将普通继承中构造出来的那个A对象变为了一个<strong>vbptr</strong>，这个指针指向BC共同的那个A对象。</p>
<p>于是我们的虚继承代码</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">int</span> x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="comment">//需要注意为了破解菱形继承，需要继承的多个类都进行虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实际上的内存空间为</span></span><br><span class="line">| B 子对象 | C 子对象 | <span class="built_in">A</span>(虚基类) | D::y |</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>然后需要注意的是，由于是D作为最派生类构造了A，于是B和C这两个构造出来的子类对A的操作都会被忽略。和重写一样，只有构造对象的那个对象才能进行操作。</p>
<p>也就是说虚继承的类也就是B和C其实和普通继承使用相似，只不过多了被多继承时只保留一个虚基类A，只不过是有一个标签表明他们是虚继承了同一个了类，这个标签也就是一个指向虚基类A的指针<strong>vbptr</strong>，以这个<strong>vbptr</strong>来判断其虚继承的是否为同一个对象。</p>
<p>而D才是虚继承那个重要的类，会通过BC的标签识别出是同一个类，然后由D亲自去构造一个A虚基类，然后A只由D去操作，其内存中BC对象的操作都被忽略。我觉得这样设计的原因是为了解决菱形继承BC中对虚基类的重写等问题</p>
<p>我们最后再来看一段代码和内存分布</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Final</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line">    <span class="comment">// 现在Final中只有一份Base子对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>内存分布</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Final 对象:</span><br><span class="line">+-------------------+</span><br><span class="line">| Derived1          |</span><br><span class="line">| +---------------+ |</span><br><span class="line">| | vptr          | |--&gt; Derived1的虚表</span><br><span class="line">| +---------------+ |</span><br><span class="line">+-------------------+</span><br><span class="line">| Derived2          |</span><br><span class="line">| +---------------+ |</span><br><span class="line">| | vptr          | |--&gt; Derived2的虚表</span><br><span class="line">| +---------------+ |</span><br><span class="line">+-------------------+</span><br><span class="line">| Base              |</span><br><span class="line">| +---------------+ |</span><br><span class="line">| | data          | |</span><br><span class="line">| +---------------+ |</span><br><span class="line">+-------------------+</span><br><span class="line">| Final 特有数据    |</span><br><span class="line">+-------------------+</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p>我们构造函数中各种构造函数的调用顺序</p>
<p><strong>调用顺序是：</strong></p>
<ol>
<li><strong>所有虚基类构造函数</strong>（按继承列表中的声明顺序）</li>
<li><strong>所有直接非虚基类构造函数</strong>（按继承列表中的声明顺序）</li>
<li><strong>所有成员对象的构造函数</strong>（按类中声明的顺序）</li>
<li><strong>派生类自身的构造函数</strong></li>
</ol>
<p><strong>为什么虚继承一定需要动态绑定</strong></p>
<p>这是因为代码没有运行的时候，由于BC都无法知道那个虚基类A的位置到底在哪，如果是普通继承的话等代码运行的时候再获取也没问题，因为都是单独构造的，没什么特别操作。</p>
<p>但是虚继承需要BC中指向同一个A对象，但是在编译过程中无法确定这共用A的地址。</p>
<p>还有就是会无法在编译过程确定最派生类，最派生类需要自己构造一个虚基类A，如果不运行代码无法确定到底是哪个类是最派生类。</p>
<h2 id="3-动态多态性"><a href="#3-动态多态性" class="headerlink" title="3.动态多态性"></a>3.动态多态性</h2><p>多态性其实就是决定使用哪个函数的一个性质，多态允许<strong>同一接口</strong>根据上下文表现出<strong>不同行为</strong>。最常见的就是静态多态，在一个对象中，拥有多个同名的函数，却因为函数的参数不同而调用不同的函数，主要有参数数量不同，参数类型不同，参数顺序不同等。</p>
<p>但是我们现在写的不是静态多态性，这个后面会和函数模板，重载和运算符重载一起写。现在要学的是动态多态性</p>
<p>首先我们要知道一个事情，C++代码在运行期间会现在编译过程中完成静态绑定和动态绑定。</p>
<p>其中静态绑定就是决定好该使用哪个对象和调用哪个函数这些都是普通的对象和函数，都是可以不通过运行代码就知道的。</p>
<p>动态绑定则是需要运行代码才能知道要执行哪些操作，比如虚继承，和虚函数。虚函数就是动态多态性的代表，需要进行动态绑定。</p>
<h3 id="1-虚函数"><a href="#1-虚函数" class="headerlink" title="1.虚函数"></a>1.虚函数</h3><p>我们之前知道之所以派生类的指针可以转换为基类的指针，这是因为派生类对象中也内嵌了一个基类对象，于是可以转换，<strong>但是如果使用的是转换为基类的指针去调用一个被重写了的方法，代码运行就会根据这是基类的指针而选择去调用基类的方法（其实是通过基类指针只能去调用基类的成员），而不是重写的方法，使用虚函数就是为了解决这个问题</strong></p>
<p>我们之前会面对一个问题，当我们来看下面代码</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> xValue;</span><br><span class="line">    <span class="type">int</span> yValue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        xValue = x;</span><br><span class="line">        yValue = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点的坐标 &quot;</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; xValue &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; yValue &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> r) : <span class="built_in">Point</span>(x, y)</span><br><span class="line">    &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showCircle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">showPoint</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;圆的半径 r=&quot;</span> &lt;&lt; radius &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">pt1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    pt<span class="number">1.</span><span class="built_in">showPoint</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Circle <span class="title">c</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    c.<span class="built_in">showCircle</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pt1 = c;</span><br><span class="line">    pt<span class="number">1.</span><span class="built_in">showPoint</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Point &amp;p2 = c;</span><br><span class="line">    p<span class="number">2.</span><span class="built_in">showPoint</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;点的面积 &quot;</span> &lt;&lt; pt<span class="number">1.</span><span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;点的面积 &quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Point *p3 = &amp;pt1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;点的坐标 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    p3-&gt;<span class="built_in">showPoint</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;点的面积 &quot;</span> &lt;&lt; p3-&gt;<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*****&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Point *p4 = &amp;c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的坐标 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    p4-&gt;<span class="built_in">showPoint</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的面积 &quot;</span> &lt;&lt; p4-&gt;<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//虽然我们是将c的地址赋值给了Point*指针是合法的，但是最后在通过p4调用area方法的时候却返回的是0，这里的原因是</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>程序运行结果为</p>
<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">点的坐标 (10,10)</span><br><span class="line">*****</span><br><span class="line">点的坐标 (0,0)</span><br><span class="line">圆的半径 r=1</span><br><span class="line">*****</span><br><span class="line">点的坐标 (0,0)</span><br><span class="line">*****</span><br><span class="line">点的坐标 (0,0)</span><br><span class="line">*****</span><br><span class="line">点的面积 0</span><br><span class="line">圆的面积 3.14</span><br><span class="line">*****</span><br><span class="line">点的面积 0</span><br><span class="line">圆的面积 0</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>最后输出圆的面积的时候调用不是Circle重写的方法，而是通过基类指针调用基类的area方法</p>
<p>那我们是如何使用虚函数来解决这个问题的呢</p>
<p>语法</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 普通函数</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>虚函数是定义在基类中的，virtual表明这个函数是虚函数，然后虚函数不是像普通函数一样存放，<strong>如果一个类有虚函数就会有一个虚函数表用来存放虚函数。</strong></p>
<p>我们都知道当派生类继承基类的时候会在其中内嵌一个基类，函数和属性一样都会内嵌，然后重写的时候不会对基类的方法进行改写，而是在通过对象调用的时候会调用派生类重写的方法。</p>
<p>但是虚函数不一样，继承的时候派生类也会继承基类的虚函数表，之所以不能和普通函数放一起，是因为虚函数表中会被完全覆盖，而不是像普通函数那样只是不同的调用。</p>
<p>我们先来看一下普通函数是如何进行调用的</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;<span class="built_in">f</span>();</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">A::<span class="built_in">f</span>(p);</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>虚函数则是</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;<span class="built_in">f</span>();</span><br><span class="line">(*(p-&gt;vptr)[idx])(p);<span class="comment">//idx是虚函数在虚函数表中的序号</span></span><br><span class="line"><span class="comment">//vptr是虚函数表的地址</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们看到会直接通过p指针访问到虚函数然后执行。</p>
<p>于是虚函数之所以可以通过派生类转化为的基类指针调用重写的虚函数，这是因为</p>
<ul>
<li><strong>首先虚函数表派生类不会重新创建，而是直接进行覆盖</strong></li>
<li>其次调用的时候不是通过确定对象类型再去代码区调用函数，而是直接通过指针找到虚函数进行调用</li>
<li>能够直接通过指针去找虚函数表是因为有vptr指针</li>
</ul>
<p>于是虚函数调用的时候不需要考虑指针类型，而是通过虚函数表直接调用。</p>
<h3 id="2-纯虚函数与抽象基类"><a href="#2-纯虚函数与抽象基类" class="headerlink" title="2.纯虚函数与抽象基类"></a>2.纯虚函数与抽象基类</h3><p>我们知道了虚函数之后就发现一个问题，如果函数被定义为虚函数就可以在虚函数表中被完全覆盖，也就意味着虚函数表或许可以不需要基类去实现，这让我想起了Java的抽象类和接口可能和这个相似</p>
<p><strong>纯虚函数</strong></p>
<p>纯虚函数是一个没有具体实现的函数，通过在函数声明后面不加括号实现，而是加上&#x3D;0表示这个是一个纯虚函数，本质是将指向函数实现的指针定义为null。</p>
<p>由于函数没有被实现于是含有纯虚函数的类也被称为抽象类，由于函数没有被实现导致不能被实例化为对象，但是却可以被继承。继承的类如果还是没有实现纯虚函数，就还是抽象类不能被定义为对象。</p>
<p>语法</p>
<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual 函数类型 函数名 (参数表)=0;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>由于纯虚函数没有实现，于是是不能对其进行调用的，需要在派生类中重写具体实现才能定义对象然后调用函数。</p>
<p><strong>抽象基类</strong></p>
<p>抽象基类就是包含纯虚函数的类，不能直接被定义为对象，只能被继承。</p>
<p>相应的，纯虚函数也属于虚函数，抽象基类中也会有vptr指针指向vtable（虚函数表），只不过由于指向具体实现的指针为null，导致必须被派生类重写才行，于是通过基类指针调用的纯虚函数也是被派生类重写的结果。</p>
<p>实例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数：计算面积</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数：绘制图形</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚析构函数（非常重要）</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> w, <span class="type">double</span> h)</span><br><span class="line">        : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Draw Rectangle\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14159</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Draw Circle\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象类不能实例化</span></span><br><span class="line">    <span class="comment">// Shape s;  // ❌ 编译错误</span></span><br><span class="line"></span><br><span class="line">    Shape* s1 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    Shape* s2 = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    s1-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; s1-&gt;<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    s2-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; s2-&gt;<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> s1;</span><br><span class="line">    <span class="keyword">delete</span> s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<h3 id="3-虚析构函数"><a href="#3-虚析构函数" class="headerlink" title="3.虚析构函数"></a>3.虚析构函数</h3><p>我们现在已经知道了，只要名字里面有个虚的函数，就会被放到虚函数表，用来重写覆盖掉基类的虚函数，以此来让派生类转换为基类指针后根据对象类型调用正确的函数。</p>
<p>我们都知道构造和析构函数都是不能被继承的，需要我们每次自己重写。于是如果有使用基类指针的请况下，虚析构函数是很重要的。</p>
<p>虽然我不知道析构函数的作用到底是什么，也不知道主动调用和对象声明周期结束自动的区别。</p>
<p>我的理解就是主动调用析构函数不会销毁对象的内存，而是会将对象内存以外其他该对象使用的内存进行释放比如</p>
<p>典型资源包括：</p>
<ul>
<li><code>new</code> 出来的内存</li>
<li>文件句柄（FILE*）</li>
<li>socket</li>
<li>mutex &#x2F; lock</li>
<li>GPU &#x2F; 系统句柄</li>
<li>数据库连接</li>
<li>日志 &#x2F; 临时文件</li>
</ul>
<p>然后对象生命周期结束的时候对象内存也被释放了，这个时候需要自动调用析构函数去带走其他内存。然后析构函数中的代码可能是需要同时执行某些操作。</p>
<p>我们先来看一个错误示例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base destructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived destructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">//delete语句销毁对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>执行结果</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base destructor</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>这个问题就在于通过基类指针在对象被销毁的时候调用的是基类的析构方法，虽然delete执行的时候也会把派生类对象给销毁掉，但是执行的不是派生类的析构函数，会导致派生类除对象内存外的其他内存被泄露。</p>
<ul>
<li><code>Derived::~Derived()</code> <strong>没有被调用</strong></li>
<li>如果 <code>Derived</code> 里有：</li>
<li><ul>
<li><code>new</code> 出来的内存<ul>
<li>文件句柄</li>
<li>mutex &#x2F; socket &#x2F; 资源</li>
</ul>
</li>
</ul>
</li>
<li>👉 <strong>全部泄漏</strong></li>
</ul>
<p>于是我们需要将基类的析构函数变为虚析构函数</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base destructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived destructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">//delete语句销毁对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>执行结果</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和构造函数一样，派生类执行析构函数的时候也会执行基类的析构函数</span></span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>





<h2 id="4-重载"><a href="#4-重载" class="headerlink" title="4.重载"></a>4.重载</h2><p>我们之前已经了解了一些重载的知识，主要就是静态多态性也就是编译期多态，在同名函数的请况下根据参数的数量，类型，顺序不同而可以实现调用同名函数使用不同参数有不同的实现的操作。</p>
<h3 id="1-函数重载"><a href="#1-函数重载" class="headerlink" title="1.函数重载"></a>1.函数重载</h3><p>我们还是有必要复习一下函数重载的。</p>
<p><strong>在同一作用域中，函数名相同、参数列表不同，编译器可以根据调用实参在编译期选择正确的函数，这叫函数重载。</strong></p>
<p>关键点只有三个：</p>
<ol>
<li><strong>同名</strong></li>
<li><strong>参数列表不同</strong></li>
<li><strong>编译期决定</strong></li>
</ol>
<p>参数列表不同还是那三个</p>
<ul>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数顺序不同</li>
</ul>
<p><strong>需要注意返回值不同不能进行函数重载。</strong></p>
<p>示例代码</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;double: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int, int: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span>);        <span class="comment">// int</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);      <span class="comment">// double</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>);      <span class="comment">// int, int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p>然后还有一些我们需要注意的地方</p>
<p>1️⃣ 派生类会隐藏基类同名函数</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">d.<span class="built_in">f</span>(<span class="number">3.14</span>); <span class="comment">// ❌ 编译错误</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>会编译错误的原因是派生类重写会隐藏掉基类所有的同名函数，会把所有重载都隐藏。</p>
<p>正确做法：using 声明</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">    <span class="keyword">using</span> Base::f;<span class="comment">//这里使用的是using的继承中的成员引入功能，引入Base的所有函数名为f的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p>2️⃣ 默认参数 + 重载（危险组合）</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); <span class="comment">// ❌ 二义性</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<h3 id="2-运算符重载"><a href="#2-运算符重载" class="headerlink" title="2.运算符重载"></a>2.运算符重载</h3><p>其实在代码中运算符也可以看作一个简单的函数，比如+就是获取两边的数字作为参数然后返回两个数字的和。</p>
<p>我们其实也可以注意到一些运算符重载的信息，比如C++相较于C语言，可以直接使用+来进行两个字符串的拼接。这个就是C++中string类对运算符的一个重载</p>
<p><strong>运算符重载是为自定义类型（class &#x2F; struct）赋予“运算符语义”的一种函数重载机制，本质仍然是函数调用，且完全发生在编译期。</strong></p>
<p>关键理解：</p>
<ul>
<li>不是发明新运算符</li>
<li>不是改变运算符优先级</li>
<li>只是 <strong>“运算符 + 自定义类型” 的函数重载</strong></li>
</ul>
<p>语法</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型 <span class="keyword">operator</span> 运算符 (参数列表) &#123;具体实现&#125;;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<p><strong>运算符重载基本规则</strong></p>
<p>1️⃣ 至少有一个操作数是用户自定义类型</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// ❌ 不允许</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>至于为什么必须要有一个操作数是用户自定义的，这是为了让使用者使用运算符重载是为了方便对特殊类型比如说类和结构体这些用户自定义类型进行运算。</p>
<p>如果可以全部使用系统类型就会导致可以将+重写为乘法，然后从类型上说的化如果全部使用系统类型也会极易导致重载之间重复使用同一种参数组合导致编译失败。</p>
<p>2️⃣ 不能改变运算符的本质属性</p>
<p>不能改变：</p>
<ul>
<li>优先级</li>
<li>结合性</li>
<li>操作数个数</li>
</ul>
<p>3️⃣ 有些运算符不能重载</p>
<p>不能重载的包括：</p>
<ul>
<li><code>.</code></li>
<li><code>.*</code></li>
<li><code>::</code></li>
<li><code>?:</code></li>
<li><code>sizeof</code></li>
<li><code>typeid</code></li>
</ul>
<p><strong>运算符重载的使用</strong></p>
<p>我们先来看一下实例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Vec2</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// +</span></span><br><span class="line">    <span class="keyword">friend</span> Vec2 <span class="keyword">operator</span>+(<span class="type">const</span> Vec2&amp; a, <span class="type">const</span> Vec2&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vec2</span>(a.x + b.x, a.y + b.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// +=</span></span><br><span class="line">    Vec2&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Vec2&amp; rhs) &#123;</span><br><span class="line">        x += rhs.x;</span><br><span class="line">        y += rhs.y;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Vec2&amp; a, <span class="type">const</span> Vec2&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;&lt;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Vec2&amp; v) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Vec2 <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Vec2 <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Vec2 c = a + b;     <span class="comment">// 使用 +</span></span><br><span class="line">    a += b;             <span class="comment">// 使用 +=</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == c) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;equal\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 使用 &lt;&lt;</span></span><br><span class="line"><span class="comment">//重载了流运算符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="built_in">equal</span></span><br><span class="line">(<span class="number">4</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们调用重载运算符的方法有好几种简单的主要是</p>
<ul>
<li>直接调用<code>Complex c = a + b; </code></li>
<li>显示调用<code>Complex c = a.operator+(b);</code></li>
</ul>
<p>我们需要注意，有些方法返回类型是类名，有些则是类名&amp;。这个其中<code>Vec2&amp;</code>这种属于对类的引用，也就是别名<code>Vec2&amp; rhs</code>这个不是简单的一个名字是rhs的Vec2的对象，而是对作为参数的那个对象的一个别名，实际上在内存中指向的就是参数那个对象，对其的修改会直接影响到传入的参数，而不是和普通的参数一样复制一次。</p>
<p>于是当使用<code>Vec2&amp;</code>这种返回值的时候返回的就是调用方法对象的一个别名，显示调用就是<code>Vec2&amp; c=a.operator+=(b);</code>由于返回值是一个引用，所以我们也需要返回<code>*this</code>。</p>
<p>我们的运算符特别多，不止 简单的加减乘除，还有一元运算符，二元运算符，赋值运算符，C++中的流运算符，以及new、delete等的其他运算符。</p>
<p>这些运算符在重载的时候有点不一样，需要注意一下</p>
<p><strong>重载单目运算符</strong></p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Counter&amp; <span class="keyword">operator</span>++() &#123;&#125;<span class="comment">//前置</span></span><br><span class="line">Counter&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;&#125;<span class="comment">//后置</span></span><br><span class="line">Counter <span class="keyword">operator</span>-() <span class="type">const</span> &#123;&#125;<span class="comment">//普通单元运算符</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>后置中那个int仅仅用来区分运算符的前置和后置，没有什么意义，直接调用的时候可以忽略。显示调用需要加上<code>operator++(int)</code></p>
<p><strong>重载流运算符</strong></p>
<p>流运算符包括插入运算符和提取运算符，分别是<code>&gt;&gt;</code>和<code>&lt;&lt;</code></p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Date&amp; date);</span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Date&amp; date);</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们注意到重载的时候返回类型和第一个参数类型需要对应，<code>&lt;&lt;</code>对应的是ostream，<code>&gt;&gt;</code>对应的则是istream。</p>
<p>实例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">    <span class="type">int</span> year, month, day;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> y = <span class="number">2000</span>, <span class="type">int</span> m = <span class="number">1</span>, <span class="type">int</span> d = <span class="number">1</span>) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 友元声明，让非成员函数可以访问私有成员</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Date&amp; date);</span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Date&amp; date);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证日期有效性</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (month &lt; <span class="number">1</span> || month &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (day &lt; <span class="number">1</span> || day &gt; <span class="number">31</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 简化验证，实际应更复杂</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出运算符</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Date&amp; date) &#123;</span><br><span class="line">    os &lt;&lt; date.year &lt;&lt; <span class="string">&quot;-&quot;</span> </span><br><span class="line">       &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; date.month &lt;&lt; <span class="string">&quot;-&quot;</span></span><br><span class="line">       &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; date.day;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入运算符</span></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Date&amp; date) &#123;</span><br><span class="line">    <span class="type">char</span> dash1, dash2;</span><br><span class="line">    is &gt;&gt; date.year &gt;&gt; dash1 &gt;&gt; date.month &gt;&gt; dash2 &gt;&gt; date.day;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dash1 != <span class="string">&#x27;-&#x27;</span> || dash2 != <span class="string">&#x27;-&#x27;</span> || !date.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">        is.<span class="built_in">setstate</span>(std::ios::failbit);  <span class="comment">// 设置错误状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>





<h2 id="5-异常处理"><a href="#5-异常处理" class="headerlink" title="5.异常处理"></a>5.异常处理</h2><p>妈的，怎么期末考试什么东西都要考啊，还有异常处理。</p>
<p>异常处理和我们之前常见的语法错误不同，异常处理需要处理一些编译器无法识别出的错误（非语法错误），而是在运行期间的问题，比如文件打开失败、使用除法去除0、数组下标越界。</p>
<p>我们先来看异常处理的关键字</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;        <span class="comment">// 尝试执行</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...) &#123; <span class="comment">// 捕获异常</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ...;    <span class="comment">// 抛出异常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>try其实没有什么特别，是配合catch使用的。throw语句就是先输出我们设置好的异常然后停止运行。通过栈去寻找到最近的catch，让catch语句去捕获异常。但是throw语句去找catch的过程好像有点复杂，我只求我考试过了就行，直接记代码吧</p>
<p>示例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;division by zero&quot;</span>;<span class="comment">//触发throw会抛出异常division by zero然后停止代码</span></span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>) &lt;&lt; endl;<span class="comment">//由于是调用函数除0，不是直接写10/0，这个会在运行期间报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>执行流程是：</p>
<ol>
<li><code>divide()</code> 中 <code>throw</code></li>
<li><strong>立即终止当前函数</strong></li>
<li>沿调用栈向上查找 <code>catch</code></li>
<li>找到后执行 <code>catch</code></li>
<li>程序继续运行</li>
</ol>
<h2 id="6-文件操作"><a href="#6-文件操作" class="headerlink" title="6.文件操作"></a>6.文件操作</h2><p>这个也要考，还考好几次。ಥ_ಥ</p>
<p>我们之前每次写代码都会写上iostream库，这个库提供给了我们C++中的各种流。cout是标准输出流，cin是标准输入流</p>
<p>文件操作也需要各种文件读写流，于是我们也需要使用到一个库</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们先来看一下常见的文件流</p>
<p>1️⃣ <code>ifstream</code> —— 读文件</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<ul>
<li>input file stream</li>
<li>只读</li>
<li>默认 <code>ios::in</code></li>
</ul>
<p>2️⃣ <code>ofstream</code> —— 写文件</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<ul>
<li>output file stream</li>
<li>默认 <code>ios::out</code></li>
<li><strong>会清空原文件</strong></li>
</ul>
<p>3️⃣ <code>fstream</code> —— 读 + 写</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">fs</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>, ios::in | ios::out)</span></span>;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<ul>
<li>需要显式指定模式</li>
<li>灵活，但更容易出错</li>
</ul>
<p>然后我们读取的数据就是储存在in流中，通过out流，我们可以对文件进行写入。</p>
<h3 id="1-文件打开流程"><a href="#1-文件打开流程" class="headerlink" title="1.文件打开流程"></a>1.文件打开流程</h3><div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造时打开</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象，然后使用open方法打开</span></span><br><span class="line">ifstream in;</span><br><span class="line">in.<span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次必须检查是否成功打开</span></span><br><span class="line"><span class="keyword">if</span> (!in.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;file open failed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是在构造时打开我们可以通过判断in对象是否成功创建来判断是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (!in) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;open failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>



<h3 id="2-文件打开模式"><a href="#2-文件打开模式" class="headerlink" title="2.文件打开模式"></a>2.文件打开模式</h3><div class="table-container"><table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>ios::in</code></td>
<td>读</td>
</tr>
<tr>
<td><code>ios::out</code></td>
<td>写</td>
</tr>
<tr>
<td><code>ios::app</code></td>
<td>追加</td>
</tr>
<tr>
<td><code>ios::trunc</code></td>
<td>清空</td>
</tr>
<tr>
<td><code>ios::binary</code></td>
<td>二进制</td>
</tr>
<tr>
<td><code>ios::ate</code></td>
<td>打开后定位到末尾</td>
</tr>
</tbody></table></div>
<p>一些常见组合</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//追加写</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;log.txt&quot;</span>, ios::app)</span></span>;</span><br><span class="line"><span class="comment">//读写同一文件</span></span><br><span class="line"><span class="function">fstream <span class="title">fs</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>, ios::in | ios::out)</span></span>;</span><br><span class="line"><span class="comment">//二进制读取</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;a.bin&quot;</span>, ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;a.txt&quot;</span>)</span></span>; </span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;a.txt&quot;</span>, ios::out | ios::trunc)</span></span>;</span><br><span class="line"><span class="comment">//因为前面是ofstream，所以只能进行写</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>每次区分读写，可以通过类型来判断 <strong>if</strong> 就是读 <strong>of</strong> 就是写， <strong>fs</strong> 则是读写。</p>
<h3 id="3-文件读写操作"><a href="#3-文件读写操作" class="headerlink" title="3.文件读写操作"></a>3.文件读写操作</h3><p>1️⃣ 按行读取（最推荐）</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(in, line)) &#123;</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>📌 优点：</p>
<ul>
<li>不丢空格</li>
<li>不丢空行</li>
<li>不受格式影响</li>
</ul>
<p>2️⃣ 用 <code>&gt;&gt;</code> 读取（格式化输入）</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line">string s;</span><br><span class="line">in &gt;&gt; a &gt;&gt; s;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>⚠️ 特点：</p>
<ul>
<li>跳过空白符</li>
<li>不适合读整行文本</li>
</ul>
<p>3️⃣ 写文件（和 cout 一模一样）考试一般考这个</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">out &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">3.14</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>就当作输出一样写文件就行了</p>
<p>我们来看一个文件读写的实例</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;<span class="comment">//读取文件</span></span><br><span class="line">    <span class="keyword">if</span> (!in) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;open failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>, ios::app)</span></span>;<span class="comment">//创建写文件流</span></span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(in, line)) &#123; <span class="comment">//getline获取一行给line</span></span><br><span class="line">        out &lt;&lt; line &lt;&lt; endl; <span class="comment">//写入文件就像输出一样</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>









<h2 id="7-STL编程"><a href="#7-STL编程" class="headerlink" title="7.STL编程"></a>7.STL编程</h2><p>明明这个好像在课上都没有讲，但是为什么期末考试会考啊。</p>
<p>C++ 标准模板库（Standard Template Library，STL）是一套功能强大的 C++ 模板类和函数的集合，它提供了一系列通用的、可复用的算法和数据结构。</p>
<p>STL 的设计基于泛型编程，这意味着使用模板可以编写出独立于任何特定数据类型的代码。</p>
<p><strong>STL 分为多个组件</strong>，包括容器（Containers）、迭代器（Iterators）、算法（Algorithms）、函数对象（Function Objects）和适配器（Adapters）等。</p>
<p>使用 STL 的好处:</p>
<ul>
<li><strong>代码复用</strong>：STL 提供了大量的通用数据结构和算法，可以减少重复编写代码的工作。</li>
<li><strong>性能优化</strong>：STL 中的算法和数据结构都经过了优化，以提供最佳的性能。</li>
<li><strong>泛型编程</strong>：使用模板，STL 支持泛型编程，使得算法和数据结构可以适用于任何数据类型。</li>
<li><strong>易于维护</strong>：STL 的设计使得代码更加模块化，易于阅读和维护。</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">容器（Containers）</td>
<td align="left">容器是 STL 中<strong>最基本的组件</strong>之一，提供了各种数据结构，包括向量（vector）、链表（list）、队列（queue）、栈（stack）、集合（set）、映射（map）等。这些容器具有不同的特性和用途，可以根据实际需求选择合适的容器。</td>
</tr>
<tr>
<td align="left">算法（Algorithms）</td>
<td align="left">STL 提供了大量的算法，用于对容器中的元素进行各种操作，包括排序、搜索、复制、移动、变换等。这些算法在使用时不需要关心容器的具体类型，只需要指定要操作的范围即可。</td>
</tr>
<tr>
<td align="left">迭代器（iterators）</td>
<td align="left"><strong>迭代器用于遍历容器中的元素</strong>，允许以统一的方式访问容器中的元素，而<strong>不用关心容器的内部实现细节</strong>。STL 提供了多种类型的迭代器，包括随机访问迭代器、双向**迭代器、前向迭代器和输入输出迭代器等。</td>
</tr>
<tr>
<td align="left">函数对象（Function Objects）</td>
<td align="left">函数对象是可以像函数一样调用的对象，可以用于算法中的各种操作。STL 提供了多种函数对象，包括一元函数对象、二元函数对象、谓词等，可以满足不同的需求。</td>
</tr>
<tr>
<td align="left">适配器（Adapters）</td>
<td align="left"><strong>适配器用于将一种容器或迭代器适配成另一种容器或迭代器</strong>，以满足特定的需求。STL 提供了多种适配器，包括栈适配器（stack adapter）、队列适配器（queue adapter）和优先队列适配器（priority queue adapter）等。</td>
</tr>
</tbody></table></div>
<p>算法不关心容器，容器不关心算法，通过迭代器解耦</p>
<h3 id="1-容器"><a href="#1-容器" class="headerlink" title="1.容器"></a>1.容器</h3><p>容器是用来存储数据的序列，它们提供了不同的存储方式和访问模式。</p>
<p>STL 中的容器可以分为三类：</p>
<p>1、序列容器：存储元素的序列，允许双向遍历。</p>
<ul>
<li>std::vector：动态数组，支持快速随机访问。</li>
<li>std::deque：双端队列，支持快速插入和删除。</li>
<li>std::list：链表，支持快速插入和删除，但不支持随机访问。</li>
</ul>
<p>2、关联容器：存储键值对，每个元素都有一个键（key）和一个值（value），并且通过键来组织元素。</p>
<ul>
<li>std::set：集合，不允许重复元素。</li>
<li>std::multiset：多重集合，允许多个元素具有相同的键。</li>
<li>std::map：映射，每个键映射到一个值。</li>
<li>std::multimap：多重映射，存储了键值对（pair），其中键是唯一的，但值可以重复，允许一个键映射到多个值。</li>
</ul>
<p>3、无序容器（C++11 引入）：哈希表，支持快速的查找、插入和删除。</p>
<ul>
<li>std::unordered_set：无序集合。</li>
<li>std::unordered_multiset：无序多重集合。</li>
<li>std::unordered_map：无序映射。</li>
<li>std::unordered_multimap：无序多重映射。</li>
</ul>
<p>示例代码</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建一个向量存储 int</span></span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; vec; </span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 显示 vec 的原始大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 推入 5 个值到向量中</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(i);<span class="comment">//无论是什么容器</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 显示 vec 扩展后的大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;extended vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 访问向量中的 5 个值</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of vec [&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; vec[i] &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 使用迭代器 iterator 访问值</span></span><br><span class="line">   vector&lt;<span class="type">int</span>&gt;::iterator v = vec.<span class="built_in">begin</span>();</span><br><span class="line">   <span class="keyword">while</span>( v != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of v = &quot;</span> &lt;&lt; *v &lt;&lt; endl;</span><br><span class="line">      v++;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>运行结果</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector size = <span class="number">0</span></span><br><span class="line">extended vector size = <span class="number">5</span></span><br><span class="line">value of vec [<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">value of vec [<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">value of vec [<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">value of vec [<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">value of vec [<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line">value of v = <span class="number">0</span></span><br><span class="line">value of v = <span class="number">1</span></span><br><span class="line">value of v = <span class="number">2</span></span><br><span class="line">value of v = <span class="number">3</span></span><br><span class="line">value of v = <span class="number">4</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>我们可以看到，</p>
<p>为了考试没办法了，只能直接记答案了</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="left">容器类型</th>
<th align="left">常用写入方法</th>
<th align="left">考试频率</th>
<th align="left">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>vector</strong></td>
<td align="left"><code>push_back()</code>, <code>insert()</code>, <code>emplace_back()</code></td>
<td align="left">⭐⭐⭐⭐⭐</td>
<td align="left">O(1)摊销 &#x2F; O(n)</td>
</tr>
<tr>
<td align="left"><strong>deque</strong></td>
<td align="left"><code>push_back()</code>, <code>push_front()</code>, <code>insert()</code></td>
<td align="left">⭐⭐⭐⭐</td>
<td align="left">O(1) &#x2F; O(n)</td>
</tr>
<tr>
<td align="left"><strong>list</strong></td>
<td align="left"><code>push_back()</code>, <code>push_front()</code>, <code>insert()</code></td>
<td align="left">⭐⭐⭐⭐</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><strong>array</strong></td>
<td align="left">下标赋值</td>
<td align="left">⭐⭐</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><strong>set&#x2F;map</strong></td>
<td align="left"><code>insert()</code>, <code>emplace()</code>, <code>operator[]</code></td>
<td align="left">⭐⭐⭐⭐⭐</td>
<td align="left">O(log n)</td>
</tr>
<tr>
<td align="left"><strong>stack</strong></td>
<td align="left"><code>push()</code></td>
<td align="left">⭐⭐⭐</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><strong>queue</strong></td>
<td align="left"><code>push()</code></td>
<td align="left">⭐⭐⭐</td>
<td align="left">O(1)</td>
</tr>
</tbody></table></div>
<p>我们在顶一个ser 和multiset的时候可以选择元素的排序方式</p>
<div class="code-container" code-lang="C++"><div class="codebox"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序 set</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序 multiset</span></span><br><span class="line">multiset&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; ms;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认是 less&lt;T&gt; 升序，也就是我们只需要记住greater就可以考试了</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

</div><div class="post-reward"><div class="post-reward-btn" title="赞赏作者"><img src="/assets/images/svg/uc/uc-gift.svg" class="icon noview" alt="Icon"><span></span></div><div class="post-reward-content"><div class="post-reward-text"></div><div class="post-reward-list"><a href="/null" target="_blank">致谢名单</a></div></div></div><div class="post-copyright"><div class="post-copyright-info">本作品由 Regulus 于 2025-12-04 16:11:57 发布</div><div class="post-copyright-link"><span>作品地址：<a href="http://example.com/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">C++面向对象编程</a></span><button class="copy-text" type="button" data-text="http://example.com/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">复制</button></div><div class="post-copyright-detail">除特别声明外，本站作品均采用 <a href='https://creativecommons.org/licenses/by-nc-sa/4.0/' title='Attribution-NonCommercial-ShareAlike' target='_blank'>CC BY-NC-SA 4.0</a> 许可协议，转载请注明来自 <a href='/'>Mei的小窝</a></div><img class="post-copyright-icon noview" src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></div><div class="post-tail-tags"><a class="post-tail-tags-link" href="/tags/C/" rel="tag">C++</a></div></div><aside id="post-sidebar" status="show"><div id="toc-container"><div class="toc-title"><img src="/assets/images/svg/ta/ta-toc.svg" class="icon noview" alt="Icon"><span>目录</span></div><div class="toc-content" id="toc-div"><ol class="toc-list"><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-list-text">C++面向对象编程</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#1-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-list-text">1.类与对象</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#1-%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1"><span class="toc-list-text">1.定义对象</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#2-%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-list-text">2.构造和析构函数</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#3-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-list-text">3.对象数组与指针</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC%E4%B8%8E%E5%A4%8D%E5%88%B6"><span class="toc-list-text">4.对象的赋值与复制</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#5-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-list-text">5.友元函数</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#6-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-list-text">6.函数模板</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#7-%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="toc-list-text">7.类的模板</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#8-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-list-text">8.用户自定义类型转换运算符</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#9-%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-list-text">9.转换构造函数</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#2-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-list-text">2.类的继承</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#1-%E7%B1%BB%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83"><span class="toc-list-text">1.类在内存中的分布</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#2-%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-list-text">2.派生类</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#3-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-list-text">3.派生类的构造和析构函数</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#4-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-list-text">4.多重继承与虚继承</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#3-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-list-text">3.动态多态性</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#1-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-list-text">1.虚函数</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#2-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-list-text">2.纯虚函数与抽象基类</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#3-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-list-text">3.虚析构函数</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#4-%E9%87%8D%E8%BD%BD"><span class="toc-list-text">4.重载</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#1-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-list-text">1.函数重载</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#2-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-list-text">2.运算符重载</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#5-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-list-text">5.异常处理</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#6-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-list-text">6.文件操作</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#1-%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%B5%81%E7%A8%8B"><span class="toc-list-text">1.文件打开流程</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#2-%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%A8%A1%E5%BC%8F"><span class="toc-list-text">2.文件打开模式</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#3-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-list-text">3.文件读写操作</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#7-STL%E7%BC%96%E7%A8%8B"><span class="toc-list-text">7.STL编程</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#1-%E5%AE%B9%E5%99%A8"><span class="toc-list-text">1.容器</span></a></li></ol></li></ol></li></ol></div></div></aside></div></div><div id="toolbar" hide=""><div id="toolbar-setting-container" hide=""><div class="toolbar-item"><button id="tool-color-mode" title="深色模式" type="button"><img src="/assets/images/svg/ta/ta-moon.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button class="copy-text" id="tool-share" title="分享" type="button" data-text="http://example.com/2025/12/04/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"><img src="/assets/images/svg/ta/ta-share.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-font-size-plus" title="放大字体" type="button"><img src="/assets/images/svg/ta/ta-text-plus.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-font-size-minus" title="缩小字体" type="button"><img src="/assets/images/svg/ta/ta-text-minus.svg" class="icon noview" alt="Icon"></button></div></div><div class="toolbar-container"><div class="toolbar-item"><button id="tool-setting" title="设置" type="button"><img src="/assets/images/svg/ta/ta-setting.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-toc" title="目录" type="button"><img src="/assets/images/svg/ta/ta-toc.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-gototop" title="返回顶部" type="button"><img src="/assets/images/svg/ta/ta-up.svg" class="icon noview" alt="Icon"></button></div></div></div><div class="search-overlay"><div class="search-container"><div class="search-header"><div class="search-title"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" /><path d="M21 21l-6 -6" /></svg>
搜索</div><div class="search-close-btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 21a9 9 0 0 0 9 -9a9 9 0 0 0 -9 -9a9 9 0 0 0 -9 9a9 9 0 0 0 9 9z" /><path d="M9 8l6 8" /><path d="M15 8l-6 8" /></svg></div></div><div class="search-input-box"><input id="search-input" type="search" placeholder="请输入关键词进行站内搜索……" value="" maxlength="80"/></div><div class="search-result-container"><div class="search-result-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" /><path d="M21 21l-6 -6" /></svg></div></div></div></div></main><footer><div class="footer"><div id="footer-copyright">© 2024 - 2026 <span>💗</span> <a href="/null">Regulus</a></div><div id="footer-info"><div id="footer-framework">🚀本站由 <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/chanwj/hexo-theme-meow" title="3.2.0" target="_blank">Meow</a> 强力驱动</div><div id="footer-runtime"><span id="runtime" data-startdate="2024-04-02T22:16:20.000Z">🌻已稳定运行.年.月.天</span></div></div><div id="footer-statistic"><span>共撰写168篇文章，全站共460.2k字</span></div><div id="footer-pageview"><div id="container_site_pv"><span>🔥总访问量</span><span id="vercount_value_site_pv"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 6l0 -3" /><path d="M16.25 7.75l2.15 -2.15" /><path d="M18 12l3 0" /><path d="M16.25 16.25l2.15 2.15" /><path d="M12 18l0 3" /><path d="M7.75 16.25l-2.15 2.15" /><path d="M6 12l-3 0" /><path d="M7.75 7.75l-2.15 -2.15" /></svg></span></div><div id="container_site_uv"><span>🐈访客人数</span><span id="vercount_value_site_uv"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 6l0 -3" /><path d="M16.25 7.75l2.15 -2.15" /><path d="M18 12l3 0" /><path d="M16.25 16.25l2.15 2.15" /><path d="M12 18l0 3" /><path d="M7.75 16.25l-2.15 2.15" /><path d="M6 12l-3 0" /><path d="M7.75 7.75l-2.15 -2.15" /></svg></span></div></div></div></footer><div class="scripts"><script>const GLOBALCONFIG = {
  root: '/',
  toolbar: true,
  lazyload_src: '/assets/images/Meow-Loading.webp',
  friends: false,
  codeblock: true,
  share_text: '',
  onblur_title: 'Please Come Back～✧(´▽`ʃ♡ƪ)',
  mouse_click: false,
  notify:{
    enable: false,
    info: '复制成功～转载请标注本文地址',
    f12_info: '开发者模式已打开，请遵循本站版权协议'
  },
  search: {
    enable: true,
    path: 'search.json',
    local: {
      top_n_per_article: 1,
      preload: false
    }
  },
  encrypt: false,
};
</script><script>if (!localStorage.getItem('color-mode')) {
  localStorage.setItem('color-mode', 'light' || 'light');
}
document.body.setAttribute('data-mode', localStorage.getItem('color-mode'));
</script>
<script src="/js/theme/tools/utils.js"></script>

<script src="/js/plugins/dist/lazyload.min.js"></script>

<script src="/js/plugins/view-image.min.js"></script>
<script src="https://events.vercount.one/js" defer="defer"></script><script>if (localStorage.getItem('font-size')) {
  document.querySelector('.post').style.fontSize = localStorage.getItem('font-size') + 'px';
}
</script>
<script src="/js/plugins/dist/search.js"></script>

<script src="/js/main.js" type="module"></script>
</div></body></html>